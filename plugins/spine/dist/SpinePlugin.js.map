{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap","webpack:///D:/wamp/www/phaser/src/plugins/BasePlugin.js","webpack:///D:/wamp/www/phaser/src/utils/Class.js","webpack:///./SpinePlugin.js","webpack:///./spine-canvas.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;ACVA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,kDAA0C,gCAAgC;AAC1E;AACA;;AAEA;AACA;AACA;AACA,gEAAwD,kBAAkB;AAC1E;AACA,yDAAiD,cAAc;AAC/D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAyC,iCAAiC;AAC1E,wHAAgH,mBAAmB,EAAE;AACrI;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;;AAGA;AACA;;;;;;;;;;;;AClFA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,6BAA6B;AACxC;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,KAAK;AACpB;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,CAAC;;AAED;;;;;;;;;;;;AC9KA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iDAAiD;AACjD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,mBAAmB,mBAAmB;AACtC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;;;;;;ACvOA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,aAAa;AACxB,WAAW,6BAA6B;AACxC;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,iBAAiB;AAChC;AACA,gBAAgB,4BAA4B;AAC5C;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA,4FAA4F,sBAAsB,EAAE;;AAEpH;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;;AAEA,gBAAgB;AAChB,KAAK;;AAEL;AACA;AACA;;AAEA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,CAAC;;AAED;;;;;;;;;;;;ACvJA;AACA;;AAEA;AACA;AACA,IAAI,gBAAgB,sCAAsC,iBAAiB,EAAE;AAC7E,mBAAmB,uDAAuD;AAC1E;AACA;AACA,iBAAiB,sBAAsB;AACvC;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,OAAO;AAC/C;AACA;AACA;AACA,yBAAyB,UAAU;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,WAAW;AAC1D;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,gDAAgD;AAClD;AACA;AACA;AACA;AACA,EAAE,+DAA+D;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,+DAA+D;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,OAAO;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,OAAO;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,iBAAiB;AACvC;AACA;AACA;AACA;AACA,sBAAsB,iBAAiB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,mBAAmB;AAC1C;AACA;AACA;AACA;AACA;AACA,uBAAuB,mBAAmB;AAC1C;AACA;AACA;AACA;AACA,sBAAsB,mBAAmB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,mBAAmB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,mBAAmB;AACzC;AACA;AACA;AACA;AACA;AACA,sBAAsB,mBAAmB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,mBAAmB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,6CAA6C;AACtD;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,OAAO;AAC5D;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,yBAAyB,EAAE;AAChF;AACA;AACA;AACA;AACA;AACA,qCAAqC,OAAO;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,OAAO;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,oBAAoB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,oBAAoB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,mBAAmB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,OAAO;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,OAAO;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,OAAO;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,OAAO;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,OAAO;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,oBAAoB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,SAAS;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,OAAO;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,oBAAoB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,uBAAuB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,uBAAuB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,uBAAuB;AAC7C;AACA;AACA;AACA;AACA;AACA,sBAAsB,uBAAuB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,uBAAuB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,uBAAuB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,sDAAsD;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA,+BAA+B,iBAAiB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,gBAAgB;AAC5C,0BAA0B,cAAc;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,4BAA4B,gBAAgB;AAC5C,0BAA0B,cAAc;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,gBAAgB;AAC5C,0BAA0B,cAAc;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,gBAAgB;AAC5C,0BAA0B,cAAc;AACxC;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iFAAiF;AACjF;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,gFAAgF;AAChF;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,+CAA+C,0BAA0B;AACzE;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,sDAAsD;AACxD,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,kEAAkE;AACpE,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,uBAAuB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,OAAO;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,OAAO;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,eAAe;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,iBAAiB;AACrC;AACA;AACA;AACA,qCAAqC,iBAAiB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,gBAAgB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;AACA,iDAAiD,iBAAiB;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA,EAAE,+DAA+D;AACjE;AACA;AACA;AACA;AACA;AACA,EAAE,4DAA4D;AAC9D;AACA;AACA;AACA;AACA;AACA,EAAE,yDAAyD;AAC3D,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA,+BAA+B,iBAAiB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,gCAAgC;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,uBAAuB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,uBAAuB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,+BAA+B;AACjD;AACA;AACA;AACA;AACA,kBAAkB,sCAAsC;AACxD;AACA;AACA;AACA;AACA,kBAAkB,iCAAiC;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,OAAO;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,qBAAqB;AAC9C,oBAAoB,cAAc;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,qBAAqB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,gBAAgB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,OAAO;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,OAAO;AACrD;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,eAAe;AACjC;AACA;AACA,kBAAkB,eAAe;AACjC;AACA,kBAAkB,eAAe;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,eAAe;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,eAAe;AAClC;AACA;AACA;AACA;AACA,mBAAmB,gBAAgB;AACnC;AACA,mBAAmB,gBAAgB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,OAAO;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,OAAO;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,OAAO;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,OAAO;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,OAAO;AAC3C;AACA;AACA,4CAA4C,OAAO;AACnD;AACA;AACA;AACA;AACA;AACA,mDAAmD,OAAO;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,OAAO;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,OAAO;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,OAAO;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,OAAO;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,OAAO;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,OAAO;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,OAAO;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,OAAO;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,OAAO;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,OAAO;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,OAAO;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,OAAO;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,SAAS;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,eAAe;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,OAAO;AAC9C;AACA;AACA,yCAAyC,SAAS;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,OAAO;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,SAAS;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,OAAO;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,SAAS;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,SAAS;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,qBAAqB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,mBAAmB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,uBAAuB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,sBAAsB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA,oBAAoB,0BAA0B;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,OAAO;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,OAAO;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE,OAAO;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,OAAO;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,OAAO;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,OAAO;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,OAAO;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,OAAO;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,OAAO;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,OAAO;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,OAAO;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,OAAO;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,OAAO;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,OAAO;AACrD;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,uBAAuB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,uBAAuB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,oBAAoB;AACvC;AACA;AACA;AACA,oBAAoB,gCAAgC;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,2BAA2B;AAC9C;AACA;AACA;AACA,oBAAoB,gCAAgC;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,sBAAsB;AACzC;AACA;AACA;AACA,oBAAoB,gCAAgC;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,OAAO;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,wBAAwB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,OAAO;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,OAAO;AAC9C;AACA;AACA,oCAAoC,QAAQ;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,wBAAwB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,wBAAwB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,wBAAwB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,wBAAwB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,wBAAwB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,0BAA0B;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,0BAA0B;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,wBAAwB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,wBAAwB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,wBAAwB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,OAAO;AAClE;AACA;AACA;AACA,yBAAyB,kBAAkB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,0BAA0B;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,oBAAoB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,QAAQ;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,uBAAuB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,2BAA2B;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,kEAAkE;AACpE;AACA;AACA;AACA;AACA;AACA,EAAE,4DAA4D;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE;AACtE,4DAA4D;AAC5D,+CAA+C;AAC/C;AACA,EAAE;AACF;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,yBAAyB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,uBAAuB;AACzC;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,OAAO;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,uBAAuB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,OAAO;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,OAAO;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,OAAO;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,OAAO;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,iBAAiB;AACnC;AACA;AACA;AACA,mCAAmC,OAAO;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,gBAAgB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,OAAO;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,OAAO;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,QAAQ;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,QAAQ;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,sBAAsB,OAAO;AAC7B,sBAAsB,OAAO;AAC7B,sBAAsB,OAAO;AAC7B,sBAAsB,OAAO;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA,2CAA2C,+BAA+B;AAC1E;AACA;AACA;AACA;AACA,0BAA0B,WAAW;AACrC;AACA;AACA;AACA;AACA;AACA,yBAAyB,UAAU;AACnC;AACA;AACA;AACA;AACA;AACA,0BAA0B,WAAW;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,UAAU;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,kBAAkB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,kBAAkB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA,kBAAkB,2BAA2B;AAC7C;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,kBAAkB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,sBAAsB,OAAO;AAC7B,sBAAsB,OAAO;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,+BAA+B,iBAAiB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,wBAAwB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,WAAW;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,WAAW;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,WAAW;AACjD;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,WAAW;AAChE;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,qEAAqE;AACvE,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,OAAO;AAC1C;AACA;AACA;AACA;AACA;AACA,mCAAmC,OAAO;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,iBAAiB;AACjD,+CAA+C,8CAA8C,EAAE;AAC/F;AACA;AACA,GAAG;AACH;AACA,EAAE,6CAA6C;AAC/C,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE;AACzE,+DAA+D;AAC/D,kDAAkD;AAClD;AACA,GAAG;AACH;AACA,EAAE,6CAA6C;AAC/C,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,OAAO;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,OAAO;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,sBAAsB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,OAAO;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,EAAE,6CAA6C;AAC/C,CAAC,sBAAsB;AACvB;;AAEA;AACA;AACA,CAAC,e","file":"SpinePlugin.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"SpinePlugin\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"SpinePlugin\"] = factory();\n\telse\n\t\troot[\"SpinePlugin\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./SpinePlugin.js\");\n","/**\r\n* @author       Richard Davey <rich@photonstorm.com>\r\n* @copyright    2018 Photon Storm Ltd.\r\n* @license      {@link https://github.com/photonstorm/phaser3-plugin-template/blob/master/LICENSE|MIT License}\r\n*/\r\n\r\nvar Class = require('../utils/Class');\r\n\r\n/**\r\n * @classdesc\r\n * A Global Plugin is installed just once into the Game owned Plugin Manager.\r\n * It can listen for Game events and respond to them.\r\n *\r\n * @class BasePlugin\r\n * @memberof Phaser.Plugins\r\n * @constructor\r\n * @since 3.8.0\r\n *\r\n * @param {Phaser.Plugins.PluginManager} pluginManager - A reference to the Plugin Manager.\r\n */\r\nvar BasePlugin = new Class({\r\n\r\n    initialize:\r\n\r\n    function BasePlugin (pluginManager)\r\n    {\r\n        /**\r\n         * A handy reference to the Plugin Manager that is responsible for this plugin.\r\n         * Can be used as a route to gain access to game systems and  events.\r\n         *\r\n         * @name Phaser.Plugins.BasePlugin#pluginManager\r\n         * @type {Phaser.Plugins.PluginManager}\r\n         * @protected\r\n         * @since 3.8.0\r\n         */\r\n        this.pluginManager = pluginManager;\r\n\r\n        /**\r\n         * A reference to the Game instance this plugin is running under.\r\n         *\r\n         * @name Phaser.Plugins.BasePlugin#game\r\n         * @type {Phaser.Game}\r\n         * @protected\r\n         * @since 3.8.0\r\n         */\r\n        this.game = pluginManager.game;\r\n\r\n        /**\r\n         * A reference to the Scene that has installed this plugin.\r\n         * Only set if it's a Scene Plugin, otherwise `null`.\r\n         * This property is only set when the plugin is instantiated and added to the Scene, not before.\r\n         * You cannot use it during the `init` method, but you can during the `boot` method.\r\n         *\r\n         * @name Phaser.Plugins.BasePlugin#scene\r\n         * @type {?Phaser.Scene}\r\n         * @protected\r\n         * @since 3.8.0\r\n         */\r\n        this.scene;\r\n\r\n        /**\r\n         * A reference to the Scene Systems of the Scene that has installed this plugin.\r\n         * Only set if it's a Scene Plugin, otherwise `null`.\r\n         * This property is only set when the plugin is instantiated and added to the Scene, not before.\r\n         * You cannot use it during the `init` method, but you can during the `boot` method.\r\n         *\r\n         * @name Phaser.Plugins.BasePlugin#systems\r\n         * @type {?Phaser.Scenes.Systems}\r\n         * @protected\r\n         * @since 3.8.0\r\n         */\r\n        this.systems;\r\n    },\r\n\r\n    /**\r\n     * Called by the PluginManager when this plugin is first instantiated.\r\n     * It will never be called again on this instance.\r\n     * In here you can set-up whatever you need for this plugin to run.\r\n     * If a plugin is set to automatically start then `BasePlugin.start` will be called immediately after this.\r\n     *\r\n     * @method Phaser.Plugins.BasePlugin#init\r\n     * @since 3.8.0\r\n     *\r\n     * @param {?any} [data] - A value specified by the user, if any, from the `data` property of the plugin's configuration object (if started at game boot) or passed in the PluginManager's `install` method (if started manually).\r\n     */\r\n    init: function ()\r\n    {\r\n    },\r\n\r\n    /**\r\n     * Called by the PluginManager when this plugin is started.\r\n     * If a plugin is stopped, and then started again, this will get called again.\r\n     * Typically called immediately after `BasePlugin.init`.\r\n     *\r\n     * @method Phaser.Plugins.BasePlugin#start\r\n     * @since 3.8.0\r\n     */\r\n    start: function ()\r\n    {\r\n        //  Here are the game-level events you can listen to.\r\n        //  At the very least you should offer a destroy handler for when the game closes down.\r\n\r\n        // var eventEmitter = this.game.events;\r\n\r\n        // eventEmitter.once('destroy', this.gameDestroy, this);\r\n        // eventEmitter.on('pause', this.gamePause, this);\r\n        // eventEmitter.on('resume', this.gameResume, this);\r\n        // eventEmitter.on('resize', this.gameResize, this);\r\n        // eventEmitter.on('prestep', this.gamePreStep, this);\r\n        // eventEmitter.on('step', this.gameStep, this);\r\n        // eventEmitter.on('poststep', this.gamePostStep, this);\r\n        // eventEmitter.on('prerender', this.gamePreRender, this);\r\n        // eventEmitter.on('postrender', this.gamePostRender, this);\r\n    },\r\n\r\n    /**\r\n     * Called by the PluginManager when this plugin is stopped.\r\n     * The game code has requested that your plugin stop doing whatever it does.\r\n     * It is now considered as 'inactive' by the PluginManager.\r\n     * Handle that process here (i.e. stop listening for events, etc)\r\n     * If the plugin is started again then `BasePlugin.start` will be called again.\r\n     *\r\n     * @method Phaser.Plugins.BasePlugin#stop\r\n     * @since 3.8.0\r\n     */\r\n    stop: function ()\r\n    {\r\n    },\r\n\r\n    /**\r\n     * If this is a Scene Plugin (i.e. installed into a Scene) then this method is called when the Scene boots.\r\n     * By this point the plugin properties `scene` and `systems` will have already been set.\r\n     * In here you can listen for Scene events and set-up whatever you need for this plugin to run.\r\n     *\r\n     * @method Phaser.Plugins.BasePlugin#boot\r\n     * @since 3.8.0\r\n     */\r\n    boot: function ()\r\n    {\r\n        //  Here are the Scene events you can listen to.\r\n        //  At the very least you should offer a destroy handler for when the Scene closes down.\r\n\r\n        // var eventEmitter = this.systems.events;\r\n\r\n        // eventEmitter.once('destroy', this.sceneDestroy, this);\r\n        // eventEmitter.on('start', this.sceneStart, this);\r\n        // eventEmitter.on('preupdate', this.scenePreUpdate, this);\r\n        // eventEmitter.on('update', this.sceneUpdate, this);\r\n        // eventEmitter.on('postupdate', this.scenePostUpdate, this);\r\n        // eventEmitter.on('pause', this.scenePause, this);\r\n        // eventEmitter.on('resume', this.sceneResume, this);\r\n        // eventEmitter.on('sleep', this.sceneSleep, this);\r\n        // eventEmitter.on('wake', this.sceneWake, this);\r\n        // eventEmitter.on('shutdown', this.sceneShutdown, this);\r\n        // eventEmitter.on('destroy', this.sceneDestroy, this);\r\n    },\r\n\r\n    /**\r\n     * Game instance has been destroyed.\r\n     * You must release everything in here, all references, all objects, free it all up.\r\n     *\r\n     * @method Phaser.Plugins.BasePlugin#destroy\r\n     * @since 3.8.0\r\n     */\r\n    destroy: function ()\r\n    {\r\n        this.pluginManager = null;\r\n        this.game = null;\r\n        this.scene = null;\r\n        this.systems = null;\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = BasePlugin;\r\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2018 Photon Storm Ltd.\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n */\n\n//  Taken from klasse by mattdesl https://github.com/mattdesl/klasse\r\n\r\nfunction hasGetterOrSetter (def)\r\n{\r\n    return (!!def.get && typeof def.get === 'function') || (!!def.set && typeof def.set === 'function');\r\n}\r\n\r\nfunction getProperty (definition, k, isClassDescriptor)\r\n{\r\n    //  This may be a lightweight object, OR it might be a property that was defined previously.\r\n\r\n    //  For simple class descriptors we can just assume its NOT previously defined.\r\n    var def = (isClassDescriptor) ? definition[k] : Object.getOwnPropertyDescriptor(definition, k);\r\n\r\n    if (!isClassDescriptor && def.value && typeof def.value === 'object')\r\n    {\r\n        def = def.value;\r\n    }\r\n\r\n    //  This might be a regular property, or it may be a getter/setter the user defined in a class.\r\n    if (def && hasGetterOrSetter(def))\r\n    {\r\n        if (typeof def.enumerable === 'undefined')\r\n        {\r\n            def.enumerable = true;\r\n        }\r\n\r\n        if (typeof def.configurable === 'undefined')\r\n        {\r\n            def.configurable = true;\r\n        }\r\n\r\n        return def;\r\n    }\r\n    else\r\n    {\r\n        return false;\r\n    }\r\n}\r\n\r\nfunction hasNonConfigurable (obj, k)\r\n{\r\n    var prop = Object.getOwnPropertyDescriptor(obj, k);\r\n\r\n    if (!prop)\r\n    {\r\n        return false;\r\n    }\r\n\r\n    if (prop.value && typeof prop.value === 'object')\r\n    {\r\n        prop = prop.value;\r\n    }\r\n\r\n    if (prop.configurable === false)\r\n    {\r\n        return true;\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\nfunction extend (ctor, definition, isClassDescriptor, extend)\r\n{\r\n    for (var k in definition)\r\n    {\r\n        if (!definition.hasOwnProperty(k))\r\n        {\r\n            continue;\r\n        }\r\n\r\n        var def = getProperty(definition, k, isClassDescriptor);\r\n\r\n        if (def !== false)\r\n        {\r\n            //  If Extends is used, we will check its prototype to see if the final variable exists.\r\n\r\n            var parent = extend || ctor;\r\n\r\n            if (hasNonConfigurable(parent.prototype, k))\r\n            {\r\n                //  Just skip the final property\r\n                if (Class.ignoreFinals)\r\n                {\r\n                    continue;\r\n                }\r\n\r\n                //  We cannot re-define a property that is configurable=false.\r\n                //  So we will consider them final and throw an error. This is by\r\n                //  default so it is clear to the developer what is happening.\r\n                //  You can set ignoreFinals to true if you need to extend a class\r\n                //  which has configurable=false; it will simply not re-define final properties.\r\n                throw new Error('cannot override final property \\'' + k + '\\', set Class.ignoreFinals = true to skip');\r\n            }\r\n\r\n            Object.defineProperty(ctor.prototype, k, def);\r\n        }\r\n        else\r\n        {\r\n            ctor.prototype[k] = definition[k];\r\n        }\r\n    }\r\n}\r\n\r\nfunction mixin (myClass, mixins)\r\n{\r\n    if (!mixins)\r\n    {\r\n        return;\r\n    }\r\n\r\n    if (!Array.isArray(mixins))\r\n    {\r\n        mixins = [ mixins ];\r\n    }\r\n\r\n    for (var i = 0; i < mixins.length; i++)\r\n    {\r\n        extend(myClass, mixins[i].prototype || mixins[i]);\r\n    }\r\n}\r\n\r\n/**\r\n * Creates a new class with the given descriptor.\r\n * The constructor, defined by the name `initialize`,\r\n * is an optional function. If unspecified, an anonymous\r\n * function will be used which calls the parent class (if\r\n * one exists).\r\n *\r\n * You can also use `Extends` and `Mixins` to provide subclassing\r\n * and inheritance.\r\n *\r\n * @class  Class\r\n * @constructor\r\n * @param {Object} definition a dictionary of functions for the class\r\n * @example\r\n *\r\n *      var MyClass = new Phaser.Class({\r\n *\r\n *          initialize: function() {\r\n *              this.foo = 2.0;\r\n *          },\r\n *\r\n *          bar: function() {\r\n *              return this.foo + 5;\r\n *          }\r\n *      });\r\n */\r\nfunction Class (definition)\r\n{\r\n    if (!definition)\r\n    {\r\n        definition = {};\r\n    }\r\n\r\n    //  The variable name here dictates what we see in Chrome debugger\r\n    var initialize;\r\n    var Extends;\r\n\r\n    if (definition.initialize)\r\n    {\r\n        if (typeof definition.initialize !== 'function')\r\n        {\r\n            throw new Error('initialize must be a function');\r\n        }\r\n\r\n        initialize = definition.initialize;\r\n\r\n        //  Usually we should avoid 'delete' in V8 at all costs.\r\n        //  However, its unlikely to make any performance difference\r\n        //  here since we only call this on class creation (i.e. not object creation).\r\n        delete definition.initialize;\r\n    }\r\n    else if (definition.Extends)\r\n    {\r\n        var base = definition.Extends;\r\n\r\n        initialize = function ()\r\n        {\r\n            base.apply(this, arguments);\r\n        };\r\n    }\r\n    else\r\n    {\r\n        initialize = function () {};\r\n    }\r\n\r\n    if (definition.Extends)\r\n    {\r\n        initialize.prototype = Object.create(definition.Extends.prototype);\r\n        initialize.prototype.constructor = initialize;\r\n\r\n        //  For getOwnPropertyDescriptor to work, we need to act directly on the Extends (or Mixin)\r\n\r\n        Extends = definition.Extends;\r\n\r\n        delete definition.Extends;\r\n    }\r\n    else\r\n    {\r\n        initialize.prototype.constructor = initialize;\r\n    }\r\n\r\n    //  Grab the mixins, if they are specified...\r\n    var mixins = null;\r\n\r\n    if (definition.Mixins)\r\n    {\r\n        mixins = definition.Mixins;\r\n        delete definition.Mixins;\r\n    }\r\n\r\n    //  First, mixin if we can.\r\n    mixin(initialize, mixins);\r\n\r\n    //  Now we grab the actual definition which defines the overrides.\r\n    extend(initialize, definition, true, Extends);\r\n\r\n    return initialize;\r\n}\r\n\r\nClass.extend = extend;\r\nClass.mixin = mixin;\r\nClass.ignoreFinals = false;\r\n\r\nmodule.exports = Class;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2018 Photon Storm Ltd.\r\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\r\n */\r\n\r\nvar Class = require('../../../src/utils/Class');\r\nvar BasePlugin = require('../../../src/plugins/BasePlugin');\r\nvar SpineCanvas = require('SpineCanvas');\r\n\r\n// var SpineGL = require('SpineGL');\r\n\r\n/**\r\n * @classdesc\r\n * TODO\r\n *\r\n * @class SpinePlugin\r\n * @constructor\r\n *\r\n * @param {Phaser.Scene} scene - The Scene to which this plugin is being installed.\r\n * @param {Phaser.Plugins.PluginManager} pluginManager - A reference to the Phaser Plugin Manager.\r\n */\r\nvar SpinePlugin = new Class({\r\n\r\n    Extends: BasePlugin,\r\n\r\n    initialize:\r\n\r\n    function SpinePlugin (pluginManager)\r\n    {\r\n        console.log('SpinePlugin enabled');\r\n\r\n        BasePlugin.call(this, pluginManager);\r\n\r\n        // console.log(SpineCanvas.canvas);\r\n        // console.log(SpineGL.webgl);\r\n\r\n        this.skeletonRenderer = new SpineCanvas.canvas.SkeletonRenderer(this.game.context);\r\n\r\n        this.textureManager = this.game.textures;\r\n        this.textCache = this.game.cache.text;\r\n        this.jsonCache = this.game.cache.json;\r\n\r\n        // console.log(this.skeletonRenderer);\r\n        // pluginManager.registerGameObject('sprite3D', this.sprite3DFactory, this.sprite3DCreator);\r\n    },\r\n\r\n    /**\r\n     * Creates a new Sprite3D Game Object and adds it to the Scene.\r\n     *\r\n     * @method Phaser.GameObjects.GameObjectFactory#sprite3D\r\n     * @since 3.0.0\r\n     * \r\n     * @param {number} x - The horizontal position of this Game Object.\r\n     * @param {number} y - The vertical position of this Game Object.\r\n     * @param {number} z - The z position of this Game Object.\r\n     * @param {string} texture - The key of the Texture this Game Object will use to render with, as stored in the Texture Manager.\r\n     * @param {(string|integer)} [frame] - An optional frame from the Texture this Game Object is rendering with.\r\n     *\r\n     * @return {Phaser.GameObjects.Sprite3D} The Game Object that was created.\r\n     */\r\n    sprite3DFactory: function (x, y, z, key, frame)\r\n    {\r\n        // var sprite = new Sprite3D(this.scene, x, y, z, key, frame);\r\n\r\n        // this.displayList.add(sprite.gameObject);\r\n        // this.updateList.add(sprite.gameObject);\r\n\r\n        // return sprite;\r\n    },\r\n\r\n    createSkeleton: function (textureKey, atlasKey, jsonKey)\r\n    {\r\n        var canvasTexture = new SpineCanvas.canvas.CanvasTexture(this.textureManager.get(textureKey).getSourceImage());\r\n\r\n        var atlas = new SpineCanvas.TextureAtlas(this.textCache.get(atlasKey), function () { return canvasTexture; });\r\n\r\n        var atlasLoader = new SpineCanvas.AtlasAttachmentLoader(atlas);\r\n        \r\n        var skeletonJson = new SpineCanvas.SkeletonJson(atlasLoader);\r\n\r\n        var skeletonData = skeletonJson.readSkeletonData(this.jsonCache.get(jsonKey));\r\n\r\n        var skeleton = new SpineCanvas.Skeleton(skeletonData);\r\n\r\n        skeleton.flipY = true;\r\n        skeleton.setToSetupPose();\r\n        skeleton.updateWorldTransform();\r\n\r\n        skeleton.setSkinByName('default');\r\n    \r\n        return skeleton;\r\n    },\r\n\r\n    getBounds: function (skeleton)\r\n    {\r\n        var offset = new SpineCanvas.Vector2();\r\n        var size = new SpineCanvas.Vector2();\r\n\r\n        skeleton.getBounds(offset, size, []);\r\n\r\n        return { offset: offset, size: size };\r\n    },\r\n\r\n    createAnimationState: function (skeleton, animationName)\r\n    {\r\n        var state = new SpineCanvas.AnimationState(new SpineCanvas.AnimationStateData(skeleton.data));\r\n\r\n        state.setAnimation(0, animationName, true);\r\n\r\n        return state;\r\n    },\r\n\r\n    /**\r\n     * The Scene that owns this plugin is shutting down.\r\n     * We need to kill and reset all internal properties as well as stop listening to Scene events.\r\n     *\r\n     * @method Camera3DPlugin#shutdown\r\n     * @private\r\n     * @since 3.0.0\r\n     */\r\n    shutdown: function ()\r\n    {\r\n        var eventEmitter = this.systems.events;\r\n\r\n        eventEmitter.off('update', this.update, this);\r\n        eventEmitter.off('shutdown', this.shutdown, this);\r\n\r\n        this.removeAll();\r\n    },\r\n\r\n    /**\r\n     * The Scene that owns this plugin is being destroyed.\r\n     * We need to shutdown and then kill off all external references.\r\n     *\r\n     * @method Camera3DPlugin#destroy\r\n     * @private\r\n     * @since 3.0.0\r\n     */\r\n    destroy: function ()\r\n    {\r\n        this.shutdown();\r\n\r\n        this.pluginManager = null;\r\n        this.game = null;\r\n        this.scene = null;\r\n        this.systems = null;\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = SpinePlugin;\r\n","/*** IMPORTS FROM imports-loader ***/\n(function() {\n\nvar __extends = (this && this.__extends) || (function () {\r\n\tvar extendStatics = Object.setPrototypeOf ||\r\n\t\t({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n\t\tfunction (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n\treturn function (d, b) {\r\n\t\textendStatics(d, b);\r\n\t\tfunction __() { this.constructor = d; }\r\n\t\td.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n\t};\r\n})();\r\nvar spine;\r\n(function (spine) {\r\n\tvar Animation = (function () {\r\n\t\tfunction Animation(name, timelines, duration) {\r\n\t\t\tif (name == null)\r\n\t\t\t\tthrow new Error(\"name cannot be null.\");\r\n\t\t\tif (timelines == null)\r\n\t\t\t\tthrow new Error(\"timelines cannot be null.\");\r\n\t\t\tthis.name = name;\r\n\t\t\tthis.timelines = timelines;\r\n\t\t\tthis.duration = duration;\r\n\t\t}\r\n\t\tAnimation.prototype.apply = function (skeleton, lastTime, time, loop, events, alpha, pose, direction) {\r\n\t\t\tif (skeleton == null)\r\n\t\t\t\tthrow new Error(\"skeleton cannot be null.\");\r\n\t\t\tif (loop && this.duration != 0) {\r\n\t\t\t\ttime %= this.duration;\r\n\t\t\t\tif (lastTime > 0)\r\n\t\t\t\t\tlastTime %= this.duration;\r\n\t\t\t}\r\n\t\t\tvar timelines = this.timelines;\r\n\t\t\tfor (var i = 0, n = timelines.length; i < n; i++)\r\n\t\t\t\ttimelines[i].apply(skeleton, lastTime, time, events, alpha, pose, direction);\r\n\t\t};\r\n\t\tAnimation.binarySearch = function (values, target, step) {\r\n\t\t\tif (step === void 0) { step = 1; }\r\n\t\t\tvar low = 0;\r\n\t\t\tvar high = values.length / step - 2;\r\n\t\t\tif (high == 0)\r\n\t\t\t\treturn step;\r\n\t\t\tvar current = high >>> 1;\r\n\t\t\twhile (true) {\r\n\t\t\t\tif (values[(current + 1) * step] <= target)\r\n\t\t\t\t\tlow = current + 1;\r\n\t\t\t\telse\r\n\t\t\t\t\thigh = current;\r\n\t\t\t\tif (low == high)\r\n\t\t\t\t\treturn (low + 1) * step;\r\n\t\t\t\tcurrent = (low + high) >>> 1;\r\n\t\t\t}\r\n\t\t};\r\n\t\tAnimation.linearSearch = function (values, target, step) {\r\n\t\t\tfor (var i = 0, last = values.length - step; i <= last; i += step)\r\n\t\t\t\tif (values[i] > target)\r\n\t\t\t\t\treturn i;\r\n\t\t\treturn -1;\r\n\t\t};\r\n\t\treturn Animation;\r\n\t}());\r\n\tspine.Animation = Animation;\r\n\tvar MixPose;\r\n\t(function (MixPose) {\r\n\t\tMixPose[MixPose[\"setup\"] = 0] = \"setup\";\r\n\t\tMixPose[MixPose[\"current\"] = 1] = \"current\";\r\n\t\tMixPose[MixPose[\"currentLayered\"] = 2] = \"currentLayered\";\r\n\t})(MixPose = spine.MixPose || (spine.MixPose = {}));\r\n\tvar MixDirection;\r\n\t(function (MixDirection) {\r\n\t\tMixDirection[MixDirection[\"in\"] = 0] = \"in\";\r\n\t\tMixDirection[MixDirection[\"out\"] = 1] = \"out\";\r\n\t})(MixDirection = spine.MixDirection || (spine.MixDirection = {}));\r\n\tvar TimelineType;\r\n\t(function (TimelineType) {\r\n\t\tTimelineType[TimelineType[\"rotate\"] = 0] = \"rotate\";\r\n\t\tTimelineType[TimelineType[\"translate\"] = 1] = \"translate\";\r\n\t\tTimelineType[TimelineType[\"scale\"] = 2] = \"scale\";\r\n\t\tTimelineType[TimelineType[\"shear\"] = 3] = \"shear\";\r\n\t\tTimelineType[TimelineType[\"attachment\"] = 4] = \"attachment\";\r\n\t\tTimelineType[TimelineType[\"color\"] = 5] = \"color\";\r\n\t\tTimelineType[TimelineType[\"deform\"] = 6] = \"deform\";\r\n\t\tTimelineType[TimelineType[\"event\"] = 7] = \"event\";\r\n\t\tTimelineType[TimelineType[\"drawOrder\"] = 8] = \"drawOrder\";\r\n\t\tTimelineType[TimelineType[\"ikConstraint\"] = 9] = \"ikConstraint\";\r\n\t\tTimelineType[TimelineType[\"transformConstraint\"] = 10] = \"transformConstraint\";\r\n\t\tTimelineType[TimelineType[\"pathConstraintPosition\"] = 11] = \"pathConstraintPosition\";\r\n\t\tTimelineType[TimelineType[\"pathConstraintSpacing\"] = 12] = \"pathConstraintSpacing\";\r\n\t\tTimelineType[TimelineType[\"pathConstraintMix\"] = 13] = \"pathConstraintMix\";\r\n\t\tTimelineType[TimelineType[\"twoColor\"] = 14] = \"twoColor\";\r\n\t})(TimelineType = spine.TimelineType || (spine.TimelineType = {}));\r\n\tvar CurveTimeline = (function () {\r\n\t\tfunction CurveTimeline(frameCount) {\r\n\t\t\tif (frameCount <= 0)\r\n\t\t\t\tthrow new Error(\"frameCount must be > 0: \" + frameCount);\r\n\t\t\tthis.curves = spine.Utils.newFloatArray((frameCount - 1) * CurveTimeline.BEZIER_SIZE);\r\n\t\t}\r\n\t\tCurveTimeline.prototype.getFrameCount = function () {\r\n\t\t\treturn this.curves.length / CurveTimeline.BEZIER_SIZE + 1;\r\n\t\t};\r\n\t\tCurveTimeline.prototype.setLinear = function (frameIndex) {\r\n\t\t\tthis.curves[frameIndex * CurveTimeline.BEZIER_SIZE] = CurveTimeline.LINEAR;\r\n\t\t};\r\n\t\tCurveTimeline.prototype.setStepped = function (frameIndex) {\r\n\t\t\tthis.curves[frameIndex * CurveTimeline.BEZIER_SIZE] = CurveTimeline.STEPPED;\r\n\t\t};\r\n\t\tCurveTimeline.prototype.getCurveType = function (frameIndex) {\r\n\t\t\tvar index = frameIndex * CurveTimeline.BEZIER_SIZE;\r\n\t\t\tif (index == this.curves.length)\r\n\t\t\t\treturn CurveTimeline.LINEAR;\r\n\t\t\tvar type = this.curves[index];\r\n\t\t\tif (type == CurveTimeline.LINEAR)\r\n\t\t\t\treturn CurveTimeline.LINEAR;\r\n\t\t\tif (type == CurveTimeline.STEPPED)\r\n\t\t\t\treturn CurveTimeline.STEPPED;\r\n\t\t\treturn CurveTimeline.BEZIER;\r\n\t\t};\r\n\t\tCurveTimeline.prototype.setCurve = function (frameIndex, cx1, cy1, cx2, cy2) {\r\n\t\t\tvar tmpx = (-cx1 * 2 + cx2) * 0.03, tmpy = (-cy1 * 2 + cy2) * 0.03;\r\n\t\t\tvar dddfx = ((cx1 - cx2) * 3 + 1) * 0.006, dddfy = ((cy1 - cy2) * 3 + 1) * 0.006;\r\n\t\t\tvar ddfx = tmpx * 2 + dddfx, ddfy = tmpy * 2 + dddfy;\r\n\t\t\tvar dfx = cx1 * 0.3 + tmpx + dddfx * 0.16666667, dfy = cy1 * 0.3 + tmpy + dddfy * 0.16666667;\r\n\t\t\tvar i = frameIndex * CurveTimeline.BEZIER_SIZE;\r\n\t\t\tvar curves = this.curves;\r\n\t\t\tcurves[i++] = CurveTimeline.BEZIER;\r\n\t\t\tvar x = dfx, y = dfy;\r\n\t\t\tfor (var n = i + CurveTimeline.BEZIER_SIZE - 1; i < n; i += 2) {\r\n\t\t\t\tcurves[i] = x;\r\n\t\t\t\tcurves[i + 1] = y;\r\n\t\t\t\tdfx += ddfx;\r\n\t\t\t\tdfy += ddfy;\r\n\t\t\t\tddfx += dddfx;\r\n\t\t\t\tddfy += dddfy;\r\n\t\t\t\tx += dfx;\r\n\t\t\t\ty += dfy;\r\n\t\t\t}\r\n\t\t};\r\n\t\tCurveTimeline.prototype.getCurvePercent = function (frameIndex, percent) {\r\n\t\t\tpercent = spine.MathUtils.clamp(percent, 0, 1);\r\n\t\t\tvar curves = this.curves;\r\n\t\t\tvar i = frameIndex * CurveTimeline.BEZIER_SIZE;\r\n\t\t\tvar type = curves[i];\r\n\t\t\tif (type == CurveTimeline.LINEAR)\r\n\t\t\t\treturn percent;\r\n\t\t\tif (type == CurveTimeline.STEPPED)\r\n\t\t\t\treturn 0;\r\n\t\t\ti++;\r\n\t\t\tvar x = 0;\r\n\t\t\tfor (var start = i, n = i + CurveTimeline.BEZIER_SIZE - 1; i < n; i += 2) {\r\n\t\t\t\tx = curves[i];\r\n\t\t\t\tif (x >= percent) {\r\n\t\t\t\t\tvar prevX = void 0, prevY = void 0;\r\n\t\t\t\t\tif (i == start) {\r\n\t\t\t\t\t\tprevX = 0;\r\n\t\t\t\t\t\tprevY = 0;\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tprevX = curves[i - 2];\r\n\t\t\t\t\t\tprevY = curves[i - 1];\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn prevY + (curves[i + 1] - prevY) * (percent - prevX) / (x - prevX);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tvar y = curves[i - 1];\r\n\t\t\treturn y + (1 - y) * (percent - x) / (1 - x);\r\n\t\t};\r\n\t\tCurveTimeline.LINEAR = 0;\r\n\t\tCurveTimeline.STEPPED = 1;\r\n\t\tCurveTimeline.BEZIER = 2;\r\n\t\tCurveTimeline.BEZIER_SIZE = 10 * 2 - 1;\r\n\t\treturn CurveTimeline;\r\n\t}());\r\n\tspine.CurveTimeline = CurveTimeline;\r\n\tvar RotateTimeline = (function (_super) {\r\n\t\t__extends(RotateTimeline, _super);\r\n\t\tfunction RotateTimeline(frameCount) {\r\n\t\t\tvar _this = _super.call(this, frameCount) || this;\r\n\t\t\t_this.frames = spine.Utils.newFloatArray(frameCount << 1);\r\n\t\t\treturn _this;\r\n\t\t}\r\n\t\tRotateTimeline.prototype.getPropertyId = function () {\r\n\t\t\treturn (TimelineType.rotate << 24) + this.boneIndex;\r\n\t\t};\r\n\t\tRotateTimeline.prototype.setFrame = function (frameIndex, time, degrees) {\r\n\t\t\tframeIndex <<= 1;\r\n\t\t\tthis.frames[frameIndex] = time;\r\n\t\t\tthis.frames[frameIndex + RotateTimeline.ROTATION] = degrees;\r\n\t\t};\r\n\t\tRotateTimeline.prototype.apply = function (skeleton, lastTime, time, events, alpha, pose, direction) {\r\n\t\t\tvar frames = this.frames;\r\n\t\t\tvar bone = skeleton.bones[this.boneIndex];\r\n\t\t\tif (time < frames[0]) {\r\n\t\t\t\tswitch (pose) {\r\n\t\t\t\t\tcase MixPose.setup:\r\n\t\t\t\t\t\tbone.rotation = bone.data.rotation;\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\tcase MixPose.current:\r\n\t\t\t\t\t\tvar r_1 = bone.data.rotation - bone.rotation;\r\n\t\t\t\t\t\tr_1 -= (16384 - ((16384.499999999996 - r_1 / 360) | 0)) * 360;\r\n\t\t\t\t\t\tbone.rotation += r_1 * alpha;\r\n\t\t\t\t}\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tif (time >= frames[frames.length - RotateTimeline.ENTRIES]) {\r\n\t\t\t\tif (pose == MixPose.setup)\r\n\t\t\t\t\tbone.rotation = bone.data.rotation + frames[frames.length + RotateTimeline.PREV_ROTATION] * alpha;\r\n\t\t\t\telse {\r\n\t\t\t\t\tvar r_2 = bone.data.rotation + frames[frames.length + RotateTimeline.PREV_ROTATION] - bone.rotation;\r\n\t\t\t\t\tr_2 -= (16384 - ((16384.499999999996 - r_2 / 360) | 0)) * 360;\r\n\t\t\t\t\tbone.rotation += r_2 * alpha;\r\n\t\t\t\t}\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tvar frame = Animation.binarySearch(frames, time, RotateTimeline.ENTRIES);\r\n\t\t\tvar prevRotation = frames[frame + RotateTimeline.PREV_ROTATION];\r\n\t\t\tvar frameTime = frames[frame];\r\n\t\t\tvar percent = this.getCurvePercent((frame >> 1) - 1, 1 - (time - frameTime) / (frames[frame + RotateTimeline.PREV_TIME] - frameTime));\r\n\t\t\tvar r = frames[frame + RotateTimeline.ROTATION] - prevRotation;\r\n\t\t\tr -= (16384 - ((16384.499999999996 - r / 360) | 0)) * 360;\r\n\t\t\tr = prevRotation + r * percent;\r\n\t\t\tif (pose == MixPose.setup) {\r\n\t\t\t\tr -= (16384 - ((16384.499999999996 - r / 360) | 0)) * 360;\r\n\t\t\t\tbone.rotation = bone.data.rotation + r * alpha;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tr = bone.data.rotation + r - bone.rotation;\r\n\t\t\t\tr -= (16384 - ((16384.499999999996 - r / 360) | 0)) * 360;\r\n\t\t\t\tbone.rotation += r * alpha;\r\n\t\t\t}\r\n\t\t};\r\n\t\tRotateTimeline.ENTRIES = 2;\r\n\t\tRotateTimeline.PREV_TIME = -2;\r\n\t\tRotateTimeline.PREV_ROTATION = -1;\r\n\t\tRotateTimeline.ROTATION = 1;\r\n\t\treturn RotateTimeline;\r\n\t}(CurveTimeline));\r\n\tspine.RotateTimeline = RotateTimeline;\r\n\tvar TranslateTimeline = (function (_super) {\r\n\t\t__extends(TranslateTimeline, _super);\r\n\t\tfunction TranslateTimeline(frameCount) {\r\n\t\t\tvar _this = _super.call(this, frameCount) || this;\r\n\t\t\t_this.frames = spine.Utils.newFloatArray(frameCount * TranslateTimeline.ENTRIES);\r\n\t\t\treturn _this;\r\n\t\t}\r\n\t\tTranslateTimeline.prototype.getPropertyId = function () {\r\n\t\t\treturn (TimelineType.translate << 24) + this.boneIndex;\r\n\t\t};\r\n\t\tTranslateTimeline.prototype.setFrame = function (frameIndex, time, x, y) {\r\n\t\t\tframeIndex *= TranslateTimeline.ENTRIES;\r\n\t\t\tthis.frames[frameIndex] = time;\r\n\t\t\tthis.frames[frameIndex + TranslateTimeline.X] = x;\r\n\t\t\tthis.frames[frameIndex + TranslateTimeline.Y] = y;\r\n\t\t};\r\n\t\tTranslateTimeline.prototype.apply = function (skeleton, lastTime, time, events, alpha, pose, direction) {\r\n\t\t\tvar frames = this.frames;\r\n\t\t\tvar bone = skeleton.bones[this.boneIndex];\r\n\t\t\tif (time < frames[0]) {\r\n\t\t\t\tswitch (pose) {\r\n\t\t\t\t\tcase MixPose.setup:\r\n\t\t\t\t\t\tbone.x = bone.data.x;\r\n\t\t\t\t\t\tbone.y = bone.data.y;\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\tcase MixPose.current:\r\n\t\t\t\t\t\tbone.x += (bone.data.x - bone.x) * alpha;\r\n\t\t\t\t\t\tbone.y += (bone.data.y - bone.y) * alpha;\r\n\t\t\t\t}\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tvar x = 0, y = 0;\r\n\t\t\tif (time >= frames[frames.length - TranslateTimeline.ENTRIES]) {\r\n\t\t\t\tx = frames[frames.length + TranslateTimeline.PREV_X];\r\n\t\t\t\ty = frames[frames.length + TranslateTimeline.PREV_Y];\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tvar frame = Animation.binarySearch(frames, time, TranslateTimeline.ENTRIES);\r\n\t\t\t\tx = frames[frame + TranslateTimeline.PREV_X];\r\n\t\t\t\ty = frames[frame + TranslateTimeline.PREV_Y];\r\n\t\t\t\tvar frameTime = frames[frame];\r\n\t\t\t\tvar percent = this.getCurvePercent(frame / TranslateTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + TranslateTimeline.PREV_TIME] - frameTime));\r\n\t\t\t\tx += (frames[frame + TranslateTimeline.X] - x) * percent;\r\n\t\t\t\ty += (frames[frame + TranslateTimeline.Y] - y) * percent;\r\n\t\t\t}\r\n\t\t\tif (pose == MixPose.setup) {\r\n\t\t\t\tbone.x = bone.data.x + x * alpha;\r\n\t\t\t\tbone.y = bone.data.y + y * alpha;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tbone.x += (bone.data.x + x - bone.x) * alpha;\r\n\t\t\t\tbone.y += (bone.data.y + y - bone.y) * alpha;\r\n\t\t\t}\r\n\t\t};\r\n\t\tTranslateTimeline.ENTRIES = 3;\r\n\t\tTranslateTimeline.PREV_TIME = -3;\r\n\t\tTranslateTimeline.PREV_X = -2;\r\n\t\tTranslateTimeline.PREV_Y = -1;\r\n\t\tTranslateTimeline.X = 1;\r\n\t\tTranslateTimeline.Y = 2;\r\n\t\treturn TranslateTimeline;\r\n\t}(CurveTimeline));\r\n\tspine.TranslateTimeline = TranslateTimeline;\r\n\tvar ScaleTimeline = (function (_super) {\r\n\t\t__extends(ScaleTimeline, _super);\r\n\t\tfunction ScaleTimeline(frameCount) {\r\n\t\t\treturn _super.call(this, frameCount) || this;\r\n\t\t}\r\n\t\tScaleTimeline.prototype.getPropertyId = function () {\r\n\t\t\treturn (TimelineType.scale << 24) + this.boneIndex;\r\n\t\t};\r\n\t\tScaleTimeline.prototype.apply = function (skeleton, lastTime, time, events, alpha, pose, direction) {\r\n\t\t\tvar frames = this.frames;\r\n\t\t\tvar bone = skeleton.bones[this.boneIndex];\r\n\t\t\tif (time < frames[0]) {\r\n\t\t\t\tswitch (pose) {\r\n\t\t\t\t\tcase MixPose.setup:\r\n\t\t\t\t\t\tbone.scaleX = bone.data.scaleX;\r\n\t\t\t\t\t\tbone.scaleY = bone.data.scaleY;\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\tcase MixPose.current:\r\n\t\t\t\t\t\tbone.scaleX += (bone.data.scaleX - bone.scaleX) * alpha;\r\n\t\t\t\t\t\tbone.scaleY += (bone.data.scaleY - bone.scaleY) * alpha;\r\n\t\t\t\t}\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tvar x = 0, y = 0;\r\n\t\t\tif (time >= frames[frames.length - ScaleTimeline.ENTRIES]) {\r\n\t\t\t\tx = frames[frames.length + ScaleTimeline.PREV_X] * bone.data.scaleX;\r\n\t\t\t\ty = frames[frames.length + ScaleTimeline.PREV_Y] * bone.data.scaleY;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tvar frame = Animation.binarySearch(frames, time, ScaleTimeline.ENTRIES);\r\n\t\t\t\tx = frames[frame + ScaleTimeline.PREV_X];\r\n\t\t\t\ty = frames[frame + ScaleTimeline.PREV_Y];\r\n\t\t\t\tvar frameTime = frames[frame];\r\n\t\t\t\tvar percent = this.getCurvePercent(frame / ScaleTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + ScaleTimeline.PREV_TIME] - frameTime));\r\n\t\t\t\tx = (x + (frames[frame + ScaleTimeline.X] - x) * percent) * bone.data.scaleX;\r\n\t\t\t\ty = (y + (frames[frame + ScaleTimeline.Y] - y) * percent) * bone.data.scaleY;\r\n\t\t\t}\r\n\t\t\tif (alpha == 1) {\r\n\t\t\t\tbone.scaleX = x;\r\n\t\t\t\tbone.scaleY = y;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tvar bx = 0, by = 0;\r\n\t\t\t\tif (pose == MixPose.setup) {\r\n\t\t\t\t\tbx = bone.data.scaleX;\r\n\t\t\t\t\tby = bone.data.scaleY;\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tbx = bone.scaleX;\r\n\t\t\t\t\tby = bone.scaleY;\r\n\t\t\t\t}\r\n\t\t\t\tif (direction == MixDirection.out) {\r\n\t\t\t\t\tx = Math.abs(x) * spine.MathUtils.signum(bx);\r\n\t\t\t\t\ty = Math.abs(y) * spine.MathUtils.signum(by);\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tbx = Math.abs(bx) * spine.MathUtils.signum(x);\r\n\t\t\t\t\tby = Math.abs(by) * spine.MathUtils.signum(y);\r\n\t\t\t\t}\r\n\t\t\t\tbone.scaleX = bx + (x - bx) * alpha;\r\n\t\t\t\tbone.scaleY = by + (y - by) * alpha;\r\n\t\t\t}\r\n\t\t};\r\n\t\treturn ScaleTimeline;\r\n\t}(TranslateTimeline));\r\n\tspine.ScaleTimeline = ScaleTimeline;\r\n\tvar ShearTimeline = (function (_super) {\r\n\t\t__extends(ShearTimeline, _super);\r\n\t\tfunction ShearTimeline(frameCount) {\r\n\t\t\treturn _super.call(this, frameCount) || this;\r\n\t\t}\r\n\t\tShearTimeline.prototype.getPropertyId = function () {\r\n\t\t\treturn (TimelineType.shear << 24) + this.boneIndex;\r\n\t\t};\r\n\t\tShearTimeline.prototype.apply = function (skeleton, lastTime, time, events, alpha, pose, direction) {\r\n\t\t\tvar frames = this.frames;\r\n\t\t\tvar bone = skeleton.bones[this.boneIndex];\r\n\t\t\tif (time < frames[0]) {\r\n\t\t\t\tswitch (pose) {\r\n\t\t\t\t\tcase MixPose.setup:\r\n\t\t\t\t\t\tbone.shearX = bone.data.shearX;\r\n\t\t\t\t\t\tbone.shearY = bone.data.shearY;\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\tcase MixPose.current:\r\n\t\t\t\t\t\tbone.shearX += (bone.data.shearX - bone.shearX) * alpha;\r\n\t\t\t\t\t\tbone.shearY += (bone.data.shearY - bone.shearY) * alpha;\r\n\t\t\t\t}\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tvar x = 0, y = 0;\r\n\t\t\tif (time >= frames[frames.length - ShearTimeline.ENTRIES]) {\r\n\t\t\t\tx = frames[frames.length + ShearTimeline.PREV_X];\r\n\t\t\t\ty = frames[frames.length + ShearTimeline.PREV_Y];\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tvar frame = Animation.binarySearch(frames, time, ShearTimeline.ENTRIES);\r\n\t\t\t\tx = frames[frame + ShearTimeline.PREV_X];\r\n\t\t\t\ty = frames[frame + ShearTimeline.PREV_Y];\r\n\t\t\t\tvar frameTime = frames[frame];\r\n\t\t\t\tvar percent = this.getCurvePercent(frame / ShearTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + ShearTimeline.PREV_TIME] - frameTime));\r\n\t\t\t\tx = x + (frames[frame + ShearTimeline.X] - x) * percent;\r\n\t\t\t\ty = y + (frames[frame + ShearTimeline.Y] - y) * percent;\r\n\t\t\t}\r\n\t\t\tif (pose == MixPose.setup) {\r\n\t\t\t\tbone.shearX = bone.data.shearX + x * alpha;\r\n\t\t\t\tbone.shearY = bone.data.shearY + y * alpha;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tbone.shearX += (bone.data.shearX + x - bone.shearX) * alpha;\r\n\t\t\t\tbone.shearY += (bone.data.shearY + y - bone.shearY) * alpha;\r\n\t\t\t}\r\n\t\t};\r\n\t\treturn ShearTimeline;\r\n\t}(TranslateTimeline));\r\n\tspine.ShearTimeline = ShearTimeline;\r\n\tvar ColorTimeline = (function (_super) {\r\n\t\t__extends(ColorTimeline, _super);\r\n\t\tfunction ColorTimeline(frameCount) {\r\n\t\t\tvar _this = _super.call(this, frameCount) || this;\r\n\t\t\t_this.frames = spine.Utils.newFloatArray(frameCount * ColorTimeline.ENTRIES);\r\n\t\t\treturn _this;\r\n\t\t}\r\n\t\tColorTimeline.prototype.getPropertyId = function () {\r\n\t\t\treturn (TimelineType.color << 24) + this.slotIndex;\r\n\t\t};\r\n\t\tColorTimeline.prototype.setFrame = function (frameIndex, time, r, g, b, a) {\r\n\t\t\tframeIndex *= ColorTimeline.ENTRIES;\r\n\t\t\tthis.frames[frameIndex] = time;\r\n\t\t\tthis.frames[frameIndex + ColorTimeline.R] = r;\r\n\t\t\tthis.frames[frameIndex + ColorTimeline.G] = g;\r\n\t\t\tthis.frames[frameIndex + ColorTimeline.B] = b;\r\n\t\t\tthis.frames[frameIndex + ColorTimeline.A] = a;\r\n\t\t};\r\n\t\tColorTimeline.prototype.apply = function (skeleton, lastTime, time, events, alpha, pose, direction) {\r\n\t\t\tvar slot = skeleton.slots[this.slotIndex];\r\n\t\t\tvar frames = this.frames;\r\n\t\t\tif (time < frames[0]) {\r\n\t\t\t\tswitch (pose) {\r\n\t\t\t\t\tcase MixPose.setup:\r\n\t\t\t\t\t\tslot.color.setFromColor(slot.data.color);\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\tcase MixPose.current:\r\n\t\t\t\t\t\tvar color = slot.color, setup = slot.data.color;\r\n\t\t\t\t\t\tcolor.add((setup.r - color.r) * alpha, (setup.g - color.g) * alpha, (setup.b - color.b) * alpha, (setup.a - color.a) * alpha);\r\n\t\t\t\t}\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tvar r = 0, g = 0, b = 0, a = 0;\r\n\t\t\tif (time >= frames[frames.length - ColorTimeline.ENTRIES]) {\r\n\t\t\t\tvar i = frames.length;\r\n\t\t\t\tr = frames[i + ColorTimeline.PREV_R];\r\n\t\t\t\tg = frames[i + ColorTimeline.PREV_G];\r\n\t\t\t\tb = frames[i + ColorTimeline.PREV_B];\r\n\t\t\t\ta = frames[i + ColorTimeline.PREV_A];\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tvar frame = Animation.binarySearch(frames, time, ColorTimeline.ENTRIES);\r\n\t\t\t\tr = frames[frame + ColorTimeline.PREV_R];\r\n\t\t\t\tg = frames[frame + ColorTimeline.PREV_G];\r\n\t\t\t\tb = frames[frame + ColorTimeline.PREV_B];\r\n\t\t\t\ta = frames[frame + ColorTimeline.PREV_A];\r\n\t\t\t\tvar frameTime = frames[frame];\r\n\t\t\t\tvar percent = this.getCurvePercent(frame / ColorTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + ColorTimeline.PREV_TIME] - frameTime));\r\n\t\t\t\tr += (frames[frame + ColorTimeline.R] - r) * percent;\r\n\t\t\t\tg += (frames[frame + ColorTimeline.G] - g) * percent;\r\n\t\t\t\tb += (frames[frame + ColorTimeline.B] - b) * percent;\r\n\t\t\t\ta += (frames[frame + ColorTimeline.A] - a) * percent;\r\n\t\t\t}\r\n\t\t\tif (alpha == 1)\r\n\t\t\t\tslot.color.set(r, g, b, a);\r\n\t\t\telse {\r\n\t\t\t\tvar color = slot.color;\r\n\t\t\t\tif (pose == MixPose.setup)\r\n\t\t\t\t\tcolor.setFromColor(slot.data.color);\r\n\t\t\t\tcolor.add((r - color.r) * alpha, (g - color.g) * alpha, (b - color.b) * alpha, (a - color.a) * alpha);\r\n\t\t\t}\r\n\t\t};\r\n\t\tColorTimeline.ENTRIES = 5;\r\n\t\tColorTimeline.PREV_TIME = -5;\r\n\t\tColorTimeline.PREV_R = -4;\r\n\t\tColorTimeline.PREV_G = -3;\r\n\t\tColorTimeline.PREV_B = -2;\r\n\t\tColorTimeline.PREV_A = -1;\r\n\t\tColorTimeline.R = 1;\r\n\t\tColorTimeline.G = 2;\r\n\t\tColorTimeline.B = 3;\r\n\t\tColorTimeline.A = 4;\r\n\t\treturn ColorTimeline;\r\n\t}(CurveTimeline));\r\n\tspine.ColorTimeline = ColorTimeline;\r\n\tvar TwoColorTimeline = (function (_super) {\r\n\t\t__extends(TwoColorTimeline, _super);\r\n\t\tfunction TwoColorTimeline(frameCount) {\r\n\t\t\tvar _this = _super.call(this, frameCount) || this;\r\n\t\t\t_this.frames = spine.Utils.newFloatArray(frameCount * TwoColorTimeline.ENTRIES);\r\n\t\t\treturn _this;\r\n\t\t}\r\n\t\tTwoColorTimeline.prototype.getPropertyId = function () {\r\n\t\t\treturn (TimelineType.twoColor << 24) + this.slotIndex;\r\n\t\t};\r\n\t\tTwoColorTimeline.prototype.setFrame = function (frameIndex, time, r, g, b, a, r2, g2, b2) {\r\n\t\t\tframeIndex *= TwoColorTimeline.ENTRIES;\r\n\t\t\tthis.frames[frameIndex] = time;\r\n\t\t\tthis.frames[frameIndex + TwoColorTimeline.R] = r;\r\n\t\t\tthis.frames[frameIndex + TwoColorTimeline.G] = g;\r\n\t\t\tthis.frames[frameIndex + TwoColorTimeline.B] = b;\r\n\t\t\tthis.frames[frameIndex + TwoColorTimeline.A] = a;\r\n\t\t\tthis.frames[frameIndex + TwoColorTimeline.R2] = r2;\r\n\t\t\tthis.frames[frameIndex + TwoColorTimeline.G2] = g2;\r\n\t\t\tthis.frames[frameIndex + TwoColorTimeline.B2] = b2;\r\n\t\t};\r\n\t\tTwoColorTimeline.prototype.apply = function (skeleton, lastTime, time, events, alpha, pose, direction) {\r\n\t\t\tvar slot = skeleton.slots[this.slotIndex];\r\n\t\t\tvar frames = this.frames;\r\n\t\t\tif (time < frames[0]) {\r\n\t\t\t\tswitch (pose) {\r\n\t\t\t\t\tcase MixPose.setup:\r\n\t\t\t\t\t\tslot.color.setFromColor(slot.data.color);\r\n\t\t\t\t\t\tslot.darkColor.setFromColor(slot.data.darkColor);\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\tcase MixPose.current:\r\n\t\t\t\t\t\tvar light = slot.color, dark = slot.darkColor, setupLight = slot.data.color, setupDark = slot.data.darkColor;\r\n\t\t\t\t\t\tlight.add((setupLight.r - light.r) * alpha, (setupLight.g - light.g) * alpha, (setupLight.b - light.b) * alpha, (setupLight.a - light.a) * alpha);\r\n\t\t\t\t\t\tdark.add((setupDark.r - dark.r) * alpha, (setupDark.g - dark.g) * alpha, (setupDark.b - dark.b) * alpha, 0);\r\n\t\t\t\t}\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tvar r = 0, g = 0, b = 0, a = 0, r2 = 0, g2 = 0, b2 = 0;\r\n\t\t\tif (time >= frames[frames.length - TwoColorTimeline.ENTRIES]) {\r\n\t\t\t\tvar i = frames.length;\r\n\t\t\t\tr = frames[i + TwoColorTimeline.PREV_R];\r\n\t\t\t\tg = frames[i + TwoColorTimeline.PREV_G];\r\n\t\t\t\tb = frames[i + TwoColorTimeline.PREV_B];\r\n\t\t\t\ta = frames[i + TwoColorTimeline.PREV_A];\r\n\t\t\t\tr2 = frames[i + TwoColorTimeline.PREV_R2];\r\n\t\t\t\tg2 = frames[i + TwoColorTimeline.PREV_G2];\r\n\t\t\t\tb2 = frames[i + TwoColorTimeline.PREV_B2];\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tvar frame = Animation.binarySearch(frames, time, TwoColorTimeline.ENTRIES);\r\n\t\t\t\tr = frames[frame + TwoColorTimeline.PREV_R];\r\n\t\t\t\tg = frames[frame + TwoColorTimeline.PREV_G];\r\n\t\t\t\tb = frames[frame + TwoColorTimeline.PREV_B];\r\n\t\t\t\ta = frames[frame + TwoColorTimeline.PREV_A];\r\n\t\t\t\tr2 = frames[frame + TwoColorTimeline.PREV_R2];\r\n\t\t\t\tg2 = frames[frame + TwoColorTimeline.PREV_G2];\r\n\t\t\t\tb2 = frames[frame + TwoColorTimeline.PREV_B2];\r\n\t\t\t\tvar frameTime = frames[frame];\r\n\t\t\t\tvar percent = this.getCurvePercent(frame / TwoColorTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + TwoColorTimeline.PREV_TIME] - frameTime));\r\n\t\t\t\tr += (frames[frame + TwoColorTimeline.R] - r) * percent;\r\n\t\t\t\tg += (frames[frame + TwoColorTimeline.G] - g) * percent;\r\n\t\t\t\tb += (frames[frame + TwoColorTimeline.B] - b) * percent;\r\n\t\t\t\ta += (frames[frame + TwoColorTimeline.A] - a) * percent;\r\n\t\t\t\tr2 += (frames[frame + TwoColorTimeline.R2] - r2) * percent;\r\n\t\t\t\tg2 += (frames[frame + TwoColorTimeline.G2] - g2) * percent;\r\n\t\t\t\tb2 += (frames[frame + TwoColorTimeline.B2] - b2) * percent;\r\n\t\t\t}\r\n\t\t\tif (alpha == 1) {\r\n\t\t\t\tslot.color.set(r, g, b, a);\r\n\t\t\t\tslot.darkColor.set(r2, g2, b2, 1);\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tvar light = slot.color, dark = slot.darkColor;\r\n\t\t\t\tif (pose == MixPose.setup) {\r\n\t\t\t\t\tlight.setFromColor(slot.data.color);\r\n\t\t\t\t\tdark.setFromColor(slot.data.darkColor);\r\n\t\t\t\t}\r\n\t\t\t\tlight.add((r - light.r) * alpha, (g - light.g) * alpha, (b - light.b) * alpha, (a - light.a) * alpha);\r\n\t\t\t\tdark.add((r2 - dark.r) * alpha, (g2 - dark.g) * alpha, (b2 - dark.b) * alpha, 0);\r\n\t\t\t}\r\n\t\t};\r\n\t\tTwoColorTimeline.ENTRIES = 8;\r\n\t\tTwoColorTimeline.PREV_TIME = -8;\r\n\t\tTwoColorTimeline.PREV_R = -7;\r\n\t\tTwoColorTimeline.PREV_G = -6;\r\n\t\tTwoColorTimeline.PREV_B = -5;\r\n\t\tTwoColorTimeline.PREV_A = -4;\r\n\t\tTwoColorTimeline.PREV_R2 = -3;\r\n\t\tTwoColorTimeline.PREV_G2 = -2;\r\n\t\tTwoColorTimeline.PREV_B2 = -1;\r\n\t\tTwoColorTimeline.R = 1;\r\n\t\tTwoColorTimeline.G = 2;\r\n\t\tTwoColorTimeline.B = 3;\r\n\t\tTwoColorTimeline.A = 4;\r\n\t\tTwoColorTimeline.R2 = 5;\r\n\t\tTwoColorTimeline.G2 = 6;\r\n\t\tTwoColorTimeline.B2 = 7;\r\n\t\treturn TwoColorTimeline;\r\n\t}(CurveTimeline));\r\n\tspine.TwoColorTimeline = TwoColorTimeline;\r\n\tvar AttachmentTimeline = (function () {\r\n\t\tfunction AttachmentTimeline(frameCount) {\r\n\t\t\tthis.frames = spine.Utils.newFloatArray(frameCount);\r\n\t\t\tthis.attachmentNames = new Array(frameCount);\r\n\t\t}\r\n\t\tAttachmentTimeline.prototype.getPropertyId = function () {\r\n\t\t\treturn (TimelineType.attachment << 24) + this.slotIndex;\r\n\t\t};\r\n\t\tAttachmentTimeline.prototype.getFrameCount = function () {\r\n\t\t\treturn this.frames.length;\r\n\t\t};\r\n\t\tAttachmentTimeline.prototype.setFrame = function (frameIndex, time, attachmentName) {\r\n\t\t\tthis.frames[frameIndex] = time;\r\n\t\t\tthis.attachmentNames[frameIndex] = attachmentName;\r\n\t\t};\r\n\t\tAttachmentTimeline.prototype.apply = function (skeleton, lastTime, time, events, alpha, pose, direction) {\r\n\t\t\tvar slot = skeleton.slots[this.slotIndex];\r\n\t\t\tif (direction == MixDirection.out && pose == MixPose.setup) {\r\n\t\t\t\tvar attachmentName_1 = slot.data.attachmentName;\r\n\t\t\t\tslot.setAttachment(attachmentName_1 == null ? null : skeleton.getAttachment(this.slotIndex, attachmentName_1));\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tvar frames = this.frames;\r\n\t\t\tif (time < frames[0]) {\r\n\t\t\t\tif (pose == MixPose.setup) {\r\n\t\t\t\t\tvar attachmentName_2 = slot.data.attachmentName;\r\n\t\t\t\t\tslot.setAttachment(attachmentName_2 == null ? null : skeleton.getAttachment(this.slotIndex, attachmentName_2));\r\n\t\t\t\t}\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tvar frameIndex = 0;\r\n\t\t\tif (time >= frames[frames.length - 1])\r\n\t\t\t\tframeIndex = frames.length - 1;\r\n\t\t\telse\r\n\t\t\t\tframeIndex = Animation.binarySearch(frames, time, 1) - 1;\r\n\t\t\tvar attachmentName = this.attachmentNames[frameIndex];\r\n\t\t\tskeleton.slots[this.slotIndex]\r\n\t\t\t\t.setAttachment(attachmentName == null ? null : skeleton.getAttachment(this.slotIndex, attachmentName));\r\n\t\t};\r\n\t\treturn AttachmentTimeline;\r\n\t}());\r\n\tspine.AttachmentTimeline = AttachmentTimeline;\r\n\tvar zeros = null;\r\n\tvar DeformTimeline = (function (_super) {\r\n\t\t__extends(DeformTimeline, _super);\r\n\t\tfunction DeformTimeline(frameCount) {\r\n\t\t\tvar _this = _super.call(this, frameCount) || this;\r\n\t\t\t_this.frames = spine.Utils.newFloatArray(frameCount);\r\n\t\t\t_this.frameVertices = new Array(frameCount);\r\n\t\t\tif (zeros == null)\r\n\t\t\t\tzeros = spine.Utils.newFloatArray(64);\r\n\t\t\treturn _this;\r\n\t\t}\r\n\t\tDeformTimeline.prototype.getPropertyId = function () {\r\n\t\t\treturn (TimelineType.deform << 27) + +this.attachment.id + this.slotIndex;\r\n\t\t};\r\n\t\tDeformTimeline.prototype.setFrame = function (frameIndex, time, vertices) {\r\n\t\t\tthis.frames[frameIndex] = time;\r\n\t\t\tthis.frameVertices[frameIndex] = vertices;\r\n\t\t};\r\n\t\tDeformTimeline.prototype.apply = function (skeleton, lastTime, time, firedEvents, alpha, pose, direction) {\r\n\t\t\tvar slot = skeleton.slots[this.slotIndex];\r\n\t\t\tvar slotAttachment = slot.getAttachment();\r\n\t\t\tif (!(slotAttachment instanceof spine.VertexAttachment) || !slotAttachment.applyDeform(this.attachment))\r\n\t\t\t\treturn;\r\n\t\t\tvar verticesArray = slot.attachmentVertices;\r\n\t\t\tif (verticesArray.length == 0)\r\n\t\t\t\talpha = 1;\r\n\t\t\tvar frameVertices = this.frameVertices;\r\n\t\t\tvar vertexCount = frameVertices[0].length;\r\n\t\t\tvar frames = this.frames;\r\n\t\t\tif (time < frames[0]) {\r\n\t\t\t\tvar vertexAttachment = slotAttachment;\r\n\t\t\t\tswitch (pose) {\r\n\t\t\t\t\tcase MixPose.setup:\r\n\t\t\t\t\t\tverticesArray.length = 0;\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\tcase MixPose.current:\r\n\t\t\t\t\t\tif (alpha == 1) {\r\n\t\t\t\t\t\t\tverticesArray.length = 0;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tvar vertices_1 = spine.Utils.setArraySize(verticesArray, vertexCount);\r\n\t\t\t\t\t\tif (vertexAttachment.bones == null) {\r\n\t\t\t\t\t\t\tvar setupVertices = vertexAttachment.vertices;\r\n\t\t\t\t\t\t\tfor (var i = 0; i < vertexCount; i++)\r\n\t\t\t\t\t\t\t\tvertices_1[i] += (setupVertices[i] - vertices_1[i]) * alpha;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\talpha = 1 - alpha;\r\n\t\t\t\t\t\t\tfor (var i = 0; i < vertexCount; i++)\r\n\t\t\t\t\t\t\t\tvertices_1[i] *= alpha;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tvar vertices = spine.Utils.setArraySize(verticesArray, vertexCount);\r\n\t\t\tif (time >= frames[frames.length - 1]) {\r\n\t\t\t\tvar lastVertices = frameVertices[frames.length - 1];\r\n\t\t\t\tif (alpha == 1) {\r\n\t\t\t\t\tspine.Utils.arrayCopy(lastVertices, 0, vertices, 0, vertexCount);\r\n\t\t\t\t}\r\n\t\t\t\telse if (pose == MixPose.setup) {\r\n\t\t\t\t\tvar vertexAttachment = slotAttachment;\r\n\t\t\t\t\tif (vertexAttachment.bones == null) {\r\n\t\t\t\t\t\tvar setupVertices_1 = vertexAttachment.vertices;\r\n\t\t\t\t\t\tfor (var i_1 = 0; i_1 < vertexCount; i_1++) {\r\n\t\t\t\t\t\t\tvar setup = setupVertices_1[i_1];\r\n\t\t\t\t\t\t\tvertices[i_1] = setup + (lastVertices[i_1] - setup) * alpha;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tfor (var i_2 = 0; i_2 < vertexCount; i_2++)\r\n\t\t\t\t\t\t\tvertices[i_2] = lastVertices[i_2] * alpha;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tfor (var i_3 = 0; i_3 < vertexCount; i_3++)\r\n\t\t\t\t\t\tvertices[i_3] += (lastVertices[i_3] - vertices[i_3]) * alpha;\r\n\t\t\t\t}\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tvar frame = Animation.binarySearch(frames, time);\r\n\t\t\tvar prevVertices = frameVertices[frame - 1];\r\n\t\t\tvar nextVertices = frameVertices[frame];\r\n\t\t\tvar frameTime = frames[frame];\r\n\t\t\tvar percent = this.getCurvePercent(frame - 1, 1 - (time - frameTime) / (frames[frame - 1] - frameTime));\r\n\t\t\tif (alpha == 1) {\r\n\t\t\t\tfor (var i_4 = 0; i_4 < vertexCount; i_4++) {\r\n\t\t\t\t\tvar prev = prevVertices[i_4];\r\n\t\t\t\t\tvertices[i_4] = prev + (nextVertices[i_4] - prev) * percent;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse if (pose == MixPose.setup) {\r\n\t\t\t\tvar vertexAttachment = slotAttachment;\r\n\t\t\t\tif (vertexAttachment.bones == null) {\r\n\t\t\t\t\tvar setupVertices_2 = vertexAttachment.vertices;\r\n\t\t\t\t\tfor (var i_5 = 0; i_5 < vertexCount; i_5++) {\r\n\t\t\t\t\t\tvar prev = prevVertices[i_5], setup = setupVertices_2[i_5];\r\n\t\t\t\t\t\tvertices[i_5] = setup + (prev + (nextVertices[i_5] - prev) * percent - setup) * alpha;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tfor (var i_6 = 0; i_6 < vertexCount; i_6++) {\r\n\t\t\t\t\t\tvar prev = prevVertices[i_6];\r\n\t\t\t\t\t\tvertices[i_6] = (prev + (nextVertices[i_6] - prev) * percent) * alpha;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tfor (var i_7 = 0; i_7 < vertexCount; i_7++) {\r\n\t\t\t\t\tvar prev = prevVertices[i_7];\r\n\t\t\t\t\tvertices[i_7] += (prev + (nextVertices[i_7] - prev) * percent - vertices[i_7]) * alpha;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\t\treturn DeformTimeline;\r\n\t}(CurveTimeline));\r\n\tspine.DeformTimeline = DeformTimeline;\r\n\tvar EventTimeline = (function () {\r\n\t\tfunction EventTimeline(frameCount) {\r\n\t\t\tthis.frames = spine.Utils.newFloatArray(frameCount);\r\n\t\t\tthis.events = new Array(frameCount);\r\n\t\t}\r\n\t\tEventTimeline.prototype.getPropertyId = function () {\r\n\t\t\treturn TimelineType.event << 24;\r\n\t\t};\r\n\t\tEventTimeline.prototype.getFrameCount = function () {\r\n\t\t\treturn this.frames.length;\r\n\t\t};\r\n\t\tEventTimeline.prototype.setFrame = function (frameIndex, event) {\r\n\t\t\tthis.frames[frameIndex] = event.time;\r\n\t\t\tthis.events[frameIndex] = event;\r\n\t\t};\r\n\t\tEventTimeline.prototype.apply = function (skeleton, lastTime, time, firedEvents, alpha, pose, direction) {\r\n\t\t\tif (firedEvents == null)\r\n\t\t\t\treturn;\r\n\t\t\tvar frames = this.frames;\r\n\t\t\tvar frameCount = this.frames.length;\r\n\t\t\tif (lastTime > time) {\r\n\t\t\t\tthis.apply(skeleton, lastTime, Number.MAX_VALUE, firedEvents, alpha, pose, direction);\r\n\t\t\t\tlastTime = -1;\r\n\t\t\t}\r\n\t\t\telse if (lastTime >= frames[frameCount - 1])\r\n\t\t\t\treturn;\r\n\t\t\tif (time < frames[0])\r\n\t\t\t\treturn;\r\n\t\t\tvar frame = 0;\r\n\t\t\tif (lastTime < frames[0])\r\n\t\t\t\tframe = 0;\r\n\t\t\telse {\r\n\t\t\t\tframe = Animation.binarySearch(frames, lastTime);\r\n\t\t\t\tvar frameTime = frames[frame];\r\n\t\t\t\twhile (frame > 0) {\r\n\t\t\t\t\tif (frames[frame - 1] != frameTime)\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tframe--;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tfor (; frame < frameCount && time >= frames[frame]; frame++)\r\n\t\t\t\tfiredEvents.push(this.events[frame]);\r\n\t\t};\r\n\t\treturn EventTimeline;\r\n\t}());\r\n\tspine.EventTimeline = EventTimeline;\r\n\tvar DrawOrderTimeline = (function () {\r\n\t\tfunction DrawOrderTimeline(frameCount) {\r\n\t\t\tthis.frames = spine.Utils.newFloatArray(frameCount);\r\n\t\t\tthis.drawOrders = new Array(frameCount);\r\n\t\t}\r\n\t\tDrawOrderTimeline.prototype.getPropertyId = function () {\r\n\t\t\treturn TimelineType.drawOrder << 24;\r\n\t\t};\r\n\t\tDrawOrderTimeline.prototype.getFrameCount = function () {\r\n\t\t\treturn this.frames.length;\r\n\t\t};\r\n\t\tDrawOrderTimeline.prototype.setFrame = function (frameIndex, time, drawOrder) {\r\n\t\t\tthis.frames[frameIndex] = time;\r\n\t\t\tthis.drawOrders[frameIndex] = drawOrder;\r\n\t\t};\r\n\t\tDrawOrderTimeline.prototype.apply = function (skeleton, lastTime, time, firedEvents, alpha, pose, direction) {\r\n\t\t\tvar drawOrder = skeleton.drawOrder;\r\n\t\t\tvar slots = skeleton.slots;\r\n\t\t\tif (direction == MixDirection.out && pose == MixPose.setup) {\r\n\t\t\t\tspine.Utils.arrayCopy(skeleton.slots, 0, skeleton.drawOrder, 0, skeleton.slots.length);\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tvar frames = this.frames;\r\n\t\t\tif (time < frames[0]) {\r\n\t\t\t\tif (pose == MixPose.setup)\r\n\t\t\t\t\tspine.Utils.arrayCopy(skeleton.slots, 0, skeleton.drawOrder, 0, skeleton.slots.length);\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tvar frame = 0;\r\n\t\t\tif (time >= frames[frames.length - 1])\r\n\t\t\t\tframe = frames.length - 1;\r\n\t\t\telse\r\n\t\t\t\tframe = Animation.binarySearch(frames, time) - 1;\r\n\t\t\tvar drawOrderToSetupIndex = this.drawOrders[frame];\r\n\t\t\tif (drawOrderToSetupIndex == null)\r\n\t\t\t\tspine.Utils.arrayCopy(slots, 0, drawOrder, 0, slots.length);\r\n\t\t\telse {\r\n\t\t\t\tfor (var i = 0, n = drawOrderToSetupIndex.length; i < n; i++)\r\n\t\t\t\t\tdrawOrder[i] = slots[drawOrderToSetupIndex[i]];\r\n\t\t\t}\r\n\t\t};\r\n\t\treturn DrawOrderTimeline;\r\n\t}());\r\n\tspine.DrawOrderTimeline = DrawOrderTimeline;\r\n\tvar IkConstraintTimeline = (function (_super) {\r\n\t\t__extends(IkConstraintTimeline, _super);\r\n\t\tfunction IkConstraintTimeline(frameCount) {\r\n\t\t\tvar _this = _super.call(this, frameCount) || this;\r\n\t\t\t_this.frames = spine.Utils.newFloatArray(frameCount * IkConstraintTimeline.ENTRIES);\r\n\t\t\treturn _this;\r\n\t\t}\r\n\t\tIkConstraintTimeline.prototype.getPropertyId = function () {\r\n\t\t\treturn (TimelineType.ikConstraint << 24) + this.ikConstraintIndex;\r\n\t\t};\r\n\t\tIkConstraintTimeline.prototype.setFrame = function (frameIndex, time, mix, bendDirection) {\r\n\t\t\tframeIndex *= IkConstraintTimeline.ENTRIES;\r\n\t\t\tthis.frames[frameIndex] = time;\r\n\t\t\tthis.frames[frameIndex + IkConstraintTimeline.MIX] = mix;\r\n\t\t\tthis.frames[frameIndex + IkConstraintTimeline.BEND_DIRECTION] = bendDirection;\r\n\t\t};\r\n\t\tIkConstraintTimeline.prototype.apply = function (skeleton, lastTime, time, firedEvents, alpha, pose, direction) {\r\n\t\t\tvar frames = this.frames;\r\n\t\t\tvar constraint = skeleton.ikConstraints[this.ikConstraintIndex];\r\n\t\t\tif (time < frames[0]) {\r\n\t\t\t\tswitch (pose) {\r\n\t\t\t\t\tcase MixPose.setup:\r\n\t\t\t\t\t\tconstraint.mix = constraint.data.mix;\r\n\t\t\t\t\t\tconstraint.bendDirection = constraint.data.bendDirection;\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\tcase MixPose.current:\r\n\t\t\t\t\t\tconstraint.mix += (constraint.data.mix - constraint.mix) * alpha;\r\n\t\t\t\t\t\tconstraint.bendDirection = constraint.data.bendDirection;\r\n\t\t\t\t}\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tif (time >= frames[frames.length - IkConstraintTimeline.ENTRIES]) {\r\n\t\t\t\tif (pose == MixPose.setup) {\r\n\t\t\t\t\tconstraint.mix = constraint.data.mix + (frames[frames.length + IkConstraintTimeline.PREV_MIX] - constraint.data.mix) * alpha;\r\n\t\t\t\t\tconstraint.bendDirection = direction == MixDirection.out ? constraint.data.bendDirection\r\n\t\t\t\t\t\t: frames[frames.length + IkConstraintTimeline.PREV_BEND_DIRECTION];\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tconstraint.mix += (frames[frames.length + IkConstraintTimeline.PREV_MIX] - constraint.mix) * alpha;\r\n\t\t\t\t\tif (direction == MixDirection[\"in\"])\r\n\t\t\t\t\t\tconstraint.bendDirection = frames[frames.length + IkConstraintTimeline.PREV_BEND_DIRECTION];\r\n\t\t\t\t}\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tvar frame = Animation.binarySearch(frames, time, IkConstraintTimeline.ENTRIES);\r\n\t\t\tvar mix = frames[frame + IkConstraintTimeline.PREV_MIX];\r\n\t\t\tvar frameTime = frames[frame];\r\n\t\t\tvar percent = this.getCurvePercent(frame / IkConstraintTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + IkConstraintTimeline.PREV_TIME] - frameTime));\r\n\t\t\tif (pose == MixPose.setup) {\r\n\t\t\t\tconstraint.mix = constraint.data.mix + (mix + (frames[frame + IkConstraintTimeline.MIX] - mix) * percent - constraint.data.mix) * alpha;\r\n\t\t\t\tconstraint.bendDirection = direction == MixDirection.out ? constraint.data.bendDirection : frames[frame + IkConstraintTimeline.PREV_BEND_DIRECTION];\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tconstraint.mix += (mix + (frames[frame + IkConstraintTimeline.MIX] - mix) * percent - constraint.mix) * alpha;\r\n\t\t\t\tif (direction == MixDirection[\"in\"])\r\n\t\t\t\t\tconstraint.bendDirection = frames[frame + IkConstraintTimeline.PREV_BEND_DIRECTION];\r\n\t\t\t}\r\n\t\t};\r\n\t\tIkConstraintTimeline.ENTRIES = 3;\r\n\t\tIkConstraintTimeline.PREV_TIME = -3;\r\n\t\tIkConstraintTimeline.PREV_MIX = -2;\r\n\t\tIkConstraintTimeline.PREV_BEND_DIRECTION = -1;\r\n\t\tIkConstraintTimeline.MIX = 1;\r\n\t\tIkConstraintTimeline.BEND_DIRECTION = 2;\r\n\t\treturn IkConstraintTimeline;\r\n\t}(CurveTimeline));\r\n\tspine.IkConstraintTimeline = IkConstraintTimeline;\r\n\tvar TransformConstraintTimeline = (function (_super) {\r\n\t\t__extends(TransformConstraintTimeline, _super);\r\n\t\tfunction TransformConstraintTimeline(frameCount) {\r\n\t\t\tvar _this = _super.call(this, frameCount) || this;\r\n\t\t\t_this.frames = spine.Utils.newFloatArray(frameCount * TransformConstraintTimeline.ENTRIES);\r\n\t\t\treturn _this;\r\n\t\t}\r\n\t\tTransformConstraintTimeline.prototype.getPropertyId = function () {\r\n\t\t\treturn (TimelineType.transformConstraint << 24) + this.transformConstraintIndex;\r\n\t\t};\r\n\t\tTransformConstraintTimeline.prototype.setFrame = function (frameIndex, time, rotateMix, translateMix, scaleMix, shearMix) {\r\n\t\t\tframeIndex *= TransformConstraintTimeline.ENTRIES;\r\n\t\t\tthis.frames[frameIndex] = time;\r\n\t\t\tthis.frames[frameIndex + TransformConstraintTimeline.ROTATE] = rotateMix;\r\n\t\t\tthis.frames[frameIndex + TransformConstraintTimeline.TRANSLATE] = translateMix;\r\n\t\t\tthis.frames[frameIndex + TransformConstraintTimeline.SCALE] = scaleMix;\r\n\t\t\tthis.frames[frameIndex + TransformConstraintTimeline.SHEAR] = shearMix;\r\n\t\t};\r\n\t\tTransformConstraintTimeline.prototype.apply = function (skeleton, lastTime, time, firedEvents, alpha, pose, direction) {\r\n\t\t\tvar frames = this.frames;\r\n\t\t\tvar constraint = skeleton.transformConstraints[this.transformConstraintIndex];\r\n\t\t\tif (time < frames[0]) {\r\n\t\t\t\tvar data = constraint.data;\r\n\t\t\t\tswitch (pose) {\r\n\t\t\t\t\tcase MixPose.setup:\r\n\t\t\t\t\t\tconstraint.rotateMix = data.rotateMix;\r\n\t\t\t\t\t\tconstraint.translateMix = data.translateMix;\r\n\t\t\t\t\t\tconstraint.scaleMix = data.scaleMix;\r\n\t\t\t\t\t\tconstraint.shearMix = data.shearMix;\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\tcase MixPose.current:\r\n\t\t\t\t\t\tconstraint.rotateMix += (data.rotateMix - constraint.rotateMix) * alpha;\r\n\t\t\t\t\t\tconstraint.translateMix += (data.translateMix - constraint.translateMix) * alpha;\r\n\t\t\t\t\t\tconstraint.scaleMix += (data.scaleMix - constraint.scaleMix) * alpha;\r\n\t\t\t\t\t\tconstraint.shearMix += (data.shearMix - constraint.shearMix) * alpha;\r\n\t\t\t\t}\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tvar rotate = 0, translate = 0, scale = 0, shear = 0;\r\n\t\t\tif (time >= frames[frames.length - TransformConstraintTimeline.ENTRIES]) {\r\n\t\t\t\tvar i = frames.length;\r\n\t\t\t\trotate = frames[i + TransformConstraintTimeline.PREV_ROTATE];\r\n\t\t\t\ttranslate = frames[i + TransformConstraintTimeline.PREV_TRANSLATE];\r\n\t\t\t\tscale = frames[i + TransformConstraintTimeline.PREV_SCALE];\r\n\t\t\t\tshear = frames[i + TransformConstraintTimeline.PREV_SHEAR];\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tvar frame = Animation.binarySearch(frames, time, TransformConstraintTimeline.ENTRIES);\r\n\t\t\t\trotate = frames[frame + TransformConstraintTimeline.PREV_ROTATE];\r\n\t\t\t\ttranslate = frames[frame + TransformConstraintTimeline.PREV_TRANSLATE];\r\n\t\t\t\tscale = frames[frame + TransformConstraintTimeline.PREV_SCALE];\r\n\t\t\t\tshear = frames[frame + TransformConstraintTimeline.PREV_SHEAR];\r\n\t\t\t\tvar frameTime = frames[frame];\r\n\t\t\t\tvar percent = this.getCurvePercent(frame / TransformConstraintTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + TransformConstraintTimeline.PREV_TIME] - frameTime));\r\n\t\t\t\trotate += (frames[frame + TransformConstraintTimeline.ROTATE] - rotate) * percent;\r\n\t\t\t\ttranslate += (frames[frame + TransformConstraintTimeline.TRANSLATE] - translate) * percent;\r\n\t\t\t\tscale += (frames[frame + TransformConstraintTimeline.SCALE] - scale) * percent;\r\n\t\t\t\tshear += (frames[frame + TransformConstraintTimeline.SHEAR] - shear) * percent;\r\n\t\t\t}\r\n\t\t\tif (pose == MixPose.setup) {\r\n\t\t\t\tvar data = constraint.data;\r\n\t\t\t\tconstraint.rotateMix = data.rotateMix + (rotate - data.rotateMix) * alpha;\r\n\t\t\t\tconstraint.translateMix = data.translateMix + (translate - data.translateMix) * alpha;\r\n\t\t\t\tconstraint.scaleMix = data.scaleMix + (scale - data.scaleMix) * alpha;\r\n\t\t\t\tconstraint.shearMix = data.shearMix + (shear - data.shearMix) * alpha;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tconstraint.rotateMix += (rotate - constraint.rotateMix) * alpha;\r\n\t\t\t\tconstraint.translateMix += (translate - constraint.translateMix) * alpha;\r\n\t\t\t\tconstraint.scaleMix += (scale - constraint.scaleMix) * alpha;\r\n\t\t\t\tconstraint.shearMix += (shear - constraint.shearMix) * alpha;\r\n\t\t\t}\r\n\t\t};\r\n\t\tTransformConstraintTimeline.ENTRIES = 5;\r\n\t\tTransformConstraintTimeline.PREV_TIME = -5;\r\n\t\tTransformConstraintTimeline.PREV_ROTATE = -4;\r\n\t\tTransformConstraintTimeline.PREV_TRANSLATE = -3;\r\n\t\tTransformConstraintTimeline.PREV_SCALE = -2;\r\n\t\tTransformConstraintTimeline.PREV_SHEAR = -1;\r\n\t\tTransformConstraintTimeline.ROTATE = 1;\r\n\t\tTransformConstraintTimeline.TRANSLATE = 2;\r\n\t\tTransformConstraintTimeline.SCALE = 3;\r\n\t\tTransformConstraintTimeline.SHEAR = 4;\r\n\t\treturn TransformConstraintTimeline;\r\n\t}(CurveTimeline));\r\n\tspine.TransformConstraintTimeline = TransformConstraintTimeline;\r\n\tvar PathConstraintPositionTimeline = (function (_super) {\r\n\t\t__extends(PathConstraintPositionTimeline, _super);\r\n\t\tfunction PathConstraintPositionTimeline(frameCount) {\r\n\t\t\tvar _this = _super.call(this, frameCount) || this;\r\n\t\t\t_this.frames = spine.Utils.newFloatArray(frameCount * PathConstraintPositionTimeline.ENTRIES);\r\n\t\t\treturn _this;\r\n\t\t}\r\n\t\tPathConstraintPositionTimeline.prototype.getPropertyId = function () {\r\n\t\t\treturn (TimelineType.pathConstraintPosition << 24) + this.pathConstraintIndex;\r\n\t\t};\r\n\t\tPathConstraintPositionTimeline.prototype.setFrame = function (frameIndex, time, value) {\r\n\t\t\tframeIndex *= PathConstraintPositionTimeline.ENTRIES;\r\n\t\t\tthis.frames[frameIndex] = time;\r\n\t\t\tthis.frames[frameIndex + PathConstraintPositionTimeline.VALUE] = value;\r\n\t\t};\r\n\t\tPathConstraintPositionTimeline.prototype.apply = function (skeleton, lastTime, time, firedEvents, alpha, pose, direction) {\r\n\t\t\tvar frames = this.frames;\r\n\t\t\tvar constraint = skeleton.pathConstraints[this.pathConstraintIndex];\r\n\t\t\tif (time < frames[0]) {\r\n\t\t\t\tswitch (pose) {\r\n\t\t\t\t\tcase MixPose.setup:\r\n\t\t\t\t\t\tconstraint.position = constraint.data.position;\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\tcase MixPose.current:\r\n\t\t\t\t\t\tconstraint.position += (constraint.data.position - constraint.position) * alpha;\r\n\t\t\t\t}\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tvar position = 0;\r\n\t\t\tif (time >= frames[frames.length - PathConstraintPositionTimeline.ENTRIES])\r\n\t\t\t\tposition = frames[frames.length + PathConstraintPositionTimeline.PREV_VALUE];\r\n\t\t\telse {\r\n\t\t\t\tvar frame = Animation.binarySearch(frames, time, PathConstraintPositionTimeline.ENTRIES);\r\n\t\t\t\tposition = frames[frame + PathConstraintPositionTimeline.PREV_VALUE];\r\n\t\t\t\tvar frameTime = frames[frame];\r\n\t\t\t\tvar percent = this.getCurvePercent(frame / PathConstraintPositionTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + PathConstraintPositionTimeline.PREV_TIME] - frameTime));\r\n\t\t\t\tposition += (frames[frame + PathConstraintPositionTimeline.VALUE] - position) * percent;\r\n\t\t\t}\r\n\t\t\tif (pose == MixPose.setup)\r\n\t\t\t\tconstraint.position = constraint.data.position + (position - constraint.data.position) * alpha;\r\n\t\t\telse\r\n\t\t\t\tconstraint.position += (position - constraint.position) * alpha;\r\n\t\t};\r\n\t\tPathConstraintPositionTimeline.ENTRIES = 2;\r\n\t\tPathConstraintPositionTimeline.PREV_TIME = -2;\r\n\t\tPathConstraintPositionTimeline.PREV_VALUE = -1;\r\n\t\tPathConstraintPositionTimeline.VALUE = 1;\r\n\t\treturn PathConstraintPositionTimeline;\r\n\t}(CurveTimeline));\r\n\tspine.PathConstraintPositionTimeline = PathConstraintPositionTimeline;\r\n\tvar PathConstraintSpacingTimeline = (function (_super) {\r\n\t\t__extends(PathConstraintSpacingTimeline, _super);\r\n\t\tfunction PathConstraintSpacingTimeline(frameCount) {\r\n\t\t\treturn _super.call(this, frameCount) || this;\r\n\t\t}\r\n\t\tPathConstraintSpacingTimeline.prototype.getPropertyId = function () {\r\n\t\t\treturn (TimelineType.pathConstraintSpacing << 24) + this.pathConstraintIndex;\r\n\t\t};\r\n\t\tPathConstraintSpacingTimeline.prototype.apply = function (skeleton, lastTime, time, firedEvents, alpha, pose, direction) {\r\n\t\t\tvar frames = this.frames;\r\n\t\t\tvar constraint = skeleton.pathConstraints[this.pathConstraintIndex];\r\n\t\t\tif (time < frames[0]) {\r\n\t\t\t\tswitch (pose) {\r\n\t\t\t\t\tcase MixPose.setup:\r\n\t\t\t\t\t\tconstraint.spacing = constraint.data.spacing;\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\tcase MixPose.current:\r\n\t\t\t\t\t\tconstraint.spacing += (constraint.data.spacing - constraint.spacing) * alpha;\r\n\t\t\t\t}\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tvar spacing = 0;\r\n\t\t\tif (time >= frames[frames.length - PathConstraintSpacingTimeline.ENTRIES])\r\n\t\t\t\tspacing = frames[frames.length + PathConstraintSpacingTimeline.PREV_VALUE];\r\n\t\t\telse {\r\n\t\t\t\tvar frame = Animation.binarySearch(frames, time, PathConstraintSpacingTimeline.ENTRIES);\r\n\t\t\t\tspacing = frames[frame + PathConstraintSpacingTimeline.PREV_VALUE];\r\n\t\t\t\tvar frameTime = frames[frame];\r\n\t\t\t\tvar percent = this.getCurvePercent(frame / PathConstraintSpacingTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + PathConstraintSpacingTimeline.PREV_TIME] - frameTime));\r\n\t\t\t\tspacing += (frames[frame + PathConstraintSpacingTimeline.VALUE] - spacing) * percent;\r\n\t\t\t}\r\n\t\t\tif (pose == MixPose.setup)\r\n\t\t\t\tconstraint.spacing = constraint.data.spacing + (spacing - constraint.data.spacing) * alpha;\r\n\t\t\telse\r\n\t\t\t\tconstraint.spacing += (spacing - constraint.spacing) * alpha;\r\n\t\t};\r\n\t\treturn PathConstraintSpacingTimeline;\r\n\t}(PathConstraintPositionTimeline));\r\n\tspine.PathConstraintSpacingTimeline = PathConstraintSpacingTimeline;\r\n\tvar PathConstraintMixTimeline = (function (_super) {\r\n\t\t__extends(PathConstraintMixTimeline, _super);\r\n\t\tfunction PathConstraintMixTimeline(frameCount) {\r\n\t\t\tvar _this = _super.call(this, frameCount) || this;\r\n\t\t\t_this.frames = spine.Utils.newFloatArray(frameCount * PathConstraintMixTimeline.ENTRIES);\r\n\t\t\treturn _this;\r\n\t\t}\r\n\t\tPathConstraintMixTimeline.prototype.getPropertyId = function () {\r\n\t\t\treturn (TimelineType.pathConstraintMix << 24) + this.pathConstraintIndex;\r\n\t\t};\r\n\t\tPathConstraintMixTimeline.prototype.setFrame = function (frameIndex, time, rotateMix, translateMix) {\r\n\t\t\tframeIndex *= PathConstraintMixTimeline.ENTRIES;\r\n\t\t\tthis.frames[frameIndex] = time;\r\n\t\t\tthis.frames[frameIndex + PathConstraintMixTimeline.ROTATE] = rotateMix;\r\n\t\t\tthis.frames[frameIndex + PathConstraintMixTimeline.TRANSLATE] = translateMix;\r\n\t\t};\r\n\t\tPathConstraintMixTimeline.prototype.apply = function (skeleton, lastTime, time, firedEvents, alpha, pose, direction) {\r\n\t\t\tvar frames = this.frames;\r\n\t\t\tvar constraint = skeleton.pathConstraints[this.pathConstraintIndex];\r\n\t\t\tif (time < frames[0]) {\r\n\t\t\t\tswitch (pose) {\r\n\t\t\t\t\tcase MixPose.setup:\r\n\t\t\t\t\t\tconstraint.rotateMix = constraint.data.rotateMix;\r\n\t\t\t\t\t\tconstraint.translateMix = constraint.data.translateMix;\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\tcase MixPose.current:\r\n\t\t\t\t\t\tconstraint.rotateMix += (constraint.data.rotateMix - constraint.rotateMix) * alpha;\r\n\t\t\t\t\t\tconstraint.translateMix += (constraint.data.translateMix - constraint.translateMix) * alpha;\r\n\t\t\t\t}\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tvar rotate = 0, translate = 0;\r\n\t\t\tif (time >= frames[frames.length - PathConstraintMixTimeline.ENTRIES]) {\r\n\t\t\t\trotate = frames[frames.length + PathConstraintMixTimeline.PREV_ROTATE];\r\n\t\t\t\ttranslate = frames[frames.length + PathConstraintMixTimeline.PREV_TRANSLATE];\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tvar frame = Animation.binarySearch(frames, time, PathConstraintMixTimeline.ENTRIES);\r\n\t\t\t\trotate = frames[frame + PathConstraintMixTimeline.PREV_ROTATE];\r\n\t\t\t\ttranslate = frames[frame + PathConstraintMixTimeline.PREV_TRANSLATE];\r\n\t\t\t\tvar frameTime = frames[frame];\r\n\t\t\t\tvar percent = this.getCurvePercent(frame / PathConstraintMixTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + PathConstraintMixTimeline.PREV_TIME] - frameTime));\r\n\t\t\t\trotate += (frames[frame + PathConstraintMixTimeline.ROTATE] - rotate) * percent;\r\n\t\t\t\ttranslate += (frames[frame + PathConstraintMixTimeline.TRANSLATE] - translate) * percent;\r\n\t\t\t}\r\n\t\t\tif (pose == MixPose.setup) {\r\n\t\t\t\tconstraint.rotateMix = constraint.data.rotateMix + (rotate - constraint.data.rotateMix) * alpha;\r\n\t\t\t\tconstraint.translateMix = constraint.data.translateMix + (translate - constraint.data.translateMix) * alpha;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tconstraint.rotateMix += (rotate - constraint.rotateMix) * alpha;\r\n\t\t\t\tconstraint.translateMix += (translate - constraint.translateMix) * alpha;\r\n\t\t\t}\r\n\t\t};\r\n\t\tPathConstraintMixTimeline.ENTRIES = 3;\r\n\t\tPathConstraintMixTimeline.PREV_TIME = -3;\r\n\t\tPathConstraintMixTimeline.PREV_ROTATE = -2;\r\n\t\tPathConstraintMixTimeline.PREV_TRANSLATE = -1;\r\n\t\tPathConstraintMixTimeline.ROTATE = 1;\r\n\t\tPathConstraintMixTimeline.TRANSLATE = 2;\r\n\t\treturn PathConstraintMixTimeline;\r\n\t}(CurveTimeline));\r\n\tspine.PathConstraintMixTimeline = PathConstraintMixTimeline;\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n\tvar AnimationState = (function () {\r\n\t\tfunction AnimationState(data) {\r\n\t\t\tthis.tracks = new Array();\r\n\t\t\tthis.events = new Array();\r\n\t\t\tthis.listeners = new Array();\r\n\t\t\tthis.queue = new EventQueue(this);\r\n\t\t\tthis.propertyIDs = new spine.IntSet();\r\n\t\t\tthis.mixingTo = new Array();\r\n\t\t\tthis.animationsChanged = false;\r\n\t\t\tthis.timeScale = 1;\r\n\t\t\tthis.trackEntryPool = new spine.Pool(function () { return new TrackEntry(); });\r\n\t\t\tthis.data = data;\r\n\t\t}\r\n\t\tAnimationState.prototype.update = function (delta) {\r\n\t\t\tdelta *= this.timeScale;\r\n\t\t\tvar tracks = this.tracks;\r\n\t\t\tfor (var i = 0, n = tracks.length; i < n; i++) {\r\n\t\t\t\tvar current = tracks[i];\r\n\t\t\t\tif (current == null)\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\tcurrent.animationLast = current.nextAnimationLast;\r\n\t\t\t\tcurrent.trackLast = current.nextTrackLast;\r\n\t\t\t\tvar currentDelta = delta * current.timeScale;\r\n\t\t\t\tif (current.delay > 0) {\r\n\t\t\t\t\tcurrent.delay -= currentDelta;\r\n\t\t\t\t\tif (current.delay > 0)\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\tcurrentDelta = -current.delay;\r\n\t\t\t\t\tcurrent.delay = 0;\r\n\t\t\t\t}\r\n\t\t\t\tvar next = current.next;\r\n\t\t\t\tif (next != null) {\r\n\t\t\t\t\tvar nextTime = current.trackLast - next.delay;\r\n\t\t\t\t\tif (nextTime >= 0) {\r\n\t\t\t\t\t\tnext.delay = 0;\r\n\t\t\t\t\t\tnext.trackTime = nextTime + delta * next.timeScale;\r\n\t\t\t\t\t\tcurrent.trackTime += currentDelta;\r\n\t\t\t\t\t\tthis.setCurrent(i, next, true);\r\n\t\t\t\t\t\twhile (next.mixingFrom != null) {\r\n\t\t\t\t\t\t\tnext.mixTime += currentDelta;\r\n\t\t\t\t\t\t\tnext = next.mixingFrom;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\telse if (current.trackLast >= current.trackEnd && current.mixingFrom == null) {\r\n\t\t\t\t\ttracks[i] = null;\r\n\t\t\t\t\tthis.queue.end(current);\r\n\t\t\t\t\tthis.disposeNext(current);\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t\tif (current.mixingFrom != null && this.updateMixingFrom(current, delta)) {\r\n\t\t\t\t\tvar from = current.mixingFrom;\r\n\t\t\t\t\tcurrent.mixingFrom = null;\r\n\t\t\t\t\twhile (from != null) {\r\n\t\t\t\t\t\tthis.queue.end(from);\r\n\t\t\t\t\t\tfrom = from.mixingFrom;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tcurrent.trackTime += currentDelta;\r\n\t\t\t}\r\n\t\t\tthis.queue.drain();\r\n\t\t};\r\n\t\tAnimationState.prototype.updateMixingFrom = function (to, delta) {\r\n\t\t\tvar from = to.mixingFrom;\r\n\t\t\tif (from == null)\r\n\t\t\t\treturn true;\r\n\t\t\tvar finished = this.updateMixingFrom(from, delta);\r\n\t\t\tfrom.animationLast = from.nextAnimationLast;\r\n\t\t\tfrom.trackLast = from.nextTrackLast;\r\n\t\t\tif (to.mixTime > 0 && (to.mixTime >= to.mixDuration || to.timeScale == 0)) {\r\n\t\t\t\tif (from.totalAlpha == 0 || to.mixDuration == 0) {\r\n\t\t\t\t\tto.mixingFrom = from.mixingFrom;\r\n\t\t\t\t\tto.interruptAlpha = from.interruptAlpha;\r\n\t\t\t\t\tthis.queue.end(from);\r\n\t\t\t\t}\r\n\t\t\t\treturn finished;\r\n\t\t\t}\r\n\t\t\tfrom.trackTime += delta * from.timeScale;\r\n\t\t\tto.mixTime += delta * to.timeScale;\r\n\t\t\treturn false;\r\n\t\t};\r\n\t\tAnimationState.prototype.apply = function (skeleton) {\r\n\t\t\tif (skeleton == null)\r\n\t\t\t\tthrow new Error(\"skeleton cannot be null.\");\r\n\t\t\tif (this.animationsChanged)\r\n\t\t\t\tthis._animationsChanged();\r\n\t\t\tvar events = this.events;\r\n\t\t\tvar tracks = this.tracks;\r\n\t\t\tvar applied = false;\r\n\t\t\tfor (var i = 0, n = tracks.length; i < n; i++) {\r\n\t\t\t\tvar current = tracks[i];\r\n\t\t\t\tif (current == null || current.delay > 0)\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\tapplied = true;\r\n\t\t\t\tvar currentPose = i == 0 ? spine.MixPose.current : spine.MixPose.currentLayered;\r\n\t\t\t\tvar mix = current.alpha;\r\n\t\t\t\tif (current.mixingFrom != null)\r\n\t\t\t\t\tmix *= this.applyMixingFrom(current, skeleton, currentPose);\r\n\t\t\t\telse if (current.trackTime >= current.trackEnd && current.next == null)\r\n\t\t\t\t\tmix = 0;\r\n\t\t\t\tvar animationLast = current.animationLast, animationTime = current.getAnimationTime();\r\n\t\t\t\tvar timelineCount = current.animation.timelines.length;\r\n\t\t\t\tvar timelines = current.animation.timelines;\r\n\t\t\t\tif (mix == 1) {\r\n\t\t\t\t\tfor (var ii = 0; ii < timelineCount; ii++)\r\n\t\t\t\t\t\ttimelines[ii].apply(skeleton, animationLast, animationTime, events, 1, spine.MixPose.setup, spine.MixDirection[\"in\"]);\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tvar timelineData = current.timelineData;\r\n\t\t\t\t\tvar firstFrame = current.timelinesRotation.length == 0;\r\n\t\t\t\t\tif (firstFrame)\r\n\t\t\t\t\t\tspine.Utils.setArraySize(current.timelinesRotation, timelineCount << 1, null);\r\n\t\t\t\t\tvar timelinesRotation = current.timelinesRotation;\r\n\t\t\t\t\tfor (var ii = 0; ii < timelineCount; ii++) {\r\n\t\t\t\t\t\tvar timeline = timelines[ii];\r\n\t\t\t\t\t\tvar pose = timelineData[ii] >= AnimationState.FIRST ? spine.MixPose.setup : currentPose;\r\n\t\t\t\t\t\tif (timeline instanceof spine.RotateTimeline) {\r\n\t\t\t\t\t\t\tthis.applyRotateTimeline(timeline, skeleton, animationTime, mix, pose, timelinesRotation, ii << 1, firstFrame);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\tspine.Utils.webkit602BugfixHelper(mix, pose);\r\n\t\t\t\t\t\t\ttimeline.apply(skeleton, animationLast, animationTime, events, mix, pose, spine.MixDirection[\"in\"]);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tthis.queueEvents(current, animationTime);\r\n\t\t\t\tevents.length = 0;\r\n\t\t\t\tcurrent.nextAnimationLast = animationTime;\r\n\t\t\t\tcurrent.nextTrackLast = current.trackTime;\r\n\t\t\t}\r\n\t\t\tthis.queue.drain();\r\n\t\t\treturn applied;\r\n\t\t};\r\n\t\tAnimationState.prototype.applyMixingFrom = function (to, skeleton, currentPose) {\r\n\t\t\tvar from = to.mixingFrom;\r\n\t\t\tif (from.mixingFrom != null)\r\n\t\t\t\tthis.applyMixingFrom(from, skeleton, currentPose);\r\n\t\t\tvar mix = 0;\r\n\t\t\tif (to.mixDuration == 0) {\r\n\t\t\t\tmix = 1;\r\n\t\t\t\tcurrentPose = spine.MixPose.setup;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tmix = to.mixTime / to.mixDuration;\r\n\t\t\t\tif (mix > 1)\r\n\t\t\t\t\tmix = 1;\r\n\t\t\t}\r\n\t\t\tvar events = mix < from.eventThreshold ? this.events : null;\r\n\t\t\tvar attachments = mix < from.attachmentThreshold, drawOrder = mix < from.drawOrderThreshold;\r\n\t\t\tvar animationLast = from.animationLast, animationTime = from.getAnimationTime();\r\n\t\t\tvar timelineCount = from.animation.timelines.length;\r\n\t\t\tvar timelines = from.animation.timelines;\r\n\t\t\tvar timelineData = from.timelineData;\r\n\t\t\tvar timelineDipMix = from.timelineDipMix;\r\n\t\t\tvar firstFrame = from.timelinesRotation.length == 0;\r\n\t\t\tif (firstFrame)\r\n\t\t\t\tspine.Utils.setArraySize(from.timelinesRotation, timelineCount << 1, null);\r\n\t\t\tvar timelinesRotation = from.timelinesRotation;\r\n\t\t\tvar pose;\r\n\t\t\tvar alphaDip = from.alpha * to.interruptAlpha, alphaMix = alphaDip * (1 - mix), alpha = 0;\r\n\t\t\tfrom.totalAlpha = 0;\r\n\t\t\tfor (var i = 0; i < timelineCount; i++) {\r\n\t\t\t\tvar timeline = timelines[i];\r\n\t\t\t\tswitch (timelineData[i]) {\r\n\t\t\t\t\tcase AnimationState.SUBSEQUENT:\r\n\t\t\t\t\t\tif (!attachments && timeline instanceof spine.AttachmentTimeline)\r\n\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\tif (!drawOrder && timeline instanceof spine.DrawOrderTimeline)\r\n\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\tpose = currentPose;\r\n\t\t\t\t\t\talpha = alphaMix;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase AnimationState.FIRST:\r\n\t\t\t\t\t\tpose = spine.MixPose.setup;\r\n\t\t\t\t\t\talpha = alphaMix;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase AnimationState.DIP:\r\n\t\t\t\t\t\tpose = spine.MixPose.setup;\r\n\t\t\t\t\t\talpha = alphaDip;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tdefault:\r\n\t\t\t\t\t\tpose = spine.MixPose.setup;\r\n\t\t\t\t\t\talpha = alphaDip;\r\n\t\t\t\t\t\tvar dipMix = timelineDipMix[i];\r\n\t\t\t\t\t\talpha *= Math.max(0, 1 - dipMix.mixTime / dipMix.mixDuration);\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\tfrom.totalAlpha += alpha;\r\n\t\t\t\tif (timeline instanceof spine.RotateTimeline)\r\n\t\t\t\t\tthis.applyRotateTimeline(timeline, skeleton, animationTime, alpha, pose, timelinesRotation, i << 1, firstFrame);\r\n\t\t\t\telse {\r\n\t\t\t\t\tspine.Utils.webkit602BugfixHelper(alpha, pose);\r\n\t\t\t\t\ttimeline.apply(skeleton, animationLast, animationTime, events, alpha, pose, spine.MixDirection.out);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (to.mixDuration > 0)\r\n\t\t\t\tthis.queueEvents(from, animationTime);\r\n\t\t\tthis.events.length = 0;\r\n\t\t\tfrom.nextAnimationLast = animationTime;\r\n\t\t\tfrom.nextTrackLast = from.trackTime;\r\n\t\t\treturn mix;\r\n\t\t};\r\n\t\tAnimationState.prototype.applyRotateTimeline = function (timeline, skeleton, time, alpha, pose, timelinesRotation, i, firstFrame) {\r\n\t\t\tif (firstFrame)\r\n\t\t\t\ttimelinesRotation[i] = 0;\r\n\t\t\tif (alpha == 1) {\r\n\t\t\t\ttimeline.apply(skeleton, 0, time, null, 1, pose, spine.MixDirection[\"in\"]);\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tvar rotateTimeline = timeline;\r\n\t\t\tvar frames = rotateTimeline.frames;\r\n\t\t\tvar bone = skeleton.bones[rotateTimeline.boneIndex];\r\n\t\t\tif (time < frames[0]) {\r\n\t\t\t\tif (pose == spine.MixPose.setup)\r\n\t\t\t\t\tbone.rotation = bone.data.rotation;\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tvar r2 = 0;\r\n\t\t\tif (time >= frames[frames.length - spine.RotateTimeline.ENTRIES])\r\n\t\t\t\tr2 = bone.data.rotation + frames[frames.length + spine.RotateTimeline.PREV_ROTATION];\r\n\t\t\telse {\r\n\t\t\t\tvar frame = spine.Animation.binarySearch(frames, time, spine.RotateTimeline.ENTRIES);\r\n\t\t\t\tvar prevRotation = frames[frame + spine.RotateTimeline.PREV_ROTATION];\r\n\t\t\t\tvar frameTime = frames[frame];\r\n\t\t\t\tvar percent = rotateTimeline.getCurvePercent((frame >> 1) - 1, 1 - (time - frameTime) / (frames[frame + spine.RotateTimeline.PREV_TIME] - frameTime));\r\n\t\t\t\tr2 = frames[frame + spine.RotateTimeline.ROTATION] - prevRotation;\r\n\t\t\t\tr2 -= (16384 - ((16384.499999999996 - r2 / 360) | 0)) * 360;\r\n\t\t\t\tr2 = prevRotation + r2 * percent + bone.data.rotation;\r\n\t\t\t\tr2 -= (16384 - ((16384.499999999996 - r2 / 360) | 0)) * 360;\r\n\t\t\t}\r\n\t\t\tvar r1 = pose == spine.MixPose.setup ? bone.data.rotation : bone.rotation;\r\n\t\t\tvar total = 0, diff = r2 - r1;\r\n\t\t\tif (diff == 0) {\r\n\t\t\t\ttotal = timelinesRotation[i];\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tdiff -= (16384 - ((16384.499999999996 - diff / 360) | 0)) * 360;\r\n\t\t\t\tvar lastTotal = 0, lastDiff = 0;\r\n\t\t\t\tif (firstFrame) {\r\n\t\t\t\t\tlastTotal = 0;\r\n\t\t\t\t\tlastDiff = diff;\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tlastTotal = timelinesRotation[i];\r\n\t\t\t\t\tlastDiff = timelinesRotation[i + 1];\r\n\t\t\t\t}\r\n\t\t\t\tvar current = diff > 0, dir = lastTotal >= 0;\r\n\t\t\t\tif (spine.MathUtils.signum(lastDiff) != spine.MathUtils.signum(diff) && Math.abs(lastDiff) <= 90) {\r\n\t\t\t\t\tif (Math.abs(lastTotal) > 180)\r\n\t\t\t\t\t\tlastTotal += 360 * spine.MathUtils.signum(lastTotal);\r\n\t\t\t\t\tdir = current;\r\n\t\t\t\t}\r\n\t\t\t\ttotal = diff + lastTotal - lastTotal % 360;\r\n\t\t\t\tif (dir != current)\r\n\t\t\t\t\ttotal += 360 * spine.MathUtils.signum(lastTotal);\r\n\t\t\t\ttimelinesRotation[i] = total;\r\n\t\t\t}\r\n\t\t\ttimelinesRotation[i + 1] = diff;\r\n\t\t\tr1 += total * alpha;\r\n\t\t\tbone.rotation = r1 - (16384 - ((16384.499999999996 - r1 / 360) | 0)) * 360;\r\n\t\t};\r\n\t\tAnimationState.prototype.queueEvents = function (entry, animationTime) {\r\n\t\t\tvar animationStart = entry.animationStart, animationEnd = entry.animationEnd;\r\n\t\t\tvar duration = animationEnd - animationStart;\r\n\t\t\tvar trackLastWrapped = entry.trackLast % duration;\r\n\t\t\tvar events = this.events;\r\n\t\t\tvar i = 0, n = events.length;\r\n\t\t\tfor (; i < n; i++) {\r\n\t\t\t\tvar event_1 = events[i];\r\n\t\t\t\tif (event_1.time < trackLastWrapped)\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tif (event_1.time > animationEnd)\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\tthis.queue.event(entry, event_1);\r\n\t\t\t}\r\n\t\t\tvar complete = false;\r\n\t\t\tif (entry.loop)\r\n\t\t\t\tcomplete = duration == 0 || trackLastWrapped > entry.trackTime % duration;\r\n\t\t\telse\r\n\t\t\t\tcomplete = animationTime >= animationEnd && entry.animationLast < animationEnd;\r\n\t\t\tif (complete)\r\n\t\t\t\tthis.queue.complete(entry);\r\n\t\t\tfor (; i < n; i++) {\r\n\t\t\t\tvar event_2 = events[i];\r\n\t\t\t\tif (event_2.time < animationStart)\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\tthis.queue.event(entry, events[i]);\r\n\t\t\t}\r\n\t\t};\r\n\t\tAnimationState.prototype.clearTracks = function () {\r\n\t\t\tvar oldDrainDisabled = this.queue.drainDisabled;\r\n\t\t\tthis.queue.drainDisabled = true;\r\n\t\t\tfor (var i = 0, n = this.tracks.length; i < n; i++)\r\n\t\t\t\tthis.clearTrack(i);\r\n\t\t\tthis.tracks.length = 0;\r\n\t\t\tthis.queue.drainDisabled = oldDrainDisabled;\r\n\t\t\tthis.queue.drain();\r\n\t\t};\r\n\t\tAnimationState.prototype.clearTrack = function (trackIndex) {\r\n\t\t\tif (trackIndex >= this.tracks.length)\r\n\t\t\t\treturn;\r\n\t\t\tvar current = this.tracks[trackIndex];\r\n\t\t\tif (current == null)\r\n\t\t\t\treturn;\r\n\t\t\tthis.queue.end(current);\r\n\t\t\tthis.disposeNext(current);\r\n\t\t\tvar entry = current;\r\n\t\t\twhile (true) {\r\n\t\t\t\tvar from = entry.mixingFrom;\r\n\t\t\t\tif (from == null)\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tthis.queue.end(from);\r\n\t\t\t\tentry.mixingFrom = null;\r\n\t\t\t\tentry = from;\r\n\t\t\t}\r\n\t\t\tthis.tracks[current.trackIndex] = null;\r\n\t\t\tthis.queue.drain();\r\n\t\t};\r\n\t\tAnimationState.prototype.setCurrent = function (index, current, interrupt) {\r\n\t\t\tvar from = this.expandToIndex(index);\r\n\t\t\tthis.tracks[index] = current;\r\n\t\t\tif (from != null) {\r\n\t\t\t\tif (interrupt)\r\n\t\t\t\t\tthis.queue.interrupt(from);\r\n\t\t\t\tcurrent.mixingFrom = from;\r\n\t\t\t\tcurrent.mixTime = 0;\r\n\t\t\t\tif (from.mixingFrom != null && from.mixDuration > 0)\r\n\t\t\t\t\tcurrent.interruptAlpha *= Math.min(1, from.mixTime / from.mixDuration);\r\n\t\t\t\tfrom.timelinesRotation.length = 0;\r\n\t\t\t}\r\n\t\t\tthis.queue.start(current);\r\n\t\t};\r\n\t\tAnimationState.prototype.setAnimation = function (trackIndex, animationName, loop) {\r\n\t\t\tvar animation = this.data.skeletonData.findAnimation(animationName);\r\n\t\t\tif (animation == null)\r\n\t\t\t\tthrow new Error(\"Animation not found: \" + animationName);\r\n\t\t\treturn this.setAnimationWith(trackIndex, animation, loop);\r\n\t\t};\r\n\t\tAnimationState.prototype.setAnimationWith = function (trackIndex, animation, loop) {\r\n\t\t\tif (animation == null)\r\n\t\t\t\tthrow new Error(\"animation cannot be null.\");\r\n\t\t\tvar interrupt = true;\r\n\t\t\tvar current = this.expandToIndex(trackIndex);\r\n\t\t\tif (current != null) {\r\n\t\t\t\tif (current.nextTrackLast == -1) {\r\n\t\t\t\t\tthis.tracks[trackIndex] = current.mixingFrom;\r\n\t\t\t\t\tthis.queue.interrupt(current);\r\n\t\t\t\t\tthis.queue.end(current);\r\n\t\t\t\t\tthis.disposeNext(current);\r\n\t\t\t\t\tcurrent = current.mixingFrom;\r\n\t\t\t\t\tinterrupt = false;\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t\tthis.disposeNext(current);\r\n\t\t\t}\r\n\t\t\tvar entry = this.trackEntry(trackIndex, animation, loop, current);\r\n\t\t\tthis.setCurrent(trackIndex, entry, interrupt);\r\n\t\t\tthis.queue.drain();\r\n\t\t\treturn entry;\r\n\t\t};\r\n\t\tAnimationState.prototype.addAnimation = function (trackIndex, animationName, loop, delay) {\r\n\t\t\tvar animation = this.data.skeletonData.findAnimation(animationName);\r\n\t\t\tif (animation == null)\r\n\t\t\t\tthrow new Error(\"Animation not found: \" + animationName);\r\n\t\t\treturn this.addAnimationWith(trackIndex, animation, loop, delay);\r\n\t\t};\r\n\t\tAnimationState.prototype.addAnimationWith = function (trackIndex, animation, loop, delay) {\r\n\t\t\tif (animation == null)\r\n\t\t\t\tthrow new Error(\"animation cannot be null.\");\r\n\t\t\tvar last = this.expandToIndex(trackIndex);\r\n\t\t\tif (last != null) {\r\n\t\t\t\twhile (last.next != null)\r\n\t\t\t\t\tlast = last.next;\r\n\t\t\t}\r\n\t\t\tvar entry = this.trackEntry(trackIndex, animation, loop, last);\r\n\t\t\tif (last == null) {\r\n\t\t\t\tthis.setCurrent(trackIndex, entry, true);\r\n\t\t\t\tthis.queue.drain();\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tlast.next = entry;\r\n\t\t\t\tif (delay <= 0) {\r\n\t\t\t\t\tvar duration = last.animationEnd - last.animationStart;\r\n\t\t\t\t\tif (duration != 0) {\r\n\t\t\t\t\t\tif (last.loop)\r\n\t\t\t\t\t\t\tdelay += duration * (1 + ((last.trackTime / duration) | 0));\r\n\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\tdelay += duration;\r\n\t\t\t\t\t\tdelay -= this.data.getMix(last.animation, animation);\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tdelay = 0;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tentry.delay = delay;\r\n\t\t\treturn entry;\r\n\t\t};\r\n\t\tAnimationState.prototype.setEmptyAnimation = function (trackIndex, mixDuration) {\r\n\t\t\tvar entry = this.setAnimationWith(trackIndex, AnimationState.emptyAnimation, false);\r\n\t\t\tentry.mixDuration = mixDuration;\r\n\t\t\tentry.trackEnd = mixDuration;\r\n\t\t\treturn entry;\r\n\t\t};\r\n\t\tAnimationState.prototype.addEmptyAnimation = function (trackIndex, mixDuration, delay) {\r\n\t\t\tif (delay <= 0)\r\n\t\t\t\tdelay -= mixDuration;\r\n\t\t\tvar entry = this.addAnimationWith(trackIndex, AnimationState.emptyAnimation, false, delay);\r\n\t\t\tentry.mixDuration = mixDuration;\r\n\t\t\tentry.trackEnd = mixDuration;\r\n\t\t\treturn entry;\r\n\t\t};\r\n\t\tAnimationState.prototype.setEmptyAnimations = function (mixDuration) {\r\n\t\t\tvar oldDrainDisabled = this.queue.drainDisabled;\r\n\t\t\tthis.queue.drainDisabled = true;\r\n\t\t\tfor (var i = 0, n = this.tracks.length; i < n; i++) {\r\n\t\t\t\tvar current = this.tracks[i];\r\n\t\t\t\tif (current != null)\r\n\t\t\t\t\tthis.setEmptyAnimation(current.trackIndex, mixDuration);\r\n\t\t\t}\r\n\t\t\tthis.queue.drainDisabled = oldDrainDisabled;\r\n\t\t\tthis.queue.drain();\r\n\t\t};\r\n\t\tAnimationState.prototype.expandToIndex = function (index) {\r\n\t\t\tif (index < this.tracks.length)\r\n\t\t\t\treturn this.tracks[index];\r\n\t\t\tspine.Utils.ensureArrayCapacity(this.tracks, index - this.tracks.length + 1, null);\r\n\t\t\tthis.tracks.length = index + 1;\r\n\t\t\treturn null;\r\n\t\t};\r\n\t\tAnimationState.prototype.trackEntry = function (trackIndex, animation, loop, last) {\r\n\t\t\tvar entry = this.trackEntryPool.obtain();\r\n\t\t\tentry.trackIndex = trackIndex;\r\n\t\t\tentry.animation = animation;\r\n\t\t\tentry.loop = loop;\r\n\t\t\tentry.eventThreshold = 0;\r\n\t\t\tentry.attachmentThreshold = 0;\r\n\t\t\tentry.drawOrderThreshold = 0;\r\n\t\t\tentry.animationStart = 0;\r\n\t\t\tentry.animationEnd = animation.duration;\r\n\t\t\tentry.animationLast = -1;\r\n\t\t\tentry.nextAnimationLast = -1;\r\n\t\t\tentry.delay = 0;\r\n\t\t\tentry.trackTime = 0;\r\n\t\t\tentry.trackLast = -1;\r\n\t\t\tentry.nextTrackLast = -1;\r\n\t\t\tentry.trackEnd = Number.MAX_VALUE;\r\n\t\t\tentry.timeScale = 1;\r\n\t\t\tentry.alpha = 1;\r\n\t\t\tentry.interruptAlpha = 1;\r\n\t\t\tentry.mixTime = 0;\r\n\t\t\tentry.mixDuration = last == null ? 0 : this.data.getMix(last.animation, animation);\r\n\t\t\treturn entry;\r\n\t\t};\r\n\t\tAnimationState.prototype.disposeNext = function (entry) {\r\n\t\t\tvar next = entry.next;\r\n\t\t\twhile (next != null) {\r\n\t\t\t\tthis.queue.dispose(next);\r\n\t\t\t\tnext = next.next;\r\n\t\t\t}\r\n\t\t\tentry.next = null;\r\n\t\t};\r\n\t\tAnimationState.prototype._animationsChanged = function () {\r\n\t\t\tthis.animationsChanged = false;\r\n\t\t\tvar propertyIDs = this.propertyIDs;\r\n\t\t\tpropertyIDs.clear();\r\n\t\t\tvar mixingTo = this.mixingTo;\r\n\t\t\tfor (var i = 0, n = this.tracks.length; i < n; i++) {\r\n\t\t\t\tvar entry = this.tracks[i];\r\n\t\t\t\tif (entry != null)\r\n\t\t\t\t\tentry.setTimelineData(null, mixingTo, propertyIDs);\r\n\t\t\t}\r\n\t\t};\r\n\t\tAnimationState.prototype.getCurrent = function (trackIndex) {\r\n\t\t\tif (trackIndex >= this.tracks.length)\r\n\t\t\t\treturn null;\r\n\t\t\treturn this.tracks[trackIndex];\r\n\t\t};\r\n\t\tAnimationState.prototype.addListener = function (listener) {\r\n\t\t\tif (listener == null)\r\n\t\t\t\tthrow new Error(\"listener cannot be null.\");\r\n\t\t\tthis.listeners.push(listener);\r\n\t\t};\r\n\t\tAnimationState.prototype.removeListener = function (listener) {\r\n\t\t\tvar index = this.listeners.indexOf(listener);\r\n\t\t\tif (index >= 0)\r\n\t\t\t\tthis.listeners.splice(index, 1);\r\n\t\t};\r\n\t\tAnimationState.prototype.clearListeners = function () {\r\n\t\t\tthis.listeners.length = 0;\r\n\t\t};\r\n\t\tAnimationState.prototype.clearListenerNotifications = function () {\r\n\t\t\tthis.queue.clear();\r\n\t\t};\r\n\t\tAnimationState.emptyAnimation = new spine.Animation(\"<empty>\", [], 0);\r\n\t\tAnimationState.SUBSEQUENT = 0;\r\n\t\tAnimationState.FIRST = 1;\r\n\t\tAnimationState.DIP = 2;\r\n\t\tAnimationState.DIP_MIX = 3;\r\n\t\treturn AnimationState;\r\n\t}());\r\n\tspine.AnimationState = AnimationState;\r\n\tvar TrackEntry = (function () {\r\n\t\tfunction TrackEntry() {\r\n\t\t\tthis.timelineData = new Array();\r\n\t\t\tthis.timelineDipMix = new Array();\r\n\t\t\tthis.timelinesRotation = new Array();\r\n\t\t}\r\n\t\tTrackEntry.prototype.reset = function () {\r\n\t\t\tthis.next = null;\r\n\t\t\tthis.mixingFrom = null;\r\n\t\t\tthis.animation = null;\r\n\t\t\tthis.listener = null;\r\n\t\t\tthis.timelineData.length = 0;\r\n\t\t\tthis.timelineDipMix.length = 0;\r\n\t\t\tthis.timelinesRotation.length = 0;\r\n\t\t};\r\n\t\tTrackEntry.prototype.setTimelineData = function (to, mixingToArray, propertyIDs) {\r\n\t\t\tif (to != null)\r\n\t\t\t\tmixingToArray.push(to);\r\n\t\t\tvar lastEntry = this.mixingFrom != null ? this.mixingFrom.setTimelineData(this, mixingToArray, propertyIDs) : this;\r\n\t\t\tif (to != null)\r\n\t\t\t\tmixingToArray.pop();\r\n\t\t\tvar mixingTo = mixingToArray;\r\n\t\t\tvar mixingToLast = mixingToArray.length - 1;\r\n\t\t\tvar timelines = this.animation.timelines;\r\n\t\t\tvar timelinesCount = this.animation.timelines.length;\r\n\t\t\tvar timelineData = spine.Utils.setArraySize(this.timelineData, timelinesCount);\r\n\t\t\tthis.timelineDipMix.length = 0;\r\n\t\t\tvar timelineDipMix = spine.Utils.setArraySize(this.timelineDipMix, timelinesCount);\r\n\t\t\touter: for (var i = 0; i < timelinesCount; i++) {\r\n\t\t\t\tvar id = timelines[i].getPropertyId();\r\n\t\t\t\tif (!propertyIDs.add(id))\r\n\t\t\t\t\ttimelineData[i] = AnimationState.SUBSEQUENT;\r\n\t\t\t\telse if (to == null || !to.hasTimeline(id))\r\n\t\t\t\t\ttimelineData[i] = AnimationState.FIRST;\r\n\t\t\t\telse {\r\n\t\t\t\t\tfor (var ii = mixingToLast; ii >= 0; ii--) {\r\n\t\t\t\t\t\tvar entry = mixingTo[ii];\r\n\t\t\t\t\t\tif (!entry.hasTimeline(id)) {\r\n\t\t\t\t\t\t\tif (entry.mixDuration > 0) {\r\n\t\t\t\t\t\t\t\ttimelineData[i] = AnimationState.DIP_MIX;\r\n\t\t\t\t\t\t\t\ttimelineDipMix[i] = entry;\r\n\t\t\t\t\t\t\t\tcontinue outer;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\ttimelineData[i] = AnimationState.DIP;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn lastEntry;\r\n\t\t};\r\n\t\tTrackEntry.prototype.hasTimeline = function (id) {\r\n\t\t\tvar timelines = this.animation.timelines;\r\n\t\t\tfor (var i = 0, n = timelines.length; i < n; i++)\r\n\t\t\t\tif (timelines[i].getPropertyId() == id)\r\n\t\t\t\t\treturn true;\r\n\t\t\treturn false;\r\n\t\t};\r\n\t\tTrackEntry.prototype.getAnimationTime = function () {\r\n\t\t\tif (this.loop) {\r\n\t\t\t\tvar duration = this.animationEnd - this.animationStart;\r\n\t\t\t\tif (duration == 0)\r\n\t\t\t\t\treturn this.animationStart;\r\n\t\t\t\treturn (this.trackTime % duration) + this.animationStart;\r\n\t\t\t}\r\n\t\t\treturn Math.min(this.trackTime + this.animationStart, this.animationEnd);\r\n\t\t};\r\n\t\tTrackEntry.prototype.setAnimationLast = function (animationLast) {\r\n\t\t\tthis.animationLast = animationLast;\r\n\t\t\tthis.nextAnimationLast = animationLast;\r\n\t\t};\r\n\t\tTrackEntry.prototype.isComplete = function () {\r\n\t\t\treturn this.trackTime >= this.animationEnd - this.animationStart;\r\n\t\t};\r\n\t\tTrackEntry.prototype.resetRotationDirections = function () {\r\n\t\t\tthis.timelinesRotation.length = 0;\r\n\t\t};\r\n\t\treturn TrackEntry;\r\n\t}());\r\n\tspine.TrackEntry = TrackEntry;\r\n\tvar EventQueue = (function () {\r\n\t\tfunction EventQueue(animState) {\r\n\t\t\tthis.objects = [];\r\n\t\t\tthis.drainDisabled = false;\r\n\t\t\tthis.animState = animState;\r\n\t\t}\r\n\t\tEventQueue.prototype.start = function (entry) {\r\n\t\t\tthis.objects.push(EventType.start);\r\n\t\t\tthis.objects.push(entry);\r\n\t\t\tthis.animState.animationsChanged = true;\r\n\t\t};\r\n\t\tEventQueue.prototype.interrupt = function (entry) {\r\n\t\t\tthis.objects.push(EventType.interrupt);\r\n\t\t\tthis.objects.push(entry);\r\n\t\t};\r\n\t\tEventQueue.prototype.end = function (entry) {\r\n\t\t\tthis.objects.push(EventType.end);\r\n\t\t\tthis.objects.push(entry);\r\n\t\t\tthis.animState.animationsChanged = true;\r\n\t\t};\r\n\t\tEventQueue.prototype.dispose = function (entry) {\r\n\t\t\tthis.objects.push(EventType.dispose);\r\n\t\t\tthis.objects.push(entry);\r\n\t\t};\r\n\t\tEventQueue.prototype.complete = function (entry) {\r\n\t\t\tthis.objects.push(EventType.complete);\r\n\t\t\tthis.objects.push(entry);\r\n\t\t};\r\n\t\tEventQueue.prototype.event = function (entry, event) {\r\n\t\t\tthis.objects.push(EventType.event);\r\n\t\t\tthis.objects.push(entry);\r\n\t\t\tthis.objects.push(event);\r\n\t\t};\r\n\t\tEventQueue.prototype.drain = function () {\r\n\t\t\tif (this.drainDisabled)\r\n\t\t\t\treturn;\r\n\t\t\tthis.drainDisabled = true;\r\n\t\t\tvar objects = this.objects;\r\n\t\t\tvar listeners = this.animState.listeners;\r\n\t\t\tfor (var i = 0; i < objects.length; i += 2) {\r\n\t\t\t\tvar type = objects[i];\r\n\t\t\t\tvar entry = objects[i + 1];\r\n\t\t\t\tswitch (type) {\r\n\t\t\t\t\tcase EventType.start:\r\n\t\t\t\t\t\tif (entry.listener != null && entry.listener.start)\r\n\t\t\t\t\t\t\tentry.listener.start(entry);\r\n\t\t\t\t\t\tfor (var ii = 0; ii < listeners.length; ii++)\r\n\t\t\t\t\t\t\tif (listeners[ii].start)\r\n\t\t\t\t\t\t\t\tlisteners[ii].start(entry);\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase EventType.interrupt:\r\n\t\t\t\t\t\tif (entry.listener != null && entry.listener.interrupt)\r\n\t\t\t\t\t\t\tentry.listener.interrupt(entry);\r\n\t\t\t\t\t\tfor (var ii = 0; ii < listeners.length; ii++)\r\n\t\t\t\t\t\t\tif (listeners[ii].interrupt)\r\n\t\t\t\t\t\t\t\tlisteners[ii].interrupt(entry);\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase EventType.end:\r\n\t\t\t\t\t\tif (entry.listener != null && entry.listener.end)\r\n\t\t\t\t\t\t\tentry.listener.end(entry);\r\n\t\t\t\t\t\tfor (var ii = 0; ii < listeners.length; ii++)\r\n\t\t\t\t\t\t\tif (listeners[ii].end)\r\n\t\t\t\t\t\t\t\tlisteners[ii].end(entry);\r\n\t\t\t\t\tcase EventType.dispose:\r\n\t\t\t\t\t\tif (entry.listener != null && entry.listener.dispose)\r\n\t\t\t\t\t\t\tentry.listener.dispose(entry);\r\n\t\t\t\t\t\tfor (var ii = 0; ii < listeners.length; ii++)\r\n\t\t\t\t\t\t\tif (listeners[ii].dispose)\r\n\t\t\t\t\t\t\t\tlisteners[ii].dispose(entry);\r\n\t\t\t\t\t\tthis.animState.trackEntryPool.free(entry);\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase EventType.complete:\r\n\t\t\t\t\t\tif (entry.listener != null && entry.listener.complete)\r\n\t\t\t\t\t\t\tentry.listener.complete(entry);\r\n\t\t\t\t\t\tfor (var ii = 0; ii < listeners.length; ii++)\r\n\t\t\t\t\t\t\tif (listeners[ii].complete)\r\n\t\t\t\t\t\t\t\tlisteners[ii].complete(entry);\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase EventType.event:\r\n\t\t\t\t\t\tvar event_3 = objects[i++ + 2];\r\n\t\t\t\t\t\tif (entry.listener != null && entry.listener.event)\r\n\t\t\t\t\t\t\tentry.listener.event(entry, event_3);\r\n\t\t\t\t\t\tfor (var ii = 0; ii < listeners.length; ii++)\r\n\t\t\t\t\t\t\tif (listeners[ii].event)\r\n\t\t\t\t\t\t\t\tlisteners[ii].event(entry, event_3);\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tthis.clear();\r\n\t\t\tthis.drainDisabled = false;\r\n\t\t};\r\n\t\tEventQueue.prototype.clear = function () {\r\n\t\t\tthis.objects.length = 0;\r\n\t\t};\r\n\t\treturn EventQueue;\r\n\t}());\r\n\tspine.EventQueue = EventQueue;\r\n\tvar EventType;\r\n\t(function (EventType) {\r\n\t\tEventType[EventType[\"start\"] = 0] = \"start\";\r\n\t\tEventType[EventType[\"interrupt\"] = 1] = \"interrupt\";\r\n\t\tEventType[EventType[\"end\"] = 2] = \"end\";\r\n\t\tEventType[EventType[\"dispose\"] = 3] = \"dispose\";\r\n\t\tEventType[EventType[\"complete\"] = 4] = \"complete\";\r\n\t\tEventType[EventType[\"event\"] = 5] = \"event\";\r\n\t})(EventType = spine.EventType || (spine.EventType = {}));\r\n\tvar AnimationStateAdapter2 = (function () {\r\n\t\tfunction AnimationStateAdapter2() {\r\n\t\t}\r\n\t\tAnimationStateAdapter2.prototype.start = function (entry) {\r\n\t\t};\r\n\t\tAnimationStateAdapter2.prototype.interrupt = function (entry) {\r\n\t\t};\r\n\t\tAnimationStateAdapter2.prototype.end = function (entry) {\r\n\t\t};\r\n\t\tAnimationStateAdapter2.prototype.dispose = function (entry) {\r\n\t\t};\r\n\t\tAnimationStateAdapter2.prototype.complete = function (entry) {\r\n\t\t};\r\n\t\tAnimationStateAdapter2.prototype.event = function (entry, event) {\r\n\t\t};\r\n\t\treturn AnimationStateAdapter2;\r\n\t}());\r\n\tspine.AnimationStateAdapter2 = AnimationStateAdapter2;\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n\tvar AnimationStateData = (function () {\r\n\t\tfunction AnimationStateData(skeletonData) {\r\n\t\t\tthis.animationToMixTime = {};\r\n\t\t\tthis.defaultMix = 0;\r\n\t\t\tif (skeletonData == null)\r\n\t\t\t\tthrow new Error(\"skeletonData cannot be null.\");\r\n\t\t\tthis.skeletonData = skeletonData;\r\n\t\t}\r\n\t\tAnimationStateData.prototype.setMix = function (fromName, toName, duration) {\r\n\t\t\tvar from = this.skeletonData.findAnimation(fromName);\r\n\t\t\tif (from == null)\r\n\t\t\t\tthrow new Error(\"Animation not found: \" + fromName);\r\n\t\t\tvar to = this.skeletonData.findAnimation(toName);\r\n\t\t\tif (to == null)\r\n\t\t\t\tthrow new Error(\"Animation not found: \" + toName);\r\n\t\t\tthis.setMixWith(from, to, duration);\r\n\t\t};\r\n\t\tAnimationStateData.prototype.setMixWith = function (from, to, duration) {\r\n\t\t\tif (from == null)\r\n\t\t\t\tthrow new Error(\"from cannot be null.\");\r\n\t\t\tif (to == null)\r\n\t\t\t\tthrow new Error(\"to cannot be null.\");\r\n\t\t\tvar key = from.name + \".\" + to.name;\r\n\t\t\tthis.animationToMixTime[key] = duration;\r\n\t\t};\r\n\t\tAnimationStateData.prototype.getMix = function (from, to) {\r\n\t\t\tvar key = from.name + \".\" + to.name;\r\n\t\t\tvar value = this.animationToMixTime[key];\r\n\t\t\treturn value === undefined ? this.defaultMix : value;\r\n\t\t};\r\n\t\treturn AnimationStateData;\r\n\t}());\r\n\tspine.AnimationStateData = AnimationStateData;\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n\tvar AssetManager = (function () {\r\n\t\tfunction AssetManager(textureLoader, pathPrefix) {\r\n\t\t\tif (pathPrefix === void 0) { pathPrefix = \"\"; }\r\n\t\t\tthis.assets = {};\r\n\t\t\tthis.errors = {};\r\n\t\t\tthis.toLoad = 0;\r\n\t\t\tthis.loaded = 0;\r\n\t\t\tthis.textureLoader = textureLoader;\r\n\t\t\tthis.pathPrefix = pathPrefix;\r\n\t\t}\r\n\t\tAssetManager.downloadText = function (url, success, error) {\r\n\t\t\tvar request = new XMLHttpRequest();\r\n\t\t\trequest.open(\"GET\", url, true);\r\n\t\t\trequest.onload = function () {\r\n\t\t\t\tif (request.status == 200) {\r\n\t\t\t\t\tsuccess(request.responseText);\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\terror(request.status, request.responseText);\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t\trequest.onerror = function () {\r\n\t\t\t\terror(request.status, request.responseText);\r\n\t\t\t};\r\n\t\t\trequest.send();\r\n\t\t};\r\n\t\tAssetManager.downloadBinary = function (url, success, error) {\r\n\t\t\tvar request = new XMLHttpRequest();\r\n\t\t\trequest.open(\"GET\", url, true);\r\n\t\t\trequest.responseType = \"arraybuffer\";\r\n\t\t\trequest.onload = function () {\r\n\t\t\t\tif (request.status == 200) {\r\n\t\t\t\t\tsuccess(new Uint8Array(request.response));\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\terror(request.status, request.responseText);\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t\trequest.onerror = function () {\r\n\t\t\t\terror(request.status, request.responseText);\r\n\t\t\t};\r\n\t\t\trequest.send();\r\n\t\t};\r\n\t\tAssetManager.prototype.loadText = function (path, success, error) {\r\n\t\t\tvar _this = this;\r\n\t\t\tif (success === void 0) { success = null; }\r\n\t\t\tif (error === void 0) { error = null; }\r\n\t\t\tpath = this.pathPrefix + path;\r\n\t\t\tthis.toLoad++;\r\n\t\t\tAssetManager.downloadText(path, function (data) {\r\n\t\t\t\t_this.assets[path] = data;\r\n\t\t\t\tif (success)\r\n\t\t\t\t\tsuccess(path, data);\r\n\t\t\t\t_this.toLoad--;\r\n\t\t\t\t_this.loaded++;\r\n\t\t\t}, function (state, responseText) {\r\n\t\t\t\t_this.errors[path] = \"Couldn't load text \" + path + \": status \" + status + \", \" + responseText;\r\n\t\t\t\tif (error)\r\n\t\t\t\t\terror(path, \"Couldn't load text \" + path + \": status \" + status + \", \" + responseText);\r\n\t\t\t\t_this.toLoad--;\r\n\t\t\t\t_this.loaded++;\r\n\t\t\t});\r\n\t\t};\r\n\t\tAssetManager.prototype.loadTexture = function (path, success, error) {\r\n\t\t\tvar _this = this;\r\n\t\t\tif (success === void 0) { success = null; }\r\n\t\t\tif (error === void 0) { error = null; }\r\n\t\t\tpath = this.pathPrefix + path;\r\n\t\t\tthis.toLoad++;\r\n\t\t\tvar img = new Image();\r\n\t\t\timg.crossOrigin = \"anonymous\";\r\n\t\t\timg.onload = function (ev) {\r\n\t\t\t\tvar texture = _this.textureLoader(img);\r\n\t\t\t\t_this.assets[path] = texture;\r\n\t\t\t\t_this.toLoad--;\r\n\t\t\t\t_this.loaded++;\r\n\t\t\t\tif (success)\r\n\t\t\t\t\tsuccess(path, img);\r\n\t\t\t};\r\n\t\t\timg.onerror = function (ev) {\r\n\t\t\t\t_this.errors[path] = \"Couldn't load image \" + path;\r\n\t\t\t\t_this.toLoad--;\r\n\t\t\t\t_this.loaded++;\r\n\t\t\t\tif (error)\r\n\t\t\t\t\terror(path, \"Couldn't load image \" + path);\r\n\t\t\t};\r\n\t\t\timg.src = path;\r\n\t\t};\r\n\t\tAssetManager.prototype.loadTextureData = function (path, data, success, error) {\r\n\t\t\tvar _this = this;\r\n\t\t\tif (success === void 0) { success = null; }\r\n\t\t\tif (error === void 0) { error = null; }\r\n\t\t\tpath = this.pathPrefix + path;\r\n\t\t\tthis.toLoad++;\r\n\t\t\tvar img = new Image();\r\n\t\t\timg.onload = function (ev) {\r\n\t\t\t\tvar texture = _this.textureLoader(img);\r\n\t\t\t\t_this.assets[path] = texture;\r\n\t\t\t\t_this.toLoad--;\r\n\t\t\t\t_this.loaded++;\r\n\t\t\t\tif (success)\r\n\t\t\t\t\tsuccess(path, img);\r\n\t\t\t};\r\n\t\t\timg.onerror = function (ev) {\r\n\t\t\t\t_this.errors[path] = \"Couldn't load image \" + path;\r\n\t\t\t\t_this.toLoad--;\r\n\t\t\t\t_this.loaded++;\r\n\t\t\t\tif (error)\r\n\t\t\t\t\terror(path, \"Couldn't load image \" + path);\r\n\t\t\t};\r\n\t\t\timg.src = data;\r\n\t\t};\r\n\t\tAssetManager.prototype.loadTextureAtlas = function (path, success, error) {\r\n\t\t\tvar _this = this;\r\n\t\t\tif (success === void 0) { success = null; }\r\n\t\t\tif (error === void 0) { error = null; }\r\n\t\t\tvar parent = path.lastIndexOf(\"/\") >= 0 ? path.substring(0, path.lastIndexOf(\"/\")) : \"\";\r\n\t\t\tpath = this.pathPrefix + path;\r\n\t\t\tthis.toLoad++;\r\n\t\t\tAssetManager.downloadText(path, function (atlasData) {\r\n\t\t\t\tvar pagesLoaded = { count: 0 };\r\n\t\t\t\tvar atlasPages = new Array();\r\n\t\t\t\ttry {\r\n\t\t\t\t\tvar atlas = new spine.TextureAtlas(atlasData, function (path) {\r\n\t\t\t\t\t\tatlasPages.push(parent + \"/\" + path);\r\n\t\t\t\t\t\tvar image = document.createElement(\"img\");\r\n\t\t\t\t\t\timage.width = 16;\r\n\t\t\t\t\t\timage.height = 16;\r\n\t\t\t\t\t\treturn new spine.FakeTexture(image);\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t\tcatch (e) {\r\n\t\t\t\t\tvar ex = e;\r\n\t\t\t\t\t_this.errors[path] = \"Couldn't load texture atlas \" + path + \": \" + ex.message;\r\n\t\t\t\t\tif (error)\r\n\t\t\t\t\t\terror(path, \"Couldn't load texture atlas \" + path + \": \" + ex.message);\r\n\t\t\t\t\t_this.toLoad--;\r\n\t\t\t\t\t_this.loaded++;\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t\tvar _loop_1 = function (atlasPage) {\r\n\t\t\t\t\tvar pageLoadError = false;\r\n\t\t\t\t\t_this.loadTexture(atlasPage, function (imagePath, image) {\r\n\t\t\t\t\t\tpagesLoaded.count++;\r\n\t\t\t\t\t\tif (pagesLoaded.count == atlasPages.length) {\r\n\t\t\t\t\t\t\tif (!pageLoadError) {\r\n\t\t\t\t\t\t\t\ttry {\r\n\t\t\t\t\t\t\t\t\tvar atlas = new spine.TextureAtlas(atlasData, function (path) {\r\n\t\t\t\t\t\t\t\t\t\treturn _this.get(parent + \"/\" + path);\r\n\t\t\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t\t\t\t_this.assets[path] = atlas;\r\n\t\t\t\t\t\t\t\t\tif (success)\r\n\t\t\t\t\t\t\t\t\t\tsuccess(path, atlas);\r\n\t\t\t\t\t\t\t\t\t_this.toLoad--;\r\n\t\t\t\t\t\t\t\t\t_this.loaded++;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tcatch (e) {\r\n\t\t\t\t\t\t\t\t\tvar ex = e;\r\n\t\t\t\t\t\t\t\t\t_this.errors[path] = \"Couldn't load texture atlas \" + path + \": \" + ex.message;\r\n\t\t\t\t\t\t\t\t\tif (error)\r\n\t\t\t\t\t\t\t\t\t\terror(path, \"Couldn't load texture atlas \" + path + \": \" + ex.message);\r\n\t\t\t\t\t\t\t\t\t_this.toLoad--;\r\n\t\t\t\t\t\t\t\t\t_this.loaded++;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\t\t_this.errors[path] = \"Couldn't load texture atlas page \" + imagePath + \"} of atlas \" + path;\r\n\t\t\t\t\t\t\t\tif (error)\r\n\t\t\t\t\t\t\t\t\terror(path, \"Couldn't load texture atlas page \" + imagePath + \" of atlas \" + path);\r\n\t\t\t\t\t\t\t\t_this.toLoad--;\r\n\t\t\t\t\t\t\t\t_this.loaded++;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}, function (imagePath, errorMessage) {\r\n\t\t\t\t\t\tpageLoadError = true;\r\n\t\t\t\t\t\tpagesLoaded.count++;\r\n\t\t\t\t\t\tif (pagesLoaded.count == atlasPages.length) {\r\n\t\t\t\t\t\t\t_this.errors[path] = \"Couldn't load texture atlas page \" + imagePath + \"} of atlas \" + path;\r\n\t\t\t\t\t\t\tif (error)\r\n\t\t\t\t\t\t\t\terror(path, \"Couldn't load texture atlas page \" + imagePath + \" of atlas \" + path);\r\n\t\t\t\t\t\t\t_this.toLoad--;\r\n\t\t\t\t\t\t\t_this.loaded++;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t});\r\n\t\t\t\t};\r\n\t\t\t\tfor (var _i = 0, atlasPages_1 = atlasPages; _i < atlasPages_1.length; _i++) {\r\n\t\t\t\t\tvar atlasPage = atlasPages_1[_i];\r\n\t\t\t\t\t_loop_1(atlasPage);\r\n\t\t\t\t}\r\n\t\t\t}, function (state, responseText) {\r\n\t\t\t\t_this.errors[path] = \"Couldn't load texture atlas \" + path + \": status \" + status + \", \" + responseText;\r\n\t\t\t\tif (error)\r\n\t\t\t\t\terror(path, \"Couldn't load texture atlas \" + path + \": status \" + status + \", \" + responseText);\r\n\t\t\t\t_this.toLoad--;\r\n\t\t\t\t_this.loaded++;\r\n\t\t\t});\r\n\t\t};\r\n\t\tAssetManager.prototype.get = function (path) {\r\n\t\t\tpath = this.pathPrefix + path;\r\n\t\t\treturn this.assets[path];\r\n\t\t};\r\n\t\tAssetManager.prototype.remove = function (path) {\r\n\t\t\tpath = this.pathPrefix + path;\r\n\t\t\tvar asset = this.assets[path];\r\n\t\t\tif (asset.dispose)\r\n\t\t\t\tasset.dispose();\r\n\t\t\tthis.assets[path] = null;\r\n\t\t};\r\n\t\tAssetManager.prototype.removeAll = function () {\r\n\t\t\tfor (var key in this.assets) {\r\n\t\t\t\tvar asset = this.assets[key];\r\n\t\t\t\tif (asset.dispose)\r\n\t\t\t\t\tasset.dispose();\r\n\t\t\t}\r\n\t\t\tthis.assets = {};\r\n\t\t};\r\n\t\tAssetManager.prototype.isLoadingComplete = function () {\r\n\t\t\treturn this.toLoad == 0;\r\n\t\t};\r\n\t\tAssetManager.prototype.getToLoad = function () {\r\n\t\t\treturn this.toLoad;\r\n\t\t};\r\n\t\tAssetManager.prototype.getLoaded = function () {\r\n\t\t\treturn this.loaded;\r\n\t\t};\r\n\t\tAssetManager.prototype.dispose = function () {\r\n\t\t\tthis.removeAll();\r\n\t\t};\r\n\t\tAssetManager.prototype.hasErrors = function () {\r\n\t\t\treturn Object.keys(this.errors).length > 0;\r\n\t\t};\r\n\t\tAssetManager.prototype.getErrors = function () {\r\n\t\t\treturn this.errors;\r\n\t\t};\r\n\t\treturn AssetManager;\r\n\t}());\r\n\tspine.AssetManager = AssetManager;\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n\tvar AtlasAttachmentLoader = (function () {\r\n\t\tfunction AtlasAttachmentLoader(atlas) {\r\n\t\t\tthis.atlas = atlas;\r\n\t\t}\r\n\t\tAtlasAttachmentLoader.prototype.newRegionAttachment = function (skin, name, path) {\r\n\t\t\tvar region = this.atlas.findRegion(path);\r\n\t\t\tif (region == null)\r\n\t\t\t\tthrow new Error(\"Region not found in atlas: \" + path + \" (region attachment: \" + name + \")\");\r\n\t\t\tregion.renderObject = region;\r\n\t\t\tvar attachment = new spine.RegionAttachment(name);\r\n\t\t\tattachment.setRegion(region);\r\n\t\t\treturn attachment;\r\n\t\t};\r\n\t\tAtlasAttachmentLoader.prototype.newMeshAttachment = function (skin, name, path) {\r\n\t\t\tvar region = this.atlas.findRegion(path);\r\n\t\t\tif (region == null)\r\n\t\t\t\tthrow new Error(\"Region not found in atlas: \" + path + \" (mesh attachment: \" + name + \")\");\r\n\t\t\tregion.renderObject = region;\r\n\t\t\tvar attachment = new spine.MeshAttachment(name);\r\n\t\t\tattachment.region = region;\r\n\t\t\treturn attachment;\r\n\t\t};\r\n\t\tAtlasAttachmentLoader.prototype.newBoundingBoxAttachment = function (skin, name) {\r\n\t\t\treturn new spine.BoundingBoxAttachment(name);\r\n\t\t};\r\n\t\tAtlasAttachmentLoader.prototype.newPathAttachment = function (skin, name) {\r\n\t\t\treturn new spine.PathAttachment(name);\r\n\t\t};\r\n\t\tAtlasAttachmentLoader.prototype.newPointAttachment = function (skin, name) {\r\n\t\t\treturn new spine.PointAttachment(name);\r\n\t\t};\r\n\t\tAtlasAttachmentLoader.prototype.newClippingAttachment = function (skin, name) {\r\n\t\t\treturn new spine.ClippingAttachment(name);\r\n\t\t};\r\n\t\treturn AtlasAttachmentLoader;\r\n\t}());\r\n\tspine.AtlasAttachmentLoader = AtlasAttachmentLoader;\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n\tvar BlendMode;\r\n\t(function (BlendMode) {\r\n\t\tBlendMode[BlendMode[\"Normal\"] = 0] = \"Normal\";\r\n\t\tBlendMode[BlendMode[\"Additive\"] = 1] = \"Additive\";\r\n\t\tBlendMode[BlendMode[\"Multiply\"] = 2] = \"Multiply\";\r\n\t\tBlendMode[BlendMode[\"Screen\"] = 3] = \"Screen\";\r\n\t})(BlendMode = spine.BlendMode || (spine.BlendMode = {}));\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n\tvar Bone = (function () {\r\n\t\tfunction Bone(data, skeleton, parent) {\r\n\t\t\tthis.children = new Array();\r\n\t\t\tthis.x = 0;\r\n\t\t\tthis.y = 0;\r\n\t\t\tthis.rotation = 0;\r\n\t\t\tthis.scaleX = 0;\r\n\t\t\tthis.scaleY = 0;\r\n\t\t\tthis.shearX = 0;\r\n\t\t\tthis.shearY = 0;\r\n\t\t\tthis.ax = 0;\r\n\t\t\tthis.ay = 0;\r\n\t\t\tthis.arotation = 0;\r\n\t\t\tthis.ascaleX = 0;\r\n\t\t\tthis.ascaleY = 0;\r\n\t\t\tthis.ashearX = 0;\r\n\t\t\tthis.ashearY = 0;\r\n\t\t\tthis.appliedValid = false;\r\n\t\t\tthis.a = 0;\r\n\t\t\tthis.b = 0;\r\n\t\t\tthis.worldX = 0;\r\n\t\t\tthis.c = 0;\r\n\t\t\tthis.d = 0;\r\n\t\t\tthis.worldY = 0;\r\n\t\t\tthis.sorted = false;\r\n\t\t\tif (data == null)\r\n\t\t\t\tthrow new Error(\"data cannot be null.\");\r\n\t\t\tif (skeleton == null)\r\n\t\t\t\tthrow new Error(\"skeleton cannot be null.\");\r\n\t\t\tthis.data = data;\r\n\t\t\tthis.skeleton = skeleton;\r\n\t\t\tthis.parent = parent;\r\n\t\t\tthis.setToSetupPose();\r\n\t\t}\r\n\t\tBone.prototype.update = function () {\r\n\t\t\tthis.updateWorldTransformWith(this.x, this.y, this.rotation, this.scaleX, this.scaleY, this.shearX, this.shearY);\r\n\t\t};\r\n\t\tBone.prototype.updateWorldTransform = function () {\r\n\t\t\tthis.updateWorldTransformWith(this.x, this.y, this.rotation, this.scaleX, this.scaleY, this.shearX, this.shearY);\r\n\t\t};\r\n\t\tBone.prototype.updateWorldTransformWith = function (x, y, rotation, scaleX, scaleY, shearX, shearY) {\r\n\t\t\tthis.ax = x;\r\n\t\t\tthis.ay = y;\r\n\t\t\tthis.arotation = rotation;\r\n\t\t\tthis.ascaleX = scaleX;\r\n\t\t\tthis.ascaleY = scaleY;\r\n\t\t\tthis.ashearX = shearX;\r\n\t\t\tthis.ashearY = shearY;\r\n\t\t\tthis.appliedValid = true;\r\n\t\t\tvar parent = this.parent;\r\n\t\t\tif (parent == null) {\r\n\t\t\t\tvar rotationY = rotation + 90 + shearY;\r\n\t\t\t\tvar la = spine.MathUtils.cosDeg(rotation + shearX) * scaleX;\r\n\t\t\t\tvar lb = spine.MathUtils.cosDeg(rotationY) * scaleY;\r\n\t\t\t\tvar lc = spine.MathUtils.sinDeg(rotation + shearX) * scaleX;\r\n\t\t\t\tvar ld = spine.MathUtils.sinDeg(rotationY) * scaleY;\r\n\t\t\t\tvar skeleton = this.skeleton;\r\n\t\t\t\tif (skeleton.flipX) {\r\n\t\t\t\t\tx = -x;\r\n\t\t\t\t\tla = -la;\r\n\t\t\t\t\tlb = -lb;\r\n\t\t\t\t}\r\n\t\t\t\tif (skeleton.flipY) {\r\n\t\t\t\t\ty = -y;\r\n\t\t\t\t\tlc = -lc;\r\n\t\t\t\t\tld = -ld;\r\n\t\t\t\t}\r\n\t\t\t\tthis.a = la;\r\n\t\t\t\tthis.b = lb;\r\n\t\t\t\tthis.c = lc;\r\n\t\t\t\tthis.d = ld;\r\n\t\t\t\tthis.worldX = x + skeleton.x;\r\n\t\t\t\tthis.worldY = y + skeleton.y;\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tvar pa = parent.a, pb = parent.b, pc = parent.c, pd = parent.d;\r\n\t\t\tthis.worldX = pa * x + pb * y + parent.worldX;\r\n\t\t\tthis.worldY = pc * x + pd * y + parent.worldY;\r\n\t\t\tswitch (this.data.transformMode) {\r\n\t\t\t\tcase spine.TransformMode.Normal: {\r\n\t\t\t\t\tvar rotationY = rotation + 90 + shearY;\r\n\t\t\t\t\tvar la = spine.MathUtils.cosDeg(rotation + shearX) * scaleX;\r\n\t\t\t\t\tvar lb = spine.MathUtils.cosDeg(rotationY) * scaleY;\r\n\t\t\t\t\tvar lc = spine.MathUtils.sinDeg(rotation + shearX) * scaleX;\r\n\t\t\t\t\tvar ld = spine.MathUtils.sinDeg(rotationY) * scaleY;\r\n\t\t\t\t\tthis.a = pa * la + pb * lc;\r\n\t\t\t\t\tthis.b = pa * lb + pb * ld;\r\n\t\t\t\t\tthis.c = pc * la + pd * lc;\r\n\t\t\t\t\tthis.d = pc * lb + pd * ld;\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t\tcase spine.TransformMode.OnlyTranslation: {\r\n\t\t\t\t\tvar rotationY = rotation + 90 + shearY;\r\n\t\t\t\t\tthis.a = spine.MathUtils.cosDeg(rotation + shearX) * scaleX;\r\n\t\t\t\t\tthis.b = spine.MathUtils.cosDeg(rotationY) * scaleY;\r\n\t\t\t\t\tthis.c = spine.MathUtils.sinDeg(rotation + shearX) * scaleX;\r\n\t\t\t\t\tthis.d = spine.MathUtils.sinDeg(rotationY) * scaleY;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\tcase spine.TransformMode.NoRotationOrReflection: {\r\n\t\t\t\t\tvar s = pa * pa + pc * pc;\r\n\t\t\t\t\tvar prx = 0;\r\n\t\t\t\t\tif (s > 0.0001) {\r\n\t\t\t\t\t\ts = Math.abs(pa * pd - pb * pc) / s;\r\n\t\t\t\t\t\tpb = pc * s;\r\n\t\t\t\t\t\tpd = pa * s;\r\n\t\t\t\t\t\tprx = Math.atan2(pc, pa) * spine.MathUtils.radDeg;\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tpa = 0;\r\n\t\t\t\t\t\tpc = 0;\r\n\t\t\t\t\t\tprx = 90 - Math.atan2(pd, pb) * spine.MathUtils.radDeg;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tvar rx = rotation + shearX - prx;\r\n\t\t\t\t\tvar ry = rotation + shearY - prx + 90;\r\n\t\t\t\t\tvar la = spine.MathUtils.cosDeg(rx) * scaleX;\r\n\t\t\t\t\tvar lb = spine.MathUtils.cosDeg(ry) * scaleY;\r\n\t\t\t\t\tvar lc = spine.MathUtils.sinDeg(rx) * scaleX;\r\n\t\t\t\t\tvar ld = spine.MathUtils.sinDeg(ry) * scaleY;\r\n\t\t\t\t\tthis.a = pa * la - pb * lc;\r\n\t\t\t\t\tthis.b = pa * lb - pb * ld;\r\n\t\t\t\t\tthis.c = pc * la + pd * lc;\r\n\t\t\t\t\tthis.d = pc * lb + pd * ld;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\tcase spine.TransformMode.NoScale:\r\n\t\t\t\tcase spine.TransformMode.NoScaleOrReflection: {\r\n\t\t\t\t\tvar cos = spine.MathUtils.cosDeg(rotation);\r\n\t\t\t\t\tvar sin = spine.MathUtils.sinDeg(rotation);\r\n\t\t\t\t\tvar za = pa * cos + pb * sin;\r\n\t\t\t\t\tvar zc = pc * cos + pd * sin;\r\n\t\t\t\t\tvar s = Math.sqrt(za * za + zc * zc);\r\n\t\t\t\t\tif (s > 0.00001)\r\n\t\t\t\t\t\ts = 1 / s;\r\n\t\t\t\t\tza *= s;\r\n\t\t\t\t\tzc *= s;\r\n\t\t\t\t\ts = Math.sqrt(za * za + zc * zc);\r\n\t\t\t\t\tvar r = Math.PI / 2 + Math.atan2(zc, za);\r\n\t\t\t\t\tvar zb = Math.cos(r) * s;\r\n\t\t\t\t\tvar zd = Math.sin(r) * s;\r\n\t\t\t\t\tvar la = spine.MathUtils.cosDeg(shearX) * scaleX;\r\n\t\t\t\t\tvar lb = spine.MathUtils.cosDeg(90 + shearY) * scaleY;\r\n\t\t\t\t\tvar lc = spine.MathUtils.sinDeg(shearX) * scaleX;\r\n\t\t\t\t\tvar ld = spine.MathUtils.sinDeg(90 + shearY) * scaleY;\r\n\t\t\t\t\tif (this.data.transformMode != spine.TransformMode.NoScaleOrReflection ? pa * pd - pb * pc < 0 : this.skeleton.flipX != this.skeleton.flipY) {\r\n\t\t\t\t\t\tzb = -zb;\r\n\t\t\t\t\t\tzd = -zd;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tthis.a = za * la + zb * lc;\r\n\t\t\t\t\tthis.b = za * lb + zb * ld;\r\n\t\t\t\t\tthis.c = zc * la + zd * lc;\r\n\t\t\t\t\tthis.d = zc * lb + zd * ld;\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (this.skeleton.flipX) {\r\n\t\t\t\tthis.a = -this.a;\r\n\t\t\t\tthis.b = -this.b;\r\n\t\t\t}\r\n\t\t\tif (this.skeleton.flipY) {\r\n\t\t\t\tthis.c = -this.c;\r\n\t\t\t\tthis.d = -this.d;\r\n\t\t\t}\r\n\t\t};\r\n\t\tBone.prototype.setToSetupPose = function () {\r\n\t\t\tvar data = this.data;\r\n\t\t\tthis.x = data.x;\r\n\t\t\tthis.y = data.y;\r\n\t\t\tthis.rotation = data.rotation;\r\n\t\t\tthis.scaleX = data.scaleX;\r\n\t\t\tthis.scaleY = data.scaleY;\r\n\t\t\tthis.shearX = data.shearX;\r\n\t\t\tthis.shearY = data.shearY;\r\n\t\t};\r\n\t\tBone.prototype.getWorldRotationX = function () {\r\n\t\t\treturn Math.atan2(this.c, this.a) * spine.MathUtils.radDeg;\r\n\t\t};\r\n\t\tBone.prototype.getWorldRotationY = function () {\r\n\t\t\treturn Math.atan2(this.d, this.b) * spine.MathUtils.radDeg;\r\n\t\t};\r\n\t\tBone.prototype.getWorldScaleX = function () {\r\n\t\t\treturn Math.sqrt(this.a * this.a + this.c * this.c);\r\n\t\t};\r\n\t\tBone.prototype.getWorldScaleY = function () {\r\n\t\t\treturn Math.sqrt(this.b * this.b + this.d * this.d);\r\n\t\t};\r\n\t\tBone.prototype.updateAppliedTransform = function () {\r\n\t\t\tthis.appliedValid = true;\r\n\t\t\tvar parent = this.parent;\r\n\t\t\tif (parent == null) {\r\n\t\t\t\tthis.ax = this.worldX;\r\n\t\t\t\tthis.ay = this.worldY;\r\n\t\t\t\tthis.arotation = Math.atan2(this.c, this.a) * spine.MathUtils.radDeg;\r\n\t\t\t\tthis.ascaleX = Math.sqrt(this.a * this.a + this.c * this.c);\r\n\t\t\t\tthis.ascaleY = Math.sqrt(this.b * this.b + this.d * this.d);\r\n\t\t\t\tthis.ashearX = 0;\r\n\t\t\t\tthis.ashearY = Math.atan2(this.a * this.b + this.c * this.d, this.a * this.d - this.b * this.c) * spine.MathUtils.radDeg;\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tvar pa = parent.a, pb = parent.b, pc = parent.c, pd = parent.d;\r\n\t\t\tvar pid = 1 / (pa * pd - pb * pc);\r\n\t\t\tvar dx = this.worldX - parent.worldX, dy = this.worldY - parent.worldY;\r\n\t\t\tthis.ax = (dx * pd * pid - dy * pb * pid);\r\n\t\t\tthis.ay = (dy * pa * pid - dx * pc * pid);\r\n\t\t\tvar ia = pid * pd;\r\n\t\t\tvar id = pid * pa;\r\n\t\t\tvar ib = pid * pb;\r\n\t\t\tvar ic = pid * pc;\r\n\t\t\tvar ra = ia * this.a - ib * this.c;\r\n\t\t\tvar rb = ia * this.b - ib * this.d;\r\n\t\t\tvar rc = id * this.c - ic * this.a;\r\n\t\t\tvar rd = id * this.d - ic * this.b;\r\n\t\t\tthis.ashearX = 0;\r\n\t\t\tthis.ascaleX = Math.sqrt(ra * ra + rc * rc);\r\n\t\t\tif (this.ascaleX > 0.0001) {\r\n\t\t\t\tvar det = ra * rd - rb * rc;\r\n\t\t\t\tthis.ascaleY = det / this.ascaleX;\r\n\t\t\t\tthis.ashearY = Math.atan2(ra * rb + rc * rd, det) * spine.MathUtils.radDeg;\r\n\t\t\t\tthis.arotation = Math.atan2(rc, ra) * spine.MathUtils.radDeg;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tthis.ascaleX = 0;\r\n\t\t\t\tthis.ascaleY = Math.sqrt(rb * rb + rd * rd);\r\n\t\t\t\tthis.ashearY = 0;\r\n\t\t\t\tthis.arotation = 90 - Math.atan2(rd, rb) * spine.MathUtils.radDeg;\r\n\t\t\t}\r\n\t\t};\r\n\t\tBone.prototype.worldToLocal = function (world) {\r\n\t\t\tvar a = this.a, b = this.b, c = this.c, d = this.d;\r\n\t\t\tvar invDet = 1 / (a * d - b * c);\r\n\t\t\tvar x = world.x - this.worldX, y = world.y - this.worldY;\r\n\t\t\tworld.x = (x * d * invDet - y * b * invDet);\r\n\t\t\tworld.y = (y * a * invDet - x * c * invDet);\r\n\t\t\treturn world;\r\n\t\t};\r\n\t\tBone.prototype.localToWorld = function (local) {\r\n\t\t\tvar x = local.x, y = local.y;\r\n\t\t\tlocal.x = x * this.a + y * this.b + this.worldX;\r\n\t\t\tlocal.y = x * this.c + y * this.d + this.worldY;\r\n\t\t\treturn local;\r\n\t\t};\r\n\t\tBone.prototype.worldToLocalRotation = function (worldRotation) {\r\n\t\t\tvar sin = spine.MathUtils.sinDeg(worldRotation), cos = spine.MathUtils.cosDeg(worldRotation);\r\n\t\t\treturn Math.atan2(this.a * sin - this.c * cos, this.d * cos - this.b * sin) * spine.MathUtils.radDeg;\r\n\t\t};\r\n\t\tBone.prototype.localToWorldRotation = function (localRotation) {\r\n\t\t\tvar sin = spine.MathUtils.sinDeg(localRotation), cos = spine.MathUtils.cosDeg(localRotation);\r\n\t\t\treturn Math.atan2(cos * this.c + sin * this.d, cos * this.a + sin * this.b) * spine.MathUtils.radDeg;\r\n\t\t};\r\n\t\tBone.prototype.rotateWorld = function (degrees) {\r\n\t\t\tvar a = this.a, b = this.b, c = this.c, d = this.d;\r\n\t\t\tvar cos = spine.MathUtils.cosDeg(degrees), sin = spine.MathUtils.sinDeg(degrees);\r\n\t\t\tthis.a = cos * a - sin * c;\r\n\t\t\tthis.b = cos * b - sin * d;\r\n\t\t\tthis.c = sin * a + cos * c;\r\n\t\t\tthis.d = sin * b + cos * d;\r\n\t\t\tthis.appliedValid = false;\r\n\t\t};\r\n\t\treturn Bone;\r\n\t}());\r\n\tspine.Bone = Bone;\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n\tvar BoneData = (function () {\r\n\t\tfunction BoneData(index, name, parent) {\r\n\t\t\tthis.x = 0;\r\n\t\t\tthis.y = 0;\r\n\t\t\tthis.rotation = 0;\r\n\t\t\tthis.scaleX = 1;\r\n\t\t\tthis.scaleY = 1;\r\n\t\t\tthis.shearX = 0;\r\n\t\t\tthis.shearY = 0;\r\n\t\t\tthis.transformMode = TransformMode.Normal;\r\n\t\t\tif (index < 0)\r\n\t\t\t\tthrow new Error(\"index must be >= 0.\");\r\n\t\t\tif (name == null)\r\n\t\t\t\tthrow new Error(\"name cannot be null.\");\r\n\t\t\tthis.index = index;\r\n\t\t\tthis.name = name;\r\n\t\t\tthis.parent = parent;\r\n\t\t}\r\n\t\treturn BoneData;\r\n\t}());\r\n\tspine.BoneData = BoneData;\r\n\tvar TransformMode;\r\n\t(function (TransformMode) {\r\n\t\tTransformMode[TransformMode[\"Normal\"] = 0] = \"Normal\";\r\n\t\tTransformMode[TransformMode[\"OnlyTranslation\"] = 1] = \"OnlyTranslation\";\r\n\t\tTransformMode[TransformMode[\"NoRotationOrReflection\"] = 2] = \"NoRotationOrReflection\";\r\n\t\tTransformMode[TransformMode[\"NoScale\"] = 3] = \"NoScale\";\r\n\t\tTransformMode[TransformMode[\"NoScaleOrReflection\"] = 4] = \"NoScaleOrReflection\";\r\n\t})(TransformMode = spine.TransformMode || (spine.TransformMode = {}));\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n\tvar Event = (function () {\r\n\t\tfunction Event(time, data) {\r\n\t\t\tif (data == null)\r\n\t\t\t\tthrow new Error(\"data cannot be null.\");\r\n\t\t\tthis.time = time;\r\n\t\t\tthis.data = data;\r\n\t\t}\r\n\t\treturn Event;\r\n\t}());\r\n\tspine.Event = Event;\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n\tvar EventData = (function () {\r\n\t\tfunction EventData(name) {\r\n\t\t\tthis.name = name;\r\n\t\t}\r\n\t\treturn EventData;\r\n\t}());\r\n\tspine.EventData = EventData;\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n\tvar IkConstraint = (function () {\r\n\t\tfunction IkConstraint(data, skeleton) {\r\n\t\t\tthis.mix = 1;\r\n\t\t\tthis.bendDirection = 0;\r\n\t\t\tif (data == null)\r\n\t\t\t\tthrow new Error(\"data cannot be null.\");\r\n\t\t\tif (skeleton == null)\r\n\t\t\t\tthrow new Error(\"skeleton cannot be null.\");\r\n\t\t\tthis.data = data;\r\n\t\t\tthis.mix = data.mix;\r\n\t\t\tthis.bendDirection = data.bendDirection;\r\n\t\t\tthis.bones = new Array();\r\n\t\t\tfor (var i = 0; i < data.bones.length; i++)\r\n\t\t\t\tthis.bones.push(skeleton.findBone(data.bones[i].name));\r\n\t\t\tthis.target = skeleton.findBone(data.target.name);\r\n\t\t}\r\n\t\tIkConstraint.prototype.getOrder = function () {\r\n\t\t\treturn this.data.order;\r\n\t\t};\r\n\t\tIkConstraint.prototype.apply = function () {\r\n\t\t\tthis.update();\r\n\t\t};\r\n\t\tIkConstraint.prototype.update = function () {\r\n\t\t\tvar target = this.target;\r\n\t\t\tvar bones = this.bones;\r\n\t\t\tswitch (bones.length) {\r\n\t\t\t\tcase 1:\r\n\t\t\t\t\tthis.apply1(bones[0], target.worldX, target.worldY, this.mix);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 2:\r\n\t\t\t\t\tthis.apply2(bones[0], bones[1], target.worldX, target.worldY, this.bendDirection, this.mix);\r\n\t\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t};\r\n\t\tIkConstraint.prototype.apply1 = function (bone, targetX, targetY, alpha) {\r\n\t\t\tif (!bone.appliedValid)\r\n\t\t\t\tbone.updateAppliedTransform();\r\n\t\t\tvar p = bone.parent;\r\n\t\t\tvar id = 1 / (p.a * p.d - p.b * p.c);\r\n\t\t\tvar x = targetX - p.worldX, y = targetY - p.worldY;\r\n\t\t\tvar tx = (x * p.d - y * p.b) * id - bone.ax, ty = (y * p.a - x * p.c) * id - bone.ay;\r\n\t\t\tvar rotationIK = Math.atan2(ty, tx) * spine.MathUtils.radDeg - bone.ashearX - bone.arotation;\r\n\t\t\tif (bone.ascaleX < 0)\r\n\t\t\t\trotationIK += 180;\r\n\t\t\tif (rotationIK > 180)\r\n\t\t\t\trotationIK -= 360;\r\n\t\t\telse if (rotationIK < -180)\r\n\t\t\t\trotationIK += 360;\r\n\t\t\tbone.updateWorldTransformWith(bone.ax, bone.ay, bone.arotation + rotationIK * alpha, bone.ascaleX, bone.ascaleY, bone.ashearX, bone.ashearY);\r\n\t\t};\r\n\t\tIkConstraint.prototype.apply2 = function (parent, child, targetX, targetY, bendDir, alpha) {\r\n\t\t\tif (alpha == 0) {\r\n\t\t\t\tchild.updateWorldTransform();\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tif (!parent.appliedValid)\r\n\t\t\t\tparent.updateAppliedTransform();\r\n\t\t\tif (!child.appliedValid)\r\n\t\t\t\tchild.updateAppliedTransform();\r\n\t\t\tvar px = parent.ax, py = parent.ay, psx = parent.ascaleX, psy = parent.ascaleY, csx = child.ascaleX;\r\n\t\t\tvar os1 = 0, os2 = 0, s2 = 0;\r\n\t\t\tif (psx < 0) {\r\n\t\t\t\tpsx = -psx;\r\n\t\t\t\tos1 = 180;\r\n\t\t\t\ts2 = -1;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tos1 = 0;\r\n\t\t\t\ts2 = 1;\r\n\t\t\t}\r\n\t\t\tif (psy < 0) {\r\n\t\t\t\tpsy = -psy;\r\n\t\t\t\ts2 = -s2;\r\n\t\t\t}\r\n\t\t\tif (csx < 0) {\r\n\t\t\t\tcsx = -csx;\r\n\t\t\t\tos2 = 180;\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t\tos2 = 0;\r\n\t\t\tvar cx = child.ax, cy = 0, cwx = 0, cwy = 0, a = parent.a, b = parent.b, c = parent.c, d = parent.d;\r\n\t\t\tvar u = Math.abs(psx - psy) <= 0.0001;\r\n\t\t\tif (!u) {\r\n\t\t\t\tcy = 0;\r\n\t\t\t\tcwx = a * cx + parent.worldX;\r\n\t\t\t\tcwy = c * cx + parent.worldY;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tcy = child.ay;\r\n\t\t\t\tcwx = a * cx + b * cy + parent.worldX;\r\n\t\t\t\tcwy = c * cx + d * cy + parent.worldY;\r\n\t\t\t}\r\n\t\t\tvar pp = parent.parent;\r\n\t\t\ta = pp.a;\r\n\t\t\tb = pp.b;\r\n\t\t\tc = pp.c;\r\n\t\t\td = pp.d;\r\n\t\t\tvar id = 1 / (a * d - b * c), x = targetX - pp.worldX, y = targetY - pp.worldY;\r\n\t\t\tvar tx = (x * d - y * b) * id - px, ty = (y * a - x * c) * id - py;\r\n\t\t\tx = cwx - pp.worldX;\r\n\t\t\ty = cwy - pp.worldY;\r\n\t\t\tvar dx = (x * d - y * b) * id - px, dy = (y * a - x * c) * id - py;\r\n\t\t\tvar l1 = Math.sqrt(dx * dx + dy * dy), l2 = child.data.length * csx, a1 = 0, a2 = 0;\r\n\t\t\touter: if (u) {\r\n\t\t\t\tl2 *= psx;\r\n\t\t\t\tvar cos = (tx * tx + ty * ty - l1 * l1 - l2 * l2) / (2 * l1 * l2);\r\n\t\t\t\tif (cos < -1)\r\n\t\t\t\t\tcos = -1;\r\n\t\t\t\telse if (cos > 1)\r\n\t\t\t\t\tcos = 1;\r\n\t\t\t\ta2 = Math.acos(cos) * bendDir;\r\n\t\t\t\ta = l1 + l2 * cos;\r\n\t\t\t\tb = l2 * Math.sin(a2);\r\n\t\t\t\ta1 = Math.atan2(ty * a - tx * b, tx * a + ty * b);\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\ta = psx * l2;\r\n\t\t\t\tb = psy * l2;\r\n\t\t\t\tvar aa = a * a, bb = b * b, dd = tx * tx + ty * ty, ta = Math.atan2(ty, tx);\r\n\t\t\t\tc = bb * l1 * l1 + aa * dd - aa * bb;\r\n\t\t\t\tvar c1 = -2 * bb * l1, c2 = bb - aa;\r\n\t\t\t\td = c1 * c1 - 4 * c2 * c;\r\n\t\t\t\tif (d >= 0) {\r\n\t\t\t\t\tvar q = Math.sqrt(d);\r\n\t\t\t\t\tif (c1 < 0)\r\n\t\t\t\t\t\tq = -q;\r\n\t\t\t\t\tq = -(c1 + q) / 2;\r\n\t\t\t\t\tvar r0 = q / c2, r1 = c / q;\r\n\t\t\t\t\tvar r = Math.abs(r0) < Math.abs(r1) ? r0 : r1;\r\n\t\t\t\t\tif (r * r <= dd) {\r\n\t\t\t\t\t\ty = Math.sqrt(dd - r * r) * bendDir;\r\n\t\t\t\t\t\ta1 = ta - Math.atan2(y, r);\r\n\t\t\t\t\t\ta2 = Math.atan2(y / psy, (r - l1) / psx);\r\n\t\t\t\t\t\tbreak outer;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tvar minAngle = spine.MathUtils.PI, minX = l1 - a, minDist = minX * minX, minY = 0;\r\n\t\t\t\tvar maxAngle = 0, maxX = l1 + a, maxDist = maxX * maxX, maxY = 0;\r\n\t\t\t\tc = -a * l1 / (aa - bb);\r\n\t\t\t\tif (c >= -1 && c <= 1) {\r\n\t\t\t\t\tc = Math.acos(c);\r\n\t\t\t\t\tx = a * Math.cos(c) + l1;\r\n\t\t\t\t\ty = b * Math.sin(c);\r\n\t\t\t\t\td = x * x + y * y;\r\n\t\t\t\t\tif (d < minDist) {\r\n\t\t\t\t\t\tminAngle = c;\r\n\t\t\t\t\t\tminDist = d;\r\n\t\t\t\t\t\tminX = x;\r\n\t\t\t\t\t\tminY = y;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (d > maxDist) {\r\n\t\t\t\t\t\tmaxAngle = c;\r\n\t\t\t\t\t\tmaxDist = d;\r\n\t\t\t\t\t\tmaxX = x;\r\n\t\t\t\t\t\tmaxY = y;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (dd <= (minDist + maxDist) / 2) {\r\n\t\t\t\t\ta1 = ta - Math.atan2(minY * bendDir, minX);\r\n\t\t\t\t\ta2 = minAngle * bendDir;\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\ta1 = ta - Math.atan2(maxY * bendDir, maxX);\r\n\t\t\t\t\ta2 = maxAngle * bendDir;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tvar os = Math.atan2(cy, cx) * s2;\r\n\t\t\tvar rotation = parent.arotation;\r\n\t\t\ta1 = (a1 - os) * spine.MathUtils.radDeg + os1 - rotation;\r\n\t\t\tif (a1 > 180)\r\n\t\t\t\ta1 -= 360;\r\n\t\t\telse if (a1 < -180)\r\n\t\t\t\ta1 += 360;\r\n\t\t\tparent.updateWorldTransformWith(px, py, rotation + a1 * alpha, parent.ascaleX, parent.ascaleY, 0, 0);\r\n\t\t\trotation = child.arotation;\r\n\t\t\ta2 = ((a2 + os) * spine.MathUtils.radDeg - child.ashearX) * s2 + os2 - rotation;\r\n\t\t\tif (a2 > 180)\r\n\t\t\t\ta2 -= 360;\r\n\t\t\telse if (a2 < -180)\r\n\t\t\t\ta2 += 360;\r\n\t\t\tchild.updateWorldTransformWith(cx, cy, rotation + a2 * alpha, child.ascaleX, child.ascaleY, child.ashearX, child.ashearY);\r\n\t\t};\r\n\t\treturn IkConstraint;\r\n\t}());\r\n\tspine.IkConstraint = IkConstraint;\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n\tvar IkConstraintData = (function () {\r\n\t\tfunction IkConstraintData(name) {\r\n\t\t\tthis.order = 0;\r\n\t\t\tthis.bones = new Array();\r\n\t\t\tthis.bendDirection = 1;\r\n\t\t\tthis.mix = 1;\r\n\t\t\tthis.name = name;\r\n\t\t}\r\n\t\treturn IkConstraintData;\r\n\t}());\r\n\tspine.IkConstraintData = IkConstraintData;\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n\tvar PathConstraint = (function () {\r\n\t\tfunction PathConstraint(data, skeleton) {\r\n\t\t\tthis.position = 0;\r\n\t\t\tthis.spacing = 0;\r\n\t\t\tthis.rotateMix = 0;\r\n\t\t\tthis.translateMix = 0;\r\n\t\t\tthis.spaces = new Array();\r\n\t\t\tthis.positions = new Array();\r\n\t\t\tthis.world = new Array();\r\n\t\t\tthis.curves = new Array();\r\n\t\t\tthis.lengths = new Array();\r\n\t\t\tthis.segments = new Array();\r\n\t\t\tif (data == null)\r\n\t\t\t\tthrow new Error(\"data cannot be null.\");\r\n\t\t\tif (skeleton == null)\r\n\t\t\t\tthrow new Error(\"skeleton cannot be null.\");\r\n\t\t\tthis.data = data;\r\n\t\t\tthis.bones = new Array();\r\n\t\t\tfor (var i = 0, n = data.bones.length; i < n; i++)\r\n\t\t\t\tthis.bones.push(skeleton.findBone(data.bones[i].name));\r\n\t\t\tthis.target = skeleton.findSlot(data.target.name);\r\n\t\t\tthis.position = data.position;\r\n\t\t\tthis.spacing = data.spacing;\r\n\t\t\tthis.rotateMix = data.rotateMix;\r\n\t\t\tthis.translateMix = data.translateMix;\r\n\t\t}\r\n\t\tPathConstraint.prototype.apply = function () {\r\n\t\t\tthis.update();\r\n\t\t};\r\n\t\tPathConstraint.prototype.update = function () {\r\n\t\t\tvar attachment = this.target.getAttachment();\r\n\t\t\tif (!(attachment instanceof spine.PathAttachment))\r\n\t\t\t\treturn;\r\n\t\t\tvar rotateMix = this.rotateMix, translateMix = this.translateMix;\r\n\t\t\tvar translate = translateMix > 0, rotate = rotateMix > 0;\r\n\t\t\tif (!translate && !rotate)\r\n\t\t\t\treturn;\r\n\t\t\tvar data = this.data;\r\n\t\t\tvar spacingMode = data.spacingMode;\r\n\t\t\tvar lengthSpacing = spacingMode == spine.SpacingMode.Length;\r\n\t\t\tvar rotateMode = data.rotateMode;\r\n\t\t\tvar tangents = rotateMode == spine.RotateMode.Tangent, scale = rotateMode == spine.RotateMode.ChainScale;\r\n\t\t\tvar boneCount = this.bones.length, spacesCount = tangents ? boneCount : boneCount + 1;\r\n\t\t\tvar bones = this.bones;\r\n\t\t\tvar spaces = spine.Utils.setArraySize(this.spaces, spacesCount), lengths = null;\r\n\t\t\tvar spacing = this.spacing;\r\n\t\t\tif (scale || lengthSpacing) {\r\n\t\t\t\tif (scale)\r\n\t\t\t\t\tlengths = spine.Utils.setArraySize(this.lengths, boneCount);\r\n\t\t\t\tfor (var i = 0, n = spacesCount - 1; i < n;) {\r\n\t\t\t\t\tvar bone = bones[i];\r\n\t\t\t\t\tvar setupLength = bone.data.length;\r\n\t\t\t\t\tif (setupLength < PathConstraint.epsilon) {\r\n\t\t\t\t\t\tif (scale)\r\n\t\t\t\t\t\t\tlengths[i] = 0;\r\n\t\t\t\t\t\tspaces[++i] = 0;\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tvar x = setupLength * bone.a, y = setupLength * bone.c;\r\n\t\t\t\t\t\tvar length_1 = Math.sqrt(x * x + y * y);\r\n\t\t\t\t\t\tif (scale)\r\n\t\t\t\t\t\t\tlengths[i] = length_1;\r\n\t\t\t\t\t\tspaces[++i] = (lengthSpacing ? setupLength + spacing : spacing) * length_1 / setupLength;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tfor (var i = 1; i < spacesCount; i++)\r\n\t\t\t\t\tspaces[i] = spacing;\r\n\t\t\t}\r\n\t\t\tvar positions = this.computeWorldPositions(attachment, spacesCount, tangents, data.positionMode == spine.PositionMode.Percent, spacingMode == spine.SpacingMode.Percent);\r\n\t\t\tvar boneX = positions[0], boneY = positions[1], offsetRotation = data.offsetRotation;\r\n\t\t\tvar tip = false;\r\n\t\t\tif (offsetRotation == 0)\r\n\t\t\t\ttip = rotateMode == spine.RotateMode.Chain;\r\n\t\t\telse {\r\n\t\t\t\ttip = false;\r\n\t\t\t\tvar p = this.target.bone;\r\n\t\t\t\toffsetRotation *= p.a * p.d - p.b * p.c > 0 ? spine.MathUtils.degRad : -spine.MathUtils.degRad;\r\n\t\t\t}\r\n\t\t\tfor (var i = 0, p = 3; i < boneCount; i++, p += 3) {\r\n\t\t\t\tvar bone = bones[i];\r\n\t\t\t\tbone.worldX += (boneX - bone.worldX) * translateMix;\r\n\t\t\t\tbone.worldY += (boneY - bone.worldY) * translateMix;\r\n\t\t\t\tvar x = positions[p], y = positions[p + 1], dx = x - boneX, dy = y - boneY;\r\n\t\t\t\tif (scale) {\r\n\t\t\t\t\tvar length_2 = lengths[i];\r\n\t\t\t\t\tif (length_2 != 0) {\r\n\t\t\t\t\t\tvar s = (Math.sqrt(dx * dx + dy * dy) / length_2 - 1) * rotateMix + 1;\r\n\t\t\t\t\t\tbone.a *= s;\r\n\t\t\t\t\t\tbone.c *= s;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tboneX = x;\r\n\t\t\t\tboneY = y;\r\n\t\t\t\tif (rotate) {\r\n\t\t\t\t\tvar a = bone.a, b = bone.b, c = bone.c, d = bone.d, r = 0, cos = 0, sin = 0;\r\n\t\t\t\t\tif (tangents)\r\n\t\t\t\t\t\tr = positions[p - 1];\r\n\t\t\t\t\telse if (spaces[i + 1] == 0)\r\n\t\t\t\t\t\tr = positions[p + 2];\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tr = Math.atan2(dy, dx);\r\n\t\t\t\t\tr -= Math.atan2(c, a);\r\n\t\t\t\t\tif (tip) {\r\n\t\t\t\t\t\tcos = Math.cos(r);\r\n\t\t\t\t\t\tsin = Math.sin(r);\r\n\t\t\t\t\t\tvar length_3 = bone.data.length;\r\n\t\t\t\t\t\tboneX += (length_3 * (cos * a - sin * c) - dx) * rotateMix;\r\n\t\t\t\t\t\tboneY += (length_3 * (sin * a + cos * c) - dy) * rotateMix;\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tr += offsetRotation;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (r > spine.MathUtils.PI)\r\n\t\t\t\t\t\tr -= spine.MathUtils.PI2;\r\n\t\t\t\t\telse if (r < -spine.MathUtils.PI)\r\n\t\t\t\t\t\tr += spine.MathUtils.PI2;\r\n\t\t\t\t\tr *= rotateMix;\r\n\t\t\t\t\tcos = Math.cos(r);\r\n\t\t\t\t\tsin = Math.sin(r);\r\n\t\t\t\t\tbone.a = cos * a - sin * c;\r\n\t\t\t\t\tbone.b = cos * b - sin * d;\r\n\t\t\t\t\tbone.c = sin * a + cos * c;\r\n\t\t\t\t\tbone.d = sin * b + cos * d;\r\n\t\t\t\t}\r\n\t\t\t\tbone.appliedValid = false;\r\n\t\t\t}\r\n\t\t};\r\n\t\tPathConstraint.prototype.computeWorldPositions = function (path, spacesCount, tangents, percentPosition, percentSpacing) {\r\n\t\t\tvar target = this.target;\r\n\t\t\tvar position = this.position;\r\n\t\t\tvar spaces = this.spaces, out = spine.Utils.setArraySize(this.positions, spacesCount * 3 + 2), world = null;\r\n\t\t\tvar closed = path.closed;\r\n\t\t\tvar verticesLength = path.worldVerticesLength, curveCount = verticesLength / 6, prevCurve = PathConstraint.NONE;\r\n\t\t\tif (!path.constantSpeed) {\r\n\t\t\t\tvar lengths = path.lengths;\r\n\t\t\t\tcurveCount -= closed ? 1 : 2;\r\n\t\t\t\tvar pathLength_1 = lengths[curveCount];\r\n\t\t\t\tif (percentPosition)\r\n\t\t\t\t\tposition *= pathLength_1;\r\n\t\t\t\tif (percentSpacing) {\r\n\t\t\t\t\tfor (var i = 0; i < spacesCount; i++)\r\n\t\t\t\t\t\tspaces[i] *= pathLength_1;\r\n\t\t\t\t}\r\n\t\t\t\tworld = spine.Utils.setArraySize(this.world, 8);\r\n\t\t\t\tfor (var i = 0, o = 0, curve = 0; i < spacesCount; i++, o += 3) {\r\n\t\t\t\t\tvar space = spaces[i];\r\n\t\t\t\t\tposition += space;\r\n\t\t\t\t\tvar p = position;\r\n\t\t\t\t\tif (closed) {\r\n\t\t\t\t\t\tp %= pathLength_1;\r\n\t\t\t\t\t\tif (p < 0)\r\n\t\t\t\t\t\t\tp += pathLength_1;\r\n\t\t\t\t\t\tcurve = 0;\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse if (p < 0) {\r\n\t\t\t\t\t\tif (prevCurve != PathConstraint.BEFORE) {\r\n\t\t\t\t\t\t\tprevCurve = PathConstraint.BEFORE;\r\n\t\t\t\t\t\t\tpath.computeWorldVertices(target, 2, 4, world, 0, 2);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tthis.addBeforePosition(p, world, 0, out, o);\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse if (p > pathLength_1) {\r\n\t\t\t\t\t\tif (prevCurve != PathConstraint.AFTER) {\r\n\t\t\t\t\t\t\tprevCurve = PathConstraint.AFTER;\r\n\t\t\t\t\t\t\tpath.computeWorldVertices(target, verticesLength - 6, 4, world, 0, 2);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tthis.addAfterPosition(p - pathLength_1, world, 0, out, o);\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tfor (;; curve++) {\r\n\t\t\t\t\t\tvar length_4 = lengths[curve];\r\n\t\t\t\t\t\tif (p > length_4)\r\n\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\tif (curve == 0)\r\n\t\t\t\t\t\t\tp /= length_4;\r\n\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\tvar prev = lengths[curve - 1];\r\n\t\t\t\t\t\t\tp = (p - prev) / (length_4 - prev);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (curve != prevCurve) {\r\n\t\t\t\t\t\tprevCurve = curve;\r\n\t\t\t\t\t\tif (closed && curve == curveCount) {\r\n\t\t\t\t\t\t\tpath.computeWorldVertices(target, verticesLength - 4, 4, world, 0, 2);\r\n\t\t\t\t\t\t\tpath.computeWorldVertices(target, 0, 4, world, 4, 2);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\tpath.computeWorldVertices(target, curve * 6 + 2, 8, world, 0, 2);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tthis.addCurvePosition(p, world[0], world[1], world[2], world[3], world[4], world[5], world[6], world[7], out, o, tangents || (i > 0 && space == 0));\r\n\t\t\t\t}\r\n\t\t\t\treturn out;\r\n\t\t\t}\r\n\t\t\tif (closed) {\r\n\t\t\t\tverticesLength += 2;\r\n\t\t\t\tworld = spine.Utils.setArraySize(this.world, verticesLength);\r\n\t\t\t\tpath.computeWorldVertices(target, 2, verticesLength - 4, world, 0, 2);\r\n\t\t\t\tpath.computeWorldVertices(target, 0, 2, world, verticesLength - 4, 2);\r\n\t\t\t\tworld[verticesLength - 2] = world[0];\r\n\t\t\t\tworld[verticesLength - 1] = world[1];\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tcurveCount--;\r\n\t\t\t\tverticesLength -= 4;\r\n\t\t\t\tworld = spine.Utils.setArraySize(this.world, verticesLength);\r\n\t\t\t\tpath.computeWorldVertices(target, 2, verticesLength, world, 0, 2);\r\n\t\t\t}\r\n\t\t\tvar curves = spine.Utils.setArraySize(this.curves, curveCount);\r\n\t\t\tvar pathLength = 0;\r\n\t\t\tvar x1 = world[0], y1 = world[1], cx1 = 0, cy1 = 0, cx2 = 0, cy2 = 0, x2 = 0, y2 = 0;\r\n\t\t\tvar tmpx = 0, tmpy = 0, dddfx = 0, dddfy = 0, ddfx = 0, ddfy = 0, dfx = 0, dfy = 0;\r\n\t\t\tfor (var i = 0, w = 2; i < curveCount; i++, w += 6) {\r\n\t\t\t\tcx1 = world[w];\r\n\t\t\t\tcy1 = world[w + 1];\r\n\t\t\t\tcx2 = world[w + 2];\r\n\t\t\t\tcy2 = world[w + 3];\r\n\t\t\t\tx2 = world[w + 4];\r\n\t\t\t\ty2 = world[w + 5];\r\n\t\t\t\ttmpx = (x1 - cx1 * 2 + cx2) * 0.1875;\r\n\t\t\t\ttmpy = (y1 - cy1 * 2 + cy2) * 0.1875;\r\n\t\t\t\tdddfx = ((cx1 - cx2) * 3 - x1 + x2) * 0.09375;\r\n\t\t\t\tdddfy = ((cy1 - cy2) * 3 - y1 + y2) * 0.09375;\r\n\t\t\t\tddfx = tmpx * 2 + dddfx;\r\n\t\t\t\tddfy = tmpy * 2 + dddfy;\r\n\t\t\t\tdfx = (cx1 - x1) * 0.75 + tmpx + dddfx * 0.16666667;\r\n\t\t\t\tdfy = (cy1 - y1) * 0.75 + tmpy + dddfy * 0.16666667;\r\n\t\t\t\tpathLength += Math.sqrt(dfx * dfx + dfy * dfy);\r\n\t\t\t\tdfx += ddfx;\r\n\t\t\t\tdfy += ddfy;\r\n\t\t\t\tddfx += dddfx;\r\n\t\t\t\tddfy += dddfy;\r\n\t\t\t\tpathLength += Math.sqrt(dfx * dfx + dfy * dfy);\r\n\t\t\t\tdfx += ddfx;\r\n\t\t\t\tdfy += ddfy;\r\n\t\t\t\tpathLength += Math.sqrt(dfx * dfx + dfy * dfy);\r\n\t\t\t\tdfx += ddfx + dddfx;\r\n\t\t\t\tdfy += ddfy + dddfy;\r\n\t\t\t\tpathLength += Math.sqrt(dfx * dfx + dfy * dfy);\r\n\t\t\t\tcurves[i] = pathLength;\r\n\t\t\t\tx1 = x2;\r\n\t\t\t\ty1 = y2;\r\n\t\t\t}\r\n\t\t\tif (percentPosition)\r\n\t\t\t\tposition *= pathLength;\r\n\t\t\tif (percentSpacing) {\r\n\t\t\t\tfor (var i = 0; i < spacesCount; i++)\r\n\t\t\t\t\tspaces[i] *= pathLength;\r\n\t\t\t}\r\n\t\t\tvar segments = this.segments;\r\n\t\t\tvar curveLength = 0;\r\n\t\t\tfor (var i = 0, o = 0, curve = 0, segment = 0; i < spacesCount; i++, o += 3) {\r\n\t\t\t\tvar space = spaces[i];\r\n\t\t\t\tposition += space;\r\n\t\t\t\tvar p = position;\r\n\t\t\t\tif (closed) {\r\n\t\t\t\t\tp %= pathLength;\r\n\t\t\t\t\tif (p < 0)\r\n\t\t\t\t\t\tp += pathLength;\r\n\t\t\t\t\tcurve = 0;\r\n\t\t\t\t}\r\n\t\t\t\telse if (p < 0) {\r\n\t\t\t\t\tthis.addBeforePosition(p, world, 0, out, o);\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t\telse if (p > pathLength) {\r\n\t\t\t\t\tthis.addAfterPosition(p - pathLength, world, verticesLength - 4, out, o);\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t\tfor (;; curve++) {\r\n\t\t\t\t\tvar length_5 = curves[curve];\r\n\t\t\t\t\tif (p > length_5)\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\tif (curve == 0)\r\n\t\t\t\t\t\tp /= length_5;\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tvar prev = curves[curve - 1];\r\n\t\t\t\t\t\tp = (p - prev) / (length_5 - prev);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\tif (curve != prevCurve) {\r\n\t\t\t\t\tprevCurve = curve;\r\n\t\t\t\t\tvar ii = curve * 6;\r\n\t\t\t\t\tx1 = world[ii];\r\n\t\t\t\t\ty1 = world[ii + 1];\r\n\t\t\t\t\tcx1 = world[ii + 2];\r\n\t\t\t\t\tcy1 = world[ii + 3];\r\n\t\t\t\t\tcx2 = world[ii + 4];\r\n\t\t\t\t\tcy2 = world[ii + 5];\r\n\t\t\t\t\tx2 = world[ii + 6];\r\n\t\t\t\t\ty2 = world[ii + 7];\r\n\t\t\t\t\ttmpx = (x1 - cx1 * 2 + cx2) * 0.03;\r\n\t\t\t\t\ttmpy = (y1 - cy1 * 2 + cy2) * 0.03;\r\n\t\t\t\t\tdddfx = ((cx1 - cx2) * 3 - x1 + x2) * 0.006;\r\n\t\t\t\t\tdddfy = ((cy1 - cy2) * 3 - y1 + y2) * 0.006;\r\n\t\t\t\t\tddfx = tmpx * 2 + dddfx;\r\n\t\t\t\t\tddfy = tmpy * 2 + dddfy;\r\n\t\t\t\t\tdfx = (cx1 - x1) * 0.3 + tmpx + dddfx * 0.16666667;\r\n\t\t\t\t\tdfy = (cy1 - y1) * 0.3 + tmpy + dddfy * 0.16666667;\r\n\t\t\t\t\tcurveLength = Math.sqrt(dfx * dfx + dfy * dfy);\r\n\t\t\t\t\tsegments[0] = curveLength;\r\n\t\t\t\t\tfor (ii = 1; ii < 8; ii++) {\r\n\t\t\t\t\t\tdfx += ddfx;\r\n\t\t\t\t\t\tdfy += ddfy;\r\n\t\t\t\t\t\tddfx += dddfx;\r\n\t\t\t\t\t\tddfy += dddfy;\r\n\t\t\t\t\t\tcurveLength += Math.sqrt(dfx * dfx + dfy * dfy);\r\n\t\t\t\t\t\tsegments[ii] = curveLength;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tdfx += ddfx;\r\n\t\t\t\t\tdfy += ddfy;\r\n\t\t\t\t\tcurveLength += Math.sqrt(dfx * dfx + dfy * dfy);\r\n\t\t\t\t\tsegments[8] = curveLength;\r\n\t\t\t\t\tdfx += ddfx + dddfx;\r\n\t\t\t\t\tdfy += ddfy + dddfy;\r\n\t\t\t\t\tcurveLength += Math.sqrt(dfx * dfx + dfy * dfy);\r\n\t\t\t\t\tsegments[9] = curveLength;\r\n\t\t\t\t\tsegment = 0;\r\n\t\t\t\t}\r\n\t\t\t\tp *= curveLength;\r\n\t\t\t\tfor (;; segment++) {\r\n\t\t\t\t\tvar length_6 = segments[segment];\r\n\t\t\t\t\tif (p > length_6)\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\tif (segment == 0)\r\n\t\t\t\t\t\tp /= length_6;\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tvar prev = segments[segment - 1];\r\n\t\t\t\t\t\tp = segment + (p - prev) / (length_6 - prev);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\tthis.addCurvePosition(p * 0.1, x1, y1, cx1, cy1, cx2, cy2, x2, y2, out, o, tangents || (i > 0 && space == 0));\r\n\t\t\t}\r\n\t\t\treturn out;\r\n\t\t};\r\n\t\tPathConstraint.prototype.addBeforePosition = function (p, temp, i, out, o) {\r\n\t\t\tvar x1 = temp[i], y1 = temp[i + 1], dx = temp[i + 2] - x1, dy = temp[i + 3] - y1, r = Math.atan2(dy, dx);\r\n\t\t\tout[o] = x1 + p * Math.cos(r);\r\n\t\t\tout[o + 1] = y1 + p * Math.sin(r);\r\n\t\t\tout[o + 2] = r;\r\n\t\t};\r\n\t\tPathConstraint.prototype.addAfterPosition = function (p, temp, i, out, o) {\r\n\t\t\tvar x1 = temp[i + 2], y1 = temp[i + 3], dx = x1 - temp[i], dy = y1 - temp[i + 1], r = Math.atan2(dy, dx);\r\n\t\t\tout[o] = x1 + p * Math.cos(r);\r\n\t\t\tout[o + 1] = y1 + p * Math.sin(r);\r\n\t\t\tout[o + 2] = r;\r\n\t\t};\r\n\t\tPathConstraint.prototype.addCurvePosition = function (p, x1, y1, cx1, cy1, cx2, cy2, x2, y2, out, o, tangents) {\r\n\t\t\tif (p == 0 || isNaN(p))\r\n\t\t\t\tp = 0.0001;\r\n\t\t\tvar tt = p * p, ttt = tt * p, u = 1 - p, uu = u * u, uuu = uu * u;\r\n\t\t\tvar ut = u * p, ut3 = ut * 3, uut3 = u * ut3, utt3 = ut3 * p;\r\n\t\t\tvar x = x1 * uuu + cx1 * uut3 + cx2 * utt3 + x2 * ttt, y = y1 * uuu + cy1 * uut3 + cy2 * utt3 + y2 * ttt;\r\n\t\t\tout[o] = x;\r\n\t\t\tout[o + 1] = y;\r\n\t\t\tif (tangents)\r\n\t\t\t\tout[o + 2] = Math.atan2(y - (y1 * uu + cy1 * ut * 2 + cy2 * tt), x - (x1 * uu + cx1 * ut * 2 + cx2 * tt));\r\n\t\t};\r\n\t\tPathConstraint.prototype.getOrder = function () {\r\n\t\t\treturn this.data.order;\r\n\t\t};\r\n\t\tPathConstraint.NONE = -1;\r\n\t\tPathConstraint.BEFORE = -2;\r\n\t\tPathConstraint.AFTER = -3;\r\n\t\tPathConstraint.epsilon = 0.00001;\r\n\t\treturn PathConstraint;\r\n\t}());\r\n\tspine.PathConstraint = PathConstraint;\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n\tvar PathConstraintData = (function () {\r\n\t\tfunction PathConstraintData(name) {\r\n\t\t\tthis.order = 0;\r\n\t\t\tthis.bones = new Array();\r\n\t\t\tthis.name = name;\r\n\t\t}\r\n\t\treturn PathConstraintData;\r\n\t}());\r\n\tspine.PathConstraintData = PathConstraintData;\r\n\tvar PositionMode;\r\n\t(function (PositionMode) {\r\n\t\tPositionMode[PositionMode[\"Fixed\"] = 0] = \"Fixed\";\r\n\t\tPositionMode[PositionMode[\"Percent\"] = 1] = \"Percent\";\r\n\t})(PositionMode = spine.PositionMode || (spine.PositionMode = {}));\r\n\tvar SpacingMode;\r\n\t(function (SpacingMode) {\r\n\t\tSpacingMode[SpacingMode[\"Length\"] = 0] = \"Length\";\r\n\t\tSpacingMode[SpacingMode[\"Fixed\"] = 1] = \"Fixed\";\r\n\t\tSpacingMode[SpacingMode[\"Percent\"] = 2] = \"Percent\";\r\n\t})(SpacingMode = spine.SpacingMode || (spine.SpacingMode = {}));\r\n\tvar RotateMode;\r\n\t(function (RotateMode) {\r\n\t\tRotateMode[RotateMode[\"Tangent\"] = 0] = \"Tangent\";\r\n\t\tRotateMode[RotateMode[\"Chain\"] = 1] = \"Chain\";\r\n\t\tRotateMode[RotateMode[\"ChainScale\"] = 2] = \"ChainScale\";\r\n\t})(RotateMode = spine.RotateMode || (spine.RotateMode = {}));\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n\tvar Assets = (function () {\r\n\t\tfunction Assets(clientId) {\r\n\t\t\tthis.toLoad = new Array();\r\n\t\t\tthis.assets = {};\r\n\t\t\tthis.clientId = clientId;\r\n\t\t}\r\n\t\tAssets.prototype.loaded = function () {\r\n\t\t\tvar i = 0;\r\n\t\t\tfor (var v in this.assets)\r\n\t\t\t\ti++;\r\n\t\t\treturn i;\r\n\t\t};\r\n\t\treturn Assets;\r\n\t}());\r\n\tvar SharedAssetManager = (function () {\r\n\t\tfunction SharedAssetManager(pathPrefix) {\r\n\t\t\tif (pathPrefix === void 0) { pathPrefix = \"\"; }\r\n\t\t\tthis.clientAssets = {};\r\n\t\t\tthis.queuedAssets = {};\r\n\t\t\tthis.rawAssets = {};\r\n\t\t\tthis.errors = {};\r\n\t\t\tthis.pathPrefix = pathPrefix;\r\n\t\t}\r\n\t\tSharedAssetManager.prototype.queueAsset = function (clientId, textureLoader, path) {\r\n\t\t\tvar clientAssets = this.clientAssets[clientId];\r\n\t\t\tif (clientAssets === null || clientAssets === undefined) {\r\n\t\t\t\tclientAssets = new Assets(clientId);\r\n\t\t\t\tthis.clientAssets[clientId] = clientAssets;\r\n\t\t\t}\r\n\t\t\tif (textureLoader !== null)\r\n\t\t\t\tclientAssets.textureLoader = textureLoader;\r\n\t\t\tclientAssets.toLoad.push(path);\r\n\t\t\tif (this.queuedAssets[path] === path) {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tthis.queuedAssets[path] = path;\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t};\r\n\t\tSharedAssetManager.prototype.loadText = function (clientId, path) {\r\n\t\t\tvar _this = this;\r\n\t\t\tpath = this.pathPrefix + path;\r\n\t\t\tif (!this.queueAsset(clientId, null, path))\r\n\t\t\t\treturn;\r\n\t\t\tvar request = new XMLHttpRequest();\r\n\t\t\trequest.onreadystatechange = function () {\r\n\t\t\t\tif (request.readyState == XMLHttpRequest.DONE) {\r\n\t\t\t\t\tif (request.status >= 200 && request.status < 300) {\r\n\t\t\t\t\t\t_this.rawAssets[path] = request.responseText;\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\t_this.errors[path] = \"Couldn't load text \" + path + \": status \" + request.status + \", \" + request.responseText;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t\trequest.open(\"GET\", path, true);\r\n\t\t\trequest.send();\r\n\t\t};\r\n\t\tSharedAssetManager.prototype.loadJson = function (clientId, path) {\r\n\t\t\tvar _this = this;\r\n\t\t\tpath = this.pathPrefix + path;\r\n\t\t\tif (!this.queueAsset(clientId, null, path))\r\n\t\t\t\treturn;\r\n\t\t\tvar request = new XMLHttpRequest();\r\n\t\t\trequest.onreadystatechange = function () {\r\n\t\t\t\tif (request.readyState == XMLHttpRequest.DONE) {\r\n\t\t\t\t\tif (request.status >= 200 && request.status < 300) {\r\n\t\t\t\t\t\t_this.rawAssets[path] = JSON.parse(request.responseText);\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\t_this.errors[path] = \"Couldn't load text \" + path + \": status \" + request.status + \", \" + request.responseText;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t\trequest.open(\"GET\", path, true);\r\n\t\t\trequest.send();\r\n\t\t};\r\n\t\tSharedAssetManager.prototype.loadTexture = function (clientId, textureLoader, path) {\r\n\t\t\tvar _this = this;\r\n\t\t\tpath = this.pathPrefix + path;\r\n\t\t\tif (!this.queueAsset(clientId, textureLoader, path))\r\n\t\t\t\treturn;\r\n\t\t\tvar img = new Image();\r\n\t\t\timg.src = path;\r\n\t\t\timg.crossOrigin = \"anonymous\";\r\n\t\t\timg.onload = function (ev) {\r\n\t\t\t\t_this.rawAssets[path] = img;\r\n\t\t\t};\r\n\t\t\timg.onerror = function (ev) {\r\n\t\t\t\t_this.errors[path] = \"Couldn't load image \" + path;\r\n\t\t\t};\r\n\t\t};\r\n\t\tSharedAssetManager.prototype.get = function (clientId, path) {\r\n\t\t\tpath = this.pathPrefix + path;\r\n\t\t\tvar clientAssets = this.clientAssets[clientId];\r\n\t\t\tif (clientAssets === null || clientAssets === undefined)\r\n\t\t\t\treturn true;\r\n\t\t\treturn clientAssets.assets[path];\r\n\t\t};\r\n\t\tSharedAssetManager.prototype.updateClientAssets = function (clientAssets) {\r\n\t\t\tfor (var i = 0; i < clientAssets.toLoad.length; i++) {\r\n\t\t\t\tvar path = clientAssets.toLoad[i];\r\n\t\t\t\tvar asset = clientAssets.assets[path];\r\n\t\t\t\tif (asset === null || asset === undefined) {\r\n\t\t\t\t\tvar rawAsset = this.rawAssets[path];\r\n\t\t\t\t\tif (rawAsset === null || rawAsset === undefined)\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\tif (rawAsset instanceof HTMLImageElement) {\r\n\t\t\t\t\t\tclientAssets.assets[path] = clientAssets.textureLoader(rawAsset);\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tclientAssets.assets[path] = rawAsset;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\t\tSharedAssetManager.prototype.isLoadingComplete = function (clientId) {\r\n\t\t\tvar clientAssets = this.clientAssets[clientId];\r\n\t\t\tif (clientAssets === null || clientAssets === undefined)\r\n\t\t\t\treturn true;\r\n\t\t\tthis.updateClientAssets(clientAssets);\r\n\t\t\treturn clientAssets.toLoad.length == clientAssets.loaded();\r\n\t\t};\r\n\t\tSharedAssetManager.prototype.dispose = function () {\r\n\t\t};\r\n\t\tSharedAssetManager.prototype.hasErrors = function () {\r\n\t\t\treturn Object.keys(this.errors).length > 0;\r\n\t\t};\r\n\t\tSharedAssetManager.prototype.getErrors = function () {\r\n\t\t\treturn this.errors;\r\n\t\t};\r\n\t\treturn SharedAssetManager;\r\n\t}());\r\n\tspine.SharedAssetManager = SharedAssetManager;\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n\tvar Skeleton = (function () {\r\n\t\tfunction Skeleton(data) {\r\n\t\t\tthis._updateCache = new Array();\r\n\t\t\tthis.updateCacheReset = new Array();\r\n\t\t\tthis.time = 0;\r\n\t\t\tthis.flipX = false;\r\n\t\t\tthis.flipY = false;\r\n\t\t\tthis.x = 0;\r\n\t\t\tthis.y = 0;\r\n\t\t\tif (data == null)\r\n\t\t\t\tthrow new Error(\"data cannot be null.\");\r\n\t\t\tthis.data = data;\r\n\t\t\tthis.bones = new Array();\r\n\t\t\tfor (var i = 0; i < data.bones.length; i++) {\r\n\t\t\t\tvar boneData = data.bones[i];\r\n\t\t\t\tvar bone = void 0;\r\n\t\t\t\tif (boneData.parent == null)\r\n\t\t\t\t\tbone = new spine.Bone(boneData, this, null);\r\n\t\t\t\telse {\r\n\t\t\t\t\tvar parent_1 = this.bones[boneData.parent.index];\r\n\t\t\t\t\tbone = new spine.Bone(boneData, this, parent_1);\r\n\t\t\t\t\tparent_1.children.push(bone);\r\n\t\t\t\t}\r\n\t\t\t\tthis.bones.push(bone);\r\n\t\t\t}\r\n\t\t\tthis.slots = new Array();\r\n\t\t\tthis.drawOrder = new Array();\r\n\t\t\tfor (var i = 0; i < data.slots.length; i++) {\r\n\t\t\t\tvar slotData = data.slots[i];\r\n\t\t\t\tvar bone = this.bones[slotData.boneData.index];\r\n\t\t\t\tvar slot = new spine.Slot(slotData, bone);\r\n\t\t\t\tthis.slots.push(slot);\r\n\t\t\t\tthis.drawOrder.push(slot);\r\n\t\t\t}\r\n\t\t\tthis.ikConstraints = new Array();\r\n\t\t\tfor (var i = 0; i < data.ikConstraints.length; i++) {\r\n\t\t\t\tvar ikConstraintData = data.ikConstraints[i];\r\n\t\t\t\tthis.ikConstraints.push(new spine.IkConstraint(ikConstraintData, this));\r\n\t\t\t}\r\n\t\t\tthis.transformConstraints = new Array();\r\n\t\t\tfor (var i = 0; i < data.transformConstraints.length; i++) {\r\n\t\t\t\tvar transformConstraintData = data.transformConstraints[i];\r\n\t\t\t\tthis.transformConstraints.push(new spine.TransformConstraint(transformConstraintData, this));\r\n\t\t\t}\r\n\t\t\tthis.pathConstraints = new Array();\r\n\t\t\tfor (var i = 0; i < data.pathConstraints.length; i++) {\r\n\t\t\t\tvar pathConstraintData = data.pathConstraints[i];\r\n\t\t\t\tthis.pathConstraints.push(new spine.PathConstraint(pathConstraintData, this));\r\n\t\t\t}\r\n\t\t\tthis.color = new spine.Color(1, 1, 1, 1);\r\n\t\t\tthis.updateCache();\r\n\t\t}\r\n\t\tSkeleton.prototype.updateCache = function () {\r\n\t\t\tvar updateCache = this._updateCache;\r\n\t\t\tupdateCache.length = 0;\r\n\t\t\tthis.updateCacheReset.length = 0;\r\n\t\t\tvar bones = this.bones;\r\n\t\t\tfor (var i = 0, n = bones.length; i < n; i++)\r\n\t\t\t\tbones[i].sorted = false;\r\n\t\t\tvar ikConstraints = this.ikConstraints;\r\n\t\t\tvar transformConstraints = this.transformConstraints;\r\n\t\t\tvar pathConstraints = this.pathConstraints;\r\n\t\t\tvar ikCount = ikConstraints.length, transformCount = transformConstraints.length, pathCount = pathConstraints.length;\r\n\t\t\tvar constraintCount = ikCount + transformCount + pathCount;\r\n\t\t\touter: for (var i = 0; i < constraintCount; i++) {\r\n\t\t\t\tfor (var ii = 0; ii < ikCount; ii++) {\r\n\t\t\t\t\tvar constraint = ikConstraints[ii];\r\n\t\t\t\t\tif (constraint.data.order == i) {\r\n\t\t\t\t\t\tthis.sortIkConstraint(constraint);\r\n\t\t\t\t\t\tcontinue outer;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tfor (var ii = 0; ii < transformCount; ii++) {\r\n\t\t\t\t\tvar constraint = transformConstraints[ii];\r\n\t\t\t\t\tif (constraint.data.order == i) {\r\n\t\t\t\t\t\tthis.sortTransformConstraint(constraint);\r\n\t\t\t\t\t\tcontinue outer;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tfor (var ii = 0; ii < pathCount; ii++) {\r\n\t\t\t\t\tvar constraint = pathConstraints[ii];\r\n\t\t\t\t\tif (constraint.data.order == i) {\r\n\t\t\t\t\t\tthis.sortPathConstraint(constraint);\r\n\t\t\t\t\t\tcontinue outer;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tfor (var i = 0, n = bones.length; i < n; i++)\r\n\t\t\t\tthis.sortBone(bones[i]);\r\n\t\t};\r\n\t\tSkeleton.prototype.sortIkConstraint = function (constraint) {\r\n\t\t\tvar target = constraint.target;\r\n\t\t\tthis.sortBone(target);\r\n\t\t\tvar constrained = constraint.bones;\r\n\t\t\tvar parent = constrained[0];\r\n\t\t\tthis.sortBone(parent);\r\n\t\t\tif (constrained.length > 1) {\r\n\t\t\t\tvar child = constrained[constrained.length - 1];\r\n\t\t\t\tif (!(this._updateCache.indexOf(child) > -1))\r\n\t\t\t\t\tthis.updateCacheReset.push(child);\r\n\t\t\t}\r\n\t\t\tthis._updateCache.push(constraint);\r\n\t\t\tthis.sortReset(parent.children);\r\n\t\t\tconstrained[constrained.length - 1].sorted = true;\r\n\t\t};\r\n\t\tSkeleton.prototype.sortPathConstraint = function (constraint) {\r\n\t\t\tvar slot = constraint.target;\r\n\t\t\tvar slotIndex = slot.data.index;\r\n\t\t\tvar slotBone = slot.bone;\r\n\t\t\tif (this.skin != null)\r\n\t\t\t\tthis.sortPathConstraintAttachment(this.skin, slotIndex, slotBone);\r\n\t\t\tif (this.data.defaultSkin != null && this.data.defaultSkin != this.skin)\r\n\t\t\t\tthis.sortPathConstraintAttachment(this.data.defaultSkin, slotIndex, slotBone);\r\n\t\t\tfor (var i = 0, n = this.data.skins.length; i < n; i++)\r\n\t\t\t\tthis.sortPathConstraintAttachment(this.data.skins[i], slotIndex, slotBone);\r\n\t\t\tvar attachment = slot.getAttachment();\r\n\t\t\tif (attachment instanceof spine.PathAttachment)\r\n\t\t\t\tthis.sortPathConstraintAttachmentWith(attachment, slotBone);\r\n\t\t\tvar constrained = constraint.bones;\r\n\t\t\tvar boneCount = constrained.length;\r\n\t\t\tfor (var i = 0; i < boneCount; i++)\r\n\t\t\t\tthis.sortBone(constrained[i]);\r\n\t\t\tthis._updateCache.push(constraint);\r\n\t\t\tfor (var i = 0; i < boneCount; i++)\r\n\t\t\t\tthis.sortReset(constrained[i].children);\r\n\t\t\tfor (var i = 0; i < boneCount; i++)\r\n\t\t\t\tconstrained[i].sorted = true;\r\n\t\t};\r\n\t\tSkeleton.prototype.sortTransformConstraint = function (constraint) {\r\n\t\t\tthis.sortBone(constraint.target);\r\n\t\t\tvar constrained = constraint.bones;\r\n\t\t\tvar boneCount = constrained.length;\r\n\t\t\tif (constraint.data.local) {\r\n\t\t\t\tfor (var i = 0; i < boneCount; i++) {\r\n\t\t\t\t\tvar child = constrained[i];\r\n\t\t\t\t\tthis.sortBone(child.parent);\r\n\t\t\t\t\tif (!(this._updateCache.indexOf(child) > -1))\r\n\t\t\t\t\t\tthis.updateCacheReset.push(child);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tfor (var i = 0; i < boneCount; i++) {\r\n\t\t\t\t\tthis.sortBone(constrained[i]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tthis._updateCache.push(constraint);\r\n\t\t\tfor (var ii = 0; ii < boneCount; ii++)\r\n\t\t\t\tthis.sortReset(constrained[ii].children);\r\n\t\t\tfor (var ii = 0; ii < boneCount; ii++)\r\n\t\t\t\tconstrained[ii].sorted = true;\r\n\t\t};\r\n\t\tSkeleton.prototype.sortPathConstraintAttachment = function (skin, slotIndex, slotBone) {\r\n\t\t\tvar attachments = skin.attachments[slotIndex];\r\n\t\t\tif (!attachments)\r\n\t\t\t\treturn;\r\n\t\t\tfor (var key in attachments) {\r\n\t\t\t\tthis.sortPathConstraintAttachmentWith(attachments[key], slotBone);\r\n\t\t\t}\r\n\t\t};\r\n\t\tSkeleton.prototype.sortPathConstraintAttachmentWith = function (attachment, slotBone) {\r\n\t\t\tif (!(attachment instanceof spine.PathAttachment))\r\n\t\t\t\treturn;\r\n\t\t\tvar pathBones = attachment.bones;\r\n\t\t\tif (pathBones == null)\r\n\t\t\t\tthis.sortBone(slotBone);\r\n\t\t\telse {\r\n\t\t\t\tvar bones = this.bones;\r\n\t\t\t\tvar i = 0;\r\n\t\t\t\twhile (i < pathBones.length) {\r\n\t\t\t\t\tvar boneCount = pathBones[i++];\r\n\t\t\t\t\tfor (var n = i + boneCount; i < n; i++) {\r\n\t\t\t\t\t\tvar boneIndex = pathBones[i];\r\n\t\t\t\t\t\tthis.sortBone(bones[boneIndex]);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\t\tSkeleton.prototype.sortBone = function (bone) {\r\n\t\t\tif (bone.sorted)\r\n\t\t\t\treturn;\r\n\t\t\tvar parent = bone.parent;\r\n\t\t\tif (parent != null)\r\n\t\t\t\tthis.sortBone(parent);\r\n\t\t\tbone.sorted = true;\r\n\t\t\tthis._updateCache.push(bone);\r\n\t\t};\r\n\t\tSkeleton.prototype.sortReset = function (bones) {\r\n\t\t\tfor (var i = 0, n = bones.length; i < n; i++) {\r\n\t\t\t\tvar bone = bones[i];\r\n\t\t\t\tif (bone.sorted)\r\n\t\t\t\t\tthis.sortReset(bone.children);\r\n\t\t\t\tbone.sorted = false;\r\n\t\t\t}\r\n\t\t};\r\n\t\tSkeleton.prototype.updateWorldTransform = function () {\r\n\t\t\tvar updateCacheReset = this.updateCacheReset;\r\n\t\t\tfor (var i = 0, n = updateCacheReset.length; i < n; i++) {\r\n\t\t\t\tvar bone = updateCacheReset[i];\r\n\t\t\t\tbone.ax = bone.x;\r\n\t\t\t\tbone.ay = bone.y;\r\n\t\t\t\tbone.arotation = bone.rotation;\r\n\t\t\t\tbone.ascaleX = bone.scaleX;\r\n\t\t\t\tbone.ascaleY = bone.scaleY;\r\n\t\t\t\tbone.ashearX = bone.shearX;\r\n\t\t\t\tbone.ashearY = bone.shearY;\r\n\t\t\t\tbone.appliedValid = true;\r\n\t\t\t}\r\n\t\t\tvar updateCache = this._updateCache;\r\n\t\t\tfor (var i = 0, n = updateCache.length; i < n; i++)\r\n\t\t\t\tupdateCache[i].update();\r\n\t\t};\r\n\t\tSkeleton.prototype.setToSetupPose = function () {\r\n\t\t\tthis.setBonesToSetupPose();\r\n\t\t\tthis.setSlotsToSetupPose();\r\n\t\t};\r\n\t\tSkeleton.prototype.setBonesToSetupPose = function () {\r\n\t\t\tvar bones = this.bones;\r\n\t\t\tfor (var i = 0, n = bones.length; i < n; i++)\r\n\t\t\t\tbones[i].setToSetupPose();\r\n\t\t\tvar ikConstraints = this.ikConstraints;\r\n\t\t\tfor (var i = 0, n = ikConstraints.length; i < n; i++) {\r\n\t\t\t\tvar constraint = ikConstraints[i];\r\n\t\t\t\tconstraint.bendDirection = constraint.data.bendDirection;\r\n\t\t\t\tconstraint.mix = constraint.data.mix;\r\n\t\t\t}\r\n\t\t\tvar transformConstraints = this.transformConstraints;\r\n\t\t\tfor (var i = 0, n = transformConstraints.length; i < n; i++) {\r\n\t\t\t\tvar constraint = transformConstraints[i];\r\n\t\t\t\tvar data = constraint.data;\r\n\t\t\t\tconstraint.rotateMix = data.rotateMix;\r\n\t\t\t\tconstraint.translateMix = data.translateMix;\r\n\t\t\t\tconstraint.scaleMix = data.scaleMix;\r\n\t\t\t\tconstraint.shearMix = data.shearMix;\r\n\t\t\t}\r\n\t\t\tvar pathConstraints = this.pathConstraints;\r\n\t\t\tfor (var i = 0, n = pathConstraints.length; i < n; i++) {\r\n\t\t\t\tvar constraint = pathConstraints[i];\r\n\t\t\t\tvar data = constraint.data;\r\n\t\t\t\tconstraint.position = data.position;\r\n\t\t\t\tconstraint.spacing = data.spacing;\r\n\t\t\t\tconstraint.rotateMix = data.rotateMix;\r\n\t\t\t\tconstraint.translateMix = data.translateMix;\r\n\t\t\t}\r\n\t\t};\r\n\t\tSkeleton.prototype.setSlotsToSetupPose = function () {\r\n\t\t\tvar slots = this.slots;\r\n\t\t\tspine.Utils.arrayCopy(slots, 0, this.drawOrder, 0, slots.length);\r\n\t\t\tfor (var i = 0, n = slots.length; i < n; i++)\r\n\t\t\t\tslots[i].setToSetupPose();\r\n\t\t};\r\n\t\tSkeleton.prototype.getRootBone = function () {\r\n\t\t\tif (this.bones.length == 0)\r\n\t\t\t\treturn null;\r\n\t\t\treturn this.bones[0];\r\n\t\t};\r\n\t\tSkeleton.prototype.findBone = function (boneName) {\r\n\t\t\tif (boneName == null)\r\n\t\t\t\tthrow new Error(\"boneName cannot be null.\");\r\n\t\t\tvar bones = this.bones;\r\n\t\t\tfor (var i = 0, n = bones.length; i < n; i++) {\r\n\t\t\t\tvar bone = bones[i];\r\n\t\t\t\tif (bone.data.name == boneName)\r\n\t\t\t\t\treturn bone;\r\n\t\t\t}\r\n\t\t\treturn null;\r\n\t\t};\r\n\t\tSkeleton.prototype.findBoneIndex = function (boneName) {\r\n\t\t\tif (boneName == null)\r\n\t\t\t\tthrow new Error(\"boneName cannot be null.\");\r\n\t\t\tvar bones = this.bones;\r\n\t\t\tfor (var i = 0, n = bones.length; i < n; i++)\r\n\t\t\t\tif (bones[i].data.name == boneName)\r\n\t\t\t\t\treturn i;\r\n\t\t\treturn -1;\r\n\t\t};\r\n\t\tSkeleton.prototype.findSlot = function (slotName) {\r\n\t\t\tif (slotName == null)\r\n\t\t\t\tthrow new Error(\"slotName cannot be null.\");\r\n\t\t\tvar slots = this.slots;\r\n\t\t\tfor (var i = 0, n = slots.length; i < n; i++) {\r\n\t\t\t\tvar slot = slots[i];\r\n\t\t\t\tif (slot.data.name == slotName)\r\n\t\t\t\t\treturn slot;\r\n\t\t\t}\r\n\t\t\treturn null;\r\n\t\t};\r\n\t\tSkeleton.prototype.findSlotIndex = function (slotName) {\r\n\t\t\tif (slotName == null)\r\n\t\t\t\tthrow new Error(\"slotName cannot be null.\");\r\n\t\t\tvar slots = this.slots;\r\n\t\t\tfor (var i = 0, n = slots.length; i < n; i++)\r\n\t\t\t\tif (slots[i].data.name == slotName)\r\n\t\t\t\t\treturn i;\r\n\t\t\treturn -1;\r\n\t\t};\r\n\t\tSkeleton.prototype.setSkinByName = function (skinName) {\r\n\t\t\tvar skin = this.data.findSkin(skinName);\r\n\t\t\tif (skin == null)\r\n\t\t\t\tthrow new Error(\"Skin not found: \" + skinName);\r\n\t\t\tthis.setSkin(skin);\r\n\t\t};\r\n\t\tSkeleton.prototype.setSkin = function (newSkin) {\r\n\t\t\tif (newSkin != null) {\r\n\t\t\t\tif (this.skin != null)\r\n\t\t\t\t\tnewSkin.attachAll(this, this.skin);\r\n\t\t\t\telse {\r\n\t\t\t\t\tvar slots = this.slots;\r\n\t\t\t\t\tfor (var i = 0, n = slots.length; i < n; i++) {\r\n\t\t\t\t\t\tvar slot = slots[i];\r\n\t\t\t\t\t\tvar name_1 = slot.data.attachmentName;\r\n\t\t\t\t\t\tif (name_1 != null) {\r\n\t\t\t\t\t\t\tvar attachment = newSkin.getAttachment(i, name_1);\r\n\t\t\t\t\t\t\tif (attachment != null)\r\n\t\t\t\t\t\t\t\tslot.setAttachment(attachment);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tthis.skin = newSkin;\r\n\t\t};\r\n\t\tSkeleton.prototype.getAttachmentByName = function (slotName, attachmentName) {\r\n\t\t\treturn this.getAttachment(this.data.findSlotIndex(slotName), attachmentName);\r\n\t\t};\r\n\t\tSkeleton.prototype.getAttachment = function (slotIndex, attachmentName) {\r\n\t\t\tif (attachmentName == null)\r\n\t\t\t\tthrow new Error(\"attachmentName cannot be null.\");\r\n\t\t\tif (this.skin != null) {\r\n\t\t\t\tvar attachment = this.skin.getAttachment(slotIndex, attachmentName);\r\n\t\t\t\tif (attachment != null)\r\n\t\t\t\t\treturn attachment;\r\n\t\t\t}\r\n\t\t\tif (this.data.defaultSkin != null)\r\n\t\t\t\treturn this.data.defaultSkin.getAttachment(slotIndex, attachmentName);\r\n\t\t\treturn null;\r\n\t\t};\r\n\t\tSkeleton.prototype.setAttachment = function (slotName, attachmentName) {\r\n\t\t\tif (slotName == null)\r\n\t\t\t\tthrow new Error(\"slotName cannot be null.\");\r\n\t\t\tvar slots = this.slots;\r\n\t\t\tfor (var i = 0, n = slots.length; i < n; i++) {\r\n\t\t\t\tvar slot = slots[i];\r\n\t\t\t\tif (slot.data.name == slotName) {\r\n\t\t\t\t\tvar attachment = null;\r\n\t\t\t\t\tif (attachmentName != null) {\r\n\t\t\t\t\t\tattachment = this.getAttachment(i, attachmentName);\r\n\t\t\t\t\t\tif (attachment == null)\r\n\t\t\t\t\t\t\tthrow new Error(\"Attachment not found: \" + attachmentName + \", for slot: \" + slotName);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tslot.setAttachment(attachment);\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tthrow new Error(\"Slot not found: \" + slotName);\r\n\t\t};\r\n\t\tSkeleton.prototype.findIkConstraint = function (constraintName) {\r\n\t\t\tif (constraintName == null)\r\n\t\t\t\tthrow new Error(\"constraintName cannot be null.\");\r\n\t\t\tvar ikConstraints = this.ikConstraints;\r\n\t\t\tfor (var i = 0, n = ikConstraints.length; i < n; i++) {\r\n\t\t\t\tvar ikConstraint = ikConstraints[i];\r\n\t\t\t\tif (ikConstraint.data.name == constraintName)\r\n\t\t\t\t\treturn ikConstraint;\r\n\t\t\t}\r\n\t\t\treturn null;\r\n\t\t};\r\n\t\tSkeleton.prototype.findTransformConstraint = function (constraintName) {\r\n\t\t\tif (constraintName == null)\r\n\t\t\t\tthrow new Error(\"constraintName cannot be null.\");\r\n\t\t\tvar transformConstraints = this.transformConstraints;\r\n\t\t\tfor (var i = 0, n = transformConstraints.length; i < n; i++) {\r\n\t\t\t\tvar constraint = transformConstraints[i];\r\n\t\t\t\tif (constraint.data.name == constraintName)\r\n\t\t\t\t\treturn constraint;\r\n\t\t\t}\r\n\t\t\treturn null;\r\n\t\t};\r\n\t\tSkeleton.prototype.findPathConstraint = function (constraintName) {\r\n\t\t\tif (constraintName == null)\r\n\t\t\t\tthrow new Error(\"constraintName cannot be null.\");\r\n\t\t\tvar pathConstraints = this.pathConstraints;\r\n\t\t\tfor (var i = 0, n = pathConstraints.length; i < n; i++) {\r\n\t\t\t\tvar constraint = pathConstraints[i];\r\n\t\t\t\tif (constraint.data.name == constraintName)\r\n\t\t\t\t\treturn constraint;\r\n\t\t\t}\r\n\t\t\treturn null;\r\n\t\t};\r\n\t\tSkeleton.prototype.getBounds = function (offset, size, temp) {\r\n\t\t\tif (offset == null)\r\n\t\t\t\tthrow new Error(\"offset cannot be null.\");\r\n\t\t\tif (size == null)\r\n\t\t\t\tthrow new Error(\"size cannot be null.\");\r\n\t\t\tvar drawOrder = this.drawOrder;\r\n\t\t\tvar minX = Number.POSITIVE_INFINITY, minY = Number.POSITIVE_INFINITY, maxX = Number.NEGATIVE_INFINITY, maxY = Number.NEGATIVE_INFINITY;\r\n\t\t\tfor (var i = 0, n = drawOrder.length; i < n; i++) {\r\n\t\t\t\tvar slot = drawOrder[i];\r\n\t\t\t\tvar verticesLength = 0;\r\n\t\t\t\tvar vertices = null;\r\n\t\t\t\tvar attachment = slot.getAttachment();\r\n\t\t\t\tif (attachment instanceof spine.RegionAttachment) {\r\n\t\t\t\t\tverticesLength = 8;\r\n\t\t\t\t\tvertices = spine.Utils.setArraySize(temp, verticesLength, 0);\r\n\t\t\t\t\tattachment.computeWorldVertices(slot.bone, vertices, 0, 2);\r\n\t\t\t\t}\r\n\t\t\t\telse if (attachment instanceof spine.MeshAttachment) {\r\n\t\t\t\t\tvar mesh = attachment;\r\n\t\t\t\t\tverticesLength = mesh.worldVerticesLength;\r\n\t\t\t\t\tvertices = spine.Utils.setArraySize(temp, verticesLength, 0);\r\n\t\t\t\t\tmesh.computeWorldVertices(slot, 0, verticesLength, vertices, 0, 2);\r\n\t\t\t\t}\r\n\t\t\t\tif (vertices != null) {\r\n\t\t\t\t\tfor (var ii = 0, nn = vertices.length; ii < nn; ii += 2) {\r\n\t\t\t\t\t\tvar x = vertices[ii], y = vertices[ii + 1];\r\n\t\t\t\t\t\tminX = Math.min(minX, x);\r\n\t\t\t\t\t\tminY = Math.min(minY, y);\r\n\t\t\t\t\t\tmaxX = Math.max(maxX, x);\r\n\t\t\t\t\t\tmaxY = Math.max(maxY, y);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\toffset.set(minX, minY);\r\n\t\t\tsize.set(maxX - minX, maxY - minY);\r\n\t\t};\r\n\t\tSkeleton.prototype.update = function (delta) {\r\n\t\t\tthis.time += delta;\r\n\t\t};\r\n\t\treturn Skeleton;\r\n\t}());\r\n\tspine.Skeleton = Skeleton;\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n\tvar SkeletonBounds = (function () {\r\n\t\tfunction SkeletonBounds() {\r\n\t\t\tthis.minX = 0;\r\n\t\t\tthis.minY = 0;\r\n\t\t\tthis.maxX = 0;\r\n\t\t\tthis.maxY = 0;\r\n\t\t\tthis.boundingBoxes = new Array();\r\n\t\t\tthis.polygons = new Array();\r\n\t\t\tthis.polygonPool = new spine.Pool(function () {\r\n\t\t\t\treturn spine.Utils.newFloatArray(16);\r\n\t\t\t});\r\n\t\t}\r\n\t\tSkeletonBounds.prototype.update = function (skeleton, updateAabb) {\r\n\t\t\tif (skeleton == null)\r\n\t\t\t\tthrow new Error(\"skeleton cannot be null.\");\r\n\t\t\tvar boundingBoxes = this.boundingBoxes;\r\n\t\t\tvar polygons = this.polygons;\r\n\t\t\tvar polygonPool = this.polygonPool;\r\n\t\t\tvar slots = skeleton.slots;\r\n\t\t\tvar slotCount = slots.length;\r\n\t\t\tboundingBoxes.length = 0;\r\n\t\t\tpolygonPool.freeAll(polygons);\r\n\t\t\tpolygons.length = 0;\r\n\t\t\tfor (var i = 0; i < slotCount; i++) {\r\n\t\t\t\tvar slot = slots[i];\r\n\t\t\t\tvar attachment = slot.getAttachment();\r\n\t\t\t\tif (attachment instanceof spine.BoundingBoxAttachment) {\r\n\t\t\t\t\tvar boundingBox = attachment;\r\n\t\t\t\t\tboundingBoxes.push(boundingBox);\r\n\t\t\t\t\tvar polygon = polygonPool.obtain();\r\n\t\t\t\t\tif (polygon.length != boundingBox.worldVerticesLength) {\r\n\t\t\t\t\t\tpolygon = spine.Utils.newFloatArray(boundingBox.worldVerticesLength);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tpolygons.push(polygon);\r\n\t\t\t\t\tboundingBox.computeWorldVertices(slot, 0, boundingBox.worldVerticesLength, polygon, 0, 2);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (updateAabb) {\r\n\t\t\t\tthis.aabbCompute();\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tthis.minX = Number.POSITIVE_INFINITY;\r\n\t\t\t\tthis.minY = Number.POSITIVE_INFINITY;\r\n\t\t\t\tthis.maxX = Number.NEGATIVE_INFINITY;\r\n\t\t\t\tthis.maxY = Number.NEGATIVE_INFINITY;\r\n\t\t\t}\r\n\t\t};\r\n\t\tSkeletonBounds.prototype.aabbCompute = function () {\r\n\t\t\tvar minX = Number.POSITIVE_INFINITY, minY = Number.POSITIVE_INFINITY, maxX = Number.NEGATIVE_INFINITY, maxY = Number.NEGATIVE_INFINITY;\r\n\t\t\tvar polygons = this.polygons;\r\n\t\t\tfor (var i = 0, n = polygons.length; i < n; i++) {\r\n\t\t\t\tvar polygon = polygons[i];\r\n\t\t\t\tvar vertices = polygon;\r\n\t\t\t\tfor (var ii = 0, nn = polygon.length; ii < nn; ii += 2) {\r\n\t\t\t\t\tvar x = vertices[ii];\r\n\t\t\t\t\tvar y = vertices[ii + 1];\r\n\t\t\t\t\tminX = Math.min(minX, x);\r\n\t\t\t\t\tminY = Math.min(minY, y);\r\n\t\t\t\t\tmaxX = Math.max(maxX, x);\r\n\t\t\t\t\tmaxY = Math.max(maxY, y);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tthis.minX = minX;\r\n\t\t\tthis.minY = minY;\r\n\t\t\tthis.maxX = maxX;\r\n\t\t\tthis.maxY = maxY;\r\n\t\t};\r\n\t\tSkeletonBounds.prototype.aabbContainsPoint = function (x, y) {\r\n\t\t\treturn x >= this.minX && x <= this.maxX && y >= this.minY && y <= this.maxY;\r\n\t\t};\r\n\t\tSkeletonBounds.prototype.aabbIntersectsSegment = function (x1, y1, x2, y2) {\r\n\t\t\tvar minX = this.minX;\r\n\t\t\tvar minY = this.minY;\r\n\t\t\tvar maxX = this.maxX;\r\n\t\t\tvar maxY = this.maxY;\r\n\t\t\tif ((x1 <= minX && x2 <= minX) || (y1 <= minY && y2 <= minY) || (x1 >= maxX && x2 >= maxX) || (y1 >= maxY && y2 >= maxY))\r\n\t\t\t\treturn false;\r\n\t\t\tvar m = (y2 - y1) / (x2 - x1);\r\n\t\t\tvar y = m * (minX - x1) + y1;\r\n\t\t\tif (y > minY && y < maxY)\r\n\t\t\t\treturn true;\r\n\t\t\ty = m * (maxX - x1) + y1;\r\n\t\t\tif (y > minY && y < maxY)\r\n\t\t\t\treturn true;\r\n\t\t\tvar x = (minY - y1) / m + x1;\r\n\t\t\tif (x > minX && x < maxX)\r\n\t\t\t\treturn true;\r\n\t\t\tx = (maxY - y1) / m + x1;\r\n\t\t\tif (x > minX && x < maxX)\r\n\t\t\t\treturn true;\r\n\t\t\treturn false;\r\n\t\t};\r\n\t\tSkeletonBounds.prototype.aabbIntersectsSkeleton = function (bounds) {\r\n\t\t\treturn this.minX < bounds.maxX && this.maxX > bounds.minX && this.minY < bounds.maxY && this.maxY > bounds.minY;\r\n\t\t};\r\n\t\tSkeletonBounds.prototype.containsPoint = function (x, y) {\r\n\t\t\tvar polygons = this.polygons;\r\n\t\t\tfor (var i = 0, n = polygons.length; i < n; i++)\r\n\t\t\t\tif (this.containsPointPolygon(polygons[i], x, y))\r\n\t\t\t\t\treturn this.boundingBoxes[i];\r\n\t\t\treturn null;\r\n\t\t};\r\n\t\tSkeletonBounds.prototype.containsPointPolygon = function (polygon, x, y) {\r\n\t\t\tvar vertices = polygon;\r\n\t\t\tvar nn = polygon.length;\r\n\t\t\tvar prevIndex = nn - 2;\r\n\t\t\tvar inside = false;\r\n\t\t\tfor (var ii = 0; ii < nn; ii += 2) {\r\n\t\t\t\tvar vertexY = vertices[ii + 1];\r\n\t\t\t\tvar prevY = vertices[prevIndex + 1];\r\n\t\t\t\tif ((vertexY < y && prevY >= y) || (prevY < y && vertexY >= y)) {\r\n\t\t\t\t\tvar vertexX = vertices[ii];\r\n\t\t\t\t\tif (vertexX + (y - vertexY) / (prevY - vertexY) * (vertices[prevIndex] - vertexX) < x)\r\n\t\t\t\t\t\tinside = !inside;\r\n\t\t\t\t}\r\n\t\t\t\tprevIndex = ii;\r\n\t\t\t}\r\n\t\t\treturn inside;\r\n\t\t};\r\n\t\tSkeletonBounds.prototype.intersectsSegment = function (x1, y1, x2, y2) {\r\n\t\t\tvar polygons = this.polygons;\r\n\t\t\tfor (var i = 0, n = polygons.length; i < n; i++)\r\n\t\t\t\tif (this.intersectsSegmentPolygon(polygons[i], x1, y1, x2, y2))\r\n\t\t\t\t\treturn this.boundingBoxes[i];\r\n\t\t\treturn null;\r\n\t\t};\r\n\t\tSkeletonBounds.prototype.intersectsSegmentPolygon = function (polygon, x1, y1, x2, y2) {\r\n\t\t\tvar vertices = polygon;\r\n\t\t\tvar nn = polygon.length;\r\n\t\t\tvar width12 = x1 - x2, height12 = y1 - y2;\r\n\t\t\tvar det1 = x1 * y2 - y1 * x2;\r\n\t\t\tvar x3 = vertices[nn - 2], y3 = vertices[nn - 1];\r\n\t\t\tfor (var ii = 0; ii < nn; ii += 2) {\r\n\t\t\t\tvar x4 = vertices[ii], y4 = vertices[ii + 1];\r\n\t\t\t\tvar det2 = x3 * y4 - y3 * x4;\r\n\t\t\t\tvar width34 = x3 - x4, height34 = y3 - y4;\r\n\t\t\t\tvar det3 = width12 * height34 - height12 * width34;\r\n\t\t\t\tvar x = (det1 * width34 - width12 * det2) / det3;\r\n\t\t\t\tif (((x >= x3 && x <= x4) || (x >= x4 && x <= x3)) && ((x >= x1 && x <= x2) || (x >= x2 && x <= x1))) {\r\n\t\t\t\t\tvar y = (det1 * height34 - height12 * det2) / det3;\r\n\t\t\t\t\tif (((y >= y3 && y <= y4) || (y >= y4 && y <= y3)) && ((y >= y1 && y <= y2) || (y >= y2 && y <= y1)))\r\n\t\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\t\t\t\tx3 = x4;\r\n\t\t\t\ty3 = y4;\r\n\t\t\t}\r\n\t\t\treturn false;\r\n\t\t};\r\n\t\tSkeletonBounds.prototype.getPolygon = function (boundingBox) {\r\n\t\t\tif (boundingBox == null)\r\n\t\t\t\tthrow new Error(\"boundingBox cannot be null.\");\r\n\t\t\tvar index = this.boundingBoxes.indexOf(boundingBox);\r\n\t\t\treturn index == -1 ? null : this.polygons[index];\r\n\t\t};\r\n\t\tSkeletonBounds.prototype.getWidth = function () {\r\n\t\t\treturn this.maxX - this.minX;\r\n\t\t};\r\n\t\tSkeletonBounds.prototype.getHeight = function () {\r\n\t\t\treturn this.maxY - this.minY;\r\n\t\t};\r\n\t\treturn SkeletonBounds;\r\n\t}());\r\n\tspine.SkeletonBounds = SkeletonBounds;\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n\tvar SkeletonClipping = (function () {\r\n\t\tfunction SkeletonClipping() {\r\n\t\t\tthis.triangulator = new spine.Triangulator();\r\n\t\t\tthis.clippingPolygon = new Array();\r\n\t\t\tthis.clipOutput = new Array();\r\n\t\t\tthis.clippedVertices = new Array();\r\n\t\t\tthis.clippedTriangles = new Array();\r\n\t\t\tthis.scratch = new Array();\r\n\t\t}\r\n\t\tSkeletonClipping.prototype.clipStart = function (slot, clip) {\r\n\t\t\tif (this.clipAttachment != null)\r\n\t\t\t\treturn 0;\r\n\t\t\tthis.clipAttachment = clip;\r\n\t\t\tvar n = clip.worldVerticesLength;\r\n\t\t\tvar vertices = spine.Utils.setArraySize(this.clippingPolygon, n);\r\n\t\t\tclip.computeWorldVertices(slot, 0, n, vertices, 0, 2);\r\n\t\t\tvar clippingPolygon = this.clippingPolygon;\r\n\t\t\tSkeletonClipping.makeClockwise(clippingPolygon);\r\n\t\t\tvar clippingPolygons = this.clippingPolygons = this.triangulator.decompose(clippingPolygon, this.triangulator.triangulate(clippingPolygon));\r\n\t\t\tfor (var i = 0, n_1 = clippingPolygons.length; i < n_1; i++) {\r\n\t\t\t\tvar polygon = clippingPolygons[i];\r\n\t\t\t\tSkeletonClipping.makeClockwise(polygon);\r\n\t\t\t\tpolygon.push(polygon[0]);\r\n\t\t\t\tpolygon.push(polygon[1]);\r\n\t\t\t}\r\n\t\t\treturn clippingPolygons.length;\r\n\t\t};\r\n\t\tSkeletonClipping.prototype.clipEndWithSlot = function (slot) {\r\n\t\t\tif (this.clipAttachment != null && this.clipAttachment.endSlot == slot.data)\r\n\t\t\t\tthis.clipEnd();\r\n\t\t};\r\n\t\tSkeletonClipping.prototype.clipEnd = function () {\r\n\t\t\tif (this.clipAttachment == null)\r\n\t\t\t\treturn;\r\n\t\t\tthis.clipAttachment = null;\r\n\t\t\tthis.clippingPolygons = null;\r\n\t\t\tthis.clippedVertices.length = 0;\r\n\t\t\tthis.clippedTriangles.length = 0;\r\n\t\t\tthis.clippingPolygon.length = 0;\r\n\t\t};\r\n\t\tSkeletonClipping.prototype.isClipping = function () {\r\n\t\t\treturn this.clipAttachment != null;\r\n\t\t};\r\n\t\tSkeletonClipping.prototype.clipTriangles = function (vertices, verticesLength, triangles, trianglesLength, uvs, light, dark, twoColor) {\r\n\t\t\tvar clipOutput = this.clipOutput, clippedVertices = this.clippedVertices;\r\n\t\t\tvar clippedTriangles = this.clippedTriangles;\r\n\t\t\tvar polygons = this.clippingPolygons;\r\n\t\t\tvar polygonsCount = this.clippingPolygons.length;\r\n\t\t\tvar vertexSize = twoColor ? 12 : 8;\r\n\t\t\tvar index = 0;\r\n\t\t\tclippedVertices.length = 0;\r\n\t\t\tclippedTriangles.length = 0;\r\n\t\t\touter: for (var i = 0; i < trianglesLength; i += 3) {\r\n\t\t\t\tvar vertexOffset = triangles[i] << 1;\r\n\t\t\t\tvar x1 = vertices[vertexOffset], y1 = vertices[vertexOffset + 1];\r\n\t\t\t\tvar u1 = uvs[vertexOffset], v1 = uvs[vertexOffset + 1];\r\n\t\t\t\tvertexOffset = triangles[i + 1] << 1;\r\n\t\t\t\tvar x2 = vertices[vertexOffset], y2 = vertices[vertexOffset + 1];\r\n\t\t\t\tvar u2 = uvs[vertexOffset], v2 = uvs[vertexOffset + 1];\r\n\t\t\t\tvertexOffset = triangles[i + 2] << 1;\r\n\t\t\t\tvar x3 = vertices[vertexOffset], y3 = vertices[vertexOffset + 1];\r\n\t\t\t\tvar u3 = uvs[vertexOffset], v3 = uvs[vertexOffset + 1];\r\n\t\t\t\tfor (var p = 0; p < polygonsCount; p++) {\r\n\t\t\t\t\tvar s = clippedVertices.length;\r\n\t\t\t\t\tif (this.clip(x1, y1, x2, y2, x3, y3, polygons[p], clipOutput)) {\r\n\t\t\t\t\t\tvar clipOutputLength = clipOutput.length;\r\n\t\t\t\t\t\tif (clipOutputLength == 0)\r\n\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\tvar d0 = y2 - y3, d1 = x3 - x2, d2 = x1 - x3, d4 = y3 - y1;\r\n\t\t\t\t\t\tvar d = 1 / (d0 * d2 + d1 * (y1 - y3));\r\n\t\t\t\t\t\tvar clipOutputCount = clipOutputLength >> 1;\r\n\t\t\t\t\t\tvar clipOutputItems = this.clipOutput;\r\n\t\t\t\t\t\tvar clippedVerticesItems = spine.Utils.setArraySize(clippedVertices, s + clipOutputCount * vertexSize);\r\n\t\t\t\t\t\tfor (var ii = 0; ii < clipOutputLength; ii += 2) {\r\n\t\t\t\t\t\t\tvar x = clipOutputItems[ii], y = clipOutputItems[ii + 1];\r\n\t\t\t\t\t\t\tclippedVerticesItems[s] = x;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 1] = y;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 2] = light.r;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 3] = light.g;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 4] = light.b;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 5] = light.a;\r\n\t\t\t\t\t\t\tvar c0 = x - x3, c1 = y - y3;\r\n\t\t\t\t\t\t\tvar a = (d0 * c0 + d1 * c1) * d;\r\n\t\t\t\t\t\t\tvar b = (d4 * c0 + d2 * c1) * d;\r\n\t\t\t\t\t\t\tvar c = 1 - a - b;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 6] = u1 * a + u2 * b + u3 * c;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 7] = v1 * a + v2 * b + v3 * c;\r\n\t\t\t\t\t\t\tif (twoColor) {\r\n\t\t\t\t\t\t\t\tclippedVerticesItems[s + 8] = dark.r;\r\n\t\t\t\t\t\t\t\tclippedVerticesItems[s + 9] = dark.g;\r\n\t\t\t\t\t\t\t\tclippedVerticesItems[s + 10] = dark.b;\r\n\t\t\t\t\t\t\t\tclippedVerticesItems[s + 11] = dark.a;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\ts += vertexSize;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\ts = clippedTriangles.length;\r\n\t\t\t\t\t\tvar clippedTrianglesItems = spine.Utils.setArraySize(clippedTriangles, s + 3 * (clipOutputCount - 2));\r\n\t\t\t\t\t\tclipOutputCount--;\r\n\t\t\t\t\t\tfor (var ii = 1; ii < clipOutputCount; ii++) {\r\n\t\t\t\t\t\t\tclippedTrianglesItems[s] = index;\r\n\t\t\t\t\t\t\tclippedTrianglesItems[s + 1] = (index + ii);\r\n\t\t\t\t\t\t\tclippedTrianglesItems[s + 2] = (index + ii + 1);\r\n\t\t\t\t\t\t\ts += 3;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tindex += clipOutputCount + 1;\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tvar clippedVerticesItems = spine.Utils.setArraySize(clippedVertices, s + 3 * vertexSize);\r\n\t\t\t\t\t\tclippedVerticesItems[s] = x1;\r\n\t\t\t\t\t\tclippedVerticesItems[s + 1] = y1;\r\n\t\t\t\t\t\tclippedVerticesItems[s + 2] = light.r;\r\n\t\t\t\t\t\tclippedVerticesItems[s + 3] = light.g;\r\n\t\t\t\t\t\tclippedVerticesItems[s + 4] = light.b;\r\n\t\t\t\t\t\tclippedVerticesItems[s + 5] = light.a;\r\n\t\t\t\t\t\tif (!twoColor) {\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 6] = u1;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 7] = v1;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 8] = x2;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 9] = y2;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 10] = light.r;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 11] = light.g;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 12] = light.b;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 13] = light.a;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 14] = u2;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 15] = v2;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 16] = x3;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 17] = y3;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 18] = light.r;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 19] = light.g;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 20] = light.b;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 21] = light.a;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 22] = u3;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 23] = v3;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 6] = u1;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 7] = v1;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 8] = dark.r;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 9] = dark.g;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 10] = dark.b;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 11] = dark.a;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 12] = x2;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 13] = y2;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 14] = light.r;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 15] = light.g;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 16] = light.b;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 17] = light.a;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 18] = u2;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 19] = v2;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 20] = dark.r;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 21] = dark.g;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 22] = dark.b;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 23] = dark.a;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 24] = x3;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 25] = y3;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 26] = light.r;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 27] = light.g;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 28] = light.b;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 29] = light.a;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 30] = u3;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 31] = v3;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 32] = dark.r;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 33] = dark.g;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 34] = dark.b;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 35] = dark.a;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\ts = clippedTriangles.length;\r\n\t\t\t\t\t\tvar clippedTrianglesItems = spine.Utils.setArraySize(clippedTriangles, s + 3);\r\n\t\t\t\t\t\tclippedTrianglesItems[s] = index;\r\n\t\t\t\t\t\tclippedTrianglesItems[s + 1] = (index + 1);\r\n\t\t\t\t\t\tclippedTrianglesItems[s + 2] = (index + 2);\r\n\t\t\t\t\t\tindex += 3;\r\n\t\t\t\t\t\tcontinue outer;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\t\tSkeletonClipping.prototype.clip = function (x1, y1, x2, y2, x3, y3, clippingArea, output) {\r\n\t\t\tvar originalOutput = output;\r\n\t\t\tvar clipped = false;\r\n\t\t\tvar input = null;\r\n\t\t\tif (clippingArea.length % 4 >= 2) {\r\n\t\t\t\tinput = output;\r\n\t\t\t\toutput = this.scratch;\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t\tinput = this.scratch;\r\n\t\t\tinput.length = 0;\r\n\t\t\tinput.push(x1);\r\n\t\t\tinput.push(y1);\r\n\t\t\tinput.push(x2);\r\n\t\t\tinput.push(y2);\r\n\t\t\tinput.push(x3);\r\n\t\t\tinput.push(y3);\r\n\t\t\tinput.push(x1);\r\n\t\t\tinput.push(y1);\r\n\t\t\toutput.length = 0;\r\n\t\t\tvar clippingVertices = clippingArea;\r\n\t\t\tvar clippingVerticesLast = clippingArea.length - 4;\r\n\t\t\tfor (var i = 0;; i += 2) {\r\n\t\t\t\tvar edgeX = clippingVertices[i], edgeY = clippingVertices[i + 1];\r\n\t\t\t\tvar edgeX2 = clippingVertices[i + 2], edgeY2 = clippingVertices[i + 3];\r\n\t\t\t\tvar deltaX = edgeX - edgeX2, deltaY = edgeY - edgeY2;\r\n\t\t\t\tvar inputVertices = input;\r\n\t\t\t\tvar inputVerticesLength = input.length - 2, outputStart = output.length;\r\n\t\t\t\tfor (var ii = 0; ii < inputVerticesLength; ii += 2) {\r\n\t\t\t\t\tvar inputX = inputVertices[ii], inputY = inputVertices[ii + 1];\r\n\t\t\t\t\tvar inputX2 = inputVertices[ii + 2], inputY2 = inputVertices[ii + 3];\r\n\t\t\t\t\tvar side2 = deltaX * (inputY2 - edgeY2) - deltaY * (inputX2 - edgeX2) > 0;\r\n\t\t\t\t\tif (deltaX * (inputY - edgeY2) - deltaY * (inputX - edgeX2) > 0) {\r\n\t\t\t\t\t\tif (side2) {\r\n\t\t\t\t\t\t\toutput.push(inputX2);\r\n\t\t\t\t\t\t\toutput.push(inputY2);\r\n\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tvar c0 = inputY2 - inputY, c2 = inputX2 - inputX;\r\n\t\t\t\t\t\tvar ua = (c2 * (edgeY - inputY) - c0 * (edgeX - inputX)) / (c0 * (edgeX2 - edgeX) - c2 * (edgeY2 - edgeY));\r\n\t\t\t\t\t\toutput.push(edgeX + (edgeX2 - edgeX) * ua);\r\n\t\t\t\t\t\toutput.push(edgeY + (edgeY2 - edgeY) * ua);\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse if (side2) {\r\n\t\t\t\t\t\tvar c0 = inputY2 - inputY, c2 = inputX2 - inputX;\r\n\t\t\t\t\t\tvar ua = (c2 * (edgeY - inputY) - c0 * (edgeX - inputX)) / (c0 * (edgeX2 - edgeX) - c2 * (edgeY2 - edgeY));\r\n\t\t\t\t\t\toutput.push(edgeX + (edgeX2 - edgeX) * ua);\r\n\t\t\t\t\t\toutput.push(edgeY + (edgeY2 - edgeY) * ua);\r\n\t\t\t\t\t\toutput.push(inputX2);\r\n\t\t\t\t\t\toutput.push(inputY2);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tclipped = true;\r\n\t\t\t\t}\r\n\t\t\t\tif (outputStart == output.length) {\r\n\t\t\t\t\toriginalOutput.length = 0;\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\t\t\t\toutput.push(output[0]);\r\n\t\t\t\toutput.push(output[1]);\r\n\t\t\t\tif (i == clippingVerticesLast)\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tvar temp = output;\r\n\t\t\t\toutput = input;\r\n\t\t\t\toutput.length = 0;\r\n\t\t\t\tinput = temp;\r\n\t\t\t}\r\n\t\t\tif (originalOutput != output) {\r\n\t\t\t\toriginalOutput.length = 0;\r\n\t\t\t\tfor (var i = 0, n = output.length - 2; i < n; i++)\r\n\t\t\t\t\toriginalOutput[i] = output[i];\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t\toriginalOutput.length = originalOutput.length - 2;\r\n\t\t\treturn clipped;\r\n\t\t};\r\n\t\tSkeletonClipping.makeClockwise = function (polygon) {\r\n\t\t\tvar vertices = polygon;\r\n\t\t\tvar verticeslength = polygon.length;\r\n\t\t\tvar area = vertices[verticeslength - 2] * vertices[1] - vertices[0] * vertices[verticeslength - 1], p1x = 0, p1y = 0, p2x = 0, p2y = 0;\r\n\t\t\tfor (var i = 0, n = verticeslength - 3; i < n; i += 2) {\r\n\t\t\t\tp1x = vertices[i];\r\n\t\t\t\tp1y = vertices[i + 1];\r\n\t\t\t\tp2x = vertices[i + 2];\r\n\t\t\t\tp2y = vertices[i + 3];\r\n\t\t\t\tarea += p1x * p2y - p2x * p1y;\r\n\t\t\t}\r\n\t\t\tif (area < 0)\r\n\t\t\t\treturn;\r\n\t\t\tfor (var i = 0, lastX = verticeslength - 2, n = verticeslength >> 1; i < n; i += 2) {\r\n\t\t\t\tvar x = vertices[i], y = vertices[i + 1];\r\n\t\t\t\tvar other = lastX - i;\r\n\t\t\t\tvertices[i] = vertices[other];\r\n\t\t\t\tvertices[i + 1] = vertices[other + 1];\r\n\t\t\t\tvertices[other] = x;\r\n\t\t\t\tvertices[other + 1] = y;\r\n\t\t\t}\r\n\t\t};\r\n\t\treturn SkeletonClipping;\r\n\t}());\r\n\tspine.SkeletonClipping = SkeletonClipping;\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n\tvar SkeletonData = (function () {\r\n\t\tfunction SkeletonData() {\r\n\t\t\tthis.bones = new Array();\r\n\t\t\tthis.slots = new Array();\r\n\t\t\tthis.skins = new Array();\r\n\t\t\tthis.events = new Array();\r\n\t\t\tthis.animations = new Array();\r\n\t\t\tthis.ikConstraints = new Array();\r\n\t\t\tthis.transformConstraints = new Array();\r\n\t\t\tthis.pathConstraints = new Array();\r\n\t\t\tthis.fps = 0;\r\n\t\t}\r\n\t\tSkeletonData.prototype.findBone = function (boneName) {\r\n\t\t\tif (boneName == null)\r\n\t\t\t\tthrow new Error(\"boneName cannot be null.\");\r\n\t\t\tvar bones = this.bones;\r\n\t\t\tfor (var i = 0, n = bones.length; i < n; i++) {\r\n\t\t\t\tvar bone = bones[i];\r\n\t\t\t\tif (bone.name == boneName)\r\n\t\t\t\t\treturn bone;\r\n\t\t\t}\r\n\t\t\treturn null;\r\n\t\t};\r\n\t\tSkeletonData.prototype.findBoneIndex = function (boneName) {\r\n\t\t\tif (boneName == null)\r\n\t\t\t\tthrow new Error(\"boneName cannot be null.\");\r\n\t\t\tvar bones = this.bones;\r\n\t\t\tfor (var i = 0, n = bones.length; i < n; i++)\r\n\t\t\t\tif (bones[i].name == boneName)\r\n\t\t\t\t\treturn i;\r\n\t\t\treturn -1;\r\n\t\t};\r\n\t\tSkeletonData.prototype.findSlot = function (slotName) {\r\n\t\t\tif (slotName == null)\r\n\t\t\t\tthrow new Error(\"slotName cannot be null.\");\r\n\t\t\tvar slots = this.slots;\r\n\t\t\tfor (var i = 0, n = slots.length; i < n; i++) {\r\n\t\t\t\tvar slot = slots[i];\r\n\t\t\t\tif (slot.name == slotName)\r\n\t\t\t\t\treturn slot;\r\n\t\t\t}\r\n\t\t\treturn null;\r\n\t\t};\r\n\t\tSkeletonData.prototype.findSlotIndex = function (slotName) {\r\n\t\t\tif (slotName == null)\r\n\t\t\t\tthrow new Error(\"slotName cannot be null.\");\r\n\t\t\tvar slots = this.slots;\r\n\t\t\tfor (var i = 0, n = slots.length; i < n; i++)\r\n\t\t\t\tif (slots[i].name == slotName)\r\n\t\t\t\t\treturn i;\r\n\t\t\treturn -1;\r\n\t\t};\r\n\t\tSkeletonData.prototype.findSkin = function (skinName) {\r\n\t\t\tif (skinName == null)\r\n\t\t\t\tthrow new Error(\"skinName cannot be null.\");\r\n\t\t\tvar skins = this.skins;\r\n\t\t\tfor (var i = 0, n = skins.length; i < n; i++) {\r\n\t\t\t\tvar skin = skins[i];\r\n\t\t\t\tif (skin.name == skinName)\r\n\t\t\t\t\treturn skin;\r\n\t\t\t}\r\n\t\t\treturn null;\r\n\t\t};\r\n\t\tSkeletonData.prototype.findEvent = function (eventDataName) {\r\n\t\t\tif (eventDataName == null)\r\n\t\t\t\tthrow new Error(\"eventDataName cannot be null.\");\r\n\t\t\tvar events = this.events;\r\n\t\t\tfor (var i = 0, n = events.length; i < n; i++) {\r\n\t\t\t\tvar event_4 = events[i];\r\n\t\t\t\tif (event_4.name == eventDataName)\r\n\t\t\t\t\treturn event_4;\r\n\t\t\t}\r\n\t\t\treturn null;\r\n\t\t};\r\n\t\tSkeletonData.prototype.findAnimation = function (animationName) {\r\n\t\t\tif (animationName == null)\r\n\t\t\t\tthrow new Error(\"animationName cannot be null.\");\r\n\t\t\tvar animations = this.animations;\r\n\t\t\tfor (var i = 0, n = animations.length; i < n; i++) {\r\n\t\t\t\tvar animation = animations[i];\r\n\t\t\t\tif (animation.name == animationName)\r\n\t\t\t\t\treturn animation;\r\n\t\t\t}\r\n\t\t\treturn null;\r\n\t\t};\r\n\t\tSkeletonData.prototype.findIkConstraint = function (constraintName) {\r\n\t\t\tif (constraintName == null)\r\n\t\t\t\tthrow new Error(\"constraintName cannot be null.\");\r\n\t\t\tvar ikConstraints = this.ikConstraints;\r\n\t\t\tfor (var i = 0, n = ikConstraints.length; i < n; i++) {\r\n\t\t\t\tvar constraint = ikConstraints[i];\r\n\t\t\t\tif (constraint.name == constraintName)\r\n\t\t\t\t\treturn constraint;\r\n\t\t\t}\r\n\t\t\treturn null;\r\n\t\t};\r\n\t\tSkeletonData.prototype.findTransformConstraint = function (constraintName) {\r\n\t\t\tif (constraintName == null)\r\n\t\t\t\tthrow new Error(\"constraintName cannot be null.\");\r\n\t\t\tvar transformConstraints = this.transformConstraints;\r\n\t\t\tfor (var i = 0, n = transformConstraints.length; i < n; i++) {\r\n\t\t\t\tvar constraint = transformConstraints[i];\r\n\t\t\t\tif (constraint.name == constraintName)\r\n\t\t\t\t\treturn constraint;\r\n\t\t\t}\r\n\t\t\treturn null;\r\n\t\t};\r\n\t\tSkeletonData.prototype.findPathConstraint = function (constraintName) {\r\n\t\t\tif (constraintName == null)\r\n\t\t\t\tthrow new Error(\"constraintName cannot be null.\");\r\n\t\t\tvar pathConstraints = this.pathConstraints;\r\n\t\t\tfor (var i = 0, n = pathConstraints.length; i < n; i++) {\r\n\t\t\t\tvar constraint = pathConstraints[i];\r\n\t\t\t\tif (constraint.name == constraintName)\r\n\t\t\t\t\treturn constraint;\r\n\t\t\t}\r\n\t\t\treturn null;\r\n\t\t};\r\n\t\tSkeletonData.prototype.findPathConstraintIndex = function (pathConstraintName) {\r\n\t\t\tif (pathConstraintName == null)\r\n\t\t\t\tthrow new Error(\"pathConstraintName cannot be null.\");\r\n\t\t\tvar pathConstraints = this.pathConstraints;\r\n\t\t\tfor (var i = 0, n = pathConstraints.length; i < n; i++)\r\n\t\t\t\tif (pathConstraints[i].name == pathConstraintName)\r\n\t\t\t\t\treturn i;\r\n\t\t\treturn -1;\r\n\t\t};\r\n\t\treturn SkeletonData;\r\n\t}());\r\n\tspine.SkeletonData = SkeletonData;\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n\tvar SkeletonJson = (function () {\r\n\t\tfunction SkeletonJson(attachmentLoader) {\r\n\t\t\tthis.scale = 1;\r\n\t\t\tthis.linkedMeshes = new Array();\r\n\t\t\tthis.attachmentLoader = attachmentLoader;\r\n\t\t}\r\n\t\tSkeletonJson.prototype.readSkeletonData = function (json) {\r\n\t\t\tvar scale = this.scale;\r\n\t\t\tvar skeletonData = new spine.SkeletonData();\r\n\t\t\tvar root = typeof (json) === \"string\" ? JSON.parse(json) : json;\r\n\t\t\tvar skeletonMap = root.skeleton;\r\n\t\t\tif (skeletonMap != null) {\r\n\t\t\t\tskeletonData.hash = skeletonMap.hash;\r\n\t\t\t\tskeletonData.version = skeletonMap.spine;\r\n\t\t\t\tskeletonData.width = skeletonMap.width;\r\n\t\t\t\tskeletonData.height = skeletonMap.height;\r\n\t\t\t\tskeletonData.fps = skeletonMap.fps;\r\n\t\t\t\tskeletonData.imagesPath = skeletonMap.images;\r\n\t\t\t}\r\n\t\t\tif (root.bones) {\r\n\t\t\t\tfor (var i = 0; i < root.bones.length; i++) {\r\n\t\t\t\t\tvar boneMap = root.bones[i];\r\n\t\t\t\t\tvar parent_2 = null;\r\n\t\t\t\t\tvar parentName = this.getValue(boneMap, \"parent\", null);\r\n\t\t\t\t\tif (parentName != null) {\r\n\t\t\t\t\t\tparent_2 = skeletonData.findBone(parentName);\r\n\t\t\t\t\t\tif (parent_2 == null)\r\n\t\t\t\t\t\t\tthrow new Error(\"Parent bone not found: \" + parentName);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tvar data = new spine.BoneData(skeletonData.bones.length, boneMap.name, parent_2);\r\n\t\t\t\t\tdata.length = this.getValue(boneMap, \"length\", 0) * scale;\r\n\t\t\t\t\tdata.x = this.getValue(boneMap, \"x\", 0) * scale;\r\n\t\t\t\t\tdata.y = this.getValue(boneMap, \"y\", 0) * scale;\r\n\t\t\t\t\tdata.rotation = this.getValue(boneMap, \"rotation\", 0);\r\n\t\t\t\t\tdata.scaleX = this.getValue(boneMap, \"scaleX\", 1);\r\n\t\t\t\t\tdata.scaleY = this.getValue(boneMap, \"scaleY\", 1);\r\n\t\t\t\t\tdata.shearX = this.getValue(boneMap, \"shearX\", 0);\r\n\t\t\t\t\tdata.shearY = this.getValue(boneMap, \"shearY\", 0);\r\n\t\t\t\t\tdata.transformMode = SkeletonJson.transformModeFromString(this.getValue(boneMap, \"transform\", \"normal\"));\r\n\t\t\t\t\tskeletonData.bones.push(data);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (root.slots) {\r\n\t\t\t\tfor (var i = 0; i < root.slots.length; i++) {\r\n\t\t\t\t\tvar slotMap = root.slots[i];\r\n\t\t\t\t\tvar slotName = slotMap.name;\r\n\t\t\t\t\tvar boneName = slotMap.bone;\r\n\t\t\t\t\tvar boneData = skeletonData.findBone(boneName);\r\n\t\t\t\t\tif (boneData == null)\r\n\t\t\t\t\t\tthrow new Error(\"Slot bone not found: \" + boneName);\r\n\t\t\t\t\tvar data = new spine.SlotData(skeletonData.slots.length, slotName, boneData);\r\n\t\t\t\t\tvar color = this.getValue(slotMap, \"color\", null);\r\n\t\t\t\t\tif (color != null)\r\n\t\t\t\t\t\tdata.color.setFromString(color);\r\n\t\t\t\t\tvar dark = this.getValue(slotMap, \"dark\", null);\r\n\t\t\t\t\tif (dark != null) {\r\n\t\t\t\t\t\tdata.darkColor = new spine.Color(1, 1, 1, 1);\r\n\t\t\t\t\t\tdata.darkColor.setFromString(dark);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tdata.attachmentName = this.getValue(slotMap, \"attachment\", null);\r\n\t\t\t\t\tdata.blendMode = SkeletonJson.blendModeFromString(this.getValue(slotMap, \"blend\", \"normal\"));\r\n\t\t\t\t\tskeletonData.slots.push(data);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (root.ik) {\r\n\t\t\t\tfor (var i = 0; i < root.ik.length; i++) {\r\n\t\t\t\t\tvar constraintMap = root.ik[i];\r\n\t\t\t\t\tvar data = new spine.IkConstraintData(constraintMap.name);\r\n\t\t\t\t\tdata.order = this.getValue(constraintMap, \"order\", 0);\r\n\t\t\t\t\tfor (var j = 0; j < constraintMap.bones.length; j++) {\r\n\t\t\t\t\t\tvar boneName = constraintMap.bones[j];\r\n\t\t\t\t\t\tvar bone = skeletonData.findBone(boneName);\r\n\t\t\t\t\t\tif (bone == null)\r\n\t\t\t\t\t\t\tthrow new Error(\"IK bone not found: \" + boneName);\r\n\t\t\t\t\t\tdata.bones.push(bone);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tvar targetName = constraintMap.target;\r\n\t\t\t\t\tdata.target = skeletonData.findBone(targetName);\r\n\t\t\t\t\tif (data.target == null)\r\n\t\t\t\t\t\tthrow new Error(\"IK target bone not found: \" + targetName);\r\n\t\t\t\t\tdata.bendDirection = this.getValue(constraintMap, \"bendPositive\", true) ? 1 : -1;\r\n\t\t\t\t\tdata.mix = this.getValue(constraintMap, \"mix\", 1);\r\n\t\t\t\t\tskeletonData.ikConstraints.push(data);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (root.transform) {\r\n\t\t\t\tfor (var i = 0; i < root.transform.length; i++) {\r\n\t\t\t\t\tvar constraintMap = root.transform[i];\r\n\t\t\t\t\tvar data = new spine.TransformConstraintData(constraintMap.name);\r\n\t\t\t\t\tdata.order = this.getValue(constraintMap, \"order\", 0);\r\n\t\t\t\t\tfor (var j = 0; j < constraintMap.bones.length; j++) {\r\n\t\t\t\t\t\tvar boneName = constraintMap.bones[j];\r\n\t\t\t\t\t\tvar bone = skeletonData.findBone(boneName);\r\n\t\t\t\t\t\tif (bone == null)\r\n\t\t\t\t\t\t\tthrow new Error(\"Transform constraint bone not found: \" + boneName);\r\n\t\t\t\t\t\tdata.bones.push(bone);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tvar targetName = constraintMap.target;\r\n\t\t\t\t\tdata.target = skeletonData.findBone(targetName);\r\n\t\t\t\t\tif (data.target == null)\r\n\t\t\t\t\t\tthrow new Error(\"Transform constraint target bone not found: \" + targetName);\r\n\t\t\t\t\tdata.local = this.getValue(constraintMap, \"local\", false);\r\n\t\t\t\t\tdata.relative = this.getValue(constraintMap, \"relative\", false);\r\n\t\t\t\t\tdata.offsetRotation = this.getValue(constraintMap, \"rotation\", 0);\r\n\t\t\t\t\tdata.offsetX = this.getValue(constraintMap, \"x\", 0) * scale;\r\n\t\t\t\t\tdata.offsetY = this.getValue(constraintMap, \"y\", 0) * scale;\r\n\t\t\t\t\tdata.offsetScaleX = this.getValue(constraintMap, \"scaleX\", 0);\r\n\t\t\t\t\tdata.offsetScaleY = this.getValue(constraintMap, \"scaleY\", 0);\r\n\t\t\t\t\tdata.offsetShearY = this.getValue(constraintMap, \"shearY\", 0);\r\n\t\t\t\t\tdata.rotateMix = this.getValue(constraintMap, \"rotateMix\", 1);\r\n\t\t\t\t\tdata.translateMix = this.getValue(constraintMap, \"translateMix\", 1);\r\n\t\t\t\t\tdata.scaleMix = this.getValue(constraintMap, \"scaleMix\", 1);\r\n\t\t\t\t\tdata.shearMix = this.getValue(constraintMap, \"shearMix\", 1);\r\n\t\t\t\t\tskeletonData.transformConstraints.push(data);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (root.path) {\r\n\t\t\t\tfor (var i = 0; i < root.path.length; i++) {\r\n\t\t\t\t\tvar constraintMap = root.path[i];\r\n\t\t\t\t\tvar data = new spine.PathConstraintData(constraintMap.name);\r\n\t\t\t\t\tdata.order = this.getValue(constraintMap, \"order\", 0);\r\n\t\t\t\t\tfor (var j = 0; j < constraintMap.bones.length; j++) {\r\n\t\t\t\t\t\tvar boneName = constraintMap.bones[j];\r\n\t\t\t\t\t\tvar bone = skeletonData.findBone(boneName);\r\n\t\t\t\t\t\tif (bone == null)\r\n\t\t\t\t\t\t\tthrow new Error(\"Transform constraint bone not found: \" + boneName);\r\n\t\t\t\t\t\tdata.bones.push(bone);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tvar targetName = constraintMap.target;\r\n\t\t\t\t\tdata.target = skeletonData.findSlot(targetName);\r\n\t\t\t\t\tif (data.target == null)\r\n\t\t\t\t\t\tthrow new Error(\"Path target slot not found: \" + targetName);\r\n\t\t\t\t\tdata.positionMode = SkeletonJson.positionModeFromString(this.getValue(constraintMap, \"positionMode\", \"percent\"));\r\n\t\t\t\t\tdata.spacingMode = SkeletonJson.spacingModeFromString(this.getValue(constraintMap, \"spacingMode\", \"length\"));\r\n\t\t\t\t\tdata.rotateMode = SkeletonJson.rotateModeFromString(this.getValue(constraintMap, \"rotateMode\", \"tangent\"));\r\n\t\t\t\t\tdata.offsetRotation = this.getValue(constraintMap, \"rotation\", 0);\r\n\t\t\t\t\tdata.position = this.getValue(constraintMap, \"position\", 0);\r\n\t\t\t\t\tif (data.positionMode == spine.PositionMode.Fixed)\r\n\t\t\t\t\t\tdata.position *= scale;\r\n\t\t\t\t\tdata.spacing = this.getValue(constraintMap, \"spacing\", 0);\r\n\t\t\t\t\tif (data.spacingMode == spine.SpacingMode.Length || data.spacingMode == spine.SpacingMode.Fixed)\r\n\t\t\t\t\t\tdata.spacing *= scale;\r\n\t\t\t\t\tdata.rotateMix = this.getValue(constraintMap, \"rotateMix\", 1);\r\n\t\t\t\t\tdata.translateMix = this.getValue(constraintMap, \"translateMix\", 1);\r\n\t\t\t\t\tskeletonData.pathConstraints.push(data);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (root.skins) {\r\n\t\t\t\tfor (var skinName in root.skins) {\r\n\t\t\t\t\tvar skinMap = root.skins[skinName];\r\n\t\t\t\t\tvar skin = new spine.Skin(skinName);\r\n\t\t\t\t\tfor (var slotName in skinMap) {\r\n\t\t\t\t\t\tvar slotIndex = skeletonData.findSlotIndex(slotName);\r\n\t\t\t\t\t\tif (slotIndex == -1)\r\n\t\t\t\t\t\t\tthrow new Error(\"Slot not found: \" + slotName);\r\n\t\t\t\t\t\tvar slotMap = skinMap[slotName];\r\n\t\t\t\t\t\tfor (var entryName in slotMap) {\r\n\t\t\t\t\t\t\tvar attachment = this.readAttachment(slotMap[entryName], skin, slotIndex, entryName, skeletonData);\r\n\t\t\t\t\t\t\tif (attachment != null)\r\n\t\t\t\t\t\t\t\tskin.addAttachment(slotIndex, entryName, attachment);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tskeletonData.skins.push(skin);\r\n\t\t\t\t\tif (skin.name == \"default\")\r\n\t\t\t\t\t\tskeletonData.defaultSkin = skin;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tfor (var i = 0, n = this.linkedMeshes.length; i < n; i++) {\r\n\t\t\t\tvar linkedMesh = this.linkedMeshes[i];\r\n\t\t\t\tvar skin = linkedMesh.skin == null ? skeletonData.defaultSkin : skeletonData.findSkin(linkedMesh.skin);\r\n\t\t\t\tif (skin == null)\r\n\t\t\t\t\tthrow new Error(\"Skin not found: \" + linkedMesh.skin);\r\n\t\t\t\tvar parent_3 = skin.getAttachment(linkedMesh.slotIndex, linkedMesh.parent);\r\n\t\t\t\tif (parent_3 == null)\r\n\t\t\t\t\tthrow new Error(\"Parent mesh not found: \" + linkedMesh.parent);\r\n\t\t\t\tlinkedMesh.mesh.setParentMesh(parent_3);\r\n\t\t\t\tlinkedMesh.mesh.updateUVs();\r\n\t\t\t}\r\n\t\t\tthis.linkedMeshes.length = 0;\r\n\t\t\tif (root.events) {\r\n\t\t\t\tfor (var eventName in root.events) {\r\n\t\t\t\t\tvar eventMap = root.events[eventName];\r\n\t\t\t\t\tvar data = new spine.EventData(eventName);\r\n\t\t\t\t\tdata.intValue = this.getValue(eventMap, \"int\", 0);\r\n\t\t\t\t\tdata.floatValue = this.getValue(eventMap, \"float\", 0);\r\n\t\t\t\t\tdata.stringValue = this.getValue(eventMap, \"string\", \"\");\r\n\t\t\t\t\tskeletonData.events.push(data);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (root.animations) {\r\n\t\t\t\tfor (var animationName in root.animations) {\r\n\t\t\t\t\tvar animationMap = root.animations[animationName];\r\n\t\t\t\t\tthis.readAnimation(animationMap, animationName, skeletonData);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn skeletonData;\r\n\t\t};\r\n\t\tSkeletonJson.prototype.readAttachment = function (map, skin, slotIndex, name, skeletonData) {\r\n\t\t\tvar scale = this.scale;\r\n\t\t\tname = this.getValue(map, \"name\", name);\r\n\t\t\tvar type = this.getValue(map, \"type\", \"region\");\r\n\t\t\tswitch (type) {\r\n\t\t\t\tcase \"region\": {\r\n\t\t\t\t\tvar path = this.getValue(map, \"path\", name);\r\n\t\t\t\t\tvar region = this.attachmentLoader.newRegionAttachment(skin, name, path);\r\n\t\t\t\t\tif (region == null)\r\n\t\t\t\t\t\treturn null;\r\n\t\t\t\t\tregion.path = path;\r\n\t\t\t\t\tregion.x = this.getValue(map, \"x\", 0) * scale;\r\n\t\t\t\t\tregion.y = this.getValue(map, \"y\", 0) * scale;\r\n\t\t\t\t\tregion.scaleX = this.getValue(map, \"scaleX\", 1);\r\n\t\t\t\t\tregion.scaleY = this.getValue(map, \"scaleY\", 1);\r\n\t\t\t\t\tregion.rotation = this.getValue(map, \"rotation\", 0);\r\n\t\t\t\t\tregion.width = map.width * scale;\r\n\t\t\t\t\tregion.height = map.height * scale;\r\n\t\t\t\t\tvar color = this.getValue(map, \"color\", null);\r\n\t\t\t\t\tif (color != null)\r\n\t\t\t\t\t\tregion.color.setFromString(color);\r\n\t\t\t\t\tregion.updateOffset();\r\n\t\t\t\t\treturn region;\r\n\t\t\t\t}\r\n\t\t\t\tcase \"boundingbox\": {\r\n\t\t\t\t\tvar box = this.attachmentLoader.newBoundingBoxAttachment(skin, name);\r\n\t\t\t\t\tif (box == null)\r\n\t\t\t\t\t\treturn null;\r\n\t\t\t\t\tthis.readVertices(map, box, map.vertexCount << 1);\r\n\t\t\t\t\tvar color = this.getValue(map, \"color\", null);\r\n\t\t\t\t\tif (color != null)\r\n\t\t\t\t\t\tbox.color.setFromString(color);\r\n\t\t\t\t\treturn box;\r\n\t\t\t\t}\r\n\t\t\t\tcase \"mesh\":\r\n\t\t\t\tcase \"linkedmesh\": {\r\n\t\t\t\t\tvar path = this.getValue(map, \"path\", name);\r\n\t\t\t\t\tvar mesh = this.attachmentLoader.newMeshAttachment(skin, name, path);\r\n\t\t\t\t\tif (mesh == null)\r\n\t\t\t\t\t\treturn null;\r\n\t\t\t\t\tmesh.path = path;\r\n\t\t\t\t\tvar color = this.getValue(map, \"color\", null);\r\n\t\t\t\t\tif (color != null)\r\n\t\t\t\t\t\tmesh.color.setFromString(color);\r\n\t\t\t\t\tvar parent_4 = this.getValue(map, \"parent\", null);\r\n\t\t\t\t\tif (parent_4 != null) {\r\n\t\t\t\t\t\tmesh.inheritDeform = this.getValue(map, \"deform\", true);\r\n\t\t\t\t\t\tthis.linkedMeshes.push(new LinkedMesh(mesh, this.getValue(map, \"skin\", null), slotIndex, parent_4));\r\n\t\t\t\t\t\treturn mesh;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tvar uvs = map.uvs;\r\n\t\t\t\t\tthis.readVertices(map, mesh, uvs.length);\r\n\t\t\t\t\tmesh.triangles = map.triangles;\r\n\t\t\t\t\tmesh.regionUVs = uvs;\r\n\t\t\t\t\tmesh.updateUVs();\r\n\t\t\t\t\tmesh.hullLength = this.getValue(map, \"hull\", 0) * 2;\r\n\t\t\t\t\treturn mesh;\r\n\t\t\t\t}\r\n\t\t\t\tcase \"path\": {\r\n\t\t\t\t\tvar path = this.attachmentLoader.newPathAttachment(skin, name);\r\n\t\t\t\t\tif (path == null)\r\n\t\t\t\t\t\treturn null;\r\n\t\t\t\t\tpath.closed = this.getValue(map, \"closed\", false);\r\n\t\t\t\t\tpath.constantSpeed = this.getValue(map, \"constantSpeed\", true);\r\n\t\t\t\t\tvar vertexCount = map.vertexCount;\r\n\t\t\t\t\tthis.readVertices(map, path, vertexCount << 1);\r\n\t\t\t\t\tvar lengths = spine.Utils.newArray(vertexCount / 3, 0);\r\n\t\t\t\t\tfor (var i = 0; i < map.lengths.length; i++)\r\n\t\t\t\t\t\tlengths[i] = map.lengths[i] * scale;\r\n\t\t\t\t\tpath.lengths = lengths;\r\n\t\t\t\t\tvar color = this.getValue(map, \"color\", null);\r\n\t\t\t\t\tif (color != null)\r\n\t\t\t\t\t\tpath.color.setFromString(color);\r\n\t\t\t\t\treturn path;\r\n\t\t\t\t}\r\n\t\t\t\tcase \"point\": {\r\n\t\t\t\t\tvar point = this.attachmentLoader.newPointAttachment(skin, name);\r\n\t\t\t\t\tif (point == null)\r\n\t\t\t\t\t\treturn null;\r\n\t\t\t\t\tpoint.x = this.getValue(map, \"x\", 0) * scale;\r\n\t\t\t\t\tpoint.y = this.getValue(map, \"y\", 0) * scale;\r\n\t\t\t\t\tpoint.rotation = this.getValue(map, \"rotation\", 0);\r\n\t\t\t\t\tvar color = this.getValue(map, \"color\", null);\r\n\t\t\t\t\tif (color != null)\r\n\t\t\t\t\t\tpoint.color.setFromString(color);\r\n\t\t\t\t\treturn point;\r\n\t\t\t\t}\r\n\t\t\t\tcase \"clipping\": {\r\n\t\t\t\t\tvar clip = this.attachmentLoader.newClippingAttachment(skin, name);\r\n\t\t\t\t\tif (clip == null)\r\n\t\t\t\t\t\treturn null;\r\n\t\t\t\t\tvar end = this.getValue(map, \"end\", null);\r\n\t\t\t\t\tif (end != null) {\r\n\t\t\t\t\t\tvar slot = skeletonData.findSlot(end);\r\n\t\t\t\t\t\tif (slot == null)\r\n\t\t\t\t\t\t\tthrow new Error(\"Clipping end slot not found: \" + end);\r\n\t\t\t\t\t\tclip.endSlot = slot;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tvar vertexCount = map.vertexCount;\r\n\t\t\t\t\tthis.readVertices(map, clip, vertexCount << 1);\r\n\t\t\t\t\tvar color = this.getValue(map, \"color\", null);\r\n\t\t\t\t\tif (color != null)\r\n\t\t\t\t\t\tclip.color.setFromString(color);\r\n\t\t\t\t\treturn clip;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn null;\r\n\t\t};\r\n\t\tSkeletonJson.prototype.readVertices = function (map, attachment, verticesLength) {\r\n\t\t\tvar scale = this.scale;\r\n\t\t\tattachment.worldVerticesLength = verticesLength;\r\n\t\t\tvar vertices = map.vertices;\r\n\t\t\tif (verticesLength == vertices.length) {\r\n\t\t\t\tvar scaledVertices = spine.Utils.toFloatArray(vertices);\r\n\t\t\t\tif (scale != 1) {\r\n\t\t\t\t\tfor (var i = 0, n = vertices.length; i < n; i++)\r\n\t\t\t\t\t\tscaledVertices[i] *= scale;\r\n\t\t\t\t}\r\n\t\t\t\tattachment.vertices = scaledVertices;\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tvar weights = new Array();\r\n\t\t\tvar bones = new Array();\r\n\t\t\tfor (var i = 0, n = vertices.length; i < n;) {\r\n\t\t\t\tvar boneCount = vertices[i++];\r\n\t\t\t\tbones.push(boneCount);\r\n\t\t\t\tfor (var nn = i + boneCount * 4; i < nn; i += 4) {\r\n\t\t\t\t\tbones.push(vertices[i]);\r\n\t\t\t\t\tweights.push(vertices[i + 1] * scale);\r\n\t\t\t\t\tweights.push(vertices[i + 2] * scale);\r\n\t\t\t\t\tweights.push(vertices[i + 3]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tattachment.bones = bones;\r\n\t\t\tattachment.vertices = spine.Utils.toFloatArray(weights);\r\n\t\t};\r\n\t\tSkeletonJson.prototype.readAnimation = function (map, name, skeletonData) {\r\n\t\t\tvar scale = this.scale;\r\n\t\t\tvar timelines = new Array();\r\n\t\t\tvar duration = 0;\r\n\t\t\tif (map.slots) {\r\n\t\t\t\tfor (var slotName in map.slots) {\r\n\t\t\t\t\tvar slotMap = map.slots[slotName];\r\n\t\t\t\t\tvar slotIndex = skeletonData.findSlotIndex(slotName);\r\n\t\t\t\t\tif (slotIndex == -1)\r\n\t\t\t\t\t\tthrow new Error(\"Slot not found: \" + slotName);\r\n\t\t\t\t\tfor (var timelineName in slotMap) {\r\n\t\t\t\t\t\tvar timelineMap = slotMap[timelineName];\r\n\t\t\t\t\t\tif (timelineName == \"attachment\") {\r\n\t\t\t\t\t\t\tvar timeline = new spine.AttachmentTimeline(timelineMap.length);\r\n\t\t\t\t\t\t\ttimeline.slotIndex = slotIndex;\r\n\t\t\t\t\t\t\tvar frameIndex = 0;\r\n\t\t\t\t\t\t\tfor (var i = 0; i < timelineMap.length; i++) {\r\n\t\t\t\t\t\t\t\tvar valueMap = timelineMap[i];\r\n\t\t\t\t\t\t\t\ttimeline.setFrame(frameIndex++, valueMap.time, valueMap.name);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\ttimelines.push(timeline);\r\n\t\t\t\t\t\t\tduration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse if (timelineName == \"color\") {\r\n\t\t\t\t\t\t\tvar timeline = new spine.ColorTimeline(timelineMap.length);\r\n\t\t\t\t\t\t\ttimeline.slotIndex = slotIndex;\r\n\t\t\t\t\t\t\tvar frameIndex = 0;\r\n\t\t\t\t\t\t\tfor (var i = 0; i < timelineMap.length; i++) {\r\n\t\t\t\t\t\t\t\tvar valueMap = timelineMap[i];\r\n\t\t\t\t\t\t\t\tvar color = new spine.Color();\r\n\t\t\t\t\t\t\t\tcolor.setFromString(valueMap.color);\r\n\t\t\t\t\t\t\t\ttimeline.setFrame(frameIndex, valueMap.time, color.r, color.g, color.b, color.a);\r\n\t\t\t\t\t\t\t\tthis.readCurve(valueMap, timeline, frameIndex);\r\n\t\t\t\t\t\t\t\tframeIndex++;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\ttimelines.push(timeline);\r\n\t\t\t\t\t\t\tduration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * spine.ColorTimeline.ENTRIES]);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse if (timelineName == \"twoColor\") {\r\n\t\t\t\t\t\t\tvar timeline = new spine.TwoColorTimeline(timelineMap.length);\r\n\t\t\t\t\t\t\ttimeline.slotIndex = slotIndex;\r\n\t\t\t\t\t\t\tvar frameIndex = 0;\r\n\t\t\t\t\t\t\tfor (var i = 0; i < timelineMap.length; i++) {\r\n\t\t\t\t\t\t\t\tvar valueMap = timelineMap[i];\r\n\t\t\t\t\t\t\t\tvar light = new spine.Color();\r\n\t\t\t\t\t\t\t\tvar dark = new spine.Color();\r\n\t\t\t\t\t\t\t\tlight.setFromString(valueMap.light);\r\n\t\t\t\t\t\t\t\tdark.setFromString(valueMap.dark);\r\n\t\t\t\t\t\t\t\ttimeline.setFrame(frameIndex, valueMap.time, light.r, light.g, light.b, light.a, dark.r, dark.g, dark.b);\r\n\t\t\t\t\t\t\t\tthis.readCurve(valueMap, timeline, frameIndex);\r\n\t\t\t\t\t\t\t\tframeIndex++;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\ttimelines.push(timeline);\r\n\t\t\t\t\t\t\tduration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * spine.TwoColorTimeline.ENTRIES]);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\tthrow new Error(\"Invalid timeline type for a slot: \" + timelineName + \" (\" + slotName + \")\");\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (map.bones) {\r\n\t\t\t\tfor (var boneName in map.bones) {\r\n\t\t\t\t\tvar boneMap = map.bones[boneName];\r\n\t\t\t\t\tvar boneIndex = skeletonData.findBoneIndex(boneName);\r\n\t\t\t\t\tif (boneIndex == -1)\r\n\t\t\t\t\t\tthrow new Error(\"Bone not found: \" + boneName);\r\n\t\t\t\t\tfor (var timelineName in boneMap) {\r\n\t\t\t\t\t\tvar timelineMap = boneMap[timelineName];\r\n\t\t\t\t\t\tif (timelineName === \"rotate\") {\r\n\t\t\t\t\t\t\tvar timeline = new spine.RotateTimeline(timelineMap.length);\r\n\t\t\t\t\t\t\ttimeline.boneIndex = boneIndex;\r\n\t\t\t\t\t\t\tvar frameIndex = 0;\r\n\t\t\t\t\t\t\tfor (var i = 0; i < timelineMap.length; i++) {\r\n\t\t\t\t\t\t\t\tvar valueMap = timelineMap[i];\r\n\t\t\t\t\t\t\t\ttimeline.setFrame(frameIndex, valueMap.time, valueMap.angle);\r\n\t\t\t\t\t\t\t\tthis.readCurve(valueMap, timeline, frameIndex);\r\n\t\t\t\t\t\t\t\tframeIndex++;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\ttimelines.push(timeline);\r\n\t\t\t\t\t\t\tduration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * spine.RotateTimeline.ENTRIES]);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse if (timelineName === \"translate\" || timelineName === \"scale\" || timelineName === \"shear\") {\r\n\t\t\t\t\t\t\tvar timeline = null;\r\n\t\t\t\t\t\t\tvar timelineScale = 1;\r\n\t\t\t\t\t\t\tif (timelineName === \"scale\")\r\n\t\t\t\t\t\t\t\ttimeline = new spine.ScaleTimeline(timelineMap.length);\r\n\t\t\t\t\t\t\telse if (timelineName === \"shear\")\r\n\t\t\t\t\t\t\t\ttimeline = new spine.ShearTimeline(timelineMap.length);\r\n\t\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\t\ttimeline = new spine.TranslateTimeline(timelineMap.length);\r\n\t\t\t\t\t\t\t\ttimelineScale = scale;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\ttimeline.boneIndex = boneIndex;\r\n\t\t\t\t\t\t\tvar frameIndex = 0;\r\n\t\t\t\t\t\t\tfor (var i = 0; i < timelineMap.length; i++) {\r\n\t\t\t\t\t\t\t\tvar valueMap = timelineMap[i];\r\n\t\t\t\t\t\t\t\tvar x = this.getValue(valueMap, \"x\", 0), y = this.getValue(valueMap, \"y\", 0);\r\n\t\t\t\t\t\t\t\ttimeline.setFrame(frameIndex, valueMap.time, x * timelineScale, y * timelineScale);\r\n\t\t\t\t\t\t\t\tthis.readCurve(valueMap, timeline, frameIndex);\r\n\t\t\t\t\t\t\t\tframeIndex++;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\ttimelines.push(timeline);\r\n\t\t\t\t\t\t\tduration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * spine.TranslateTimeline.ENTRIES]);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\tthrow new Error(\"Invalid timeline type for a bone: \" + timelineName + \" (\" + boneName + \")\");\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (map.ik) {\r\n\t\t\t\tfor (var constraintName in map.ik) {\r\n\t\t\t\t\tvar constraintMap = map.ik[constraintName];\r\n\t\t\t\t\tvar constraint = skeletonData.findIkConstraint(constraintName);\r\n\t\t\t\t\tvar timeline = new spine.IkConstraintTimeline(constraintMap.length);\r\n\t\t\t\t\ttimeline.ikConstraintIndex = skeletonData.ikConstraints.indexOf(constraint);\r\n\t\t\t\t\tvar frameIndex = 0;\r\n\t\t\t\t\tfor (var i = 0; i < constraintMap.length; i++) {\r\n\t\t\t\t\t\tvar valueMap = constraintMap[i];\r\n\t\t\t\t\t\ttimeline.setFrame(frameIndex, valueMap.time, this.getValue(valueMap, \"mix\", 1), this.getValue(valueMap, \"bendPositive\", true) ? 1 : -1);\r\n\t\t\t\t\t\tthis.readCurve(valueMap, timeline, frameIndex);\r\n\t\t\t\t\t\tframeIndex++;\r\n\t\t\t\t\t}\r\n\t\t\t\t\ttimelines.push(timeline);\r\n\t\t\t\t\tduration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * spine.IkConstraintTimeline.ENTRIES]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (map.transform) {\r\n\t\t\t\tfor (var constraintName in map.transform) {\r\n\t\t\t\t\tvar constraintMap = map.transform[constraintName];\r\n\t\t\t\t\tvar constraint = skeletonData.findTransformConstraint(constraintName);\r\n\t\t\t\t\tvar timeline = new spine.TransformConstraintTimeline(constraintMap.length);\r\n\t\t\t\t\ttimeline.transformConstraintIndex = skeletonData.transformConstraints.indexOf(constraint);\r\n\t\t\t\t\tvar frameIndex = 0;\r\n\t\t\t\t\tfor (var i = 0; i < constraintMap.length; i++) {\r\n\t\t\t\t\t\tvar valueMap = constraintMap[i];\r\n\t\t\t\t\t\ttimeline.setFrame(frameIndex, valueMap.time, this.getValue(valueMap, \"rotateMix\", 1), this.getValue(valueMap, \"translateMix\", 1), this.getValue(valueMap, \"scaleMix\", 1), this.getValue(valueMap, \"shearMix\", 1));\r\n\t\t\t\t\t\tthis.readCurve(valueMap, timeline, frameIndex);\r\n\t\t\t\t\t\tframeIndex++;\r\n\t\t\t\t\t}\r\n\t\t\t\t\ttimelines.push(timeline);\r\n\t\t\t\t\tduration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * spine.TransformConstraintTimeline.ENTRIES]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (map.paths) {\r\n\t\t\t\tfor (var constraintName in map.paths) {\r\n\t\t\t\t\tvar constraintMap = map.paths[constraintName];\r\n\t\t\t\t\tvar index = skeletonData.findPathConstraintIndex(constraintName);\r\n\t\t\t\t\tif (index == -1)\r\n\t\t\t\t\t\tthrow new Error(\"Path constraint not found: \" + constraintName);\r\n\t\t\t\t\tvar data = skeletonData.pathConstraints[index];\r\n\t\t\t\t\tfor (var timelineName in constraintMap) {\r\n\t\t\t\t\t\tvar timelineMap = constraintMap[timelineName];\r\n\t\t\t\t\t\tif (timelineName === \"position\" || timelineName === \"spacing\") {\r\n\t\t\t\t\t\t\tvar timeline = null;\r\n\t\t\t\t\t\t\tvar timelineScale = 1;\r\n\t\t\t\t\t\t\tif (timelineName === \"spacing\") {\r\n\t\t\t\t\t\t\t\ttimeline = new spine.PathConstraintSpacingTimeline(timelineMap.length);\r\n\t\t\t\t\t\t\t\tif (data.spacingMode == spine.SpacingMode.Length || data.spacingMode == spine.SpacingMode.Fixed)\r\n\t\t\t\t\t\t\t\t\ttimelineScale = scale;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\t\ttimeline = new spine.PathConstraintPositionTimeline(timelineMap.length);\r\n\t\t\t\t\t\t\t\tif (data.positionMode == spine.PositionMode.Fixed)\r\n\t\t\t\t\t\t\t\t\ttimelineScale = scale;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\ttimeline.pathConstraintIndex = index;\r\n\t\t\t\t\t\t\tvar frameIndex = 0;\r\n\t\t\t\t\t\t\tfor (var i = 0; i < timelineMap.length; i++) {\r\n\t\t\t\t\t\t\t\tvar valueMap = timelineMap[i];\r\n\t\t\t\t\t\t\t\ttimeline.setFrame(frameIndex, valueMap.time, this.getValue(valueMap, timelineName, 0) * timelineScale);\r\n\t\t\t\t\t\t\t\tthis.readCurve(valueMap, timeline, frameIndex);\r\n\t\t\t\t\t\t\t\tframeIndex++;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\ttimelines.push(timeline);\r\n\t\t\t\t\t\t\tduration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * spine.PathConstraintPositionTimeline.ENTRIES]);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse if (timelineName === \"mix\") {\r\n\t\t\t\t\t\t\tvar timeline = new spine.PathConstraintMixTimeline(timelineMap.length);\r\n\t\t\t\t\t\t\ttimeline.pathConstraintIndex = index;\r\n\t\t\t\t\t\t\tvar frameIndex = 0;\r\n\t\t\t\t\t\t\tfor (var i = 0; i < timelineMap.length; i++) {\r\n\t\t\t\t\t\t\t\tvar valueMap = timelineMap[i];\r\n\t\t\t\t\t\t\t\ttimeline.setFrame(frameIndex, valueMap.time, this.getValue(valueMap, \"rotateMix\", 1), this.getValue(valueMap, \"translateMix\", 1));\r\n\t\t\t\t\t\t\t\tthis.readCurve(valueMap, timeline, frameIndex);\r\n\t\t\t\t\t\t\t\tframeIndex++;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\ttimelines.push(timeline);\r\n\t\t\t\t\t\t\tduration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * spine.PathConstraintMixTimeline.ENTRIES]);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (map.deform) {\r\n\t\t\t\tfor (var deformName in map.deform) {\r\n\t\t\t\t\tvar deformMap = map.deform[deformName];\r\n\t\t\t\t\tvar skin = skeletonData.findSkin(deformName);\r\n\t\t\t\t\tif (skin == null)\r\n\t\t\t\t\t\tthrow new Error(\"Skin not found: \" + deformName);\r\n\t\t\t\t\tfor (var slotName in deformMap) {\r\n\t\t\t\t\t\tvar slotMap = deformMap[slotName];\r\n\t\t\t\t\t\tvar slotIndex = skeletonData.findSlotIndex(slotName);\r\n\t\t\t\t\t\tif (slotIndex == -1)\r\n\t\t\t\t\t\t\tthrow new Error(\"Slot not found: \" + slotMap.name);\r\n\t\t\t\t\t\tfor (var timelineName in slotMap) {\r\n\t\t\t\t\t\t\tvar timelineMap = slotMap[timelineName];\r\n\t\t\t\t\t\t\tvar attachment = skin.getAttachment(slotIndex, timelineName);\r\n\t\t\t\t\t\t\tif (attachment == null)\r\n\t\t\t\t\t\t\t\tthrow new Error(\"Deform attachment not found: \" + timelineMap.name);\r\n\t\t\t\t\t\t\tvar weighted = attachment.bones != null;\r\n\t\t\t\t\t\t\tvar vertices = attachment.vertices;\r\n\t\t\t\t\t\t\tvar deformLength = weighted ? vertices.length / 3 * 2 : vertices.length;\r\n\t\t\t\t\t\t\tvar timeline = new spine.DeformTimeline(timelineMap.length);\r\n\t\t\t\t\t\t\ttimeline.slotIndex = slotIndex;\r\n\t\t\t\t\t\t\ttimeline.attachment = attachment;\r\n\t\t\t\t\t\t\tvar frameIndex = 0;\r\n\t\t\t\t\t\t\tfor (var j = 0; j < timelineMap.length; j++) {\r\n\t\t\t\t\t\t\t\tvar valueMap = timelineMap[j];\r\n\t\t\t\t\t\t\t\tvar deform = void 0;\r\n\t\t\t\t\t\t\t\tvar verticesValue = this.getValue(valueMap, \"vertices\", null);\r\n\t\t\t\t\t\t\t\tif (verticesValue == null)\r\n\t\t\t\t\t\t\t\t\tdeform = weighted ? spine.Utils.newFloatArray(deformLength) : vertices;\r\n\t\t\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\t\t\tdeform = spine.Utils.newFloatArray(deformLength);\r\n\t\t\t\t\t\t\t\t\tvar start = this.getValue(valueMap, \"offset\", 0);\r\n\t\t\t\t\t\t\t\t\tspine.Utils.arrayCopy(verticesValue, 0, deform, start, verticesValue.length);\r\n\t\t\t\t\t\t\t\t\tif (scale != 1) {\r\n\t\t\t\t\t\t\t\t\t\tfor (var i = start, n = i + verticesValue.length; i < n; i++)\r\n\t\t\t\t\t\t\t\t\t\t\tdeform[i] *= scale;\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\tif (!weighted) {\r\n\t\t\t\t\t\t\t\t\t\tfor (var i = 0; i < deformLength; i++)\r\n\t\t\t\t\t\t\t\t\t\t\tdeform[i] += vertices[i];\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\ttimeline.setFrame(frameIndex, valueMap.time, deform);\r\n\t\t\t\t\t\t\t\tthis.readCurve(valueMap, timeline, frameIndex);\r\n\t\t\t\t\t\t\t\tframeIndex++;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\ttimelines.push(timeline);\r\n\t\t\t\t\t\t\tduration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tvar drawOrderNode = map.drawOrder;\r\n\t\t\tif (drawOrderNode == null)\r\n\t\t\t\tdrawOrderNode = map.draworder;\r\n\t\t\tif (drawOrderNode != null) {\r\n\t\t\t\tvar timeline = new spine.DrawOrderTimeline(drawOrderNode.length);\r\n\t\t\t\tvar slotCount = skeletonData.slots.length;\r\n\t\t\t\tvar frameIndex = 0;\r\n\t\t\t\tfor (var j = 0; j < drawOrderNode.length; j++) {\r\n\t\t\t\t\tvar drawOrderMap = drawOrderNode[j];\r\n\t\t\t\t\tvar drawOrder = null;\r\n\t\t\t\t\tvar offsets = this.getValue(drawOrderMap, \"offsets\", null);\r\n\t\t\t\t\tif (offsets != null) {\r\n\t\t\t\t\t\tdrawOrder = spine.Utils.newArray(slotCount, -1);\r\n\t\t\t\t\t\tvar unchanged = spine.Utils.newArray(slotCount - offsets.length, 0);\r\n\t\t\t\t\t\tvar originalIndex = 0, unchangedIndex = 0;\r\n\t\t\t\t\t\tfor (var i = 0; i < offsets.length; i++) {\r\n\t\t\t\t\t\t\tvar offsetMap = offsets[i];\r\n\t\t\t\t\t\t\tvar slotIndex = skeletonData.findSlotIndex(offsetMap.slot);\r\n\t\t\t\t\t\t\tif (slotIndex == -1)\r\n\t\t\t\t\t\t\t\tthrow new Error(\"Slot not found: \" + offsetMap.slot);\r\n\t\t\t\t\t\t\twhile (originalIndex != slotIndex)\r\n\t\t\t\t\t\t\t\tunchanged[unchangedIndex++] = originalIndex++;\r\n\t\t\t\t\t\t\tdrawOrder[originalIndex + offsetMap.offset] = originalIndex++;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\twhile (originalIndex < slotCount)\r\n\t\t\t\t\t\t\tunchanged[unchangedIndex++] = originalIndex++;\r\n\t\t\t\t\t\tfor (var i = slotCount - 1; i >= 0; i--)\r\n\t\t\t\t\t\t\tif (drawOrder[i] == -1)\r\n\t\t\t\t\t\t\t\tdrawOrder[i] = unchanged[--unchangedIndex];\r\n\t\t\t\t\t}\r\n\t\t\t\t\ttimeline.setFrame(frameIndex++, drawOrderMap.time, drawOrder);\r\n\t\t\t\t}\r\n\t\t\t\ttimelines.push(timeline);\r\n\t\t\t\tduration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);\r\n\t\t\t}\r\n\t\t\tif (map.events) {\r\n\t\t\t\tvar timeline = new spine.EventTimeline(map.events.length);\r\n\t\t\t\tvar frameIndex = 0;\r\n\t\t\t\tfor (var i = 0; i < map.events.length; i++) {\r\n\t\t\t\t\tvar eventMap = map.events[i];\r\n\t\t\t\t\tvar eventData = skeletonData.findEvent(eventMap.name);\r\n\t\t\t\t\tif (eventData == null)\r\n\t\t\t\t\t\tthrow new Error(\"Event not found: \" + eventMap.name);\r\n\t\t\t\t\tvar event_5 = new spine.Event(spine.Utils.toSinglePrecision(eventMap.time), eventData);\r\n\t\t\t\t\tevent_5.intValue = this.getValue(eventMap, \"int\", eventData.intValue);\r\n\t\t\t\t\tevent_5.floatValue = this.getValue(eventMap, \"float\", eventData.floatValue);\r\n\t\t\t\t\tevent_5.stringValue = this.getValue(eventMap, \"string\", eventData.stringValue);\r\n\t\t\t\t\ttimeline.setFrame(frameIndex++, event_5);\r\n\t\t\t\t}\r\n\t\t\t\ttimelines.push(timeline);\r\n\t\t\t\tduration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);\r\n\t\t\t}\r\n\t\t\tif (isNaN(duration)) {\r\n\t\t\t\tthrow new Error(\"Error while parsing animation, duration is NaN\");\r\n\t\t\t}\r\n\t\t\tskeletonData.animations.push(new spine.Animation(name, timelines, duration));\r\n\t\t};\r\n\t\tSkeletonJson.prototype.readCurve = function (map, timeline, frameIndex) {\r\n\t\t\tif (!map.curve)\r\n\t\t\t\treturn;\r\n\t\t\tif (map.curve === \"stepped\")\r\n\t\t\t\ttimeline.setStepped(frameIndex);\r\n\t\t\telse if (Object.prototype.toString.call(map.curve) === '[object Array]') {\r\n\t\t\t\tvar curve = map.curve;\r\n\t\t\t\ttimeline.setCurve(frameIndex, curve[0], curve[1], curve[2], curve[3]);\r\n\t\t\t}\r\n\t\t};\r\n\t\tSkeletonJson.prototype.getValue = function (map, prop, defaultValue) {\r\n\t\t\treturn map[prop] !== undefined ? map[prop] : defaultValue;\r\n\t\t};\r\n\t\tSkeletonJson.blendModeFromString = function (str) {\r\n\t\t\tstr = str.toLowerCase();\r\n\t\t\tif (str == \"normal\")\r\n\t\t\t\treturn spine.BlendMode.Normal;\r\n\t\t\tif (str == \"additive\")\r\n\t\t\t\treturn spine.BlendMode.Additive;\r\n\t\t\tif (str == \"multiply\")\r\n\t\t\t\treturn spine.BlendMode.Multiply;\r\n\t\t\tif (str == \"screen\")\r\n\t\t\t\treturn spine.BlendMode.Screen;\r\n\t\t\tthrow new Error(\"Unknown blend mode: \" + str);\r\n\t\t};\r\n\t\tSkeletonJson.positionModeFromString = function (str) {\r\n\t\t\tstr = str.toLowerCase();\r\n\t\t\tif (str == \"fixed\")\r\n\t\t\t\treturn spine.PositionMode.Fixed;\r\n\t\t\tif (str == \"percent\")\r\n\t\t\t\treturn spine.PositionMode.Percent;\r\n\t\t\tthrow new Error(\"Unknown position mode: \" + str);\r\n\t\t};\r\n\t\tSkeletonJson.spacingModeFromString = function (str) {\r\n\t\t\tstr = str.toLowerCase();\r\n\t\t\tif (str == \"length\")\r\n\t\t\t\treturn spine.SpacingMode.Length;\r\n\t\t\tif (str == \"fixed\")\r\n\t\t\t\treturn spine.SpacingMode.Fixed;\r\n\t\t\tif (str == \"percent\")\r\n\t\t\t\treturn spine.SpacingMode.Percent;\r\n\t\t\tthrow new Error(\"Unknown position mode: \" + str);\r\n\t\t};\r\n\t\tSkeletonJson.rotateModeFromString = function (str) {\r\n\t\t\tstr = str.toLowerCase();\r\n\t\t\tif (str == \"tangent\")\r\n\t\t\t\treturn spine.RotateMode.Tangent;\r\n\t\t\tif (str == \"chain\")\r\n\t\t\t\treturn spine.RotateMode.Chain;\r\n\t\t\tif (str == \"chainscale\")\r\n\t\t\t\treturn spine.RotateMode.ChainScale;\r\n\t\t\tthrow new Error(\"Unknown rotate mode: \" + str);\r\n\t\t};\r\n\t\tSkeletonJson.transformModeFromString = function (str) {\r\n\t\t\tstr = str.toLowerCase();\r\n\t\t\tif (str == \"normal\")\r\n\t\t\t\treturn spine.TransformMode.Normal;\r\n\t\t\tif (str == \"onlytranslation\")\r\n\t\t\t\treturn spine.TransformMode.OnlyTranslation;\r\n\t\t\tif (str == \"norotationorreflection\")\r\n\t\t\t\treturn spine.TransformMode.NoRotationOrReflection;\r\n\t\t\tif (str == \"noscale\")\r\n\t\t\t\treturn spine.TransformMode.NoScale;\r\n\t\t\tif (str == \"noscaleorreflection\")\r\n\t\t\t\treturn spine.TransformMode.NoScaleOrReflection;\r\n\t\t\tthrow new Error(\"Unknown transform mode: \" + str);\r\n\t\t};\r\n\t\treturn SkeletonJson;\r\n\t}());\r\n\tspine.SkeletonJson = SkeletonJson;\r\n\tvar LinkedMesh = (function () {\r\n\t\tfunction LinkedMesh(mesh, skin, slotIndex, parent) {\r\n\t\t\tthis.mesh = mesh;\r\n\t\t\tthis.skin = skin;\r\n\t\t\tthis.slotIndex = slotIndex;\r\n\t\t\tthis.parent = parent;\r\n\t\t}\r\n\t\treturn LinkedMesh;\r\n\t}());\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n\tvar Skin = (function () {\r\n\t\tfunction Skin(name) {\r\n\t\t\tthis.attachments = new Array();\r\n\t\t\tif (name == null)\r\n\t\t\t\tthrow new Error(\"name cannot be null.\");\r\n\t\t\tthis.name = name;\r\n\t\t}\r\n\t\tSkin.prototype.addAttachment = function (slotIndex, name, attachment) {\r\n\t\t\tif (attachment == null)\r\n\t\t\t\tthrow new Error(\"attachment cannot be null.\");\r\n\t\t\tvar attachments = this.attachments;\r\n\t\t\tif (slotIndex >= attachments.length)\r\n\t\t\t\tattachments.length = slotIndex + 1;\r\n\t\t\tif (!attachments[slotIndex])\r\n\t\t\t\tattachments[slotIndex] = {};\r\n\t\t\tattachments[slotIndex][name] = attachment;\r\n\t\t};\r\n\t\tSkin.prototype.getAttachment = function (slotIndex, name) {\r\n\t\t\tvar dictionary = this.attachments[slotIndex];\r\n\t\t\treturn dictionary ? dictionary[name] : null;\r\n\t\t};\r\n\t\tSkin.prototype.attachAll = function (skeleton, oldSkin) {\r\n\t\t\tvar slotIndex = 0;\r\n\t\t\tfor (var i = 0; i < skeleton.slots.length; i++) {\r\n\t\t\t\tvar slot = skeleton.slots[i];\r\n\t\t\t\tvar slotAttachment = slot.getAttachment();\r\n\t\t\t\tif (slotAttachment && slotIndex < oldSkin.attachments.length) {\r\n\t\t\t\t\tvar dictionary = oldSkin.attachments[slotIndex];\r\n\t\t\t\t\tfor (var key in dictionary) {\r\n\t\t\t\t\t\tvar skinAttachment = dictionary[key];\r\n\t\t\t\t\t\tif (slotAttachment == skinAttachment) {\r\n\t\t\t\t\t\t\tvar attachment = this.getAttachment(slotIndex, key);\r\n\t\t\t\t\t\t\tif (attachment != null)\r\n\t\t\t\t\t\t\t\tslot.setAttachment(attachment);\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tslotIndex++;\r\n\t\t\t}\r\n\t\t};\r\n\t\treturn Skin;\r\n\t}());\r\n\tspine.Skin = Skin;\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n\tvar Slot = (function () {\r\n\t\tfunction Slot(data, bone) {\r\n\t\t\tthis.attachmentVertices = new Array();\r\n\t\t\tif (data == null)\r\n\t\t\t\tthrow new Error(\"data cannot be null.\");\r\n\t\t\tif (bone == null)\r\n\t\t\t\tthrow new Error(\"bone cannot be null.\");\r\n\t\t\tthis.data = data;\r\n\t\t\tthis.bone = bone;\r\n\t\t\tthis.color = new spine.Color();\r\n\t\t\tthis.darkColor = data.darkColor == null ? null : new spine.Color();\r\n\t\t\tthis.setToSetupPose();\r\n\t\t}\r\n\t\tSlot.prototype.getAttachment = function () {\r\n\t\t\treturn this.attachment;\r\n\t\t};\r\n\t\tSlot.prototype.setAttachment = function (attachment) {\r\n\t\t\tif (this.attachment == attachment)\r\n\t\t\t\treturn;\r\n\t\t\tthis.attachment = attachment;\r\n\t\t\tthis.attachmentTime = this.bone.skeleton.time;\r\n\t\t\tthis.attachmentVertices.length = 0;\r\n\t\t};\r\n\t\tSlot.prototype.setAttachmentTime = function (time) {\r\n\t\t\tthis.attachmentTime = this.bone.skeleton.time - time;\r\n\t\t};\r\n\t\tSlot.prototype.getAttachmentTime = function () {\r\n\t\t\treturn this.bone.skeleton.time - this.attachmentTime;\r\n\t\t};\r\n\t\tSlot.prototype.setToSetupPose = function () {\r\n\t\t\tthis.color.setFromColor(this.data.color);\r\n\t\t\tif (this.darkColor != null)\r\n\t\t\t\tthis.darkColor.setFromColor(this.data.darkColor);\r\n\t\t\tif (this.data.attachmentName == null)\r\n\t\t\t\tthis.attachment = null;\r\n\t\t\telse {\r\n\t\t\t\tthis.attachment = null;\r\n\t\t\t\tthis.setAttachment(this.bone.skeleton.getAttachment(this.data.index, this.data.attachmentName));\r\n\t\t\t}\r\n\t\t};\r\n\t\treturn Slot;\r\n\t}());\r\n\tspine.Slot = Slot;\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n\tvar SlotData = (function () {\r\n\t\tfunction SlotData(index, name, boneData) {\r\n\t\t\tthis.color = new spine.Color(1, 1, 1, 1);\r\n\t\t\tif (index < 0)\r\n\t\t\t\tthrow new Error(\"index must be >= 0.\");\r\n\t\t\tif (name == null)\r\n\t\t\t\tthrow new Error(\"name cannot be null.\");\r\n\t\t\tif (boneData == null)\r\n\t\t\t\tthrow new Error(\"boneData cannot be null.\");\r\n\t\t\tthis.index = index;\r\n\t\t\tthis.name = name;\r\n\t\t\tthis.boneData = boneData;\r\n\t\t}\r\n\t\treturn SlotData;\r\n\t}());\r\n\tspine.SlotData = SlotData;\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n\tvar Texture = (function () {\r\n\t\tfunction Texture(image) {\r\n\t\t\tthis._image = image;\r\n\t\t}\r\n\t\tTexture.prototype.getImage = function () {\r\n\t\t\treturn this._image;\r\n\t\t};\r\n\t\tTexture.filterFromString = function (text) {\r\n\t\t\tswitch (text.toLowerCase()) {\r\n\t\t\t\tcase \"nearest\": return TextureFilter.Nearest;\r\n\t\t\t\tcase \"linear\": return TextureFilter.Linear;\r\n\t\t\t\tcase \"mipmap\": return TextureFilter.MipMap;\r\n\t\t\t\tcase \"mipmapnearestnearest\": return TextureFilter.MipMapNearestNearest;\r\n\t\t\t\tcase \"mipmaplinearnearest\": return TextureFilter.MipMapLinearNearest;\r\n\t\t\t\tcase \"mipmapnearestlinear\": return TextureFilter.MipMapNearestLinear;\r\n\t\t\t\tcase \"mipmaplinearlinear\": return TextureFilter.MipMapLinearLinear;\r\n\t\t\t\tdefault: throw new Error(\"Unknown texture filter \" + text);\r\n\t\t\t}\r\n\t\t};\r\n\t\tTexture.wrapFromString = function (text) {\r\n\t\t\tswitch (text.toLowerCase()) {\r\n\t\t\t\tcase \"mirroredtepeat\": return TextureWrap.MirroredRepeat;\r\n\t\t\t\tcase \"clamptoedge\": return TextureWrap.ClampToEdge;\r\n\t\t\t\tcase \"repeat\": return TextureWrap.Repeat;\r\n\t\t\t\tdefault: throw new Error(\"Unknown texture wrap \" + text);\r\n\t\t\t}\r\n\t\t};\r\n\t\treturn Texture;\r\n\t}());\r\n\tspine.Texture = Texture;\r\n\tvar TextureFilter;\r\n\t(function (TextureFilter) {\r\n\t\tTextureFilter[TextureFilter[\"Nearest\"] = 9728] = \"Nearest\";\r\n\t\tTextureFilter[TextureFilter[\"Linear\"] = 9729] = \"Linear\";\r\n\t\tTextureFilter[TextureFilter[\"MipMap\"] = 9987] = \"MipMap\";\r\n\t\tTextureFilter[TextureFilter[\"MipMapNearestNearest\"] = 9984] = \"MipMapNearestNearest\";\r\n\t\tTextureFilter[TextureFilter[\"MipMapLinearNearest\"] = 9985] = \"MipMapLinearNearest\";\r\n\t\tTextureFilter[TextureFilter[\"MipMapNearestLinear\"] = 9986] = \"MipMapNearestLinear\";\r\n\t\tTextureFilter[TextureFilter[\"MipMapLinearLinear\"] = 9987] = \"MipMapLinearLinear\";\r\n\t})(TextureFilter = spine.TextureFilter || (spine.TextureFilter = {}));\r\n\tvar TextureWrap;\r\n\t(function (TextureWrap) {\r\n\t\tTextureWrap[TextureWrap[\"MirroredRepeat\"] = 33648] = \"MirroredRepeat\";\r\n\t\tTextureWrap[TextureWrap[\"ClampToEdge\"] = 33071] = \"ClampToEdge\";\r\n\t\tTextureWrap[TextureWrap[\"Repeat\"] = 10497] = \"Repeat\";\r\n\t})(TextureWrap = spine.TextureWrap || (spine.TextureWrap = {}));\r\n\tvar TextureRegion = (function () {\r\n\t\tfunction TextureRegion() {\r\n\t\t\tthis.u = 0;\r\n\t\t\tthis.v = 0;\r\n\t\t\tthis.u2 = 0;\r\n\t\t\tthis.v2 = 0;\r\n\t\t\tthis.width = 0;\r\n\t\t\tthis.height = 0;\r\n\t\t\tthis.rotate = false;\r\n\t\t\tthis.offsetX = 0;\r\n\t\t\tthis.offsetY = 0;\r\n\t\t\tthis.originalWidth = 0;\r\n\t\t\tthis.originalHeight = 0;\r\n\t\t}\r\n\t\treturn TextureRegion;\r\n\t}());\r\n\tspine.TextureRegion = TextureRegion;\r\n\tvar FakeTexture = (function (_super) {\r\n\t\t__extends(FakeTexture, _super);\r\n\t\tfunction FakeTexture() {\r\n\t\t\treturn _super !== null && _super.apply(this, arguments) || this;\r\n\t\t}\r\n\t\tFakeTexture.prototype.setFilters = function (minFilter, magFilter) { };\r\n\t\tFakeTexture.prototype.setWraps = function (uWrap, vWrap) { };\r\n\t\tFakeTexture.prototype.dispose = function () { };\r\n\t\treturn FakeTexture;\r\n\t}(spine.Texture));\r\n\tspine.FakeTexture = FakeTexture;\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n\tvar TextureAtlas = (function () {\r\n\t\tfunction TextureAtlas(atlasText, textureLoader) {\r\n\t\t\tthis.pages = new Array();\r\n\t\t\tthis.regions = new Array();\r\n\t\t\tthis.load(atlasText, textureLoader);\r\n\t\t}\r\n\t\tTextureAtlas.prototype.load = function (atlasText, textureLoader) {\r\n\t\t\tif (textureLoader == null)\r\n\t\t\t\tthrow new Error(\"textureLoader cannot be null.\");\r\n\t\t\tvar reader = new TextureAtlasReader(atlasText);\r\n\t\t\tvar tuple = new Array(4);\r\n\t\t\tvar page = null;\r\n\t\t\twhile (true) {\r\n\t\t\t\tvar line = reader.readLine();\r\n\t\t\t\tif (line == null)\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tline = line.trim();\r\n\t\t\t\tif (line.length == 0)\r\n\t\t\t\t\tpage = null;\r\n\t\t\t\telse if (!page) {\r\n\t\t\t\t\tpage = new TextureAtlasPage();\r\n\t\t\t\t\tpage.name = line;\r\n\t\t\t\t\tif (reader.readTuple(tuple) == 2) {\r\n\t\t\t\t\t\tpage.width = parseInt(tuple[0]);\r\n\t\t\t\t\t\tpage.height = parseInt(tuple[1]);\r\n\t\t\t\t\t\treader.readTuple(tuple);\r\n\t\t\t\t\t}\r\n\t\t\t\t\treader.readTuple(tuple);\r\n\t\t\t\t\tpage.minFilter = spine.Texture.filterFromString(tuple[0]);\r\n\t\t\t\t\tpage.magFilter = spine.Texture.filterFromString(tuple[1]);\r\n\t\t\t\t\tvar direction = reader.readValue();\r\n\t\t\t\t\tpage.uWrap = spine.TextureWrap.ClampToEdge;\r\n\t\t\t\t\tpage.vWrap = spine.TextureWrap.ClampToEdge;\r\n\t\t\t\t\tif (direction == \"x\")\r\n\t\t\t\t\t\tpage.uWrap = spine.TextureWrap.Repeat;\r\n\t\t\t\t\telse if (direction == \"y\")\r\n\t\t\t\t\t\tpage.vWrap = spine.TextureWrap.Repeat;\r\n\t\t\t\t\telse if (direction == \"xy\")\r\n\t\t\t\t\t\tpage.uWrap = page.vWrap = spine.TextureWrap.Repeat;\r\n\t\t\t\t\tpage.texture = textureLoader(line);\r\n\t\t\t\t\tpage.texture.setFilters(page.minFilter, page.magFilter);\r\n\t\t\t\t\tpage.texture.setWraps(page.uWrap, page.vWrap);\r\n\t\t\t\t\tpage.width = page.texture.getImage().width;\r\n\t\t\t\t\tpage.height = page.texture.getImage().height;\r\n\t\t\t\t\tthis.pages.push(page);\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tvar region = new TextureAtlasRegion();\r\n\t\t\t\t\tregion.name = line;\r\n\t\t\t\t\tregion.page = page;\r\n\t\t\t\t\tregion.rotate = reader.readValue() == \"true\";\r\n\t\t\t\t\treader.readTuple(tuple);\r\n\t\t\t\t\tvar x = parseInt(tuple[0]);\r\n\t\t\t\t\tvar y = parseInt(tuple[1]);\r\n\t\t\t\t\treader.readTuple(tuple);\r\n\t\t\t\t\tvar width = parseInt(tuple[0]);\r\n\t\t\t\t\tvar height = parseInt(tuple[1]);\r\n\t\t\t\t\tregion.u = x / page.width;\r\n\t\t\t\t\tregion.v = y / page.height;\r\n\t\t\t\t\tif (region.rotate) {\r\n\t\t\t\t\t\tregion.u2 = (x + height) / page.width;\r\n\t\t\t\t\t\tregion.v2 = (y + width) / page.height;\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tregion.u2 = (x + width) / page.width;\r\n\t\t\t\t\t\tregion.v2 = (y + height) / page.height;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tregion.x = x;\r\n\t\t\t\t\tregion.y = y;\r\n\t\t\t\t\tregion.width = Math.abs(width);\r\n\t\t\t\t\tregion.height = Math.abs(height);\r\n\t\t\t\t\tif (reader.readTuple(tuple) == 4) {\r\n\t\t\t\t\t\tif (reader.readTuple(tuple) == 4) {\r\n\t\t\t\t\t\t\treader.readTuple(tuple);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tregion.originalWidth = parseInt(tuple[0]);\r\n\t\t\t\t\tregion.originalHeight = parseInt(tuple[1]);\r\n\t\t\t\t\treader.readTuple(tuple);\r\n\t\t\t\t\tregion.offsetX = parseInt(tuple[0]);\r\n\t\t\t\t\tregion.offsetY = parseInt(tuple[1]);\r\n\t\t\t\t\tregion.index = parseInt(reader.readValue());\r\n\t\t\t\t\tregion.texture = page.texture;\r\n\t\t\t\t\tthis.regions.push(region);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\t\tTextureAtlas.prototype.findRegion = function (name) {\r\n\t\t\tfor (var i = 0; i < this.regions.length; i++) {\r\n\t\t\t\tif (this.regions[i].name == name) {\r\n\t\t\t\t\treturn this.regions[i];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn null;\r\n\t\t};\r\n\t\tTextureAtlas.prototype.dispose = function () {\r\n\t\t\tfor (var i = 0; i < this.pages.length; i++) {\r\n\t\t\t\tthis.pages[i].texture.dispose();\r\n\t\t\t}\r\n\t\t};\r\n\t\treturn TextureAtlas;\r\n\t}());\r\n\tspine.TextureAtlas = TextureAtlas;\r\n\tvar TextureAtlasReader = (function () {\r\n\t\tfunction TextureAtlasReader(text) {\r\n\t\t\tthis.index = 0;\r\n\t\t\tthis.lines = text.split(/\\r\\n|\\r|\\n/);\r\n\t\t}\r\n\t\tTextureAtlasReader.prototype.readLine = function () {\r\n\t\t\tif (this.index >= this.lines.length)\r\n\t\t\t\treturn null;\r\n\t\t\treturn this.lines[this.index++];\r\n\t\t};\r\n\t\tTextureAtlasReader.prototype.readValue = function () {\r\n\t\t\tvar line = this.readLine();\r\n\t\t\tvar colon = line.indexOf(\":\");\r\n\t\t\tif (colon == -1)\r\n\t\t\t\tthrow new Error(\"Invalid line: \" + line);\r\n\t\t\treturn line.substring(colon + 1).trim();\r\n\t\t};\r\n\t\tTextureAtlasReader.prototype.readTuple = function (tuple) {\r\n\t\t\tvar line = this.readLine();\r\n\t\t\tvar colon = line.indexOf(\":\");\r\n\t\t\tif (colon == -1)\r\n\t\t\t\tthrow new Error(\"Invalid line: \" + line);\r\n\t\t\tvar i = 0, lastMatch = colon + 1;\r\n\t\t\tfor (; i < 3; i++) {\r\n\t\t\t\tvar comma = line.indexOf(\",\", lastMatch);\r\n\t\t\t\tif (comma == -1)\r\n\t\t\t\t\tbreak;\r\n\t\t\t\ttuple[i] = line.substr(lastMatch, comma - lastMatch).trim();\r\n\t\t\t\tlastMatch = comma + 1;\r\n\t\t\t}\r\n\t\t\ttuple[i] = line.substring(lastMatch).trim();\r\n\t\t\treturn i + 1;\r\n\t\t};\r\n\t\treturn TextureAtlasReader;\r\n\t}());\r\n\tvar TextureAtlasPage = (function () {\r\n\t\tfunction TextureAtlasPage() {\r\n\t\t}\r\n\t\treturn TextureAtlasPage;\r\n\t}());\r\n\tspine.TextureAtlasPage = TextureAtlasPage;\r\n\tvar TextureAtlasRegion = (function (_super) {\r\n\t\t__extends(TextureAtlasRegion, _super);\r\n\t\tfunction TextureAtlasRegion() {\r\n\t\t\treturn _super !== null && _super.apply(this, arguments) || this;\r\n\t\t}\r\n\t\treturn TextureAtlasRegion;\r\n\t}(spine.TextureRegion));\r\n\tspine.TextureAtlasRegion = TextureAtlasRegion;\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n\tvar TransformConstraint = (function () {\r\n\t\tfunction TransformConstraint(data, skeleton) {\r\n\t\t\tthis.rotateMix = 0;\r\n\t\t\tthis.translateMix = 0;\r\n\t\t\tthis.scaleMix = 0;\r\n\t\t\tthis.shearMix = 0;\r\n\t\t\tthis.temp = new spine.Vector2();\r\n\t\t\tif (data == null)\r\n\t\t\t\tthrow new Error(\"data cannot be null.\");\r\n\t\t\tif (skeleton == null)\r\n\t\t\t\tthrow new Error(\"skeleton cannot be null.\");\r\n\t\t\tthis.data = data;\r\n\t\t\tthis.rotateMix = data.rotateMix;\r\n\t\t\tthis.translateMix = data.translateMix;\r\n\t\t\tthis.scaleMix = data.scaleMix;\r\n\t\t\tthis.shearMix = data.shearMix;\r\n\t\t\tthis.bones = new Array();\r\n\t\t\tfor (var i = 0; i < data.bones.length; i++)\r\n\t\t\t\tthis.bones.push(skeleton.findBone(data.bones[i].name));\r\n\t\t\tthis.target = skeleton.findBone(data.target.name);\r\n\t\t}\r\n\t\tTransformConstraint.prototype.apply = function () {\r\n\t\t\tthis.update();\r\n\t\t};\r\n\t\tTransformConstraint.prototype.update = function () {\r\n\t\t\tif (this.data.local) {\r\n\t\t\t\tif (this.data.relative)\r\n\t\t\t\t\tthis.applyRelativeLocal();\r\n\t\t\t\telse\r\n\t\t\t\t\tthis.applyAbsoluteLocal();\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tif (this.data.relative)\r\n\t\t\t\t\tthis.applyRelativeWorld();\r\n\t\t\t\telse\r\n\t\t\t\t\tthis.applyAbsoluteWorld();\r\n\t\t\t}\r\n\t\t};\r\n\t\tTransformConstraint.prototype.applyAbsoluteWorld = function () {\r\n\t\t\tvar rotateMix = this.rotateMix, translateMix = this.translateMix, scaleMix = this.scaleMix, shearMix = this.shearMix;\r\n\t\t\tvar target = this.target;\r\n\t\t\tvar ta = target.a, tb = target.b, tc = target.c, td = target.d;\r\n\t\t\tvar degRadReflect = ta * td - tb * tc > 0 ? spine.MathUtils.degRad : -spine.MathUtils.degRad;\r\n\t\t\tvar offsetRotation = this.data.offsetRotation * degRadReflect;\r\n\t\t\tvar offsetShearY = this.data.offsetShearY * degRadReflect;\r\n\t\t\tvar bones = this.bones;\r\n\t\t\tfor (var i = 0, n = bones.length; i < n; i++) {\r\n\t\t\t\tvar bone = bones[i];\r\n\t\t\t\tvar modified = false;\r\n\t\t\t\tif (rotateMix != 0) {\r\n\t\t\t\t\tvar a = bone.a, b = bone.b, c = bone.c, d = bone.d;\r\n\t\t\t\t\tvar r = Math.atan2(tc, ta) - Math.atan2(c, a) + offsetRotation;\r\n\t\t\t\t\tif (r > spine.MathUtils.PI)\r\n\t\t\t\t\t\tr -= spine.MathUtils.PI2;\r\n\t\t\t\t\telse if (r < -spine.MathUtils.PI)\r\n\t\t\t\t\t\tr += spine.MathUtils.PI2;\r\n\t\t\t\t\tr *= rotateMix;\r\n\t\t\t\t\tvar cos = Math.cos(r), sin = Math.sin(r);\r\n\t\t\t\t\tbone.a = cos * a - sin * c;\r\n\t\t\t\t\tbone.b = cos * b - sin * d;\r\n\t\t\t\t\tbone.c = sin * a + cos * c;\r\n\t\t\t\t\tbone.d = sin * b + cos * d;\r\n\t\t\t\t\tmodified = true;\r\n\t\t\t\t}\r\n\t\t\t\tif (translateMix != 0) {\r\n\t\t\t\t\tvar temp = this.temp;\r\n\t\t\t\t\ttarget.localToWorld(temp.set(this.data.offsetX, this.data.offsetY));\r\n\t\t\t\t\tbone.worldX += (temp.x - bone.worldX) * translateMix;\r\n\t\t\t\t\tbone.worldY += (temp.y - bone.worldY) * translateMix;\r\n\t\t\t\t\tmodified = true;\r\n\t\t\t\t}\r\n\t\t\t\tif (scaleMix > 0) {\r\n\t\t\t\t\tvar s = Math.sqrt(bone.a * bone.a + bone.c * bone.c);\r\n\t\t\t\t\tvar ts = Math.sqrt(ta * ta + tc * tc);\r\n\t\t\t\t\tif (s > 0.00001)\r\n\t\t\t\t\t\ts = (s + (ts - s + this.data.offsetScaleX) * scaleMix) / s;\r\n\t\t\t\t\tbone.a *= s;\r\n\t\t\t\t\tbone.c *= s;\r\n\t\t\t\t\ts = Math.sqrt(bone.b * bone.b + bone.d * bone.d);\r\n\t\t\t\t\tts = Math.sqrt(tb * tb + td * td);\r\n\t\t\t\t\tif (s > 0.00001)\r\n\t\t\t\t\t\ts = (s + (ts - s + this.data.offsetScaleY) * scaleMix) / s;\r\n\t\t\t\t\tbone.b *= s;\r\n\t\t\t\t\tbone.d *= s;\r\n\t\t\t\t\tmodified = true;\r\n\t\t\t\t}\r\n\t\t\t\tif (shearMix > 0) {\r\n\t\t\t\t\tvar b = bone.b, d = bone.d;\r\n\t\t\t\t\tvar by = Math.atan2(d, b);\r\n\t\t\t\t\tvar r = Math.atan2(td, tb) - Math.atan2(tc, ta) - (by - Math.atan2(bone.c, bone.a));\r\n\t\t\t\t\tif (r > spine.MathUtils.PI)\r\n\t\t\t\t\t\tr -= spine.MathUtils.PI2;\r\n\t\t\t\t\telse if (r < -spine.MathUtils.PI)\r\n\t\t\t\t\t\tr += spine.MathUtils.PI2;\r\n\t\t\t\t\tr = by + (r + offsetShearY) * shearMix;\r\n\t\t\t\t\tvar s = Math.sqrt(b * b + d * d);\r\n\t\t\t\t\tbone.b = Math.cos(r) * s;\r\n\t\t\t\t\tbone.d = Math.sin(r) * s;\r\n\t\t\t\t\tmodified = true;\r\n\t\t\t\t}\r\n\t\t\t\tif (modified)\r\n\t\t\t\t\tbone.appliedValid = false;\r\n\t\t\t}\r\n\t\t};\r\n\t\tTransformConstraint.prototype.applyRelativeWorld = function () {\r\n\t\t\tvar rotateMix = this.rotateMix, translateMix = this.translateMix, scaleMix = this.scaleMix, shearMix = this.shearMix;\r\n\t\t\tvar target = this.target;\r\n\t\t\tvar ta = target.a, tb = target.b, tc = target.c, td = target.d;\r\n\t\t\tvar degRadReflect = ta * td - tb * tc > 0 ? spine.MathUtils.degRad : -spine.MathUtils.degRad;\r\n\t\t\tvar offsetRotation = this.data.offsetRotation * degRadReflect, offsetShearY = this.data.offsetShearY * degRadReflect;\r\n\t\t\tvar bones = this.bones;\r\n\t\t\tfor (var i = 0, n = bones.length; i < n; i++) {\r\n\t\t\t\tvar bone = bones[i];\r\n\t\t\t\tvar modified = false;\r\n\t\t\t\tif (rotateMix != 0) {\r\n\t\t\t\t\tvar a = bone.a, b = bone.b, c = bone.c, d = bone.d;\r\n\t\t\t\t\tvar r = Math.atan2(tc, ta) + offsetRotation;\r\n\t\t\t\t\tif (r > spine.MathUtils.PI)\r\n\t\t\t\t\t\tr -= spine.MathUtils.PI2;\r\n\t\t\t\t\telse if (r < -spine.MathUtils.PI)\r\n\t\t\t\t\t\tr += spine.MathUtils.PI2;\r\n\t\t\t\t\tr *= rotateMix;\r\n\t\t\t\t\tvar cos = Math.cos(r), sin = Math.sin(r);\r\n\t\t\t\t\tbone.a = cos * a - sin * c;\r\n\t\t\t\t\tbone.b = cos * b - sin * d;\r\n\t\t\t\t\tbone.c = sin * a + cos * c;\r\n\t\t\t\t\tbone.d = sin * b + cos * d;\r\n\t\t\t\t\tmodified = true;\r\n\t\t\t\t}\r\n\t\t\t\tif (translateMix != 0) {\r\n\t\t\t\t\tvar temp = this.temp;\r\n\t\t\t\t\ttarget.localToWorld(temp.set(this.data.offsetX, this.data.offsetY));\r\n\t\t\t\t\tbone.worldX += temp.x * translateMix;\r\n\t\t\t\t\tbone.worldY += temp.y * translateMix;\r\n\t\t\t\t\tmodified = true;\r\n\t\t\t\t}\r\n\t\t\t\tif (scaleMix > 0) {\r\n\t\t\t\t\tvar s = (Math.sqrt(ta * ta + tc * tc) - 1 + this.data.offsetScaleX) * scaleMix + 1;\r\n\t\t\t\t\tbone.a *= s;\r\n\t\t\t\t\tbone.c *= s;\r\n\t\t\t\t\ts = (Math.sqrt(tb * tb + td * td) - 1 + this.data.offsetScaleY) * scaleMix + 1;\r\n\t\t\t\t\tbone.b *= s;\r\n\t\t\t\t\tbone.d *= s;\r\n\t\t\t\t\tmodified = true;\r\n\t\t\t\t}\r\n\t\t\t\tif (shearMix > 0) {\r\n\t\t\t\t\tvar r = Math.atan2(td, tb) - Math.atan2(tc, ta);\r\n\t\t\t\t\tif (r > spine.MathUtils.PI)\r\n\t\t\t\t\t\tr -= spine.MathUtils.PI2;\r\n\t\t\t\t\telse if (r < -spine.MathUtils.PI)\r\n\t\t\t\t\t\tr += spine.MathUtils.PI2;\r\n\t\t\t\t\tvar b = bone.b, d = bone.d;\r\n\t\t\t\t\tr = Math.atan2(d, b) + (r - spine.MathUtils.PI / 2 + offsetShearY) * shearMix;\r\n\t\t\t\t\tvar s = Math.sqrt(b * b + d * d);\r\n\t\t\t\t\tbone.b = Math.cos(r) * s;\r\n\t\t\t\t\tbone.d = Math.sin(r) * s;\r\n\t\t\t\t\tmodified = true;\r\n\t\t\t\t}\r\n\t\t\t\tif (modified)\r\n\t\t\t\t\tbone.appliedValid = false;\r\n\t\t\t}\r\n\t\t};\r\n\t\tTransformConstraint.prototype.applyAbsoluteLocal = function () {\r\n\t\t\tvar rotateMix = this.rotateMix, translateMix = this.translateMix, scaleMix = this.scaleMix, shearMix = this.shearMix;\r\n\t\t\tvar target = this.target;\r\n\t\t\tif (!target.appliedValid)\r\n\t\t\t\ttarget.updateAppliedTransform();\r\n\t\t\tvar bones = this.bones;\r\n\t\t\tfor (var i = 0, n = bones.length; i < n; i++) {\r\n\t\t\t\tvar bone = bones[i];\r\n\t\t\t\tif (!bone.appliedValid)\r\n\t\t\t\t\tbone.updateAppliedTransform();\r\n\t\t\t\tvar rotation = bone.arotation;\r\n\t\t\t\tif (rotateMix != 0) {\r\n\t\t\t\t\tvar r = target.arotation - rotation + this.data.offsetRotation;\r\n\t\t\t\t\tr -= (16384 - ((16384.499999999996 - r / 360) | 0)) * 360;\r\n\t\t\t\t\trotation += r * rotateMix;\r\n\t\t\t\t}\r\n\t\t\t\tvar x = bone.ax, y = bone.ay;\r\n\t\t\t\tif (translateMix != 0) {\r\n\t\t\t\t\tx += (target.ax - x + this.data.offsetX) * translateMix;\r\n\t\t\t\t\ty += (target.ay - y + this.data.offsetY) * translateMix;\r\n\t\t\t\t}\r\n\t\t\t\tvar scaleX = bone.ascaleX, scaleY = bone.ascaleY;\r\n\t\t\t\tif (scaleMix > 0) {\r\n\t\t\t\t\tif (scaleX > 0.00001)\r\n\t\t\t\t\t\tscaleX = (scaleX + (target.ascaleX - scaleX + this.data.offsetScaleX) * scaleMix) / scaleX;\r\n\t\t\t\t\tif (scaleY > 0.00001)\r\n\t\t\t\t\t\tscaleY = (scaleY + (target.ascaleY - scaleY + this.data.offsetScaleY) * scaleMix) / scaleY;\r\n\t\t\t\t}\r\n\t\t\t\tvar shearY = bone.ashearY;\r\n\t\t\t\tif (shearMix > 0) {\r\n\t\t\t\t\tvar r = target.ashearY - shearY + this.data.offsetShearY;\r\n\t\t\t\t\tr -= (16384 - ((16384.499999999996 - r / 360) | 0)) * 360;\r\n\t\t\t\t\tbone.shearY += r * shearMix;\r\n\t\t\t\t}\r\n\t\t\t\tbone.updateWorldTransformWith(x, y, rotation, scaleX, scaleY, bone.ashearX, shearY);\r\n\t\t\t}\r\n\t\t};\r\n\t\tTransformConstraint.prototype.applyRelativeLocal = function () {\r\n\t\t\tvar rotateMix = this.rotateMix, translateMix = this.translateMix, scaleMix = this.scaleMix, shearMix = this.shearMix;\r\n\t\t\tvar target = this.target;\r\n\t\t\tif (!target.appliedValid)\r\n\t\t\t\ttarget.updateAppliedTransform();\r\n\t\t\tvar bones = this.bones;\r\n\t\t\tfor (var i = 0, n = bones.length; i < n; i++) {\r\n\t\t\t\tvar bone = bones[i];\r\n\t\t\t\tif (!bone.appliedValid)\r\n\t\t\t\t\tbone.updateAppliedTransform();\r\n\t\t\t\tvar rotation = bone.arotation;\r\n\t\t\t\tif (rotateMix != 0)\r\n\t\t\t\t\trotation += (target.arotation + this.data.offsetRotation) * rotateMix;\r\n\t\t\t\tvar x = bone.ax, y = bone.ay;\r\n\t\t\t\tif (translateMix != 0) {\r\n\t\t\t\t\tx += (target.ax + this.data.offsetX) * translateMix;\r\n\t\t\t\t\ty += (target.ay + this.data.offsetY) * translateMix;\r\n\t\t\t\t}\r\n\t\t\t\tvar scaleX = bone.ascaleX, scaleY = bone.ascaleY;\r\n\t\t\t\tif (scaleMix > 0) {\r\n\t\t\t\t\tif (scaleX > 0.00001)\r\n\t\t\t\t\t\tscaleX *= ((target.ascaleX - 1 + this.data.offsetScaleX) * scaleMix) + 1;\r\n\t\t\t\t\tif (scaleY > 0.00001)\r\n\t\t\t\t\t\tscaleY *= ((target.ascaleY - 1 + this.data.offsetScaleY) * scaleMix) + 1;\r\n\t\t\t\t}\r\n\t\t\t\tvar shearY = bone.ashearY;\r\n\t\t\t\tif (shearMix > 0)\r\n\t\t\t\t\tshearY += (target.ashearY + this.data.offsetShearY) * shearMix;\r\n\t\t\t\tbone.updateWorldTransformWith(x, y, rotation, scaleX, scaleY, bone.ashearX, shearY);\r\n\t\t\t}\r\n\t\t};\r\n\t\tTransformConstraint.prototype.getOrder = function () {\r\n\t\t\treturn this.data.order;\r\n\t\t};\r\n\t\treturn TransformConstraint;\r\n\t}());\r\n\tspine.TransformConstraint = TransformConstraint;\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n\tvar TransformConstraintData = (function () {\r\n\t\tfunction TransformConstraintData(name) {\r\n\t\t\tthis.order = 0;\r\n\t\t\tthis.bones = new Array();\r\n\t\t\tthis.rotateMix = 0;\r\n\t\t\tthis.translateMix = 0;\r\n\t\t\tthis.scaleMix = 0;\r\n\t\t\tthis.shearMix = 0;\r\n\t\t\tthis.offsetRotation = 0;\r\n\t\t\tthis.offsetX = 0;\r\n\t\t\tthis.offsetY = 0;\r\n\t\t\tthis.offsetScaleX = 0;\r\n\t\t\tthis.offsetScaleY = 0;\r\n\t\t\tthis.offsetShearY = 0;\r\n\t\t\tthis.relative = false;\r\n\t\t\tthis.local = false;\r\n\t\t\tif (name == null)\r\n\t\t\t\tthrow new Error(\"name cannot be null.\");\r\n\t\t\tthis.name = name;\r\n\t\t}\r\n\t\treturn TransformConstraintData;\r\n\t}());\r\n\tspine.TransformConstraintData = TransformConstraintData;\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n\tvar Triangulator = (function () {\r\n\t\tfunction Triangulator() {\r\n\t\t\tthis.convexPolygons = new Array();\r\n\t\t\tthis.convexPolygonsIndices = new Array();\r\n\t\t\tthis.indicesArray = new Array();\r\n\t\t\tthis.isConcaveArray = new Array();\r\n\t\t\tthis.triangles = new Array();\r\n\t\t\tthis.polygonPool = new spine.Pool(function () {\r\n\t\t\t\treturn new Array();\r\n\t\t\t});\r\n\t\t\tthis.polygonIndicesPool = new spine.Pool(function () {\r\n\t\t\t\treturn new Array();\r\n\t\t\t});\r\n\t\t}\r\n\t\tTriangulator.prototype.triangulate = function (verticesArray) {\r\n\t\t\tvar vertices = verticesArray;\r\n\t\t\tvar vertexCount = verticesArray.length >> 1;\r\n\t\t\tvar indices = this.indicesArray;\r\n\t\t\tindices.length = 0;\r\n\t\t\tfor (var i = 0; i < vertexCount; i++)\r\n\t\t\t\tindices[i] = i;\r\n\t\t\tvar isConcave = this.isConcaveArray;\r\n\t\t\tisConcave.length = 0;\r\n\t\t\tfor (var i = 0, n = vertexCount; i < n; ++i)\r\n\t\t\t\tisConcave[i] = Triangulator.isConcave(i, vertexCount, vertices, indices);\r\n\t\t\tvar triangles = this.triangles;\r\n\t\t\ttriangles.length = 0;\r\n\t\t\twhile (vertexCount > 3) {\r\n\t\t\t\tvar previous = vertexCount - 1, i = 0, next = 1;\r\n\t\t\t\twhile (true) {\r\n\t\t\t\t\touter: if (!isConcave[i]) {\r\n\t\t\t\t\t\tvar p1 = indices[previous] << 1, p2 = indices[i] << 1, p3 = indices[next] << 1;\r\n\t\t\t\t\t\tvar p1x = vertices[p1], p1y = vertices[p1 + 1];\r\n\t\t\t\t\t\tvar p2x = vertices[p2], p2y = vertices[p2 + 1];\r\n\t\t\t\t\t\tvar p3x = vertices[p3], p3y = vertices[p3 + 1];\r\n\t\t\t\t\t\tfor (var ii = (next + 1) % vertexCount; ii != previous; ii = (ii + 1) % vertexCount) {\r\n\t\t\t\t\t\t\tif (!isConcave[ii])\r\n\t\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t\tvar v = indices[ii] << 1;\r\n\t\t\t\t\t\t\tvar vx = vertices[v], vy = vertices[v + 1];\r\n\t\t\t\t\t\t\tif (Triangulator.positiveArea(p3x, p3y, p1x, p1y, vx, vy)) {\r\n\t\t\t\t\t\t\t\tif (Triangulator.positiveArea(p1x, p1y, p2x, p2y, vx, vy)) {\r\n\t\t\t\t\t\t\t\t\tif (Triangulator.positiveArea(p2x, p2y, p3x, p3y, vx, vy))\r\n\t\t\t\t\t\t\t\t\t\tbreak outer;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (next == 0) {\r\n\t\t\t\t\t\tdo {\r\n\t\t\t\t\t\t\tif (!isConcave[i])\r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\ti--;\r\n\t\t\t\t\t\t} while (i > 0);\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tprevious = i;\r\n\t\t\t\t\ti = next;\r\n\t\t\t\t\tnext = (next + 1) % vertexCount;\r\n\t\t\t\t}\r\n\t\t\t\ttriangles.push(indices[(vertexCount + i - 1) % vertexCount]);\r\n\t\t\t\ttriangles.push(indices[i]);\r\n\t\t\t\ttriangles.push(indices[(i + 1) % vertexCount]);\r\n\t\t\t\tindices.splice(i, 1);\r\n\t\t\t\tisConcave.splice(i, 1);\r\n\t\t\t\tvertexCount--;\r\n\t\t\t\tvar previousIndex = (vertexCount + i - 1) % vertexCount;\r\n\t\t\t\tvar nextIndex = i == vertexCount ? 0 : i;\r\n\t\t\t\tisConcave[previousIndex] = Triangulator.isConcave(previousIndex, vertexCount, vertices, indices);\r\n\t\t\t\tisConcave[nextIndex] = Triangulator.isConcave(nextIndex, vertexCount, vertices, indices);\r\n\t\t\t}\r\n\t\t\tif (vertexCount == 3) {\r\n\t\t\t\ttriangles.push(indices[2]);\r\n\t\t\t\ttriangles.push(indices[0]);\r\n\t\t\t\ttriangles.push(indices[1]);\r\n\t\t\t}\r\n\t\t\treturn triangles;\r\n\t\t};\r\n\t\tTriangulator.prototype.decompose = function (verticesArray, triangles) {\r\n\t\t\tvar vertices = verticesArray;\r\n\t\t\tvar convexPolygons = this.convexPolygons;\r\n\t\t\tthis.polygonPool.freeAll(convexPolygons);\r\n\t\t\tconvexPolygons.length = 0;\r\n\t\t\tvar convexPolygonsIndices = this.convexPolygonsIndices;\r\n\t\t\tthis.polygonIndicesPool.freeAll(convexPolygonsIndices);\r\n\t\t\tconvexPolygonsIndices.length = 0;\r\n\t\t\tvar polygonIndices = this.polygonIndicesPool.obtain();\r\n\t\t\tpolygonIndices.length = 0;\r\n\t\t\tvar polygon = this.polygonPool.obtain();\r\n\t\t\tpolygon.length = 0;\r\n\t\t\tvar fanBaseIndex = -1, lastWinding = 0;\r\n\t\t\tfor (var i = 0, n = triangles.length; i < n; i += 3) {\r\n\t\t\t\tvar t1 = triangles[i] << 1, t2 = triangles[i + 1] << 1, t3 = triangles[i + 2] << 1;\r\n\t\t\t\tvar x1 = vertices[t1], y1 = vertices[t1 + 1];\r\n\t\t\t\tvar x2 = vertices[t2], y2 = vertices[t2 + 1];\r\n\t\t\t\tvar x3 = vertices[t3], y3 = vertices[t3 + 1];\r\n\t\t\t\tvar merged = false;\r\n\t\t\t\tif (fanBaseIndex == t1) {\r\n\t\t\t\t\tvar o = polygon.length - 4;\r\n\t\t\t\t\tvar winding1 = Triangulator.winding(polygon[o], polygon[o + 1], polygon[o + 2], polygon[o + 3], x3, y3);\r\n\t\t\t\t\tvar winding2 = Triangulator.winding(x3, y3, polygon[0], polygon[1], polygon[2], polygon[3]);\r\n\t\t\t\t\tif (winding1 == lastWinding && winding2 == lastWinding) {\r\n\t\t\t\t\t\tpolygon.push(x3);\r\n\t\t\t\t\t\tpolygon.push(y3);\r\n\t\t\t\t\t\tpolygonIndices.push(t3);\r\n\t\t\t\t\t\tmerged = true;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (!merged) {\r\n\t\t\t\t\tif (polygon.length > 0) {\r\n\t\t\t\t\t\tconvexPolygons.push(polygon);\r\n\t\t\t\t\t\tconvexPolygonsIndices.push(polygonIndices);\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tthis.polygonPool.free(polygon);\r\n\t\t\t\t\t\tthis.polygonIndicesPool.free(polygonIndices);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tpolygon = this.polygonPool.obtain();\r\n\t\t\t\t\tpolygon.length = 0;\r\n\t\t\t\t\tpolygon.push(x1);\r\n\t\t\t\t\tpolygon.push(y1);\r\n\t\t\t\t\tpolygon.push(x2);\r\n\t\t\t\t\tpolygon.push(y2);\r\n\t\t\t\t\tpolygon.push(x3);\r\n\t\t\t\t\tpolygon.push(y3);\r\n\t\t\t\t\tpolygonIndices = this.polygonIndicesPool.obtain();\r\n\t\t\t\t\tpolygonIndices.length = 0;\r\n\t\t\t\t\tpolygonIndices.push(t1);\r\n\t\t\t\t\tpolygonIndices.push(t2);\r\n\t\t\t\t\tpolygonIndices.push(t3);\r\n\t\t\t\t\tlastWinding = Triangulator.winding(x1, y1, x2, y2, x3, y3);\r\n\t\t\t\t\tfanBaseIndex = t1;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (polygon.length > 0) {\r\n\t\t\t\tconvexPolygons.push(polygon);\r\n\t\t\t\tconvexPolygonsIndices.push(polygonIndices);\r\n\t\t\t}\r\n\t\t\tfor (var i = 0, n = convexPolygons.length; i < n; i++) {\r\n\t\t\t\tpolygonIndices = convexPolygonsIndices[i];\r\n\t\t\t\tif (polygonIndices.length == 0)\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\tvar firstIndex = polygonIndices[0];\r\n\t\t\t\tvar lastIndex = polygonIndices[polygonIndices.length - 1];\r\n\t\t\t\tpolygon = convexPolygons[i];\r\n\t\t\t\tvar o = polygon.length - 4;\r\n\t\t\t\tvar prevPrevX = polygon[o], prevPrevY = polygon[o + 1];\r\n\t\t\t\tvar prevX = polygon[o + 2], prevY = polygon[o + 3];\r\n\t\t\t\tvar firstX = polygon[0], firstY = polygon[1];\r\n\t\t\t\tvar secondX = polygon[2], secondY = polygon[3];\r\n\t\t\t\tvar winding = Triangulator.winding(prevPrevX, prevPrevY, prevX, prevY, firstX, firstY);\r\n\t\t\t\tfor (var ii = 0; ii < n; ii++) {\r\n\t\t\t\t\tif (ii == i)\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\tvar otherIndices = convexPolygonsIndices[ii];\r\n\t\t\t\t\tif (otherIndices.length != 3)\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\tvar otherFirstIndex = otherIndices[0];\r\n\t\t\t\t\tvar otherSecondIndex = otherIndices[1];\r\n\t\t\t\t\tvar otherLastIndex = otherIndices[2];\r\n\t\t\t\t\tvar otherPoly = convexPolygons[ii];\r\n\t\t\t\t\tvar x3 = otherPoly[otherPoly.length - 2], y3 = otherPoly[otherPoly.length - 1];\r\n\t\t\t\t\tif (otherFirstIndex != firstIndex || otherSecondIndex != lastIndex)\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\tvar winding1 = Triangulator.winding(prevPrevX, prevPrevY, prevX, prevY, x3, y3);\r\n\t\t\t\t\tvar winding2 = Triangulator.winding(x3, y3, firstX, firstY, secondX, secondY);\r\n\t\t\t\t\tif (winding1 == winding && winding2 == winding) {\r\n\t\t\t\t\t\totherPoly.length = 0;\r\n\t\t\t\t\t\totherIndices.length = 0;\r\n\t\t\t\t\t\tpolygon.push(x3);\r\n\t\t\t\t\t\tpolygon.push(y3);\r\n\t\t\t\t\t\tpolygonIndices.push(otherLastIndex);\r\n\t\t\t\t\t\tprevPrevX = prevX;\r\n\t\t\t\t\t\tprevPrevY = prevY;\r\n\t\t\t\t\t\tprevX = x3;\r\n\t\t\t\t\t\tprevY = y3;\r\n\t\t\t\t\t\tii = 0;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tfor (var i = convexPolygons.length - 1; i >= 0; i--) {\r\n\t\t\t\tpolygon = convexPolygons[i];\r\n\t\t\t\tif (polygon.length == 0) {\r\n\t\t\t\t\tconvexPolygons.splice(i, 1);\r\n\t\t\t\t\tthis.polygonPool.free(polygon);\r\n\t\t\t\t\tpolygonIndices = convexPolygonsIndices[i];\r\n\t\t\t\t\tconvexPolygonsIndices.splice(i, 1);\r\n\t\t\t\t\tthis.polygonIndicesPool.free(polygonIndices);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn convexPolygons;\r\n\t\t};\r\n\t\tTriangulator.isConcave = function (index, vertexCount, vertices, indices) {\r\n\t\t\tvar previous = indices[(vertexCount + index - 1) % vertexCount] << 1;\r\n\t\t\tvar current = indices[index] << 1;\r\n\t\t\tvar next = indices[(index + 1) % vertexCount] << 1;\r\n\t\t\treturn !this.positiveArea(vertices[previous], vertices[previous + 1], vertices[current], vertices[current + 1], vertices[next], vertices[next + 1]);\r\n\t\t};\r\n\t\tTriangulator.positiveArea = function (p1x, p1y, p2x, p2y, p3x, p3y) {\r\n\t\t\treturn p1x * (p3y - p2y) + p2x * (p1y - p3y) + p3x * (p2y - p1y) >= 0;\r\n\t\t};\r\n\t\tTriangulator.winding = function (p1x, p1y, p2x, p2y, p3x, p3y) {\r\n\t\t\tvar px = p2x - p1x, py = p2y - p1y;\r\n\t\t\treturn p3x * py - p3y * px + px * p1y - p1x * py >= 0 ? 1 : -1;\r\n\t\t};\r\n\t\treturn Triangulator;\r\n\t}());\r\n\tspine.Triangulator = Triangulator;\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n\tvar IntSet = (function () {\r\n\t\tfunction IntSet() {\r\n\t\t\tthis.array = new Array();\r\n\t\t}\r\n\t\tIntSet.prototype.add = function (value) {\r\n\t\t\tvar contains = this.contains(value);\r\n\t\t\tthis.array[value | 0] = value | 0;\r\n\t\t\treturn !contains;\r\n\t\t};\r\n\t\tIntSet.prototype.contains = function (value) {\r\n\t\t\treturn this.array[value | 0] != undefined;\r\n\t\t};\r\n\t\tIntSet.prototype.remove = function (value) {\r\n\t\t\tthis.array[value | 0] = undefined;\r\n\t\t};\r\n\t\tIntSet.prototype.clear = function () {\r\n\t\t\tthis.array.length = 0;\r\n\t\t};\r\n\t\treturn IntSet;\r\n\t}());\r\n\tspine.IntSet = IntSet;\r\n\tvar Color = (function () {\r\n\t\tfunction Color(r, g, b, a) {\r\n\t\t\tif (r === void 0) { r = 0; }\r\n\t\t\tif (g === void 0) { g = 0; }\r\n\t\t\tif (b === void 0) { b = 0; }\r\n\t\t\tif (a === void 0) { a = 0; }\r\n\t\t\tthis.r = r;\r\n\t\t\tthis.g = g;\r\n\t\t\tthis.b = b;\r\n\t\t\tthis.a = a;\r\n\t\t}\r\n\t\tColor.prototype.set = function (r, g, b, a) {\r\n\t\t\tthis.r = r;\r\n\t\t\tthis.g = g;\r\n\t\t\tthis.b = b;\r\n\t\t\tthis.a = a;\r\n\t\t\tthis.clamp();\r\n\t\t\treturn this;\r\n\t\t};\r\n\t\tColor.prototype.setFromColor = function (c) {\r\n\t\t\tthis.r = c.r;\r\n\t\t\tthis.g = c.g;\r\n\t\t\tthis.b = c.b;\r\n\t\t\tthis.a = c.a;\r\n\t\t\treturn this;\r\n\t\t};\r\n\t\tColor.prototype.setFromString = function (hex) {\r\n\t\t\thex = hex.charAt(0) == '#' ? hex.substr(1) : hex;\r\n\t\t\tthis.r = parseInt(hex.substr(0, 2), 16) / 255.0;\r\n\t\t\tthis.g = parseInt(hex.substr(2, 2), 16) / 255.0;\r\n\t\t\tthis.b = parseInt(hex.substr(4, 2), 16) / 255.0;\r\n\t\t\tthis.a = (hex.length != 8 ? 255 : parseInt(hex.substr(6, 2), 16)) / 255.0;\r\n\t\t\treturn this;\r\n\t\t};\r\n\t\tColor.prototype.add = function (r, g, b, a) {\r\n\t\t\tthis.r += r;\r\n\t\t\tthis.g += g;\r\n\t\t\tthis.b += b;\r\n\t\t\tthis.a += a;\r\n\t\t\tthis.clamp();\r\n\t\t\treturn this;\r\n\t\t};\r\n\t\tColor.prototype.clamp = function () {\r\n\t\t\tif (this.r < 0)\r\n\t\t\t\tthis.r = 0;\r\n\t\t\telse if (this.r > 1)\r\n\t\t\t\tthis.r = 1;\r\n\t\t\tif (this.g < 0)\r\n\t\t\t\tthis.g = 0;\r\n\t\t\telse if (this.g > 1)\r\n\t\t\t\tthis.g = 1;\r\n\t\t\tif (this.b < 0)\r\n\t\t\t\tthis.b = 0;\r\n\t\t\telse if (this.b > 1)\r\n\t\t\t\tthis.b = 1;\r\n\t\t\tif (this.a < 0)\r\n\t\t\t\tthis.a = 0;\r\n\t\t\telse if (this.a > 1)\r\n\t\t\t\tthis.a = 1;\r\n\t\t\treturn this;\r\n\t\t};\r\n\t\tColor.WHITE = new Color(1, 1, 1, 1);\r\n\t\tColor.RED = new Color(1, 0, 0, 1);\r\n\t\tColor.GREEN = new Color(0, 1, 0, 1);\r\n\t\tColor.BLUE = new Color(0, 0, 1, 1);\r\n\t\tColor.MAGENTA = new Color(1, 0, 1, 1);\r\n\t\treturn Color;\r\n\t}());\r\n\tspine.Color = Color;\r\n\tvar MathUtils = (function () {\r\n\t\tfunction MathUtils() {\r\n\t\t}\r\n\t\tMathUtils.clamp = function (value, min, max) {\r\n\t\t\tif (value < min)\r\n\t\t\t\treturn min;\r\n\t\t\tif (value > max)\r\n\t\t\t\treturn max;\r\n\t\t\treturn value;\r\n\t\t};\r\n\t\tMathUtils.cosDeg = function (degrees) {\r\n\t\t\treturn Math.cos(degrees * MathUtils.degRad);\r\n\t\t};\r\n\t\tMathUtils.sinDeg = function (degrees) {\r\n\t\t\treturn Math.sin(degrees * MathUtils.degRad);\r\n\t\t};\r\n\t\tMathUtils.signum = function (value) {\r\n\t\t\treturn value > 0 ? 1 : value < 0 ? -1 : 0;\r\n\t\t};\r\n\t\tMathUtils.toInt = function (x) {\r\n\t\t\treturn x > 0 ? Math.floor(x) : Math.ceil(x);\r\n\t\t};\r\n\t\tMathUtils.cbrt = function (x) {\r\n\t\t\tvar y = Math.pow(Math.abs(x), 1 / 3);\r\n\t\t\treturn x < 0 ? -y : y;\r\n\t\t};\r\n\t\tMathUtils.randomTriangular = function (min, max) {\r\n\t\t\treturn MathUtils.randomTriangularWith(min, max, (min + max) * 0.5);\r\n\t\t};\r\n\t\tMathUtils.randomTriangularWith = function (min, max, mode) {\r\n\t\t\tvar u = Math.random();\r\n\t\t\tvar d = max - min;\r\n\t\t\tif (u <= (mode - min) / d)\r\n\t\t\t\treturn min + Math.sqrt(u * d * (mode - min));\r\n\t\t\treturn max - Math.sqrt((1 - u) * d * (max - mode));\r\n\t\t};\r\n\t\tMathUtils.PI = 3.1415927;\r\n\t\tMathUtils.PI2 = MathUtils.PI * 2;\r\n\t\tMathUtils.radiansToDegrees = 180 / MathUtils.PI;\r\n\t\tMathUtils.radDeg = MathUtils.radiansToDegrees;\r\n\t\tMathUtils.degreesToRadians = MathUtils.PI / 180;\r\n\t\tMathUtils.degRad = MathUtils.degreesToRadians;\r\n\t\treturn MathUtils;\r\n\t}());\r\n\tspine.MathUtils = MathUtils;\r\n\tvar Interpolation = (function () {\r\n\t\tfunction Interpolation() {\r\n\t\t}\r\n\t\tInterpolation.prototype.apply = function (start, end, a) {\r\n\t\t\treturn start + (end - start) * this.applyInternal(a);\r\n\t\t};\r\n\t\treturn Interpolation;\r\n\t}());\r\n\tspine.Interpolation = Interpolation;\r\n\tvar Pow = (function (_super) {\r\n\t\t__extends(Pow, _super);\r\n\t\tfunction Pow(power) {\r\n\t\t\tvar _this = _super.call(this) || this;\r\n\t\t\t_this.power = 2;\r\n\t\t\t_this.power = power;\r\n\t\t\treturn _this;\r\n\t\t}\r\n\t\tPow.prototype.applyInternal = function (a) {\r\n\t\t\tif (a <= 0.5)\r\n\t\t\t\treturn Math.pow(a * 2, this.power) / 2;\r\n\t\t\treturn Math.pow((a - 1) * 2, this.power) / (this.power % 2 == 0 ? -2 : 2) + 1;\r\n\t\t};\r\n\t\treturn Pow;\r\n\t}(Interpolation));\r\n\tspine.Pow = Pow;\r\n\tvar PowOut = (function (_super) {\r\n\t\t__extends(PowOut, _super);\r\n\t\tfunction PowOut(power) {\r\n\t\t\treturn _super.call(this, power) || this;\r\n\t\t}\r\n\t\tPowOut.prototype.applyInternal = function (a) {\r\n\t\t\treturn Math.pow(a - 1, this.power) * (this.power % 2 == 0 ? -1 : 1) + 1;\r\n\t\t};\r\n\t\treturn PowOut;\r\n\t}(Pow));\r\n\tspine.PowOut = PowOut;\r\n\tvar Utils = (function () {\r\n\t\tfunction Utils() {\r\n\t\t}\r\n\t\tUtils.arrayCopy = function (source, sourceStart, dest, destStart, numElements) {\r\n\t\t\tfor (var i = sourceStart, j = destStart; i < sourceStart + numElements; i++, j++) {\r\n\t\t\t\tdest[j] = source[i];\r\n\t\t\t}\r\n\t\t};\r\n\t\tUtils.setArraySize = function (array, size, value) {\r\n\t\t\tif (value === void 0) { value = 0; }\r\n\t\t\tvar oldSize = array.length;\r\n\t\t\tif (oldSize == size)\r\n\t\t\t\treturn array;\r\n\t\t\tarray.length = size;\r\n\t\t\tif (oldSize < size) {\r\n\t\t\t\tfor (var i = oldSize; i < size; i++)\r\n\t\t\t\t\tarray[i] = value;\r\n\t\t\t}\r\n\t\t\treturn array;\r\n\t\t};\r\n\t\tUtils.ensureArrayCapacity = function (array, size, value) {\r\n\t\t\tif (value === void 0) { value = 0; }\r\n\t\t\tif (array.length >= size)\r\n\t\t\t\treturn array;\r\n\t\t\treturn Utils.setArraySize(array, size, value);\r\n\t\t};\r\n\t\tUtils.newArray = function (size, defaultValue) {\r\n\t\t\tvar array = new Array(size);\r\n\t\t\tfor (var i = 0; i < size; i++)\r\n\t\t\t\tarray[i] = defaultValue;\r\n\t\t\treturn array;\r\n\t\t};\r\n\t\tUtils.newFloatArray = function (size) {\r\n\t\t\tif (Utils.SUPPORTS_TYPED_ARRAYS) {\r\n\t\t\t\treturn new Float32Array(size);\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tvar array = new Array(size);\r\n\t\t\t\tfor (var i = 0; i < array.length; i++)\r\n\t\t\t\t\tarray[i] = 0;\r\n\t\t\t\treturn array;\r\n\t\t\t}\r\n\t\t};\r\n\t\tUtils.newShortArray = function (size) {\r\n\t\t\tif (Utils.SUPPORTS_TYPED_ARRAYS) {\r\n\t\t\t\treturn new Int16Array(size);\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tvar array = new Array(size);\r\n\t\t\t\tfor (var i = 0; i < array.length; i++)\r\n\t\t\t\t\tarray[i] = 0;\r\n\t\t\t\treturn array;\r\n\t\t\t}\r\n\t\t};\r\n\t\tUtils.toFloatArray = function (array) {\r\n\t\t\treturn Utils.SUPPORTS_TYPED_ARRAYS ? new Float32Array(array) : array;\r\n\t\t};\r\n\t\tUtils.toSinglePrecision = function (value) {\r\n\t\t\treturn Utils.SUPPORTS_TYPED_ARRAYS ? Math.fround(value) : value;\r\n\t\t};\r\n\t\tUtils.webkit602BugfixHelper = function (alpha, pose) {\r\n\t\t};\r\n\t\tUtils.SUPPORTS_TYPED_ARRAYS = typeof (Float32Array) !== \"undefined\";\r\n\t\treturn Utils;\r\n\t}());\r\n\tspine.Utils = Utils;\r\n\tvar DebugUtils = (function () {\r\n\t\tfunction DebugUtils() {\r\n\t\t}\r\n\t\tDebugUtils.logBones = function (skeleton) {\r\n\t\t\tfor (var i = 0; i < skeleton.bones.length; i++) {\r\n\t\t\t\tvar bone = skeleton.bones[i];\r\n\t\t\t\tconsole.log(bone.data.name + \", \" + bone.a + \", \" + bone.b + \", \" + bone.c + \", \" + bone.d + \", \" + bone.worldX + \", \" + bone.worldY);\r\n\t\t\t}\r\n\t\t};\r\n\t\treturn DebugUtils;\r\n\t}());\r\n\tspine.DebugUtils = DebugUtils;\r\n\tvar Pool = (function () {\r\n\t\tfunction Pool(instantiator) {\r\n\t\t\tthis.items = new Array();\r\n\t\t\tthis.instantiator = instantiator;\r\n\t\t}\r\n\t\tPool.prototype.obtain = function () {\r\n\t\t\treturn this.items.length > 0 ? this.items.pop() : this.instantiator();\r\n\t\t};\r\n\t\tPool.prototype.free = function (item) {\r\n\t\t\tif (item.reset)\r\n\t\t\t\titem.reset();\r\n\t\t\tthis.items.push(item);\r\n\t\t};\r\n\t\tPool.prototype.freeAll = function (items) {\r\n\t\t\tfor (var i = 0; i < items.length; i++) {\r\n\t\t\t\tif (items[i].reset)\r\n\t\t\t\t\titems[i].reset();\r\n\t\t\t\tthis.items[i] = items[i];\r\n\t\t\t}\r\n\t\t};\r\n\t\tPool.prototype.clear = function () {\r\n\t\t\tthis.items.length = 0;\r\n\t\t};\r\n\t\treturn Pool;\r\n\t}());\r\n\tspine.Pool = Pool;\r\n\tvar Vector2 = (function () {\r\n\t\tfunction Vector2(x, y) {\r\n\t\t\tif (x === void 0) { x = 0; }\r\n\t\t\tif (y === void 0) { y = 0; }\r\n\t\t\tthis.x = x;\r\n\t\t\tthis.y = y;\r\n\t\t}\r\n\t\tVector2.prototype.set = function (x, y) {\r\n\t\t\tthis.x = x;\r\n\t\t\tthis.y = y;\r\n\t\t\treturn this;\r\n\t\t};\r\n\t\tVector2.prototype.length = function () {\r\n\t\t\tvar x = this.x;\r\n\t\t\tvar y = this.y;\r\n\t\t\treturn Math.sqrt(x * x + y * y);\r\n\t\t};\r\n\t\tVector2.prototype.normalize = function () {\r\n\t\t\tvar len = this.length();\r\n\t\t\tif (len != 0) {\r\n\t\t\t\tthis.x /= len;\r\n\t\t\t\tthis.y /= len;\r\n\t\t\t}\r\n\t\t\treturn this;\r\n\t\t};\r\n\t\treturn Vector2;\r\n\t}());\r\n\tspine.Vector2 = Vector2;\r\n\tvar TimeKeeper = (function () {\r\n\t\tfunction TimeKeeper() {\r\n\t\t\tthis.maxDelta = 0.064;\r\n\t\t\tthis.framesPerSecond = 0;\r\n\t\t\tthis.delta = 0;\r\n\t\t\tthis.totalTime = 0;\r\n\t\t\tthis.lastTime = Date.now() / 1000;\r\n\t\t\tthis.frameCount = 0;\r\n\t\t\tthis.frameTime = 0;\r\n\t\t}\r\n\t\tTimeKeeper.prototype.update = function () {\r\n\t\t\tvar now = Date.now() / 1000;\r\n\t\t\tthis.delta = now - this.lastTime;\r\n\t\t\tthis.frameTime += this.delta;\r\n\t\t\tthis.totalTime += this.delta;\r\n\t\t\tif (this.delta > this.maxDelta)\r\n\t\t\t\tthis.delta = this.maxDelta;\r\n\t\t\tthis.lastTime = now;\r\n\t\t\tthis.frameCount++;\r\n\t\t\tif (this.frameTime > 1) {\r\n\t\t\t\tthis.framesPerSecond = this.frameCount / this.frameTime;\r\n\t\t\t\tthis.frameTime = 0;\r\n\t\t\t\tthis.frameCount = 0;\r\n\t\t\t}\r\n\t\t};\r\n\t\treturn TimeKeeper;\r\n\t}());\r\n\tspine.TimeKeeper = TimeKeeper;\r\n\tvar WindowedMean = (function () {\r\n\t\tfunction WindowedMean(windowSize) {\r\n\t\t\tif (windowSize === void 0) { windowSize = 32; }\r\n\t\t\tthis.addedValues = 0;\r\n\t\t\tthis.lastValue = 0;\r\n\t\t\tthis.mean = 0;\r\n\t\t\tthis.dirty = true;\r\n\t\t\tthis.values = new Array(windowSize);\r\n\t\t}\r\n\t\tWindowedMean.prototype.hasEnoughData = function () {\r\n\t\t\treturn this.addedValues >= this.values.length;\r\n\t\t};\r\n\t\tWindowedMean.prototype.addValue = function (value) {\r\n\t\t\tif (this.addedValues < this.values.length)\r\n\t\t\t\tthis.addedValues++;\r\n\t\t\tthis.values[this.lastValue++] = value;\r\n\t\t\tif (this.lastValue > this.values.length - 1)\r\n\t\t\t\tthis.lastValue = 0;\r\n\t\t\tthis.dirty = true;\r\n\t\t};\r\n\t\tWindowedMean.prototype.getMean = function () {\r\n\t\t\tif (this.hasEnoughData()) {\r\n\t\t\t\tif (this.dirty) {\r\n\t\t\t\t\tvar mean = 0;\r\n\t\t\t\t\tfor (var i = 0; i < this.values.length; i++) {\r\n\t\t\t\t\t\tmean += this.values[i];\r\n\t\t\t\t\t}\r\n\t\t\t\t\tthis.mean = mean / this.values.length;\r\n\t\t\t\t\tthis.dirty = false;\r\n\t\t\t\t}\r\n\t\t\t\treturn this.mean;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\treturn 0;\r\n\t\t\t}\r\n\t\t};\r\n\t\treturn WindowedMean;\r\n\t}());\r\n\tspine.WindowedMean = WindowedMean;\r\n})(spine || (spine = {}));\r\n(function () {\r\n\tif (!Math.fround) {\r\n\t\tMath.fround = (function (array) {\r\n\t\t\treturn function (x) {\r\n\t\t\t\treturn array[0] = x, array[0];\r\n\t\t\t};\r\n\t\t})(new Float32Array(1));\r\n\t}\r\n})();\r\nvar spine;\r\n(function (spine) {\r\n\tvar Attachment = (function () {\r\n\t\tfunction Attachment(name) {\r\n\t\t\tif (name == null)\r\n\t\t\t\tthrow new Error(\"name cannot be null.\");\r\n\t\t\tthis.name = name;\r\n\t\t}\r\n\t\treturn Attachment;\r\n\t}());\r\n\tspine.Attachment = Attachment;\r\n\tvar VertexAttachment = (function (_super) {\r\n\t\t__extends(VertexAttachment, _super);\r\n\t\tfunction VertexAttachment(name) {\r\n\t\t\tvar _this = _super.call(this, name) || this;\r\n\t\t\t_this.id = (VertexAttachment.nextID++ & 65535) << 11;\r\n\t\t\t_this.worldVerticesLength = 0;\r\n\t\t\treturn _this;\r\n\t\t}\r\n\t\tVertexAttachment.prototype.computeWorldVertices = function (slot, start, count, worldVertices, offset, stride) {\r\n\t\t\tcount = offset + (count >> 1) * stride;\r\n\t\t\tvar skeleton = slot.bone.skeleton;\r\n\t\t\tvar deformArray = slot.attachmentVertices;\r\n\t\t\tvar vertices = this.vertices;\r\n\t\t\tvar bones = this.bones;\r\n\t\t\tif (bones == null) {\r\n\t\t\t\tif (deformArray.length > 0)\r\n\t\t\t\t\tvertices = deformArray;\r\n\t\t\t\tvar bone = slot.bone;\r\n\t\t\t\tvar x = bone.worldX;\r\n\t\t\t\tvar y = bone.worldY;\r\n\t\t\t\tvar a = bone.a, b = bone.b, c = bone.c, d = bone.d;\r\n\t\t\t\tfor (var v_1 = start, w = offset; w < count; v_1 += 2, w += stride) {\r\n\t\t\t\t\tvar vx = vertices[v_1], vy = vertices[v_1 + 1];\r\n\t\t\t\t\tworldVertices[w] = vx * a + vy * b + x;\r\n\t\t\t\t\tworldVertices[w + 1] = vx * c + vy * d + y;\r\n\t\t\t\t}\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tvar v = 0, skip = 0;\r\n\t\t\tfor (var i = 0; i < start; i += 2) {\r\n\t\t\t\tvar n = bones[v];\r\n\t\t\t\tv += n + 1;\r\n\t\t\t\tskip += n;\r\n\t\t\t}\r\n\t\t\tvar skeletonBones = skeleton.bones;\r\n\t\t\tif (deformArray.length == 0) {\r\n\t\t\t\tfor (var w = offset, b = skip * 3; w < count; w += stride) {\r\n\t\t\t\t\tvar wx = 0, wy = 0;\r\n\t\t\t\t\tvar n = bones[v++];\r\n\t\t\t\t\tn += v;\r\n\t\t\t\t\tfor (; v < n; v++, b += 3) {\r\n\t\t\t\t\t\tvar bone = skeletonBones[bones[v]];\r\n\t\t\t\t\t\tvar vx = vertices[b], vy = vertices[b + 1], weight = vertices[b + 2];\r\n\t\t\t\t\t\twx += (vx * bone.a + vy * bone.b + bone.worldX) * weight;\r\n\t\t\t\t\t\twy += (vx * bone.c + vy * bone.d + bone.worldY) * weight;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tworldVertices[w] = wx;\r\n\t\t\t\t\tworldVertices[w + 1] = wy;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tvar deform = deformArray;\r\n\t\t\t\tfor (var w = offset, b = skip * 3, f = skip << 1; w < count; w += stride) {\r\n\t\t\t\t\tvar wx = 0, wy = 0;\r\n\t\t\t\t\tvar n = bones[v++];\r\n\t\t\t\t\tn += v;\r\n\t\t\t\t\tfor (; v < n; v++, b += 3, f += 2) {\r\n\t\t\t\t\t\tvar bone = skeletonBones[bones[v]];\r\n\t\t\t\t\t\tvar vx = vertices[b] + deform[f], vy = vertices[b + 1] + deform[f + 1], weight = vertices[b + 2];\r\n\t\t\t\t\t\twx += (vx * bone.a + vy * bone.b + bone.worldX) * weight;\r\n\t\t\t\t\t\twy += (vx * bone.c + vy * bone.d + bone.worldY) * weight;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tworldVertices[w] = wx;\r\n\t\t\t\t\tworldVertices[w + 1] = wy;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\t\tVertexAttachment.prototype.applyDeform = function (sourceAttachment) {\r\n\t\t\treturn this == sourceAttachment;\r\n\t\t};\r\n\t\tVertexAttachment.nextID = 0;\r\n\t\treturn VertexAttachment;\r\n\t}(Attachment));\r\n\tspine.VertexAttachment = VertexAttachment;\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n\tvar AttachmentType;\r\n\t(function (AttachmentType) {\r\n\t\tAttachmentType[AttachmentType[\"Region\"] = 0] = \"Region\";\r\n\t\tAttachmentType[AttachmentType[\"BoundingBox\"] = 1] = \"BoundingBox\";\r\n\t\tAttachmentType[AttachmentType[\"Mesh\"] = 2] = \"Mesh\";\r\n\t\tAttachmentType[AttachmentType[\"LinkedMesh\"] = 3] = \"LinkedMesh\";\r\n\t\tAttachmentType[AttachmentType[\"Path\"] = 4] = \"Path\";\r\n\t\tAttachmentType[AttachmentType[\"Point\"] = 5] = \"Point\";\r\n\t})(AttachmentType = spine.AttachmentType || (spine.AttachmentType = {}));\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n\tvar BoundingBoxAttachment = (function (_super) {\r\n\t\t__extends(BoundingBoxAttachment, _super);\r\n\t\tfunction BoundingBoxAttachment(name) {\r\n\t\t\tvar _this = _super.call(this, name) || this;\r\n\t\t\t_this.color = new spine.Color(1, 1, 1, 1);\r\n\t\t\treturn _this;\r\n\t\t}\r\n\t\treturn BoundingBoxAttachment;\r\n\t}(spine.VertexAttachment));\r\n\tspine.BoundingBoxAttachment = BoundingBoxAttachment;\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n\tvar ClippingAttachment = (function (_super) {\r\n\t\t__extends(ClippingAttachment, _super);\r\n\t\tfunction ClippingAttachment(name) {\r\n\t\t\tvar _this = _super.call(this, name) || this;\r\n\t\t\t_this.color = new spine.Color(0.2275, 0.2275, 0.8078, 1);\r\n\t\t\treturn _this;\r\n\t\t}\r\n\t\treturn ClippingAttachment;\r\n\t}(spine.VertexAttachment));\r\n\tspine.ClippingAttachment = ClippingAttachment;\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n\tvar MeshAttachment = (function (_super) {\r\n\t\t__extends(MeshAttachment, _super);\r\n\t\tfunction MeshAttachment(name) {\r\n\t\t\tvar _this = _super.call(this, name) || this;\r\n\t\t\t_this.color = new spine.Color(1, 1, 1, 1);\r\n\t\t\t_this.inheritDeform = false;\r\n\t\t\t_this.tempColor = new spine.Color(0, 0, 0, 0);\r\n\t\t\treturn _this;\r\n\t\t}\r\n\t\tMeshAttachment.prototype.updateUVs = function () {\r\n\t\t\tvar u = 0, v = 0, width = 0, height = 0;\r\n\t\t\tif (this.region == null) {\r\n\t\t\t\tu = v = 0;\r\n\t\t\t\twidth = height = 1;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tu = this.region.u;\r\n\t\t\t\tv = this.region.v;\r\n\t\t\t\twidth = this.region.u2 - u;\r\n\t\t\t\theight = this.region.v2 - v;\r\n\t\t\t}\r\n\t\t\tvar regionUVs = this.regionUVs;\r\n\t\t\tif (this.uvs == null || this.uvs.length != regionUVs.length)\r\n\t\t\t\tthis.uvs = spine.Utils.newFloatArray(regionUVs.length);\r\n\t\t\tvar uvs = this.uvs;\r\n\t\t\tif (this.region.rotate) {\r\n\t\t\t\tfor (var i = 0, n = uvs.length; i < n; i += 2) {\r\n\t\t\t\t\tuvs[i] = u + regionUVs[i + 1] * width;\r\n\t\t\t\t\tuvs[i + 1] = v + height - regionUVs[i] * height;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tfor (var i = 0, n = uvs.length; i < n; i += 2) {\r\n\t\t\t\t\tuvs[i] = u + regionUVs[i] * width;\r\n\t\t\t\t\tuvs[i + 1] = v + regionUVs[i + 1] * height;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\t\tMeshAttachment.prototype.applyDeform = function (sourceAttachment) {\r\n\t\t\treturn this == sourceAttachment || (this.inheritDeform && this.parentMesh == sourceAttachment);\r\n\t\t};\r\n\t\tMeshAttachment.prototype.getParentMesh = function () {\r\n\t\t\treturn this.parentMesh;\r\n\t\t};\r\n\t\tMeshAttachment.prototype.setParentMesh = function (parentMesh) {\r\n\t\t\tthis.parentMesh = parentMesh;\r\n\t\t\tif (parentMesh != null) {\r\n\t\t\t\tthis.bones = parentMesh.bones;\r\n\t\t\t\tthis.vertices = parentMesh.vertices;\r\n\t\t\t\tthis.worldVerticesLength = parentMesh.worldVerticesLength;\r\n\t\t\t\tthis.regionUVs = parentMesh.regionUVs;\r\n\t\t\t\tthis.triangles = parentMesh.triangles;\r\n\t\t\t\tthis.hullLength = parentMesh.hullLength;\r\n\t\t\t\tthis.worldVerticesLength = parentMesh.worldVerticesLength;\r\n\t\t\t}\r\n\t\t};\r\n\t\treturn MeshAttachment;\r\n\t}(spine.VertexAttachment));\r\n\tspine.MeshAttachment = MeshAttachment;\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n\tvar PathAttachment = (function (_super) {\r\n\t\t__extends(PathAttachment, _super);\r\n\t\tfunction PathAttachment(name) {\r\n\t\t\tvar _this = _super.call(this, name) || this;\r\n\t\t\t_this.closed = false;\r\n\t\t\t_this.constantSpeed = false;\r\n\t\t\t_this.color = new spine.Color(1, 1, 1, 1);\r\n\t\t\treturn _this;\r\n\t\t}\r\n\t\treturn PathAttachment;\r\n\t}(spine.VertexAttachment));\r\n\tspine.PathAttachment = PathAttachment;\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n\tvar PointAttachment = (function (_super) {\r\n\t\t__extends(PointAttachment, _super);\r\n\t\tfunction PointAttachment(name) {\r\n\t\t\tvar _this = _super.call(this, name) || this;\r\n\t\t\t_this.color = new spine.Color(0.38, 0.94, 0, 1);\r\n\t\t\treturn _this;\r\n\t\t}\r\n\t\tPointAttachment.prototype.computeWorldPosition = function (bone, point) {\r\n\t\t\tpoint.x = this.x * bone.a + this.y * bone.b + bone.worldX;\r\n\t\t\tpoint.y = this.x * bone.c + this.y * bone.d + bone.worldY;\r\n\t\t\treturn point;\r\n\t\t};\r\n\t\tPointAttachment.prototype.computeWorldRotation = function (bone) {\r\n\t\t\tvar cos = spine.MathUtils.cosDeg(this.rotation), sin = spine.MathUtils.sinDeg(this.rotation);\r\n\t\t\tvar x = cos * bone.a + sin * bone.b;\r\n\t\t\tvar y = cos * bone.c + sin * bone.d;\r\n\t\t\treturn Math.atan2(y, x) * spine.MathUtils.radDeg;\r\n\t\t};\r\n\t\treturn PointAttachment;\r\n\t}(spine.VertexAttachment));\r\n\tspine.PointAttachment = PointAttachment;\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n\tvar RegionAttachment = (function (_super) {\r\n\t\t__extends(RegionAttachment, _super);\r\n\t\tfunction RegionAttachment(name) {\r\n\t\t\tvar _this = _super.call(this, name) || this;\r\n\t\t\t_this.x = 0;\r\n\t\t\t_this.y = 0;\r\n\t\t\t_this.scaleX = 1;\r\n\t\t\t_this.scaleY = 1;\r\n\t\t\t_this.rotation = 0;\r\n\t\t\t_this.width = 0;\r\n\t\t\t_this.height = 0;\r\n\t\t\t_this.color = new spine.Color(1, 1, 1, 1);\r\n\t\t\t_this.offset = spine.Utils.newFloatArray(8);\r\n\t\t\t_this.uvs = spine.Utils.newFloatArray(8);\r\n\t\t\t_this.tempColor = new spine.Color(1, 1, 1, 1);\r\n\t\t\treturn _this;\r\n\t\t}\r\n\t\tRegionAttachment.prototype.updateOffset = function () {\r\n\t\t\tvar regionScaleX = this.width / this.region.originalWidth * this.scaleX;\r\n\t\t\tvar regionScaleY = this.height / this.region.originalHeight * this.scaleY;\r\n\t\t\tvar localX = -this.width / 2 * this.scaleX + this.region.offsetX * regionScaleX;\r\n\t\t\tvar localY = -this.height / 2 * this.scaleY + this.region.offsetY * regionScaleY;\r\n\t\t\tvar localX2 = localX + this.region.width * regionScaleX;\r\n\t\t\tvar localY2 = localY + this.region.height * regionScaleY;\r\n\t\t\tvar radians = this.rotation * Math.PI / 180;\r\n\t\t\tvar cos = Math.cos(radians);\r\n\t\t\tvar sin = Math.sin(radians);\r\n\t\t\tvar localXCos = localX * cos + this.x;\r\n\t\t\tvar localXSin = localX * sin;\r\n\t\t\tvar localYCos = localY * cos + this.y;\r\n\t\t\tvar localYSin = localY * sin;\r\n\t\t\tvar localX2Cos = localX2 * cos + this.x;\r\n\t\t\tvar localX2Sin = localX2 * sin;\r\n\t\t\tvar localY2Cos = localY2 * cos + this.y;\r\n\t\t\tvar localY2Sin = localY2 * sin;\r\n\t\t\tvar offset = this.offset;\r\n\t\t\toffset[RegionAttachment.OX1] = localXCos - localYSin;\r\n\t\t\toffset[RegionAttachment.OY1] = localYCos + localXSin;\r\n\t\t\toffset[RegionAttachment.OX2] = localXCos - localY2Sin;\r\n\t\t\toffset[RegionAttachment.OY2] = localY2Cos + localXSin;\r\n\t\t\toffset[RegionAttachment.OX3] = localX2Cos - localY2Sin;\r\n\t\t\toffset[RegionAttachment.OY3] = localY2Cos + localX2Sin;\r\n\t\t\toffset[RegionAttachment.OX4] = localX2Cos - localYSin;\r\n\t\t\toffset[RegionAttachment.OY4] = localYCos + localX2Sin;\r\n\t\t};\r\n\t\tRegionAttachment.prototype.setRegion = function (region) {\r\n\t\t\tthis.region = region;\r\n\t\t\tvar uvs = this.uvs;\r\n\t\t\tif (region.rotate) {\r\n\t\t\t\tuvs[2] = region.u;\r\n\t\t\t\tuvs[3] = region.v2;\r\n\t\t\t\tuvs[4] = region.u;\r\n\t\t\t\tuvs[5] = region.v;\r\n\t\t\t\tuvs[6] = region.u2;\r\n\t\t\t\tuvs[7] = region.v;\r\n\t\t\t\tuvs[0] = region.u2;\r\n\t\t\t\tuvs[1] = region.v2;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tuvs[0] = region.u;\r\n\t\t\t\tuvs[1] = region.v2;\r\n\t\t\t\tuvs[2] = region.u;\r\n\t\t\t\tuvs[3] = region.v;\r\n\t\t\t\tuvs[4] = region.u2;\r\n\t\t\t\tuvs[5] = region.v;\r\n\t\t\t\tuvs[6] = region.u2;\r\n\t\t\t\tuvs[7] = region.v2;\r\n\t\t\t}\r\n\t\t};\r\n\t\tRegionAttachment.prototype.computeWorldVertices = function (bone, worldVertices, offset, stride) {\r\n\t\t\tvar vertexOffset = this.offset;\r\n\t\t\tvar x = bone.worldX, y = bone.worldY;\r\n\t\t\tvar a = bone.a, b = bone.b, c = bone.c, d = bone.d;\r\n\t\t\tvar offsetX = 0, offsetY = 0;\r\n\t\t\toffsetX = vertexOffset[RegionAttachment.OX1];\r\n\t\t\toffsetY = vertexOffset[RegionAttachment.OY1];\r\n\t\t\tworldVertices[offset] = offsetX * a + offsetY * b + x;\r\n\t\t\tworldVertices[offset + 1] = offsetX * c + offsetY * d + y;\r\n\t\t\toffset += stride;\r\n\t\t\toffsetX = vertexOffset[RegionAttachment.OX2];\r\n\t\t\toffsetY = vertexOffset[RegionAttachment.OY2];\r\n\t\t\tworldVertices[offset] = offsetX * a + offsetY * b + x;\r\n\t\t\tworldVertices[offset + 1] = offsetX * c + offsetY * d + y;\r\n\t\t\toffset += stride;\r\n\t\t\toffsetX = vertexOffset[RegionAttachment.OX3];\r\n\t\t\toffsetY = vertexOffset[RegionAttachment.OY3];\r\n\t\t\tworldVertices[offset] = offsetX * a + offsetY * b + x;\r\n\t\t\tworldVertices[offset + 1] = offsetX * c + offsetY * d + y;\r\n\t\t\toffset += stride;\r\n\t\t\toffsetX = vertexOffset[RegionAttachment.OX4];\r\n\t\t\toffsetY = vertexOffset[RegionAttachment.OY4];\r\n\t\t\tworldVertices[offset] = offsetX * a + offsetY * b + x;\r\n\t\t\tworldVertices[offset + 1] = offsetX * c + offsetY * d + y;\r\n\t\t};\r\n\t\tRegionAttachment.OX1 = 0;\r\n\t\tRegionAttachment.OY1 = 1;\r\n\t\tRegionAttachment.OX2 = 2;\r\n\t\tRegionAttachment.OY2 = 3;\r\n\t\tRegionAttachment.OX3 = 4;\r\n\t\tRegionAttachment.OY3 = 5;\r\n\t\tRegionAttachment.OX4 = 6;\r\n\t\tRegionAttachment.OY4 = 7;\r\n\t\tRegionAttachment.X1 = 0;\r\n\t\tRegionAttachment.Y1 = 1;\r\n\t\tRegionAttachment.C1R = 2;\r\n\t\tRegionAttachment.C1G = 3;\r\n\t\tRegionAttachment.C1B = 4;\r\n\t\tRegionAttachment.C1A = 5;\r\n\t\tRegionAttachment.U1 = 6;\r\n\t\tRegionAttachment.V1 = 7;\r\n\t\tRegionAttachment.X2 = 8;\r\n\t\tRegionAttachment.Y2 = 9;\r\n\t\tRegionAttachment.C2R = 10;\r\n\t\tRegionAttachment.C2G = 11;\r\n\t\tRegionAttachment.C2B = 12;\r\n\t\tRegionAttachment.C2A = 13;\r\n\t\tRegionAttachment.U2 = 14;\r\n\t\tRegionAttachment.V2 = 15;\r\n\t\tRegionAttachment.X3 = 16;\r\n\t\tRegionAttachment.Y3 = 17;\r\n\t\tRegionAttachment.C3R = 18;\r\n\t\tRegionAttachment.C3G = 19;\r\n\t\tRegionAttachment.C3B = 20;\r\n\t\tRegionAttachment.C3A = 21;\r\n\t\tRegionAttachment.U3 = 22;\r\n\t\tRegionAttachment.V3 = 23;\r\n\t\tRegionAttachment.X4 = 24;\r\n\t\tRegionAttachment.Y4 = 25;\r\n\t\tRegionAttachment.C4R = 26;\r\n\t\tRegionAttachment.C4G = 27;\r\n\t\tRegionAttachment.C4B = 28;\r\n\t\tRegionAttachment.C4A = 29;\r\n\t\tRegionAttachment.U4 = 30;\r\n\t\tRegionAttachment.V4 = 31;\r\n\t\treturn RegionAttachment;\r\n\t}(spine.Attachment));\r\n\tspine.RegionAttachment = RegionAttachment;\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n\tvar JitterEffect = (function () {\r\n\t\tfunction JitterEffect(jitterX, jitterY) {\r\n\t\t\tthis.jitterX = 0;\r\n\t\t\tthis.jitterY = 0;\r\n\t\t\tthis.jitterX = jitterX;\r\n\t\t\tthis.jitterY = jitterY;\r\n\t\t}\r\n\t\tJitterEffect.prototype.begin = function (skeleton) {\r\n\t\t};\r\n\t\tJitterEffect.prototype.transform = function (position, uv, light, dark) {\r\n\t\t\tposition.x += spine.MathUtils.randomTriangular(-this.jitterX, this.jitterY);\r\n\t\t\tposition.y += spine.MathUtils.randomTriangular(-this.jitterX, this.jitterY);\r\n\t\t};\r\n\t\tJitterEffect.prototype.end = function () {\r\n\t\t};\r\n\t\treturn JitterEffect;\r\n\t}());\r\n\tspine.JitterEffect = JitterEffect;\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n\tvar SwirlEffect = (function () {\r\n\t\tfunction SwirlEffect(radius) {\r\n\t\t\tthis.centerX = 0;\r\n\t\t\tthis.centerY = 0;\r\n\t\t\tthis.radius = 0;\r\n\t\t\tthis.angle = 0;\r\n\t\t\tthis.worldX = 0;\r\n\t\t\tthis.worldY = 0;\r\n\t\t\tthis.radius = radius;\r\n\t\t}\r\n\t\tSwirlEffect.prototype.begin = function (skeleton) {\r\n\t\t\tthis.worldX = skeleton.x + this.centerX;\r\n\t\t\tthis.worldY = skeleton.y + this.centerY;\r\n\t\t};\r\n\t\tSwirlEffect.prototype.transform = function (position, uv, light, dark) {\r\n\t\t\tvar radAngle = this.angle * spine.MathUtils.degreesToRadians;\r\n\t\t\tvar x = position.x - this.worldX;\r\n\t\t\tvar y = position.y - this.worldY;\r\n\t\t\tvar dist = Math.sqrt(x * x + y * y);\r\n\t\t\tif (dist < this.radius) {\r\n\t\t\t\tvar theta = SwirlEffect.interpolation.apply(0, radAngle, (this.radius - dist) / this.radius);\r\n\t\t\t\tvar cos = Math.cos(theta);\r\n\t\t\t\tvar sin = Math.sin(theta);\r\n\t\t\t\tposition.x = cos * x - sin * y + this.worldX;\r\n\t\t\t\tposition.y = sin * x + cos * y + this.worldY;\r\n\t\t\t}\r\n\t\t};\r\n\t\tSwirlEffect.prototype.end = function () {\r\n\t\t};\r\n\t\tSwirlEffect.interpolation = new spine.PowOut(2);\r\n\t\treturn SwirlEffect;\r\n\t}());\r\n\tspine.SwirlEffect = SwirlEffect;\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n\tvar canvas;\r\n\t(function (canvas) {\r\n\t\tvar AssetManager = (function (_super) {\r\n\t\t\t__extends(AssetManager, _super);\r\n\t\t\tfunction AssetManager(pathPrefix) {\r\n\t\t\t\tif (pathPrefix === void 0) { pathPrefix = \"\"; }\r\n\t\t\t\treturn _super.call(this, function (image) { return new spine.canvas.CanvasTexture(image); }, pathPrefix) || this;\r\n\t\t\t}\r\n\t\t\treturn AssetManager;\r\n\t\t}(spine.AssetManager));\r\n\t\tcanvas.AssetManager = AssetManager;\r\n\t})(canvas = spine.canvas || (spine.canvas = {}));\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n\tvar canvas;\r\n\t(function (canvas) {\r\n\t\tvar CanvasTexture = (function (_super) {\r\n\t\t\t__extends(CanvasTexture, _super);\r\n\t\t\tfunction CanvasTexture(image) {\r\n\t\t\t\treturn _super.call(this, image) || this;\r\n\t\t\t}\r\n\t\t\tCanvasTexture.prototype.setFilters = function (minFilter, magFilter) { };\r\n\t\t\tCanvasTexture.prototype.setWraps = function (uWrap, vWrap) { };\r\n\t\t\tCanvasTexture.prototype.dispose = function () { };\r\n\t\t\treturn CanvasTexture;\r\n\t\t}(spine.Texture));\r\n\t\tcanvas.CanvasTexture = CanvasTexture;\r\n\t})(canvas = spine.canvas || (spine.canvas = {}));\r\n})(spine || (spine = {}));\r\nvar spine;\r\n(function (spine) {\r\n\tvar canvas;\r\n\t(function (canvas) {\r\n\t\tvar SkeletonRenderer = (function () {\r\n\t\t\tfunction SkeletonRenderer(context) {\r\n\t\t\t\tthis.triangleRendering = false;\r\n\t\t\t\tthis.debugRendering = false;\r\n\t\t\t\tthis.vertices = spine.Utils.newFloatArray(8 * 1024);\r\n\t\t\t\tthis.tempColor = new spine.Color();\r\n\t\t\t\tthis.ctx = context;\r\n\t\t\t}\r\n\t\t\tSkeletonRenderer.prototype.draw = function (skeleton) {\r\n\t\t\t\tif (this.triangleRendering)\r\n\t\t\t\t\tthis.drawTriangles(skeleton);\r\n\t\t\t\telse\r\n\t\t\t\t\tthis.drawImages(skeleton);\r\n\t\t\t};\r\n\t\t\tSkeletonRenderer.prototype.drawImages = function (skeleton) {\r\n\t\t\t\tvar ctx = this.ctx;\r\n\t\t\t\tvar drawOrder = skeleton.drawOrder;\r\n\t\t\t\tif (this.debugRendering)\r\n\t\t\t\t\tctx.strokeStyle = \"green\";\r\n\t\t\t\tctx.save();\r\n\t\t\t\tfor (var i = 0, n = drawOrder.length; i < n; i++) {\r\n\t\t\t\t\tvar slot = drawOrder[i];\r\n\t\t\t\t\tvar attachment = slot.getAttachment();\r\n\t\t\t\t\tvar regionAttachment = null;\r\n\t\t\t\t\tvar region = null;\r\n\t\t\t\t\tvar image = null;\r\n\t\t\t\t\tif (attachment instanceof spine.RegionAttachment) {\r\n\t\t\t\t\t\tregionAttachment = attachment;\r\n\t\t\t\t\t\tregion = regionAttachment.region;\r\n\t\t\t\t\t\timage = region.texture.getImage();\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\tvar skeleton_1 = slot.bone.skeleton;\r\n\t\t\t\t\tvar skeletonColor = skeleton_1.color;\r\n\t\t\t\t\tvar slotColor = slot.color;\r\n\t\t\t\t\tvar regionColor = regionAttachment.color;\r\n\t\t\t\t\tvar alpha = skeletonColor.a * slotColor.a * regionColor.a;\r\n\t\t\t\t\tvar color = this.tempColor;\r\n\t\t\t\t\tcolor.set(skeletonColor.r * slotColor.r * regionColor.r, skeletonColor.g * slotColor.g * regionColor.g, skeletonColor.b * slotColor.b * regionColor.b, alpha);\r\n\t\t\t\t\tvar att = attachment;\r\n\t\t\t\t\tvar bone = slot.bone;\r\n\t\t\t\t\tvar w = region.width;\r\n\t\t\t\t\tvar h = region.height;\r\n\t\t\t\t\tctx.save();\r\n\t\t\t\t\tctx.transform(bone.a, bone.c, bone.b, bone.d, bone.worldX, bone.worldY);\r\n\t\t\t\t\tctx.translate(attachment.offset[0], attachment.offset[1]);\r\n\t\t\t\t\tctx.rotate(attachment.rotation * Math.PI / 180);\r\n\t\t\t\t\tvar atlasScale = att.width / w;\r\n\t\t\t\t\tctx.scale(atlasScale * attachment.scaleX, atlasScale * attachment.scaleY);\r\n\t\t\t\t\tctx.translate(w / 2, h / 2);\r\n\t\t\t\t\tif (attachment.region.rotate) {\r\n\t\t\t\t\t\tvar t = w;\r\n\t\t\t\t\t\tw = h;\r\n\t\t\t\t\t\th = t;\r\n\t\t\t\t\t\tctx.rotate(-Math.PI / 2);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tctx.scale(1, -1);\r\n\t\t\t\t\tctx.translate(-w / 2, -h / 2);\r\n\t\t\t\t\tif (color.r != 1 || color.g != 1 || color.b != 1 || color.a != 1) {\r\n\t\t\t\t\t\tctx.globalAlpha = color.a;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tctx.drawImage(image, region.x, region.y, w, h, 0, 0, w, h);\r\n\t\t\t\t\tif (this.debugRendering)\r\n\t\t\t\t\t\tctx.strokeRect(0, 0, w, h);\r\n\t\t\t\t\tctx.restore();\r\n\t\t\t\t}\r\n\t\t\t\tctx.restore();\r\n\t\t\t};\r\n\t\t\tSkeletonRenderer.prototype.drawTriangles = function (skeleton) {\r\n\t\t\t\tvar blendMode = null;\r\n\t\t\t\tvar vertices = this.vertices;\r\n\t\t\t\tvar triangles = null;\r\n\t\t\t\tvar drawOrder = skeleton.drawOrder;\r\n\t\t\t\tfor (var i = 0, n = drawOrder.length; i < n; i++) {\r\n\t\t\t\t\tvar slot = drawOrder[i];\r\n\t\t\t\t\tvar attachment = slot.getAttachment();\r\n\t\t\t\t\tvar texture = null;\r\n\t\t\t\t\tvar region = null;\r\n\t\t\t\t\tif (attachment instanceof spine.RegionAttachment) {\r\n\t\t\t\t\t\tvar regionAttachment = attachment;\r\n\t\t\t\t\t\tvertices = this.computeRegionVertices(slot, regionAttachment, false);\r\n\t\t\t\t\t\ttriangles = SkeletonRenderer.QUAD_TRIANGLES;\r\n\t\t\t\t\t\tregion = regionAttachment.region;\r\n\t\t\t\t\t\ttexture = region.texture.getImage();\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse if (attachment instanceof spine.MeshAttachment) {\r\n\t\t\t\t\t\tvar mesh = attachment;\r\n\t\t\t\t\t\tvertices = this.computeMeshVertices(slot, mesh, false);\r\n\t\t\t\t\t\ttriangles = mesh.triangles;\r\n\t\t\t\t\t\ttexture = mesh.region.renderObject.texture.getImage();\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\tif (texture != null) {\r\n\t\t\t\t\t\tvar slotBlendMode = slot.data.blendMode;\r\n\t\t\t\t\t\tif (slotBlendMode != blendMode) {\r\n\t\t\t\t\t\t\tblendMode = slotBlendMode;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tvar skeleton_2 = slot.bone.skeleton;\r\n\t\t\t\t\t\tvar skeletonColor = skeleton_2.color;\r\n\t\t\t\t\t\tvar slotColor = slot.color;\r\n\t\t\t\t\t\tvar attachmentColor = attachment.color;\r\n\t\t\t\t\t\tvar alpha = skeletonColor.a * slotColor.a * attachmentColor.a;\r\n\t\t\t\t\t\tvar color = this.tempColor;\r\n\t\t\t\t\t\tcolor.set(skeletonColor.r * slotColor.r * attachmentColor.r, skeletonColor.g * slotColor.g * attachmentColor.g, skeletonColor.b * slotColor.b * attachmentColor.b, alpha);\r\n\t\t\t\t\t\tvar ctx = this.ctx;\r\n\t\t\t\t\t\tif (color.r != 1 || color.g != 1 || color.b != 1 || color.a != 1) {\r\n\t\t\t\t\t\t\tctx.globalAlpha = color.a;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tfor (var j = 0; j < triangles.length; j += 3) {\r\n\t\t\t\t\t\t\tvar t1 = triangles[j] * 8, t2 = triangles[j + 1] * 8, t3 = triangles[j + 2] * 8;\r\n\t\t\t\t\t\t\tvar x0 = vertices[t1], y0 = vertices[t1 + 1], u0 = vertices[t1 + 6], v0 = vertices[t1 + 7];\r\n\t\t\t\t\t\t\tvar x1 = vertices[t2], y1 = vertices[t2 + 1], u1 = vertices[t2 + 6], v1 = vertices[t2 + 7];\r\n\t\t\t\t\t\t\tvar x2 = vertices[t3], y2 = vertices[t3 + 1], u2 = vertices[t3 + 6], v2 = vertices[t3 + 7];\r\n\t\t\t\t\t\t\tthis.drawTriangle(texture, x0, y0, u0, v0, x1, y1, u1, v1, x2, y2, u2, v2);\r\n\t\t\t\t\t\t\tif (this.debugRendering) {\r\n\t\t\t\t\t\t\t\tctx.strokeStyle = \"green\";\r\n\t\t\t\t\t\t\t\tctx.beginPath();\r\n\t\t\t\t\t\t\t\tctx.moveTo(x0, y0);\r\n\t\t\t\t\t\t\t\tctx.lineTo(x1, y1);\r\n\t\t\t\t\t\t\t\tctx.lineTo(x2, y2);\r\n\t\t\t\t\t\t\t\tctx.lineTo(x0, y0);\r\n\t\t\t\t\t\t\t\tctx.stroke();\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tthis.ctx.globalAlpha = 1;\r\n\t\t\t};\r\n\t\t\tSkeletonRenderer.prototype.drawTriangle = function (img, x0, y0, u0, v0, x1, y1, u1, v1, x2, y2, u2, v2) {\r\n\t\t\t\tvar ctx = this.ctx;\r\n\t\t\t\tu0 *= img.width;\r\n\t\t\t\tv0 *= img.height;\r\n\t\t\t\tu1 *= img.width;\r\n\t\t\t\tv1 *= img.height;\r\n\t\t\t\tu2 *= img.width;\r\n\t\t\t\tv2 *= img.height;\r\n\t\t\t\tctx.beginPath();\r\n\t\t\t\tctx.moveTo(x0, y0);\r\n\t\t\t\tctx.lineTo(x1, y1);\r\n\t\t\t\tctx.lineTo(x2, y2);\r\n\t\t\t\tctx.closePath();\r\n\t\t\t\tx1 -= x0;\r\n\t\t\t\ty1 -= y0;\r\n\t\t\t\tx2 -= x0;\r\n\t\t\t\ty2 -= y0;\r\n\t\t\t\tu1 -= u0;\r\n\t\t\t\tv1 -= v0;\r\n\t\t\t\tu2 -= u0;\r\n\t\t\t\tv2 -= v0;\r\n\t\t\t\tvar det = 1 / (u1 * v2 - u2 * v1), a = (v2 * x1 - v1 * x2) * det, b = (v2 * y1 - v1 * y2) * det, c = (u1 * x2 - u2 * x1) * det, d = (u1 * y2 - u2 * y1) * det, e = x0 - a * u0 - c * v0, f = y0 - b * u0 - d * v0;\r\n\t\t\t\tctx.save();\r\n\t\t\t\tctx.transform(a, b, c, d, e, f);\r\n\t\t\t\tctx.clip();\r\n\t\t\t\tctx.drawImage(img, 0, 0);\r\n\t\t\t\tctx.restore();\r\n\t\t\t};\r\n\t\t\tSkeletonRenderer.prototype.computeRegionVertices = function (slot, region, pma) {\r\n\t\t\t\tvar skeleton = slot.bone.skeleton;\r\n\t\t\t\tvar skeletonColor = skeleton.color;\r\n\t\t\t\tvar slotColor = slot.color;\r\n\t\t\t\tvar regionColor = region.color;\r\n\t\t\t\tvar alpha = skeletonColor.a * slotColor.a * regionColor.a;\r\n\t\t\t\tvar multiplier = pma ? alpha : 1;\r\n\t\t\t\tvar color = this.tempColor;\r\n\t\t\t\tcolor.set(skeletonColor.r * slotColor.r * regionColor.r * multiplier, skeletonColor.g * slotColor.g * regionColor.g * multiplier, skeletonColor.b * slotColor.b * regionColor.b * multiplier, alpha);\r\n\t\t\t\tregion.computeWorldVertices(slot.bone, this.vertices, 0, SkeletonRenderer.VERTEX_SIZE);\r\n\t\t\t\tvar vertices = this.vertices;\r\n\t\t\t\tvar uvs = region.uvs;\r\n\t\t\t\tvertices[spine.RegionAttachment.C1R] = color.r;\r\n\t\t\t\tvertices[spine.RegionAttachment.C1G] = color.g;\r\n\t\t\t\tvertices[spine.RegionAttachment.C1B] = color.b;\r\n\t\t\t\tvertices[spine.RegionAttachment.C1A] = color.a;\r\n\t\t\t\tvertices[spine.RegionAttachment.U1] = uvs[0];\r\n\t\t\t\tvertices[spine.RegionAttachment.V1] = uvs[1];\r\n\t\t\t\tvertices[spine.RegionAttachment.C2R] = color.r;\r\n\t\t\t\tvertices[spine.RegionAttachment.C2G] = color.g;\r\n\t\t\t\tvertices[spine.RegionAttachment.C2B] = color.b;\r\n\t\t\t\tvertices[spine.RegionAttachment.C2A] = color.a;\r\n\t\t\t\tvertices[spine.RegionAttachment.U2] = uvs[2];\r\n\t\t\t\tvertices[spine.RegionAttachment.V2] = uvs[3];\r\n\t\t\t\tvertices[spine.RegionAttachment.C3R] = color.r;\r\n\t\t\t\tvertices[spine.RegionAttachment.C3G] = color.g;\r\n\t\t\t\tvertices[spine.RegionAttachment.C3B] = color.b;\r\n\t\t\t\tvertices[spine.RegionAttachment.C3A] = color.a;\r\n\t\t\t\tvertices[spine.RegionAttachment.U3] = uvs[4];\r\n\t\t\t\tvertices[spine.RegionAttachment.V3] = uvs[5];\r\n\t\t\t\tvertices[spine.RegionAttachment.C4R] = color.r;\r\n\t\t\t\tvertices[spine.RegionAttachment.C4G] = color.g;\r\n\t\t\t\tvertices[spine.RegionAttachment.C4B] = color.b;\r\n\t\t\t\tvertices[spine.RegionAttachment.C4A] = color.a;\r\n\t\t\t\tvertices[spine.RegionAttachment.U4] = uvs[6];\r\n\t\t\t\tvertices[spine.RegionAttachment.V4] = uvs[7];\r\n\t\t\t\treturn vertices;\r\n\t\t\t};\r\n\t\t\tSkeletonRenderer.prototype.computeMeshVertices = function (slot, mesh, pma) {\r\n\t\t\t\tvar skeleton = slot.bone.skeleton;\r\n\t\t\t\tvar skeletonColor = skeleton.color;\r\n\t\t\t\tvar slotColor = slot.color;\r\n\t\t\t\tvar regionColor = mesh.color;\r\n\t\t\t\tvar alpha = skeletonColor.a * slotColor.a * regionColor.a;\r\n\t\t\t\tvar multiplier = pma ? alpha : 1;\r\n\t\t\t\tvar color = this.tempColor;\r\n\t\t\t\tcolor.set(skeletonColor.r * slotColor.r * regionColor.r * multiplier, skeletonColor.g * slotColor.g * regionColor.g * multiplier, skeletonColor.b * slotColor.b * regionColor.b * multiplier, alpha);\r\n\t\t\t\tvar numVertices = mesh.worldVerticesLength / 2;\r\n\t\t\t\tif (this.vertices.length < mesh.worldVerticesLength) {\r\n\t\t\t\t\tthis.vertices = spine.Utils.newFloatArray(mesh.worldVerticesLength);\r\n\t\t\t\t}\r\n\t\t\t\tvar vertices = this.vertices;\r\n\t\t\t\tmesh.computeWorldVertices(slot, 0, mesh.worldVerticesLength, vertices, 0, SkeletonRenderer.VERTEX_SIZE);\r\n\t\t\t\tvar uvs = mesh.uvs;\r\n\t\t\t\tfor (var i = 0, n = numVertices, u = 0, v = 2; i < n; i++) {\r\n\t\t\t\t\tvertices[v++] = color.r;\r\n\t\t\t\t\tvertices[v++] = color.g;\r\n\t\t\t\t\tvertices[v++] = color.b;\r\n\t\t\t\t\tvertices[v++] = color.a;\r\n\t\t\t\t\tvertices[v++] = uvs[u++];\r\n\t\t\t\t\tvertices[v++] = uvs[u++];\r\n\t\t\t\t\tv += 2;\r\n\t\t\t\t}\r\n\t\t\t\treturn vertices;\r\n\t\t\t};\r\n\t\t\tSkeletonRenderer.QUAD_TRIANGLES = [0, 1, 2, 2, 3, 0];\r\n\t\t\tSkeletonRenderer.VERTEX_SIZE = 2 + 2 + 4;\r\n\t\t\treturn SkeletonRenderer;\r\n\t\t}());\r\n\t\tcanvas.SkeletonRenderer = SkeletonRenderer;\r\n\t})(canvas = spine.canvas || (spine.canvas = {}));\r\n})(spine || (spine = {}));\r\n//# sourceMappingURL=spine-canvas.js.map\n\n/*** EXPORTS FROM exports-loader ***/\nmodule.exports = spine;\n}.call(window));"],"sourceRoot":""}