{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap","webpack:////Users/rich/Documents/GitHub/phaser/node_modules/eventemitter3/index.js","webpack:////Users/rich/Documents/GitHub/phaser/src/data/DataManager.js","webpack:////Users/rich/Documents/GitHub/phaser/src/data/events/CHANGE_DATA_EVENT.js","webpack:////Users/rich/Documents/GitHub/phaser/src/data/events/CHANGE_DATA_KEY_EVENT.js","webpack:////Users/rich/Documents/GitHub/phaser/src/data/events/REMOVE_DATA_EVENT.js","webpack:////Users/rich/Documents/GitHub/phaser/src/data/events/SET_DATA_EVENT.js","webpack:////Users/rich/Documents/GitHub/phaser/src/data/events/index.js","webpack:////Users/rich/Documents/GitHub/phaser/src/gameobjects/BuildGameObject.js","webpack:////Users/rich/Documents/GitHub/phaser/src/gameobjects/GameObject.js","webpack:////Users/rich/Documents/GitHub/phaser/src/gameobjects/components/ComputedSize.js","webpack:////Users/rich/Documents/GitHub/phaser/src/gameobjects/components/Depth.js","webpack:////Users/rich/Documents/GitHub/phaser/src/gameobjects/components/Flip.js","webpack:////Users/rich/Documents/GitHub/phaser/src/gameobjects/components/ScrollFactor.js","webpack:////Users/rich/Documents/GitHub/phaser/src/gameobjects/components/ToJSON.js","webpack:////Users/rich/Documents/GitHub/phaser/src/gameobjects/components/Transform.js","webpack:////Users/rich/Documents/GitHub/phaser/src/gameobjects/components/TransformMatrix.js","webpack:////Users/rich/Documents/GitHub/phaser/src/gameobjects/components/Visible.js","webpack:////Users/rich/Documents/GitHub/phaser/src/gameobjects/events/DESTROY_EVENT.js","webpack:////Users/rich/Documents/GitHub/phaser/src/gameobjects/events/index.js","webpack:////Users/rich/Documents/GitHub/phaser/src/loader/File.js","webpack:////Users/rich/Documents/GitHub/phaser/src/loader/FileTypesManager.js","webpack:////Users/rich/Documents/GitHub/phaser/src/loader/GetURL.js","webpack:////Users/rich/Documents/GitHub/phaser/src/loader/MergeXHRSettings.js","webpack:////Users/rich/Documents/GitHub/phaser/src/loader/MultiFile.js","webpack:////Users/rich/Documents/GitHub/phaser/src/loader/XHRLoader.js","webpack:////Users/rich/Documents/GitHub/phaser/src/loader/XHRSettings.js","webpack:////Users/rich/Documents/GitHub/phaser/src/loader/const.js","webpack:////Users/rich/Documents/GitHub/phaser/src/loader/events/ADD_EVENT.js","webpack:////Users/rich/Documents/GitHub/phaser/src/loader/events/COMPLETE_EVENT.js","webpack:////Users/rich/Documents/GitHub/phaser/src/loader/events/FILE_COMPLETE_EVENT.js","webpack:////Users/rich/Documents/GitHub/phaser/src/loader/events/FILE_KEY_COMPLETE_EVENT.js","webpack:////Users/rich/Documents/GitHub/phaser/src/loader/events/FILE_LOAD_ERROR_EVENT.js","webpack:////Users/rich/Documents/GitHub/phaser/src/loader/events/FILE_LOAD_EVENT.js","webpack:////Users/rich/Documents/GitHub/phaser/src/loader/events/FILE_PROGRESS_EVENT.js","webpack:////Users/rich/Documents/GitHub/phaser/src/loader/events/POST_PROCESS_EVENT.js","webpack:////Users/rich/Documents/GitHub/phaser/src/loader/events/PROGRESS_EVENT.js","webpack:////Users/rich/Documents/GitHub/phaser/src/loader/events/START_EVENT.js","webpack:////Users/rich/Documents/GitHub/phaser/src/loader/events/index.js","webpack:////Users/rich/Documents/GitHub/phaser/src/loader/filetypes/ImageFile.js","webpack:////Users/rich/Documents/GitHub/phaser/src/loader/filetypes/JSONFile.js","webpack:////Users/rich/Documents/GitHub/phaser/src/loader/filetypes/TextFile.js","webpack:////Users/rich/Documents/GitHub/phaser/src/math/Average.js","webpack:////Users/rich/Documents/GitHub/phaser/src/math/Bernstein.js","webpack:////Users/rich/Documents/GitHub/phaser/src/math/Between.js","webpack:////Users/rich/Documents/GitHub/phaser/src/math/CatmullRom.js","webpack:////Users/rich/Documents/GitHub/phaser/src/math/CeilTo.js","webpack:////Users/rich/Documents/GitHub/phaser/src/math/Clamp.js","webpack:////Users/rich/Documents/GitHub/phaser/src/math/DegToRad.js","webpack:////Users/rich/Documents/GitHub/phaser/src/math/Difference.js","webpack:////Users/rich/Documents/GitHub/phaser/src/math/Factorial.js","webpack:////Users/rich/Documents/GitHub/phaser/src/math/FloatBetween.js","webpack:////Users/rich/Documents/GitHub/phaser/src/math/FloorTo.js","webpack:////Users/rich/Documents/GitHub/phaser/src/math/FromPercent.js","webpack:////Users/rich/Documents/GitHub/phaser/src/math/GetSpeed.js","webpack:////Users/rich/Documents/GitHub/phaser/src/math/IsEven.js","webpack:////Users/rich/Documents/GitHub/phaser/src/math/IsEvenStrict.js","webpack:////Users/rich/Documents/GitHub/phaser/src/math/Linear.js","webpack:////Users/rich/Documents/GitHub/phaser/src/math/Matrix3.js","webpack:////Users/rich/Documents/GitHub/phaser/src/math/Matrix4.js","webpack:////Users/rich/Documents/GitHub/phaser/src/math/MaxAdd.js","webpack:////Users/rich/Documents/GitHub/phaser/src/math/MinSub.js","webpack:////Users/rich/Documents/GitHub/phaser/src/math/Percent.js","webpack:////Users/rich/Documents/GitHub/phaser/src/math/Quaternion.js","webpack:////Users/rich/Documents/GitHub/phaser/src/math/RadToDeg.js","webpack:////Users/rich/Documents/GitHub/phaser/src/math/RandomXY.js","webpack:////Users/rich/Documents/GitHub/phaser/src/math/RandomXYZ.js","webpack:////Users/rich/Documents/GitHub/phaser/src/math/RandomXYZW.js","webpack:////Users/rich/Documents/GitHub/phaser/src/math/Rotate.js","webpack:////Users/rich/Documents/GitHub/phaser/src/math/RotateAround.js","webpack:////Users/rich/Documents/GitHub/phaser/src/math/RotateAroundDistance.js","webpack:////Users/rich/Documents/GitHub/phaser/src/math/RotateVec3.js","webpack:////Users/rich/Documents/GitHub/phaser/src/math/RoundAwayFromZero.js","webpack:////Users/rich/Documents/GitHub/phaser/src/math/RoundTo.js","webpack:////Users/rich/Documents/GitHub/phaser/src/math/SinCosTableGenerator.js","webpack:////Users/rich/Documents/GitHub/phaser/src/math/SmoothStep.js","webpack:////Users/rich/Documents/GitHub/phaser/src/math/SmootherStep.js","webpack:////Users/rich/Documents/GitHub/phaser/src/math/ToXY.js","webpack:////Users/rich/Documents/GitHub/phaser/src/math/TransformXY.js","webpack:////Users/rich/Documents/GitHub/phaser/src/math/Vector2.js","webpack:////Users/rich/Documents/GitHub/phaser/src/math/Vector3.js","webpack:////Users/rich/Documents/GitHub/phaser/src/math/Vector4.js","webpack:////Users/rich/Documents/GitHub/phaser/src/math/Within.js","webpack:////Users/rich/Documents/GitHub/phaser/src/math/Wrap.js","webpack:////Users/rich/Documents/GitHub/phaser/src/math/angle/Between.js","webpack:////Users/rich/Documents/GitHub/phaser/src/math/angle/BetweenPoints.js","webpack:////Users/rich/Documents/GitHub/phaser/src/math/angle/BetweenPointsY.js","webpack:////Users/rich/Documents/GitHub/phaser/src/math/angle/BetweenY.js","webpack:////Users/rich/Documents/GitHub/phaser/src/math/angle/CounterClockwise.js","webpack:////Users/rich/Documents/GitHub/phaser/src/math/angle/Normalize.js","webpack:////Users/rich/Documents/GitHub/phaser/src/math/angle/Reverse.js","webpack:////Users/rich/Documents/GitHub/phaser/src/math/angle/RotateTo.js","webpack:////Users/rich/Documents/GitHub/phaser/src/math/angle/ShortestBetween.js","webpack:////Users/rich/Documents/GitHub/phaser/src/math/angle/Wrap.js","webpack:////Users/rich/Documents/GitHub/phaser/src/math/angle/WrapDegrees.js","webpack:////Users/rich/Documents/GitHub/phaser/src/math/angle/index.js","webpack:////Users/rich/Documents/GitHub/phaser/src/math/const.js","webpack:////Users/rich/Documents/GitHub/phaser/src/math/distance/DistanceBetween.js","webpack:////Users/rich/Documents/GitHub/phaser/src/math/distance/DistancePower.js","webpack:////Users/rich/Documents/GitHub/phaser/src/math/distance/DistanceSquared.js","webpack:////Users/rich/Documents/GitHub/phaser/src/math/distance/index.js","webpack:////Users/rich/Documents/GitHub/phaser/src/math/easing/back/In.js","webpack:////Users/rich/Documents/GitHub/phaser/src/math/easing/back/InOut.js","webpack:////Users/rich/Documents/GitHub/phaser/src/math/easing/back/Out.js","webpack:////Users/rich/Documents/GitHub/phaser/src/math/easing/back/index.js","webpack:////Users/rich/Documents/GitHub/phaser/src/math/easing/bounce/In.js","webpack:////Users/rich/Documents/GitHub/phaser/src/math/easing/bounce/InOut.js","webpack:////Users/rich/Documents/GitHub/phaser/src/math/easing/bounce/Out.js","webpack:////Users/rich/Documents/GitHub/phaser/src/math/easing/bounce/index.js","webpack:////Users/rich/Documents/GitHub/phaser/src/math/easing/circular/In.js","webpack:////Users/rich/Documents/GitHub/phaser/src/math/easing/circular/InOut.js","webpack:////Users/rich/Documents/GitHub/phaser/src/math/easing/circular/Out.js","webpack:////Users/rich/Documents/GitHub/phaser/src/math/easing/circular/index.js","webpack:////Users/rich/Documents/GitHub/phaser/src/math/easing/cubic/In.js","webpack:////Users/rich/Documents/GitHub/phaser/src/math/easing/cubic/InOut.js","webpack:////Users/rich/Documents/GitHub/phaser/src/math/easing/cubic/Out.js","webpack:////Users/rich/Documents/GitHub/phaser/src/math/easing/cubic/index.js","webpack:////Users/rich/Documents/GitHub/phaser/src/math/easing/elastic/In.js","webpack:////Users/rich/Documents/GitHub/phaser/src/math/easing/elastic/InOut.js","webpack:////Users/rich/Documents/GitHub/phaser/src/math/easing/elastic/Out.js","webpack:////Users/rich/Documents/GitHub/phaser/src/math/easing/elastic/index.js","webpack:////Users/rich/Documents/GitHub/phaser/src/math/easing/expo/In.js","webpack:////Users/rich/Documents/GitHub/phaser/src/math/easing/expo/InOut.js","webpack:////Users/rich/Documents/GitHub/phaser/src/math/easing/expo/Out.js","webpack:////Users/rich/Documents/GitHub/phaser/src/math/easing/expo/index.js","webpack:////Users/rich/Documents/GitHub/phaser/src/math/easing/index.js","webpack:////Users/rich/Documents/GitHub/phaser/src/math/easing/linear/Linear.js","webpack:////Users/rich/Documents/GitHub/phaser/src/math/easing/linear/index.js","webpack:////Users/rich/Documents/GitHub/phaser/src/math/easing/quadratic/In.js","webpack:////Users/rich/Documents/GitHub/phaser/src/math/easing/quadratic/InOut.js","webpack:////Users/rich/Documents/GitHub/phaser/src/math/easing/quadratic/Out.js","webpack:////Users/rich/Documents/GitHub/phaser/src/math/easing/quadratic/index.js","webpack:////Users/rich/Documents/GitHub/phaser/src/math/easing/quartic/In.js","webpack:////Users/rich/Documents/GitHub/phaser/src/math/easing/quartic/InOut.js","webpack:////Users/rich/Documents/GitHub/phaser/src/math/easing/quartic/Out.js","webpack:////Users/rich/Documents/GitHub/phaser/src/math/easing/quartic/index.js","webpack:////Users/rich/Documents/GitHub/phaser/src/math/easing/quintic/In.js","webpack:////Users/rich/Documents/GitHub/phaser/src/math/easing/quintic/InOut.js","webpack:////Users/rich/Documents/GitHub/phaser/src/math/easing/quintic/Out.js","webpack:////Users/rich/Documents/GitHub/phaser/src/math/easing/quintic/index.js","webpack:////Users/rich/Documents/GitHub/phaser/src/math/easing/sine/In.js","webpack:////Users/rich/Documents/GitHub/phaser/src/math/easing/sine/InOut.js","webpack:////Users/rich/Documents/GitHub/phaser/src/math/easing/sine/Out.js","webpack:////Users/rich/Documents/GitHub/phaser/src/math/easing/sine/index.js","webpack:////Users/rich/Documents/GitHub/phaser/src/math/easing/stepped/Stepped.js","webpack:////Users/rich/Documents/GitHub/phaser/src/math/easing/stepped/index.js","webpack:////Users/rich/Documents/GitHub/phaser/src/math/fuzzy/Ceil.js","webpack:////Users/rich/Documents/GitHub/phaser/src/math/fuzzy/Equal.js","webpack:////Users/rich/Documents/GitHub/phaser/src/math/fuzzy/Floor.js","webpack:////Users/rich/Documents/GitHub/phaser/src/math/fuzzy/GreaterThan.js","webpack:////Users/rich/Documents/GitHub/phaser/src/math/fuzzy/LessThan.js","webpack:////Users/rich/Documents/GitHub/phaser/src/math/fuzzy/index.js","webpack:////Users/rich/Documents/GitHub/phaser/src/math/index.js","webpack:////Users/rich/Documents/GitHub/phaser/src/math/interpolation/BezierInterpolation.js","webpack:////Users/rich/Documents/GitHub/phaser/src/math/interpolation/CatmullRomInterpolation.js","webpack:////Users/rich/Documents/GitHub/phaser/src/math/interpolation/CubicBezierInterpolation.js","webpack:////Users/rich/Documents/GitHub/phaser/src/math/interpolation/LinearInterpolation.js","webpack:////Users/rich/Documents/GitHub/phaser/src/math/interpolation/QuadraticBezierInterpolation.js","webpack:////Users/rich/Documents/GitHub/phaser/src/math/interpolation/SmoothStepInterpolation.js","webpack:////Users/rich/Documents/GitHub/phaser/src/math/interpolation/SmootherStepInterpolation.js","webpack:////Users/rich/Documents/GitHub/phaser/src/math/interpolation/index.js","webpack:////Users/rich/Documents/GitHub/phaser/src/math/pow2/GetPowerOfTwo.js","webpack:////Users/rich/Documents/GitHub/phaser/src/math/pow2/IsSizePowerOfTwo.js","webpack:////Users/rich/Documents/GitHub/phaser/src/math/pow2/IsValuePowerOfTwo.js","webpack:////Users/rich/Documents/GitHub/phaser/src/math/pow2/index.js","webpack:////Users/rich/Documents/GitHub/phaser/src/math/random-data-generator/RandomDataGenerator.js","webpack:////Users/rich/Documents/GitHub/phaser/src/math/snap/SnapCeil.js","webpack:////Users/rich/Documents/GitHub/phaser/src/math/snap/SnapFloor.js","webpack:////Users/rich/Documents/GitHub/phaser/src/math/snap/SnapTo.js","webpack:////Users/rich/Documents/GitHub/phaser/src/math/snap/index.js","webpack:////Users/rich/Documents/GitHub/phaser/src/plugins/BasePlugin.js","webpack:////Users/rich/Documents/GitHub/phaser/src/plugins/ScenePlugin.js","webpack:////Users/rich/Documents/GitHub/phaser/src/renderer/BlendModes.js","webpack:////Users/rich/Documents/GitHub/phaser/src/renderer/ScaleModes.js","webpack:////Users/rich/Documents/GitHub/phaser/src/renderer/canvas/utils/SetTransform.js","webpack:////Users/rich/Documents/GitHub/phaser/src/scale/events/RESIZE_EVENT.js","webpack:////Users/rich/Documents/GitHub/phaser/src/scene/events/BOOT_EVENT.js","webpack:////Users/rich/Documents/GitHub/phaser/src/scene/events/CREATE_EVENT.js","webpack:////Users/rich/Documents/GitHub/phaser/src/scene/events/DESTROY_EVENT.js","webpack:////Users/rich/Documents/GitHub/phaser/src/scene/events/PAUSE_EVENT.js","webpack:////Users/rich/Documents/GitHub/phaser/src/scene/events/POST_UPDATE_EVENT.js","webpack:////Users/rich/Documents/GitHub/phaser/src/scene/events/PRE_UPDATE_EVENT.js","webpack:////Users/rich/Documents/GitHub/phaser/src/scene/events/READY_EVENT.js","webpack:////Users/rich/Documents/GitHub/phaser/src/scene/events/RENDER_EVENT.js","webpack:////Users/rich/Documents/GitHub/phaser/src/scene/events/RESUME_EVENT.js","webpack:////Users/rich/Documents/GitHub/phaser/src/scene/events/SHUTDOWN_EVENT.js","webpack:////Users/rich/Documents/GitHub/phaser/src/scene/events/SLEEP_EVENT.js","webpack:////Users/rich/Documents/GitHub/phaser/src/scene/events/START_EVENT.js","webpack:////Users/rich/Documents/GitHub/phaser/src/scene/events/TRANSITION_COMPLETE_EVENT.js","webpack:////Users/rich/Documents/GitHub/phaser/src/scene/events/TRANSITION_INIT_EVENT.js","webpack:////Users/rich/Documents/GitHub/phaser/src/scene/events/TRANSITION_OUT_EVENT.js","webpack:////Users/rich/Documents/GitHub/phaser/src/scene/events/TRANSITION_START_EVENT.js","webpack:////Users/rich/Documents/GitHub/phaser/src/scene/events/TRANSITION_WAKE_EVENT.js","webpack:////Users/rich/Documents/GitHub/phaser/src/scene/events/UPDATE_EVENT.js","webpack:////Users/rich/Documents/GitHub/phaser/src/scene/events/WAKE_EVENT.js","webpack:////Users/rich/Documents/GitHub/phaser/src/scene/events/index.js","webpack:////Users/rich/Documents/GitHub/phaser/src/utils/Class.js","webpack:////Users/rich/Documents/GitHub/phaser/src/utils/NOOP.js","webpack:////Users/rich/Documents/GitHub/phaser/src/utils/object/Extend.js","webpack:////Users/rich/Documents/GitHub/phaser/src/utils/object/GetAdvancedValue.js","webpack:////Users/rich/Documents/GitHub/phaser/src/utils/object/GetFastValue.js","webpack:////Users/rich/Documents/GitHub/phaser/src/utils/object/GetValue.js","webpack:////Users/rich/Documents/GitHub/phaser/src/utils/object/IsPlainObject.js","webpack:///./SpineFile.js","webpack:///./SpinePlugin.js","webpack:///./events/COMPLETE_EVENT.js","webpack:///./events/DISPOSE_EVENT.js","webpack:///./events/END_EVENT.js","webpack:///./events/EVENT_EVENT.js","webpack:///./events/INTERRUPTED_EVENT.js","webpack:///./events/START_EVENT.js","webpack:///./events/index.js","webpack:///./gameobject/SpineGameObject.js","webpack:///./gameobject/SpineGameObjectCanvasRenderer.js","webpack:///./gameobject/SpineGameObjectRender.js","webpack:///./gameobject/SpineGameObjectWebGLRenderer.js","webpack:///./runtimes/spine-both.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;ACVA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,kDAA0C,gCAAgC;AAC1E;AACA;;AAEA;AACA;AACA;AACA,gEAAwD,kBAAkB;AAC1E;AACA,yDAAiD,cAAc;AAC/D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAyC,iCAAiC;AAC1E,wHAAgH,mBAAmB,EAAE;AACrI;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;;AAGA;AACA;;;;;;;;;;;;;AClFa;;AAEb;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,EAAE;AACb,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,aAAa;AACxB,WAAW,gBAAgB;AAC3B,WAAW,SAAS;AACpB,WAAW,EAAE;AACb,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,aAAa;AACxB,WAAW,gBAAgB;AAC3B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,gBAAgB;AAC3B,aAAa,MAAM;AACnB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,yDAAyD,OAAO;AAChE;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,gBAAgB;AAC3B,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,gBAAgB;AAC3B,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,yCAAyC,SAAS;AAClD;AACA;;AAEA;AACA,GAAG;AACH;AACA;;AAEA,eAAe,YAAY;AAC3B;;AAEA;AACA,2DAA2D;AAC3D,+DAA+D;AAC/D,mEAAmE;AACnE,uEAAuE;AACvE;AACA,0DAA0D,SAAS;AACnE;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,gBAAgB;AAC3B,WAAW,SAAS;AACpB,WAAW,EAAE;AACb,aAAa,aAAa;AAC1B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,gBAAgB;AAC3B,WAAW,SAAS;AACpB,WAAW,EAAE;AACb,aAAa,aAAa;AAC1B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,gBAAgB;AAC3B,WAAW,SAAS;AACpB,WAAW,EAAE;AACb,WAAW,QAAQ;AACnB,aAAa,aAAa;AAC1B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,2DAA2D,YAAY;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,gBAAgB;AAC3B,aAAa,aAAa;AAC1B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI,IAA6B;AACjC;AACA;;;;;;;;;;;;AC/UA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA,YAAY,mBAAO,CAAC,mDAAgB;AACpC,aAAa,mBAAO,CAAC,mDAAU;;AAE/B;AACA;AACA;AACA,WAAW,EAAE;AACb,WAAW,OAAO;AAClB,WAAW,EAAE;AACb,WAAW,KAAK;AAChB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,2BAA2B;AACtC;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,kBAAkB;AACjC;AACA,gBAAgB,EAAE;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,2BAA2B,gBAAgB;AAC3C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,mBAAmB;AACnC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,gBAAgB,mBAAmB;AACnC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,2DAA2D;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,gBAAgB;AAC/B,eAAe,EAAE;AACjB;AACA,gBAAgB,wBAAwB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,EAAE;AACjB;AACA,gBAAgB,wBAAwB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,iBAAiB;;AAEjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,aAAa;;AAEb;;AAEA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,iBAAiB;AAChC,eAAe,EAAE;AACjB,eAAe,KAAK;AACpB;AACA,gBAAgB,wBAAwB;AACxC;AACA;AACA;AACA;;AAEA,uBAAuB,sBAAsB;AAC7C;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,mBAAmB;AAClC,eAAe,QAAQ;AACvB;AACA,gBAAgB,wBAAwB;AACxC;AACA;AACA;AACA,sCAAsC,kBAAkB;;AAExD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,kBAAkB;AACjC;AACA,gBAAgB,wBAAwB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,2BAA2B,gBAAgB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,gBAAgB,wBAAwB;AACxC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,gBAAgB,EAAE;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA,gBAAgB,wBAAwB;AACxC;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,wBAAwB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,CAAC;;AAED;;;;;;;;;;;;AC1nBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,IAAI;AACf,WAAW,OAAO;AAClB,WAAW,IAAI;AACf,WAAW,IAAI;AACf;AACA;;;;;;;;;;;;ACzBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,IAAI;AACf,WAAW,OAAO;AAClB,WAAW,IAAI;AACf,WAAW,IAAI;AACf;AACA;;;;;;;;;;;;ACxBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,IAAI;AACf,WAAW,OAAO;AAClB,WAAW,IAAI;AACf;AACA;;;;;;;;;;;;ACrBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,IAAI;AACf,WAAW,OAAO;AAClB,WAAW,IAAI;AACf;AACA;;;;;;;;;;;;ACrBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;;AAEA;;AAEA,iBAAiB,mBAAO,CAAC,0EAAqB;AAC9C,qBAAqB,mBAAO,CAAC,kFAAyB;AACtD,iBAAiB,mBAAO,CAAC,0EAAqB;AAC9C,cAAc,mBAAO,CAAC,oEAAkB;;AAExC;;;;;;;;;;;;ACjBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA,iBAAiB,mBAAO,CAAC,mEAAwB;AACjD,uBAAuB,mBAAO,CAAC,uFAAkC;AACjE,iBAAiB,mBAAO,CAAC,mEAAwB;;AAEjD;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,aAAa;AACxB,WAAW,8BAA8B;AACzC,WAAW,0CAA0C;AACrD;AACA,YAAY,8BAA8B;AAC1C;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,iBAAiB,WAAW,KAAK,SAAS;;AAE1C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,kBAAkB,KAAK,gBAAgB;;AAExD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA,iBAAiB,cAAc,KAAK,UAAU;;AAE9C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;;AC9HA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA,YAAY,mBAAO,CAAC,mDAAgB;AACpC,uBAAuB,mBAAO,CAAC,0EAAqB;AACpD,kBAAkB,mBAAO,CAAC,6DAAqB;AAC/C,mBAAmB,mBAAO,CAAC,mEAAe;AAC1C,aAAa,mBAAO,CAAC,0DAAU;;AAE/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,aAAa;AACxB,WAAW,OAAO;AAClB;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,iBAAiB;AAChC;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,2DAA2D;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,gBAAgB;AAC/B,eAAe,EAAE;AACjB;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,kBAAkB;AACjC;AACA,gBAAgB,EAAE;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,4CAA4C;AAC3D,eAAe,mCAAmC;AAClD,eAAe,QAAQ;AACvB;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA;;AAEA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,KAAK;AACpB;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,wCAAwC;AACxD;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,8BAA8B;AAC7C;AACA,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,UAAU;AAC1B;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA,sCAAsC,mBAAmB;;AAEzD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA,CAAC;;AAED;AACA;AACA;AACA,cAAc,QAAQ;AACtB;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;AC1nBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;;;;;;;;;;;AC9IA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA,kCAAkC,WAAW;;AAE7C;;AAEA;AACA;;AAEA;;AAEA;;;;;;;;;;;;ACtFA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;;;;;;;;;;;AC7JA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA,8BAA8B,OAAO;;AAErC;AACA;;AAEA;AACA;;AAEA;;AAEA;;;;;;;;;;;;ACpGA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,8BAA8B;AACzC;AACA,YAAY,wCAAwC;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;;ACvDA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA,iBAAiB,mBAAO,CAAC,oDAAkB;AAC3C,sBAAsB,mBAAO,CAAC,iFAAmB;AACjD,gBAAgB,mBAAO,CAAC,8DAAuB;AAC/C,uBAAuB,mBAAO,CAAC,4EAA8B;;AAE7D;AACA,cAAc;;AAEd;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA,8BAA8B,OAAO;AACrC,8BAA8B,OAAO;AACrC,8BAA8B,OAAO;AACrC,8BAA8B,OAAO;;AAErC;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA,8BAA8B,OAAO;AACrC,8BAA8B,OAAO;AACrC,kCAAkC,oCAAoC;AACtE,mCAAmC,sCAAsC;;AAEzE;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA,oCAAoC,aAAa;;AAEjD;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA,oCAAoC,aAAa;;AAEjD;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA,8BAA8B,OAAO;AACrC,8BAA8B,OAAO;;AAErC;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA,kCAAkC,WAAW;;AAE7C;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA,kCAAkC,WAAW;;AAE7C;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA,kCAAkC,WAAW;;AAE7C;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA,kCAAkC,WAAW;;AAE7C;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,8CAA8C;AAC7D;AACA,gBAAgB,8CAA8C;AAC9D;AACA;AACA;AACA,uCAAuC,oCAAoC;;AAE3E;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,8CAA8C;AAC7D,eAAe,8CAA8C;AAC7D;AACA,gBAAgB,8CAA8C;AAC9D;AACA;AACA;AACA,uCAAuC,oCAAoC;AAC3E,yCAAyC,sCAAsC;;AAE/E;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;;;;;;;;;;;AC/gBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA,YAAY,mBAAO,CAAC,sDAAmB;AACvC,iBAAiB,mBAAO,CAAC,oDAAkB;AAC3C,cAAc,mBAAO,CAAC,wDAAoB;;AAE1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;;AAEA;;AAEA;AACA;AACA,8BAA8B,OAAO;AACrC,8BAA8B,OAAO;AACrC,8BAA8B,OAAO;AACrC,8BAA8B,OAAO;AACrC,+BAA+B,QAAQ;AACvC,+BAA+B,QAAQ;;AAEvC;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,8CAA8C;AAC7D,eAAe,8CAA8C;AAC7D;AACA,gBAAgB,8CAA8C;AAC9D;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,8CAA8C;AAC7D,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,+CAA+C;AAC9D;AACA,gBAAgB,+CAA+C;AAC/D;AACA;AACA;AACA,kCAAkC,UAAU,cAAc;;AAE1D;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,8CAA8C;AAC7D;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,yBAAyB;AACxC;AACA,gBAAgB,yBAAyB;AACzC;AACA;AACA;AACA;;AAEA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,yBAAyB;AACxC;AACA,gBAAgB,yBAAyB;AACzC;AACA;AACA;AACA;;AAEA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB;AACA,gBAAgB,MAAM;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,oBAAoB;AACnC;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA,mCAAmC,wBAAwB;;AAE3D;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,CAAC;;AAED;;;;;;;;;;;;ACj8BA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA,cAAc;;AAEd;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;;;;;;AClFA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,8BAA8B;AACzC;AACA;;;;;;;;;;;;AClBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;;AAEA,kBAAkB,UAAU,mBAAO,CAAC,yEAAiB;;;;;;;;;;;;ACVrD;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA,YAAY,mBAAO,CAAC,mDAAgB;AACpC,YAAY,mBAAO,CAAC,6CAAS;AAC7B,aAAa,mBAAO,CAAC,qDAAU;AAC/B,mBAAmB,mBAAO,CAAC,+EAA8B;AACzD,aAAa,mBAAO,CAAC,+CAAU;AAC/B,uBAAuB,mBAAO,CAAC,mEAAoB;AACnD,gBAAgB,mBAAO,CAAC,qDAAa;AACrC,kBAAkB,mBAAO,CAAC,yDAAe;;AAEzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,2BAA2B;AACtC,WAAW,+BAA+B;AAC1C;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA,4GAA4G;AAC5G;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,2DAA2D;;AAE3D;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,mBAAmB;AAClC;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,eAAe;AAC9B,eAAe,cAAc;AAC7B;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,eAAe;AAC9B,eAAe,cAAc;AAC7B;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,cAAc;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,kBAAkB;;AAEnD;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,iBAAiB;AAC5B,WAAW,KAAK;AAChB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iEAAiE;AACjE;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,eAAe,2BAA2B;AAC1C;AACA;AACA;AACA;AACA;AACA,WAAW,iBAAiB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACthBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,2BAA2B;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;;;;;;;;;;;AC9DA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,mBAAmB;AAC9B,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;AClCA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA,aAAa,mBAAO,CAAC,mEAAwB;AAC7C,kBAAkB,mBAAO,CAAC,yDAAe;;AAEzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,sCAAsC;AACjD,WAAW,sCAAsC;AACjD;AACA,YAAY,sCAAsC;AAClD;AACA;AACA;AACA,mEAAmE;;AAEnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;;ACzCA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA,YAAY,mBAAO,CAAC,mDAAgB;;AAEpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,2BAA2B;AACtC,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,qBAAqB;AAChC;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA,uBAAuB,kBAAkB;AACzC;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,mBAAmB;AAClC;AACA,gBAAgB,wBAAwB;AACxC;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,mBAAmB;AAClC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,mBAAmB;AAClC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,CAAC;;AAED;;;;;;;;;;;;AC3LA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA,uBAAuB,mBAAO,CAAC,mEAAoB;;AAEnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,mBAAmB;AAC9B,WAAW,sCAAsC;AACjD;AACA,YAAY,eAAe;AAC3B;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;;;;;;;;;;;AC7DA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,2BAA2B;AACtC,WAAW,QAAQ;AACnB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB;AACA,YAAY,sCAAsC;AAClD;AACA;AACA;AACA,qCAAqC,mBAAmB;AACxD,8BAA8B,cAAc;AAC5C,6BAA6B,WAAW;AACxC,iCAAiC,eAAe;AAChD,gCAAgC,aAAa;;AAE7C;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;;ACzDA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;;AAEA;;;;;;;;;;;;ACjJA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO,wBAAwB,8BAA8B;AACxE,WAAW,2BAA2B;AACtC,WAAW,mBAAmB;AAC9B;AACA;;;;;;;;;;;;ACvBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,2BAA2B;AACtC,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACA;;;;;;;;;;;;ACrBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0FAA0F,uDAAuD;AACjJ;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO,wBAAwB,8BAA8B;AACxE,WAAW,IAAI;AACf;AACA;;;;;;;;;;;;ACtBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,oFAAoF,mDAAmD;AACvI;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO,wBAAwB,8BAA8B;AACxE,WAAW,IAAI;AACf;AACA;;;;;;;;;;;;AC/CA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,mBAAmB;AAC9B;AACA;;;;;;;;;;;;AClBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,mBAAmB;AAC9B;AACA;;;;;;;;;;;;ACnBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,mBAAmB;AAC9B,WAAW,OAAO;AAClB;AACA;;;;;;;;;;;;ACpBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,2BAA2B;AACtC;AACA;;;;;;;;;;;;ACtBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;;;;;;;;;;;;AClBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,2BAA2B;AACtC;AACA;;;;;;;;;;;;ACpBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;;AAEA;;AAEA,SAAS,mBAAO,CAAC,4DAAa;AAC9B,cAAc,mBAAO,CAAC,sEAAkB;AACxC,mBAAmB,mBAAO,CAAC,gFAAuB;AAClD,uBAAuB,mBAAO,CAAC,wFAA2B;AAC1D,qBAAqB,mBAAO,CAAC,oFAAyB;AACtD,eAAe,mBAAO,CAAC,wEAAmB;AAC1C,mBAAmB,mBAAO,CAAC,gFAAuB;AAClD,kBAAkB,mBAAO,CAAC,8EAAsB;AAChD,cAAc,mBAAO,CAAC,sEAAkB;AACxC,WAAW,mBAAO,CAAC,gEAAe;;AAElC;;;;;;;;;;;;ACvBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA,YAAY,mBAAO,CAAC,sDAAmB;AACvC,YAAY,mBAAO,CAAC,8CAAU;AAC9B,WAAW,mBAAO,CAAC,4CAAS;AAC5B,uBAAuB,mBAAO,CAAC,oEAAqB;AACpD,mBAAmB,mBAAO,CAAC,kFAAiC;AAC5D,oBAAoB,mBAAO,CAAC,oFAAkC;;AAE9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,2BAA2B;AACtC,WAAW,uDAAuD;AAClE,WAAW,gBAAgB;AAC3B,WAAW,sCAAsC;AACjD,WAAW,+CAA+C;AAC1D;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,uGAAuG;AAClH,WAAW,gBAAgB;AAC3B,WAAW,sCAAsC;AACjD;AACA,YAAY,2BAA2B;AACvC;AACA;AACA;AACA;AACA;AACA,uBAAuB,gBAAgB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,CAAC;;AAED;;;;;;;;;;;;AC3QA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA,YAAY,mBAAO,CAAC,sDAAmB;AACvC,YAAY,mBAAO,CAAC,8CAAU;AAC9B,WAAW,mBAAO,CAAC,4CAAS;AAC5B,uBAAuB,mBAAO,CAAC,oEAAqB;AACpD,mBAAmB,mBAAO,CAAC,kFAAiC;AAC5D,eAAe,mBAAO,CAAC,0EAA6B;AACpD,oBAAoB,mBAAO,CAAC,oFAAkC;;AAE9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,2BAA2B;AACtC,WAAW,sDAAsD;AACjE,WAAW,OAAO;AAClB,WAAW,sCAAsC;AACjD,WAAW,OAAO;AAClB;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA,QAAQ;AACR,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,qGAAqG;AAChH,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,sCAAsC;AACjD;AACA,YAAY,2BAA2B;AACvC;AACA;AACA;AACA;AACA;AACA,uBAAuB,gBAAgB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,CAAC;;AAED;;;;;;;;;;;;AC/NA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA,YAAY,mBAAO,CAAC,sDAAmB;AACvC,YAAY,mBAAO,CAAC,8CAAU;AAC9B,WAAW,mBAAO,CAAC,4CAAS;AAC5B,uBAAuB,mBAAO,CAAC,oEAAqB;AACpD,mBAAmB,mBAAO,CAAC,kFAAiC;AAC5D,oBAAoB,mBAAO,CAAC,oFAAkC;;AAE9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,2BAA2B;AACtC,WAAW,sDAAsD;AACjE,WAAW,OAAO;AAClB,WAAW,sCAAsC;AACjD;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,qGAAqG;AAChH,WAAW,OAAO;AAClB,WAAW,sCAAsC;AACjD;AACA,YAAY,2BAA2B;AACvC;AACA;AACA;AACA;AACA;AACA,uBAAuB,gBAAgB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,CAAC;;AAED;;;;;;;;;;;;ACxKA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;;AAEA,mBAAmB,mBAAmB;AACtC;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;;AC5BA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA,gBAAgB,mBAAO,CAAC,mDAAa;;AAErC;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACxBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACtBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;;AC9BA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA,8BAA8B,WAAW;AACzC,6BAA6B,WAAW;;AAExC;;AAEA;AACA;;AAEA;;;;;;;;;;;;AC9BA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACvBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA,YAAY,mBAAO,CAAC,2CAAS;;AAE7B;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACvBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACtBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;;ACjCA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACtBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA,8BAA8B,WAAW;AACzC,6BAA6B,WAAW;;AAExC;;AAEA;AACA;;AAEA;;;;;;;;;;;;AC9BA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA,YAAY,mBAAO,CAAC,2CAAS;;AAE7B;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;;AC3BA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACtBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;;;;;;ACxBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACtBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACvBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;;AAEA,YAAY,mBAAO,CAAC,mDAAgB;;AAEpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,oBAAoB;AAC/B;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,8DAA8D;AAC7E;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,8DAA8D;AAC7E;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,uBAAuB;AACtC;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,CAAC;;AAED;;;;;;;;;;;;AC1kBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;;AAEA,YAAY,mBAAO,CAAC,mDAAgB;;AAEpC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,oBAAoB;AAC/B;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,0CAA0C;AACzD;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,0CAA0C;AACzD;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,0CAA0C;AACzD,eAAe,OAAO;AACtB;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,oBAAoB;AACnC;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,uBAAuB;AACtC,eAAe,oBAAoB;AACnC;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,uBAAuB;AACtC;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC,eAAe,oBAAoB;AACnC,eAAe,oBAAoB;AACnC;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC,eAAe,oBAAoB;AACnC,eAAe,oBAAoB;AACnC,eAAe,oBAAoB;AACnC,eAAe,oBAAoB;AACnC;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,CAAC;;AAED;AACA;;AAEA;;;;;;;;;;;;AC/6CA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACvBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACvBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA,4BAA4B,eAAe;;AAE3C;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;;ACpDA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;;AAEA,YAAY,mBAAO,CAAC,mDAAgB;AACpC,cAAc,mBAAO,CAAC,+CAAW;AACjC,cAAc,mBAAO,CAAC,+CAAW;;AAEjC;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,6CAA6C;AAC5D;AACA,gBAAgB,uBAAuB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,gBAAgB;AAC/B,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA,gBAAgB,uBAAuB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,6CAA6C;AAC5D;AACA,gBAAgB,uBAAuB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,6CAA6C;AAC5D;AACA,gBAAgB,uBAAuB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,gBAAgB,uBAAuB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,uBAAuB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,6CAA6C;AAC5D;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,6CAA6C;AAC5D,eAAe,OAAO;AACtB;AACA,gBAAgB,uBAAuB;AACvC;AACA;AACA;AACA,8BAA8B,OAAO;;AAErC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC,eAAe,oBAAoB;AACnC;AACA,gBAAgB,uBAAuB;AACvC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC,eAAe,oBAAoB;AACnC,eAAe,oBAAoB;AACnC;AACA,gBAAgB,uBAAuB;AACvC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,uBAAuB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC,eAAe,OAAO;AACtB;AACA,gBAAgB,uBAAuB;AACvC;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,6CAA6C;AAC5D;AACA,gBAAgB,uBAAuB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,6CAA6C;AAC5D,eAAe,OAAO;AACtB;AACA,gBAAgB,uBAAuB;AACvC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,uBAAuB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,uBAAuB;AACvC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,gBAAgB,uBAAuB;AACvC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,gBAAgB,uBAAuB;AACvC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,gBAAgB,uBAAuB;AACvC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,uBAAuB;AACvC;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC;AACA,gBAAgB,uBAAuB;AACvC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,4CAA4C;;AAE5C;;AAEA,gCAAgC;;AAEhC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,CAAC;;AAED;;;;;;;;;;;;AC7vBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA,YAAY,mBAAO,CAAC,2CAAS;;AAE7B;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACvBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,oBAAoB;AAC/B,WAAW,OAAO;AAClB;AACA,YAAY,oBAAoB;AAChC;AACA;AACA;AACA,8BAA8B,WAAW;;AAEzC;;AAEA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;;ACjCA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,oBAAoB;AAC/B,WAAW,OAAO;AAClB;AACA,YAAY,oBAAoB;AAChC;AACA;AACA;AACA,+BAA+B,YAAY;;AAE3C;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;;AChCA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,oBAAoB;AAC/B,WAAW,OAAO;AAClB;AACA,YAAY,oBAAoB;AAChC;AACA;AACA;AACA,8BAA8B,WAAW;;AAEzC,2BAA2B;AAC3B;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;;AC9BA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,2BAA2B;AACtC,WAAW,OAAO;AAClB;AACA,YAAY,kBAAkB;AAC9B;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;;AC5BA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,2BAA2B;AACtC,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA,YAAY,kBAAkB;AAC9B;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;;ACjCA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,2BAA2B;AACtC,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA,YAAY,kBAAkB;AAC9B;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;;AC9BA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA,cAAc,mBAAO,CAAC,qDAAiB;AACvC,cAAc,mBAAO,CAAC,qDAAiB;AACvC,iBAAiB,mBAAO,CAAC,2DAAoB;;AAE7C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,oBAAoB;AAC/B,WAAW,oBAAoB;AAC/B,WAAW,OAAO;AAClB;AACA,YAAY,oBAAoB;AAChC;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;;;;;;ACzCA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACtBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA,8BAA8B,WAAW;AACzC,6BAA6B,WAAW;;AAExC;;AAEA;AACA;;AAEA;;;;;;;;;;;;AC7CA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA,YAAY,8BAA8B;AAC1C;AACA;AACA;AACA,+BAA+B,YAAY;AAC3C,+BAA+B,YAAY;AAC3C,kCAAkC,eAAe;;AAEjD;;AAEA;AACA;;AAEA,mBAAmB,YAAY;AAC/B;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;AC9CA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;;;;;;;;;;;ACxCA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,6BAA6B;AAC9E;AACA;AACA;AACA,SAAS;AACT;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;;AChCA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA,cAAc,mBAAO,CAAC,+CAAW;;AAEjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,oBAAoB;AAC/B;AACA,YAAY,oBAAoB;AAChC;AACA;AACA;AACA,4BAA4B,qBAAqB;;AAEjD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;;ACnDA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA,cAAc,mBAAO,CAAC,+CAAW;;AAEjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,+CAA+C;AAC1D;AACA,YAAY,+CAA+C;AAC3D;AACA;AACA;AACA,+BAA+B,wBAAwB;;AAEvD;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;;AChDA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;;AAEA,YAAY,mBAAO,CAAC,mDAAgB;;AAEpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,qCAAqC;AAChD,WAAW,OAAO;AAClB;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,OAAO;;AAEzC;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,8BAA8B;AAC7C;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA,8BAA8B,OAAO;;AAErC;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA,6BAA6B,YAAY;;AAEzC;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC;AACA,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC,eAAe,OAAO;AACtB;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA,8BAA8B,OAAO;;AAErC;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;;;;;;;;;;;;ACxnBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;;AAEA,YAAY,mBAAO,CAAC,mDAAgB;;AAEpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC,eAAe,oBAAoB;AACnC;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC;AACA,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,0CAA0C;AACzD;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,gBAAgB;AAC/B,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,0CAA0C;AACzD;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,0CAA0C;AACzD;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,0CAA0C;AACzD;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,0CAA0C;AACzD;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,0CAA0C;AACzD;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,0CAA0C;AACzD;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC,eAAe,OAAO;AACtB;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA,8BAA8B,OAAO;;AAErC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,uBAAuB;AACtC;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC,eAAe,oBAAoB;AACnC;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;;;;;;;;;;;;ACnyBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;;AAEA,YAAY,mBAAO,CAAC,mDAAgB;;AAEpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC;AACA,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,gBAAgB;AAC/B,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,8DAA8D;AAC7E;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,8DAA8D;AAC7E;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC,eAAe,OAAO;AACtB;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA,8BAA8B,OAAO;;AAErC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,8DAA8D;AAC7E;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,8DAA8D;AAC7E;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,8DAA8D;AAC7E;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,8DAA8D;AAC7E;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,uBAAuB;AACtC;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;AC1hBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACvBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;;ACzBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACxBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,2BAA2B;AACtC,WAAW,2BAA2B;AACtC;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACxBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA,2CAA2C,sCAAsC;AACjF;AACA;AACA;AACA;AACA;AACA,WAAW,2BAA2B;AACtC,WAAW,2BAA2B;AACtC;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACzBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA,2CAA2C,gCAAgC;AAC3E;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;AC3BA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA,YAAY,mBAAO,CAAC,4CAAU;;AAE9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;;ACtCA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;AC9BA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA,gBAAgB,mBAAO,CAAC,yDAAa;;AAErC;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACvBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA,iBAAiB,mBAAO,CAAC,4CAAU;;AAEnC;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA,6BAA6B,aAAa;;AAE1C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;;AC5DA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;;;;;;;;;;;AC1CA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA,eAAe,mBAAO,CAAC,0CAAS;;AAEhC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACzBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA,WAAW,mBAAO,CAAC,0CAAS;;AAE5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACzBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;;AAEA;;AAEA,aAAa,mBAAO,CAAC,qDAAW;AAChC,mBAAmB,mBAAO,CAAC,iEAAiB;AAC5C,oBAAoB,mBAAO,CAAC,mEAAkB;AAC9C,cAAc,mBAAO,CAAC,uDAAY;AAClC,sBAAsB,mBAAO,CAAC,uEAAoB;AAClD,eAAe,mBAAO,CAAC,yDAAa;AACpC,aAAa,mBAAO,CAAC,qDAAW;AAChC,cAAc,mBAAO,CAAC,uDAAY;AAClC,qBAAqB,mBAAO,CAAC,qEAAmB;AAChD,UAAU,mBAAO,CAAC,+CAAQ;AAC1B,iBAAiB,mBAAO,CAAC,6DAAe;;AAExC;;;;;;;;;;;;ACxBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;;AAEA;;;;;;;;;;;;ACjEA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;;AC3BA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA,4BAA4B,SAAS;;AAErC;AACA;;AAEA;;;;;;;;;;;;AC3BA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;;AC3BA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;;AAEA;;AAEA,aAAa,mBAAO,CAAC,wEAAmB;AACxC,WAAW,mBAAO,CAAC,oEAAiB;AACpC,aAAa,mBAAO,CAAC,wEAAmB;;AAExC;;;;;;;;;;;;AChBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA,kCAAkC,qBAAqB;;AAEvD;AACA;;AAEA;;;;;;;;;;;;ACxBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA,kCAAkC,qBAAqB;;AAEvD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACjCA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA,kCAAkC,qBAAqB;;AAEvD;AACA;;AAEA;;;;;;;;;;;;ACxBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;;AAEA;;AAEA,QAAQ,mBAAO,CAAC,iDAAM;AACtB,SAAS,mBAAO,CAAC,mDAAO;AACxB,WAAW,mBAAO,CAAC,uDAAS;;AAE5B;;;;;;;;;;;;AChBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACtCA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACzDA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACpCA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;;AAEA;;AAEA,QAAQ,mBAAO,CAAC,mDAAM;AACtB,SAAS,mBAAO,CAAC,qDAAO;AACxB,WAAW,mBAAO,CAAC,yDAAS;;AAE5B;;;;;;;;;;;;AChBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACrBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;AC5BA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACrBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;;AAEA;;AAEA,QAAQ,mBAAO,CAAC,qDAAM;AACtB,SAAS,mBAAO,CAAC,uDAAO;AACxB,WAAW,mBAAO,CAAC,2DAAS;;AAE5B;;;;;;;;;;;;AChBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACrBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;AC5BA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACrBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;;AAEA;;AAEA,QAAQ,mBAAO,CAAC,kDAAM;AACtB,SAAS,mBAAO,CAAC,oDAAO;AACxB,WAAW,mBAAO,CAAC,wDAAS;;AAE5B;;;;;;;;;;;;AChBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA,kCAAkC,iBAAiB;AACnD,+BAA+B,cAAc;;AAE7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;;;;;;AChDA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA,kCAAkC,iBAAiB;AACnD,+BAA+B,cAAc;;AAE7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACvDA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA,kCAAkC,iBAAiB;AACnD,+BAA+B,cAAc;;AAE7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;;;;;;AChDA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;;AAEA;;AAEA,QAAQ,mBAAO,CAAC,oDAAM;AACtB,SAAS,mBAAO,CAAC,sDAAO;AACxB,WAAW,mBAAO,CAAC,0DAAS;;AAE5B;;;;;;;;;;;;AChBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACrBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;AC5BA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACrBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;;AAEA;;AAEA,QAAQ,mBAAO,CAAC,iDAAM;AACtB,SAAS,mBAAO,CAAC,mDAAO;AACxB,WAAW,mBAAO,CAAC,uDAAS;;AAE5B;;;;;;;;;;;;AChBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;;AAEA;;AAEA,UAAU,mBAAO,CAAC,sDAAQ;AAC1B,YAAY,mBAAO,CAAC,0DAAU;AAC9B,cAAc,mBAAO,CAAC,8DAAY;AAClC,WAAW,mBAAO,CAAC,wDAAS;AAC5B,aAAa,mBAAO,CAAC,4DAAW;AAChC,UAAU,mBAAO,CAAC,sDAAQ;AAC1B,YAAY,mBAAO,CAAC,0DAAU;AAC9B,eAAe,mBAAO,CAAC,gEAAa;AACpC,aAAa,mBAAO,CAAC,4DAAW;AAChC,aAAa,mBAAO,CAAC,4DAAW;AAChC,UAAU,mBAAO,CAAC,sDAAQ;AAC1B,aAAa,mBAAO,CAAC,4DAAW;;AAEhC;;;;;;;;;;;;ACzBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACrBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;;AAEA,iBAAiB,mBAAO,CAAC,2DAAU;;;;;;;;;;;;ACVnC;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACrBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;AC5BA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACrBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;;AAEA;;AAEA,QAAQ,mBAAO,CAAC,sDAAM;AACtB,SAAS,mBAAO,CAAC,wDAAO;AACxB,WAAW,mBAAO,CAAC,4DAAS;;AAE5B;;;;;;;;;;;;AChBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACrBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;AC5BA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACrBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;;AAEA;;AAEA,QAAQ,mBAAO,CAAC,oDAAM;AACtB,SAAS,mBAAO,CAAC,sDAAO;AACxB,WAAW,mBAAO,CAAC,0DAAS;;AAE5B;;;;;;;;;;;;AChBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACrBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;AC5BA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACrBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;;AAEA;;AAEA,QAAQ,mBAAO,CAAC,oDAAM;AACtB,SAAS,mBAAO,CAAC,sDAAO;AACxB,WAAW,mBAAO,CAAC,0DAAS;;AAE5B;;;;;;;;;;;;AChBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;AChCA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;AChCA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;AChCA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;;AAEA;;AAEA,QAAQ,mBAAO,CAAC,iDAAM;AACtB,SAAS,mBAAO,CAAC,mDAAO;AACxB,WAAW,mBAAO,CAAC,uDAAS;;AAE5B;;;;;;;;;;;;AChBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA,8BAA8B,WAAW;;AAEzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACnCA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;;AAEA,iBAAiB,mBAAO,CAAC,8DAAW;;;;;;;;;;;;ACVpC;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA,gCAAgC,kBAAkB;;AAElD;AACA;;AAEA;;;;;;;;;;;;ACxBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA,gCAAgC,kBAAkB;;AAElD;AACA;;AAEA;;;;;;;;;;;;AC3BA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA,gCAAgC,kBAAkB;;AAElD;AACA;;AAEA;;;;;;;;;;;;ACxBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA,gCAAgC,kBAAkB;;AAElD;AACA;;AAEA;;;;;;;;;;;;AC3BA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA,gCAAgC,kBAAkB;;AAElD;AACA;;AAEA;;;;;;;;;;;;AC3BA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;;AAEA;;AAEA,UAAU,mBAAO,CAAC,+CAAQ;AAC1B,WAAW,mBAAO,CAAC,iDAAS;AAC5B,WAAW,mBAAO,CAAC,iDAAS;AAC5B,iBAAiB,mBAAO,CAAC,6DAAe;AACxC,cAAc,mBAAO,CAAC,uDAAY;;AAElC;;;;;;;;;;;;AClBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA,YAAY,mBAAO,CAAC,2CAAS;AAC7B,aAAa,mBAAO,CAAC,mEAAwB;;AAE7C;AACA;AACA;;AAEA;;AAEA;AACA,WAAW,mBAAO,CAAC,kDAAU;AAC7B,cAAc,mBAAO,CAAC,wDAAa;AACnC,YAAY,mBAAO,CAAC,oDAAW;AAC/B,WAAW,mBAAO,CAAC,kDAAU;AAC7B,mBAAmB,mBAAO,CAAC,kEAAkB;AAC7C,UAAU,mBAAO,CAAC,gDAAS;AAC3B,UAAU,mBAAO,CAAC,gDAAS;;AAE3B;AACA,yBAAyB,mBAAO,CAAC,mHAA6C;;AAE9E;AACA,aAAa,mBAAO,CAAC,+CAAW;AAChC,eAAe,mBAAO,CAAC,mDAAa;AACpC,aAAa,mBAAO,CAAC,+CAAW;AAChC,gBAAgB,mBAAO,CAAC,qDAAc;AACtC,YAAY,mBAAO,CAAC,6CAAU;AAC9B,WAAW,mBAAO,CAAC,2CAAS;AAC5B,cAAc,mBAAO,CAAC,iDAAY;AAClC,gBAAgB,mBAAO,CAAC,qDAAc;AACtC,eAAe,mBAAO,CAAC,mDAAa;AACpC,kBAAkB,mBAAO,CAAC,yDAAgB;AAC1C,aAAa,mBAAO,CAAC,+CAAW;AAChC,iBAAiB,mBAAO,CAAC,uDAAe;AACxC,cAAc,mBAAO,CAAC,iDAAY;AAClC,YAAY,mBAAO,CAAC,6CAAU;AAC9B,kBAAkB,mBAAO,CAAC,yDAAgB;AAC1C,YAAY,mBAAO,CAAC,6CAAU;AAC9B,YAAY,mBAAO,CAAC,6CAAU;AAC9B,YAAY,mBAAO,CAAC,6CAAU;AAC9B,aAAa,mBAAO,CAAC,+CAAW;AAChC,cAAc,mBAAO,CAAC,iDAAY;AAClC,cAAc,mBAAO,CAAC,iDAAY;AAClC,eAAe,mBAAO,CAAC,mDAAa;AACpC,gBAAgB,mBAAO,CAAC,qDAAc;AACtC,YAAY,mBAAO,CAAC,6CAAU;AAC9B,kBAAkB,mBAAO,CAAC,yDAAgB;AAC1C,0BAA0B,mBAAO,CAAC,yEAAwB;AAC1D,uBAAuB,mBAAO,CAAC,mEAAqB;AACpD,aAAa,mBAAO,CAAC,+CAAW;AAChC,0BAA0B,mBAAO,CAAC,yEAAwB;AAC1D,kBAAkB,mBAAO,CAAC,yDAAgB;AAC1C,gBAAgB,mBAAO,CAAC,qDAAc;AACtC,UAAU,mBAAO,CAAC,yCAAQ;AAC1B,iBAAiB,mBAAO,CAAC,uDAAe;AACxC,YAAY,mBAAO,CAAC,6CAAU;AAC9B,UAAU,mBAAO,CAAC,yCAAQ;;AAE1B;AACA,aAAa,mBAAO,CAAC,+CAAW;AAChC,aAAa,mBAAO,CAAC,+CAAW;AAChC,aAAa,mBAAO,CAAC,+CAAW;AAChC,aAAa,mBAAO,CAAC,+CAAW;AAChC,aAAa,mBAAO,CAAC,+CAAW;AAChC,gBAAgB,mBAAO,CAAC,qDAAc;AACtC,gBAAgB,mBAAO,CAAC,qDAAc;;AAEtC;;AAEA;;AAEA;;AAEA;;AAEA;;;;;;;;;;;;ACjFA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA,gBAAgB,mBAAO,CAAC,oDAAc;;AAEtC;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,QAAQ;AAC3B;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;;AChCA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA,iBAAiB,mBAAO,CAAC,sDAAe;;AAExC;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;;;;;;AClDA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;AC/DA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA,aAAa,mBAAO,CAAC,8CAAW;;AAEhC;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,WAAW,SAAS;AACpB,WAAW,QAAQ;AACnB;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACxCA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACpDA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA,iBAAiB,mBAAO,CAAC,sDAAe;;AAExC;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;AC1BA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA,mBAAmB,mBAAO,CAAC,0DAAiB;;AAE5C;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;AC1BA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;;AAEA;;AAEA,YAAY,mBAAO,CAAC,qFAAuB;AAC3C,gBAAgB,mBAAO,CAAC,6FAA2B;AACnD,iBAAiB,mBAAO,CAAC,+FAA4B;AACrD,YAAY,mBAAO,CAAC,qFAAuB;AAC3C,qBAAqB,mBAAO,CAAC,uGAAgC;AAC7D,gBAAgB,mBAAO,CAAC,6FAA2B;AACnD,kBAAkB,mBAAO,CAAC,iGAA6B;;AAEvD;;;;;;;;;;;;ACpBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;;ACvBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACvBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACrBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;;AAEA;;AAEA,aAAa,mBAAO,CAAC,gEAAiB;AACtC,YAAY,mBAAO,CAAC,sEAAoB;AACxC,aAAa,mBAAO,CAAC,wEAAqB;;AAE1C;;;;;;;;;;;;AChBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA,YAAY,mBAAO,CAAC,sDAAmB;;AAEvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,kBAAkB;AAC7B;AACA;;AAEA;;AAEA;AACA;AACA,kCAAkC,qDAAqD;;AAEvF;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA,oEAAoE;;AAEpE;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;;AAEA;;AAEA,uBAAuB,iBAAiB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;;AAEA;;AAEA,kDAAkD;AAClD,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,kBAAkB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,uBAAuB,wCAAwC;AAC/D;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;;AAEA,wBAAwB,UAAU;AAClC;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB;AACA,gBAAgB,EAAE;AAClB;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB;AACA,gBAAgB,EAAE;AAClB;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB;AACA,gBAAgB,MAAM;AACtB;AACA;AACA;AACA;;AAEA,yBAAyB,OAAO;AAChC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,CAAC;;AAED;;;;;;;;;;;;AC5eA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA,8BAA8B,WAAW;;AAEzC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;;ACrCA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA,8BAA8B,WAAW;;AAEzC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;;ACrCA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA,8BAA8B,WAAW;;AAEzC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;;ACpCA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;;AAEA;;AAEA,UAAU,mBAAO,CAAC,sDAAY;AAC9B,WAAW,mBAAO,CAAC,wDAAa;AAChC,QAAQ,mBAAO,CAAC,kDAAU;;AAE1B;;;;;;;;;;;;AChBA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA,YAAY,mBAAO,CAAC,mDAAgB;;AAEpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,6BAA6B;AACxC;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,KAAK;AACpB;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,CAAC;;AAED;;;;;;;;;;;;AC9KA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA,iBAAiB,mBAAO,CAAC,wDAAc;AACvC,YAAY,mBAAO,CAAC,mDAAgB;AACpC,kBAAkB,mBAAO,CAAC,2DAAiB;;AAE3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,aAAa;AACxB,WAAW,6BAA6B;AACxC;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,CAAC;;AAED;;;;;;;;;;;;AClFA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;AC5UA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;;AAEA;;;;;;;;;;;;AC/CA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,sCAAsC;AACjD,WAAW,yBAAyB;AACpC,WAAW,8BAA8B;AACzC,WAAW,8BAA8B;AACzC,WAAW,8CAA8C;AACzD;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;;;;;;;;;;;AC9EA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,oBAAoB;AAC/B,WAAW,oBAAoB;AAC/B,WAAW,oBAAoB;AAC/B,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;;;;;;;;;;;;ACxBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,sBAAsB;AACjC;AACA;;;;;;;;;;;;AClBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,aAAa;AACxB;AACA;;;;;;;;;;;;ACtBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,sBAAsB;AACjC;AACA;;;;;;;;;;;;ACpBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,sBAAsB;AACjC,WAAW,IAAI;AACf;AACA;;;;;;;;;;;;ACpBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB,eAAe;AACf;AACA,oBAAoB;AACpB,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,sBAAsB;AACjC,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;;;;;;;;;;;;AC9BA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB,eAAe;AACf;AACA,oBAAoB;AACpB,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,sBAAsB;AACjC,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;;;;;;;;;;;;AC9BA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,sBAAsB;AACjC,WAAW,IAAI;AACf;AACA;;;;;;;;;;;;ACrBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB,eAAe;AACf;AACA,oBAAoB;AACpB,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,4EAA4E;AACvF;AACA;;;;;;;;;;;;AC7BA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,sBAAsB;AACjC,WAAW,IAAI;AACf;AACA;;;;;;;;;;;;ACpBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,6CAA6C;AACpF;AACA;AACA;AACA;AACA,WAAW,sBAAsB;AACjC,WAAW,IAAI;AACf;AACA;;;;;;;;;;;;ACvBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,sBAAsB;AACjC,WAAW,IAAI;AACf;AACA;;;;;;;;;;;;ACpBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,sBAAsB;AACjC;AACA;;;;;;;;;;;;AClBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,oDAAoD;AAC3E,wBAAwB,qDAAqD;AAC7E,yBAAyB,sDAAsD;AAC/E,wBAAwB,qDAAqD;AAC7E,4BAA4B,yDAAyD;AACrF;AACA;AACA;AACA;AACA,WAAW,aAAa;AACxB;AACA;;;;;;;;;;;;AC7BA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,oDAAoD;AAC3E,wBAAwB,qDAAqD;AAC7E,yBAAyB,sDAAsD;AAC/E,wBAAwB,qDAAqD;AAC7E,4BAA4B,yDAAyD;AACrF;AACA;AACA;AACA;AACA,WAAW,aAAa;AACxB,WAAW,OAAO;AAClB;AACA;;;;;;;;;;;;AC9BA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,oDAAoD;AAC3E,wBAAwB,qDAAqD;AAC7E,yBAAyB,sDAAsD;AAC/E,wBAAwB,qDAAqD;AAC7E,4BAA4B,yDAAyD;AACrF;AACA;AACA;AACA;AACA,WAAW,aAAa;AACxB,WAAW,OAAO;AAClB;AACA;;;;;;;;;;;;AC3BA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,qDAAqD;AACpH;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,oDAAoD;AAC3E,wBAAwB,qDAAqD;AAC7E,yBAAyB,sDAAsD;AAC/E,wBAAwB,qDAAqD;AAC7E,4BAA4B,yDAAyD;AACrF;AACA;AACA;AACA;AACA,WAAW,aAAa;AACxB,WAAW,OAAO;AAClB;AACA;;;;;;;;;;;;ACjCA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA,4EAA4E,sDAAsD;AAClI;AACA;AACA;AACA;AACA;AACA,uBAAuB,oDAAoD;AAC3E,wBAAwB,qDAAqD;AAC7E,yBAAyB,sDAAsD;AAC/E,wBAAwB,qDAAqD;AAC7E,4BAA4B,yDAAyD;AACrF;AACA;AACA;AACA;AACA,WAAW,aAAa;AACxB,WAAW,OAAO;AAClB;AACA;;;;;;;;;;;;AC5BA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB,eAAe;AACf;AACA,oBAAoB;AACpB,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,sBAAsB;AACjC,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;;;;;;;;;;;;AC9BA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,sBAAsB;AACjC,WAAW,IAAI;AACf;AACA;;;;;;;;;;;;ACpBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;;AAEA;;AAEA,UAAU,mBAAO,CAAC,6DAAc;AAChC,YAAY,mBAAO,CAAC,iEAAgB;AACpC,aAAa,mBAAO,CAAC,mEAAiB;AACtC,WAAW,mBAAO,CAAC,+DAAe;AAClC,iBAAiB,mBAAO,CAAC,2EAAqB;AAC9C,gBAAgB,mBAAO,CAAC,yEAAoB;AAC5C,WAAW,mBAAO,CAAC,+DAAe;AAClC,YAAY,mBAAO,CAAC,iEAAgB;AACpC,YAAY,mBAAO,CAAC,iEAAgB;AACpC,cAAc,mBAAO,CAAC,qEAAkB;AACxC,WAAW,mBAAO,CAAC,+DAAe;AAClC,WAAW,mBAAO,CAAC,+DAAe;AAClC,yBAAyB,mBAAO,CAAC,2FAA6B;AAC9D,qBAAqB,mBAAO,CAAC,mFAAyB;AACtD,oBAAoB,mBAAO,CAAC,iFAAwB;AACpD,sBAAsB,mBAAO,CAAC,qFAA0B;AACxD,qBAAqB,mBAAO,CAAC,mFAAyB;AACtD,YAAY,mBAAO,CAAC,iEAAgB;AACpC,UAAU,mBAAO,CAAC,6DAAc;;AAEhC;;;;;;;;;;;;AChCA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iDAAiD;AACjD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,qBAAqB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,mBAAmB,mBAAmB;AACtC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;;;;;;ACvPA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACpBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA,oBAAoB,mBAAO,CAAC,mEAAiB;;AAE7C,WAAW,QAAQ;AACnB,WAAW,OAAO;AAClB,YAAY,OAAO;;AAEnB;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,UAAU,YAAY;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;;;;;;AC5FA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA,WAAW,mBAAO,CAAC,8CAAY;AAC/B,eAAe,mBAAO,CAAC,yDAAY;;AAEnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,EAAE;AACb;AACA,YAAY,EAAE;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;;AChFA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA,8CAA8C,aAAa,qBAAqB;AAChF;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,EAAE;AACb;AACA,YAAY,EAAE,oBAAoB;AAClC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACpCA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,EAAE;AACb;AACA,YAAY,EAAE;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uBAAuB,iBAAiB;AACxC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;AChEA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,6CAA6C;AAC7C;AACA;;AAEA;;;;;;;;;;;;ACjDA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA,YAAY,mBAAO,CAAC,6DAA0B;AAC9C,mBAAmB,mBAAO,CAAC,yFAAwC;AACnE,gBAAgB,mBAAO,CAAC,8FAA4C;AACpE,oBAAoB,mBAAO,CAAC,2FAAyC;AACrE,eAAe,mBAAO,CAAC,4FAA2C;AAClE,gBAAgB,mBAAO,CAAC,0EAAkC;AAC1D,eAAe,mBAAO,CAAC,4FAA2C;;AAElE;AACA,aAAa,OAAO;AACpB;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,kBAAkB;AAChC,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,kBAAkB;AAChC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,2BAA2B;AACtC,WAAW,sDAAsD;AACjE,WAAW,gBAAgB;AAC3B,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB,WAAW,kBAAkB;AAC7B,WAAW,kBAAkB;AAC7B;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;;AAEA;AACA;AACA;AACA;;AAEA,uBAAuB,qBAAqB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;;AAEjB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,uBAAuB,qBAAqB;AAC5C;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,mBAAmB;AAClC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,+BAA+B,oBAAoB;AACnD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,+BAA+B,qBAAqB;AACpD;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,2BAA2B,uBAAuB;AAClD;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,sCAAsC,mEAAmE;;AAEzG;AACA;AACA;;AAEA,CAAC;;AAED;;;;;;;;;;;;ACxPA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA,sBAAsB,mBAAO,CAAC,6FAA0C;AACxE,YAAY,mBAAO,CAAC,6DAA0B;AAC9C,eAAe,mBAAO,CAAC,iFAAoC;AAC3D,kBAAkB,mBAAO,CAAC,6EAAkC;AAC5D,gBAAgB,mBAAO,CAAC,mCAAa;AACrC,YAAY,mBAAO,CAAC,uCAAO;AAC3B,sBAAsB,mBAAO,CAAC,qEAA8B;AAC5D,kBAAkB,mBAAO,CAAC,yFAAwC;;AAElE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,aAAa;AACxB,WAAW,6BAA6B;AACxC;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,aAAa;AACb;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,aAAa;AACb;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,kCAAkC,cAAc;;AAEhD;;AAEA;AACA,KAAK;;AAEL;AACA;AACA,kCAAkC,cAAc;;AAEhD;;AAEA;AACA,KAAK;;AAEL;AACA;AACA,kCAAkC,cAAc;;AAEhD;;AAEA;AACA,KAAK;;AAEL;AACA;AACA,kCAAkC,cAAc;;AAEhD;;AAEA;AACA,KAAK;;AAEL;AACA;AACA,kCAAkC,cAAc;;AAEhD;;AAEA;AACA,KAAK;;AAEL;AACA;AACA,kCAAkC,cAAc;;AAEhD;;AAEA;AACA,KAAK;;AAEL;AACA;AACA,kCAAkC,cAAc;;AAEhD;;AAEA;AACA,KAAK;;AAEL;AACA;AACA,kCAAkC,cAAc;;AAEhD;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA,2BAA2B,gBAAgB;AAC3C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,iBAAiB;AAChC;AACA,gBAAgB,yBAAyB;AACzC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,QAAQ;AACvB;AACA,gBAAgB,yBAAyB;AACzC;AACA;AACA;AACA,mCAAmC,aAAa;;AAEhD;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;;AAEA,gBAAgB;AAChB,KAAK;;AAEL;AACA;AACA;;AAEA;;AAEA,gBAAgB;AAChB,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,CAAC;;AAED;;;;;;;;;;;;AC9jBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACZA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACZA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACZA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACZA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACZA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACZA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;;AAEA;;AAEA,cAAc,mBAAO,CAAC,oDAAkB;AACxC,aAAa,mBAAO,CAAC,kDAAiB;AACtC,SAAS,mBAAO,CAAC,0CAAa;AAC9B,WAAW,mBAAO,CAAC,8CAAe;AAClC,iBAAiB,mBAAO,CAAC,0DAAqB;AAC9C,WAAW,mBAAO,CAAC,8CAAe;;AAElC;;;;;;;;;;;;ACnBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA,YAAY,mBAAO,CAAC,gEAA6B;AACjD,YAAY,mBAAO,CAAC,8DAA4B;AAChD,6BAA6B,mBAAO,CAAC,gHAAqD;AAC1F,sBAAsB,mBAAO,CAAC,kGAA8C;AAC5E,qBAAqB,mBAAO,CAAC,gGAA6C;AAC1E,6BAA6B,mBAAO,CAAC,gHAAqD;AAC1F,0BAA0B,mBAAO,CAAC,0GAAkD;AACpF,wBAAwB,mBAAO,CAAC,sGAAgD;AAChF,kBAAkB,mBAAO,CAAC,qCAAY;AACtC,iBAAiB,mBAAO,CAAC,sFAAwC;AACjE,4BAA4B,mBAAO,CAAC,sEAAyB;AAC7D,mBAAmB,mBAAO,CAAC,8EAAoC;AAC/D,uBAAuB,mBAAO,CAAC,gGAA6C;AAC5E,eAAe,mBAAO,CAAC,oEAA+B;AACtD,eAAe,mBAAO,CAAC,oEAA+B;;AAEtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,aAAa;AACxB,WAAW,6BAA6B;AACxC;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA,kCAAkC,WAAW;;AAE7C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA,kCAAkC,kBAAkB;;AAEpD;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA,kCAAkC,6BAA6B;AAC/D,mCAAmC,+BAA+B;AAClE,oCAAoC,aAAa;AACjD,oCAAoC,aAAa;;AAEjD;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA,oCAAoC,aAAa;AACjD,oCAAoC,aAAa;;AAEjD;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA;;AAEA,KAAK;;AAEL;AACA;AACA;;AAEA;;AAEA;AACA;AACA,2BAA2B,+BAA+B;AAC1D;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;;AAEA;AACA;AACA,2BAA2B,+BAA+B;AAC1D;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;;AAEA,uBAAuB,2BAA2B;AAClD;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;;AAEA;AACA;AACA,2BAA2B,oCAAoC;AAC/D;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA,uCAAuC,gBAAgB;;AAEvD;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,qCAAqC;AACpD,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA,gBAAgB,8BAA8B;AAC9C;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,iCAAiC,cAAc;AAC/C,4CAA4C,yBAAyB;;AAErE;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,2BAA2B,qBAAqB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,mCAAmC,YAAY;AAC/C,qCAAqC,cAAc;AACnD,qCAAqC,gBAAgB;;AAErD;AACA;;AAEA;;AAEA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,CAAC;;AAED;;;;;;;;;;;;AC12BA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA,mBAAmB,mBAAO,CAAC,8GAAoD;;AAE/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,sCAAsC;AACjD,WAAW,mCAAmC;AAC9C,WAAW,OAAO;AAClB,WAAW,8BAA8B;AACzC,WAAW,8CAA8C;AACzD;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;;ACxDA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA,kBAAkB,mBAAO,CAAC,8DAA4B;AACtD,mBAAmB,mBAAO,CAAC,8DAA4B;;AAEvD,IAAI,IAAqB;AACzB;AACA,kBAAkB,mBAAO,CAAC,oFAAgC;AAC1D;;AAEA,IAAI,IAAsB;AAC1B;AACA,mBAAmB,mBAAO,CAAC,sFAAiC;AAC5D;;AAEA;;AAEA;AACA;;AAEA;;;;;;;;;;;;ACxBA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA,uBAAuB,mBAAO,CAAC,gGAA6C;AAC5E,eAAe,mBAAO,CAAC,oEAA+B;AACtD,WAAW,mBAAO,CAAC,4DAA2B;;AAE9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,oCAAoC;AAC/C,WAAW,gBAAgB;AAC3B,WAAW,OAAO;AAClB,WAAW,8BAA8B;AACzC,WAAW,8CAA8C;AACzD;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;;;;;;ACjKA;AACA;;AAEA;AACA;AACA;AACA,cAAc,gBAAgB,sCAAsC,iBAAiB,EAAE;AACvF,6BAA6B,uDAAuD;AACpF;AACA;AACA;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,OAAO;AACxD;AACA;AACA;AACA,kCAAkC,UAAU;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,WAAW;AACnE;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,mDAAmD;AACxD;AACA;AACA;AACA;AACA,KAAK,+DAA+D;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,+DAA+D;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,OAAO;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE,OAAO;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,iBAAiB;AAC5D;AACA;AACA;AACA;AACA,2CAA2C,iBAAiB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,mBAAmB;AAChE;AACA;AACA;AACA;AACA,6CAA6C,mBAAmB;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,mBAAmB;AACpE;AACA;AACA;AACA;AACA;AACA,iDAAiD,mBAAmB;AACpE;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,mBAAmB;AAChE;AACA;AACA;AACA;AACA;AACA,iDAAiD,mBAAmB;AACpE;AACA;AACA;AACA;AACA,iDAAiD,mBAAmB;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,mBAAmB;AAC5D;AACA;AACA;AACA;AACA;AACA,yCAAyC,mBAAmB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,oBAAoB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,oBAAoB;AAClE;AACA;AACA;AACA;AACA;AACA,8CAA8C,oBAAoB;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,oBAAoB;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,oBAAoB;AAClE;AACA;AACA;AACA;AACA;AACA,8CAA8C,oBAAoB;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,6CAA6C;AAC/D;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,OAAO;AACxE;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,yBAAyB,EAAE;AACzF;AACA;AACA;AACA;AACA;AACA,8CAA8C,OAAO;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,OAAO;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,oBAAoB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,oBAAoB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,mBAAmB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,mBAAmB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,OAAO;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,OAAO;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,OAAO;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,OAAO;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,OAAO;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,oBAAoB;AACnD;AACA;AACA;AACA;AACA;AACA,kCAAkC,oBAAoB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,cAAc;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,OAAO;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,oBAAoB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,uBAAuB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,uBAAuB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,uBAAuB;AAC/D;AACA;AACA;AACA;AACA;AACA,wCAAwC,uBAAuB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,uBAAuB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,uBAAuB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,sDAAsD;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA,wCAAwC,iBAAiB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,gBAAgB;AACrD,mCAAmC,cAAc;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,qCAAqC,gBAAgB;AACrD,mCAAmC,cAAc;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,gBAAgB;AACrD,mCAAmC,cAAc;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,gBAAgB;AACrD,mCAAmC,cAAc;AACjD;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yGAAyG;AACzG;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,qGAAqG;AACrG;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,2DAA2D,0BAA0B;AACrF;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,sDAAsD;AAC3D,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,kEAAkE;AACvE,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,uBAAuB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,OAAO;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,OAAO;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,iBAAiB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,eAAe;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,iBAAiB;AACpD;AACA;AACA;AACA,iDAAiD,iBAAiB;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,gBAAgB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,iBAAiB;AAChD;AACA;AACA;AACA;AACA,0DAA0D,iBAAiB;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,QAAQ;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK,+DAA+D;AACpE;AACA;AACA;AACA;AACA;AACA,KAAK,4DAA4D;AACjE;AACA;AACA;AACA;AACA;AACA,KAAK,yDAAyD;AAC9D,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,wCAAwC,iBAAiB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,gCAAgC;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,uBAAuB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,uBAAuB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,+BAA+B;AAC1D;AACA;AACA;AACA;AACA,2BAA2B,sCAAsC;AACjE;AACA;AACA;AACA;AACA,2BAA2B,iCAAiC;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,OAAO;AACpD;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,qBAAqB;AACvD,gCAAgC,cAAc;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,qBAAqB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,gBAAgB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,OAAO;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,OAAO;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,eAAe;AAC1C;AACA;AACA,2BAA2B,eAAe;AAC1C;AACA,2BAA2B,eAAe;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,eAAe;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,eAAe;AAC9C;AACA;AACA;AACA;AACA,4BAA4B,gBAAgB;AAC5C;AACA,4BAA4B,gBAAgB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,OAAO;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,OAAO;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,OAAO;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,OAAO;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,OAAO;AACpD;AACA;AACA,qDAAqD,OAAO;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,OAAO;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,OAAO;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,OAAO;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,OAAO;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,OAAO;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,OAAO;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,OAAO;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,OAAO;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,OAAO;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,OAAO;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,OAAO;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,OAAO;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,qBAAqB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,OAAO;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,SAAS;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,eAAe;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,OAAO;AACvD;AACA;AACA,qDAAqD,SAAS;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,OAAO;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,SAAS;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,OAAO;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,SAAS;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,SAAS;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,qBAAqB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,mBAAmB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,uBAAuB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,sBAAsB;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA,gCAAgC,0BAA0B;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,OAAO;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,OAAO;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gFAAgF,OAAO;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,OAAO;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,OAAO;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,OAAO;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,OAAO;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,OAAO;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,OAAO;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,OAAO;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,OAAO;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,OAAO;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,OAAO;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,OAAO;AAC9D;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,uBAAuB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,uBAAuB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,oBAAoB;AACnD;AACA;AACA;AACA,mCAAmC,gCAAgC;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,2BAA2B;AAC1D;AACA;AACA;AACA,mCAAmC,gCAAgC;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,sBAAsB;AACrD;AACA;AACA;AACA,mCAAmC,gCAAgC;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,OAAO;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,wBAAwB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,OAAO;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,OAAO;AACvD;AACA;AACA,gDAAgD,QAAQ;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,wBAAwB;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,wBAAwB;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,wBAAwB;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,wBAAwB;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,wBAAwB;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,0BAA0B;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,0BAA0B;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,wBAAwB;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,wBAAwB;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,wBAAwB;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yFAAyF,OAAO;AAChG;AACA;AACA;AACA,uDAAuD,kBAAkB;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,0BAA0B;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,oBAAoB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,QAAQ;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,uBAAuB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,2BAA2B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,kEAAkE;AACvE;AACA;AACA;AACA;AACA;AACA,KAAK,4DAA4D;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,4EAA4E;AAC5E,kEAAkE;AAClE,qDAAqD;AACrD;AACA,KAAK;AACL;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,yBAAyB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,uBAAuB;AAClD;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,OAAO;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,uBAAuB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,OAAO;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,OAAO;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,OAAO;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,OAAO;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,iBAAiB;AAC5C;AACA;AACA;AACA,4CAA4C,OAAO;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,gBAAgB;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,OAAO;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,OAAO;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,QAAQ;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,QAAQ;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,+BAA+B,OAAO;AACtC,+BAA+B,OAAO;AACtC,+BAA+B,OAAO;AACtC,+BAA+B,OAAO;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,oDAAoD,+BAA+B;AACnF;AACA;AACA;AACA;AACA,mCAAmC,WAAW;AAC9C;AACA;AACA;AACA;AACA;AACA,qCAAqC,UAAU;AAC/C;AACA;AACA;AACA;AACA;AACA,mCAAmC,WAAW;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,UAAU;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,kBAAkB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,kBAAkB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,2BAA2B,2BAA2B;AACtD;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,kBAAkB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,+BAA+B,OAAO;AACtC,+BAA+B,OAAO;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,wCAAwC,iBAAiB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,wBAAwB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,WAAW;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,WAAW;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,WAAW;AAC7D;AACA;AACA;AACA,0BAA0B,OAAO;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,WAAW;AAC5E;AACA;AACA;AACA,0BAA0B,OAAO;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,qEAAqE;AAC1E,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,OAAO;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,OAAO;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,iBAAiB;AAC7D,2DAA2D,8CAA8C,EAAE;AAC3G;AACA;AACA,SAAS;AACT;AACA,KAAK,6CAA6C;AAClD,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kFAAkF;AAClF,wEAAwE;AACxE,2DAA2D;AAC3D;AACA,SAAS;AACT;AACA,KAAK,6CAA6C;AAClD,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,OAAO;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,OAAO;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,sBAAsB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,OAAO;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK,6CAA6C;AAClD,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,iBAAiB;AAC7D;AACA;AACA,iBAAiB;AACjB;AACA;AACA,SAAS;AACT;AACA,KAAK,0CAA0C;AAC/C,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK,0CAA0C;AAC/C,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,oBAAoB;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,UAAU;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK,0CAA0C;AAC/C,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK,0CAA0C;AAC/C,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,uBAAuB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,wBAAwB;AAChF,sDAAsD,sDAAsD;AAC5G,sDAAsD,qDAAqD;AAC3G;AACA;AACA;AACA;AACA,sDAAsD,sBAAsB;AAC5E,qDAAqD,4BAA4B;AACjF,qDAAqD,2BAA2B;AAChF;AACA;AACA;AACA;AACA,qDAAqD,qBAAqB;AAC1E;AACA;AACA;AACA,+BAA+B,4BAA4B;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,4BAA4B;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,4BAA4B;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,sCAAsC,UAAU;AAChD;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS,oFAAoF;AAC7F,KAAK,0CAA0C;AAC/C,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,qBAAqB;AACnE,6CAA6C,qBAAqB;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,oBAAoB;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,uBAAuB;AACxF;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK,0CAA0C;AAC/C,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,qBAAqB;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,4BAA4B;AAChF,gDAAgD,qBAAqB;AACrE,8CAA8C,mBAAmB;AACjE;AACA;AACA;AACA;AACA;AACA,oDAAoD,4BAA4B;AAChF,8CAA8C,qBAAqB;AACnE;AACA;AACA;AACA;AACA;AACA,uCAAuC,cAAc;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,cAAc;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,cAAc;AACrD,oDAAoD,4BAA4B;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,cAAc;AACrD,oDAAoD,4BAA4B;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,cAAc;AACrD,wCAAwC,eAAe;AACvD;AACA;AACA;AACA;AACA,uCAAuC,cAAc;AACrD,wCAAwC,eAAe;AACvD,wCAAwC,eAAe;AACvD;AACA;AACA;AACA;AACA,uCAAuC,cAAc;AACrD,wCAAwC,eAAe;AACvD,wCAAwC,eAAe;AACvD,wCAAwC,eAAe;AACvD;AACA;AACA;AACA;AACA,uCAAuC,cAAc;AACrD;AACA;AACA;AACA;AACA,uCAAuC,cAAc;AACrD;AACA;AACA;AACA;AACA,uCAAuC,cAAc;AACrD;AACA;AACA;AACA;AACA,uCAAuC,cAAc;AACrD,0CAA0C,cAAc;AACxD;AACA;AACA;AACA;AACA,uCAAuC,cAAc;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,yDAAyD;AAClE,KAAK,0CAA0C;AAC/C,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,qBAAqB;AAC5E,4DAA4D,0BAA0B;AACtF,8DAA8D,4BAA4B;AAC1F,kEAAkE,sBAAsB;AACxF,8DAA8D,sBAAsB;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2EAA2E,8CAA8C,kDAAkD,iDAAiD,+BAA+B,mCAAmC,0BAA0B,2CAA2C,mDAAmD,8EAA8E,WAAW;AAC/e,iHAAiH,2FAA2F,mCAAmC,sCAAsC,0BAA0B,uEAAuE,WAAW;AACjY;AACA;AACA;AACA,2EAA2E,8CAA8C,+CAA+C,kDAAkD,iDAAiD,+BAA+B,8BAA8B,mCAAmC,0BAA0B,2CAA2C,2CAA2C,mDAAmD,8EAA8E,WAAW;AACvmB,iHAAiH,2FAA2F,mCAAmC,mCAAmC,sCAAsC,0BAA0B,8DAA8D,oDAAoD,8HAA8H,WAAW;AAC7kB;AACA;AACA;AACA,2EAA2E,8CAA8C,iDAAiD,+BAA+B,0BAA0B,2CAA2C,8EAA8E,WAAW;AACvW,iHAAiH,2FAA2F,0BAA0B,mCAAmC,WAAW;AACpR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK,0CAA0C;AAC/C,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,qBAAqB;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,cAAc;AACrD;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,cAAc;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,cAAc;AACrD,wCAAwC,eAAe;AACvD,wCAAwC,eAAe;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,cAAc;AACrD,wCAAwC,eAAe;AACvD,wCAAwC,eAAe;AACvD,wCAAwC,eAAe;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,cAAc;AACrD;AACA;AACA;AACA,uCAAuC,cAAc;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,cAAc;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,OAAO;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,cAAc;AACrD,0CAA0C,cAAc;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,cAAc;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,cAAc;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,cAAc;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,sDAAsD;AAC/D,KAAK,0CAA0C;AAC/C,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,qBAAqB;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,OAAO;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,OAAO;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,OAAO;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE,SAAS;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,SAAS;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,OAAO;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,OAAO;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,SAAS;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,OAAO;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,OAAO;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,YAAY;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK,0CAA0C;AAC/C,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,8CAA8C,qBAAqB;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,qBAAqB;AACrE,8CAA8C,mBAAmB;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,OAAO;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iFAAiF,SAAS;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iFAAiF,SAAS;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sFAAsF,SAAS;AAC/F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sFAAsF,SAAS;AAC/F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sFAAsF,SAAS;AAC/F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sFAAsF,SAAS;AAC/F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK,0CAA0C;AAC/C,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,OAAO;AAC1C,mCAAmC,OAAO;AAC1C,mCAAmC,OAAO;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK,0CAA0C;AAC/C,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,kBAAkB,iBAAiB;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,qEAAqE,OAAO;AAC5E;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,4BAA4B;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK,0CAA0C;AAC/C,CAAC,sBAAsB;AACvB;;AAEA;AACA;AACA,CAAC,e","file":"SpinePlugin.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"SpinePlugin\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"SpinePlugin\"] = factory();\n\telse\n\t\troot[\"SpinePlugin\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./SpinePlugin.js\");\n","'use strict';\n\nvar has = Object.prototype.hasOwnProperty\n  , prefix = '~';\n\n/**\n * Constructor to create a storage for our `EE` objects.\n * An `Events` instance is a plain object whose properties are event names.\n *\n * @constructor\n * @private\n */\nfunction Events() {}\n\n//\n// We try to not inherit from `Object.prototype`. In some engines creating an\n// instance in this way is faster than calling `Object.create(null)` directly.\n// If `Object.create(null)` is not supported we prefix the event names with a\n// character to make sure that the built-in object properties are not\n// overridden or used as an attack vector.\n//\nif (Object.create) {\n  Events.prototype = Object.create(null);\n\n  //\n  // This hack is needed because the `__proto__` property is still inherited in\n  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.\n  //\n  if (!new Events().__proto__) prefix = false;\n}\n\n/**\n * Representation of a single event listener.\n *\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} [once=false] Specify if the listener is a one-time listener.\n * @constructor\n * @private\n */\nfunction EE(fn, context, once) {\n  this.fn = fn;\n  this.context = context;\n  this.once = once || false;\n}\n\n/**\n * Add a listener for a given event.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} once Specify if the listener is a one-time listener.\n * @returns {EventEmitter}\n * @private\n */\nfunction addListener(emitter, event, fn, context, once) {\n  if (typeof fn !== 'function') {\n    throw new TypeError('The listener must be a function');\n  }\n\n  var listener = new EE(fn, context || emitter, once)\n    , evt = prefix ? prefix + event : event;\n\n  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;\n  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);\n  else emitter._events[evt] = [emitter._events[evt], listener];\n\n  return emitter;\n}\n\n/**\n * Clear event by name.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} evt The Event name.\n * @private\n */\nfunction clearEvent(emitter, evt) {\n  if (--emitter._eventsCount === 0) emitter._events = new Events();\n  else delete emitter._events[evt];\n}\n\n/**\n * Minimal `EventEmitter` interface that is molded against the Node.js\n * `EventEmitter` interface.\n *\n * @constructor\n * @public\n */\nfunction EventEmitter() {\n  this._events = new Events();\n  this._eventsCount = 0;\n}\n\n/**\n * Return an array listing the events for which the emitter has registered\n * listeners.\n *\n * @returns {Array}\n * @public\n */\nEventEmitter.prototype.eventNames = function eventNames() {\n  var names = []\n    , events\n    , name;\n\n  if (this._eventsCount === 0) return names;\n\n  for (name in (events = this._events)) {\n    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);\n  }\n\n  if (Object.getOwnPropertySymbols) {\n    return names.concat(Object.getOwnPropertySymbols(events));\n  }\n\n  return names;\n};\n\n/**\n * Return the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Array} The registered listeners.\n * @public\n */\nEventEmitter.prototype.listeners = function listeners(event) {\n  var evt = prefix ? prefix + event : event\n    , handlers = this._events[evt];\n\n  if (!handlers) return [];\n  if (handlers.fn) return [handlers.fn];\n\n  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {\n    ee[i] = handlers[i].fn;\n  }\n\n  return ee;\n};\n\n/**\n * Return the number of listeners listening to a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Number} The number of listeners.\n * @public\n */\nEventEmitter.prototype.listenerCount = function listenerCount(event) {\n  var evt = prefix ? prefix + event : event\n    , listeners = this._events[evt];\n\n  if (!listeners) return 0;\n  if (listeners.fn) return 1;\n  return listeners.length;\n};\n\n/**\n * Calls each of the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Boolean} `true` if the event had listeners, else `false`.\n * @public\n */\nEventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return false;\n\n  var listeners = this._events[evt]\n    , len = arguments.length\n    , args\n    , i;\n\n  if (listeners.fn) {\n    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);\n\n    switch (len) {\n      case 1: return listeners.fn.call(listeners.context), true;\n      case 2: return listeners.fn.call(listeners.context, a1), true;\n      case 3: return listeners.fn.call(listeners.context, a1, a2), true;\n      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;\n      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n    }\n\n    for (i = 1, args = new Array(len -1); i < len; i++) {\n      args[i - 1] = arguments[i];\n    }\n\n    listeners.fn.apply(listeners.context, args);\n  } else {\n    var length = listeners.length\n      , j;\n\n    for (i = 0; i < length; i++) {\n      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);\n\n      switch (len) {\n        case 1: listeners[i].fn.call(listeners[i].context); break;\n        case 2: listeners[i].fn.call(listeners[i].context, a1); break;\n        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;\n        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;\n        default:\n          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {\n            args[j - 1] = arguments[j];\n          }\n\n          listeners[i].fn.apply(listeners[i].context, args);\n      }\n    }\n  }\n\n  return true;\n};\n\n/**\n * Add a listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.on = function on(event, fn, context) {\n  return addListener(this, event, fn, context, false);\n};\n\n/**\n * Add a one-time listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.once = function once(event, fn, context) {\n  return addListener(this, event, fn, context, true);\n};\n\n/**\n * Remove the listeners of a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn Only remove the listeners that match this function.\n * @param {*} context Only remove the listeners that have this context.\n * @param {Boolean} once Only remove one-time listeners.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return this;\n  if (!fn) {\n    clearEvent(this, evt);\n    return this;\n  }\n\n  var listeners = this._events[evt];\n\n  if (listeners.fn) {\n    if (\n      listeners.fn === fn &&\n      (!once || listeners.once) &&\n      (!context || listeners.context === context)\n    ) {\n      clearEvent(this, evt);\n    }\n  } else {\n    for (var i = 0, events = [], length = listeners.length; i < length; i++) {\n      if (\n        listeners[i].fn !== fn ||\n        (once && !listeners[i].once) ||\n        (context && listeners[i].context !== context)\n      ) {\n        events.push(listeners[i]);\n      }\n    }\n\n    //\n    // Reset the array, or remove it completely if we have no more listeners.\n    //\n    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;\n    else clearEvent(this, evt);\n  }\n\n  return this;\n};\n\n/**\n * Remove all listeners, or those of the specified event.\n *\n * @param {(String|Symbol)} [event] The event name.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n  var evt;\n\n  if (event) {\n    evt = prefix ? prefix + event : event;\n    if (this._events[evt]) clearEvent(this, evt);\n  } else {\n    this._events = new Events();\n    this._eventsCount = 0;\n  }\n\n  return this;\n};\n\n//\n// Alias methods names because people roll like that.\n//\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\nEventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n//\n// Expose the prefix.\n//\nEventEmitter.prefixed = prefix;\n\n//\n// Allow `EventEmitter` to be imported as module namespace.\n//\nEventEmitter.EventEmitter = EventEmitter;\n\n//\n// Expose the module.\n//\nif ('undefined' !== typeof module) {\n  module.exports = EventEmitter;\n}\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\nvar Class = require('../utils/Class');\nvar Events = require('./events');\n\n/**\n * @callback DataEachCallback\n *\n * @param {*} parent - The parent object of the DataManager.\n * @param {string} key - The key of the value.\n * @param {*} value - The value.\n * @param {...*} [args] - Additional arguments that will be passed to the callback, after the game object, key, and data.\n */\n\n/**\n * @classdesc\n * The Data Manager Component features a means to store pieces of data specific to a Game Object, System or Plugin.\n * You can then search, query it, and retrieve the data. The parent must either extend EventEmitter,\n * or have a property called `events` that is an instance of it.\n *\n * @class DataManager\n * @memberof Phaser.Data\n * @constructor\n * @since 3.0.0\n *\n * @param {object} parent - The object that this DataManager belongs to.\n * @param {Phaser.Events.EventEmitter} eventEmitter - The DataManager's event emitter.\n */\nvar DataManager = new Class({\n\n    initialize:\n\n    function DataManager (parent, eventEmitter)\n    {\n        /**\n         * The object that this DataManager belongs to.\n         *\n         * @name Phaser.Data.DataManager#parent\n         * @type {*}\n         * @since 3.0.0\n         */\n        this.parent = parent;\n\n        /**\n         * The DataManager's event emitter.\n         *\n         * @name Phaser.Data.DataManager#events\n         * @type {Phaser.Events.EventEmitter}\n         * @since 3.0.0\n         */\n        this.events = eventEmitter;\n\n        if (!eventEmitter)\n        {\n            this.events = (parent.events) ? parent.events : parent;\n        }\n\n        /**\n         * The data list.\n         *\n         * @name Phaser.Data.DataManager#list\n         * @type {Object.<string, *>}\n         * @default {}\n         * @since 3.0.0\n         */\n        this.list = {};\n\n        /**\n         * The public values list. You can use this to access anything you have stored\n         * in this Data Manager. For example, if you set a value called `gold` you can\n         * access it via:\n         *\n         * ```javascript\n         * this.data.values.gold;\n         * ```\n         *\n         * You can also modify it directly:\n         * \n         * ```javascript\n         * this.data.values.gold += 1000;\n         * ```\n         *\n         * Doing so will emit a `setdata` event from the parent of this Data Manager.\n         * \n         * Do not modify this object directly. Adding properties directly to this object will not\n         * emit any events. Always use `DataManager.set` to create new items the first time around.\n         *\n         * @name Phaser.Data.DataManager#values\n         * @type {Object.<string, *>}\n         * @default {}\n         * @since 3.10.0\n         */\n        this.values = {};\n\n        /**\n         * Whether setting data is frozen for this DataManager.\n         *\n         * @name Phaser.Data.DataManager#_frozen\n         * @type {boolean}\n         * @private\n         * @default false\n         * @since 3.0.0\n         */\n        this._frozen = false;\n\n        if (!parent.hasOwnProperty('sys') && this.events)\n        {\n            this.events.once('destroy', this.destroy, this);\n        }\n    },\n\n    /**\n     * Retrieves the value for the given key, or undefined if it doesn't exist.\n     *\n     * You can also access values via the `values` object. For example, if you had a key called `gold` you can do either:\n     * \n     * ```javascript\n     * this.data.get('gold');\n     * ```\n     *\n     * Or access the value directly:\n     * \n     * ```javascript\n     * this.data.values.gold;\n     * ```\n     *\n     * You can also pass in an array of keys, in which case an array of values will be returned:\n     * \n     * ```javascript\n     * this.data.get([ 'gold', 'armor', 'health' ]);\n     * ```\n     *\n     * This approach is useful for destructuring arrays in ES6.\n     *\n     * @method Phaser.Data.DataManager#get\n     * @since 3.0.0\n     *\n     * @param {(string|string[])} key - The key of the value to retrieve, or an array of keys.\n     *\n     * @return {*} The value belonging to the given key, or an array of values, the order of which will match the input array.\n     */\n    get: function (key)\n    {\n        var list = this.list;\n\n        if (Array.isArray(key))\n        {\n            var output = [];\n\n            for (var i = 0; i < key.length; i++)\n            {\n                output.push(list[key[i]]);\n            }\n\n            return output;\n        }\n        else\n        {\n            return list[key];\n        }\n    },\n\n    /**\n     * Retrieves all data values in a new object.\n     *\n     * @method Phaser.Data.DataManager#getAll\n     * @since 3.0.0\n     *\n     * @return {Object.<string, *>} All data values.\n     */\n    getAll: function ()\n    {\n        var results = {};\n\n        for (var key in this.list)\n        {\n            if (this.list.hasOwnProperty(key))\n            {\n                results[key] = this.list[key];\n            }\n        }\n\n        return results;\n    },\n\n    /**\n     * Queries the DataManager for the values of keys matching the given regular expression.\n     *\n     * @method Phaser.Data.DataManager#query\n     * @since 3.0.0\n     *\n     * @param {RegExp} search - A regular expression object. If a non-RegExp object obj is passed, it is implicitly converted to a RegExp by using new RegExp(obj).\n     *\n     * @return {Object.<string, *>} The values of the keys matching the search string.\n     */\n    query: function (search)\n    {\n        var results = {};\n\n        for (var key in this.list)\n        {\n            if (this.list.hasOwnProperty(key) && key.match(search))\n            {\n                results[key] = this.list[key];\n            }\n        }\n\n        return results;\n    },\n\n    /**\n     * Sets a value for the given key. If the key doesn't already exist in the Data Manager then it is created.\n     * \n     * ```javascript\n     * data.set('name', 'Red Gem Stone');\n     * ```\n     *\n     * You can also pass in an object of key value pairs as the first argument:\n     *\n     * ```javascript\n     * data.set({ name: 'Red Gem Stone', level: 2, owner: 'Link', gold: 50 });\n     * ```\n     *\n     * To get a value back again you can call `get`:\n     * \n     * ```javascript\n     * data.get('gold');\n     * ```\n     * \n     * Or you can access the value directly via the `values` property, where it works like any other variable:\n     * \n     * ```javascript\n     * data.values.gold += 50;\n     * ```\n     *\n     * When the value is first set, a `setdata` event is emitted.\n     *\n     * If the key already exists, a `changedata` event is emitted instead, along an event named after the key.\n     * For example, if you updated an existing key called `PlayerLives` then it would emit the event `changedata-PlayerLives`.\n     * These events will be emitted regardless if you use this method to set the value, or the direct `values` setter.\n     *\n     * Please note that the data keys are case-sensitive and must be valid JavaScript Object property strings.\n     * This means the keys `gold` and `Gold` are treated as two unique values within the Data Manager.\n     *\n     * @method Phaser.Data.DataManager#set\n     * @fires Phaser.Data.Events#SET_DATA\n     * @fires Phaser.Data.Events#CHANGE_DATA\n     * @fires Phaser.Data.Events#CHANGE_DATA_KEY\n     * @since 3.0.0\n     *\n     * @param {(string|object)} key - The key to set the value for. Or an object or key value pairs. If an object the `data` argument is ignored.\n     * @param {*} data - The value to set for the given key. If an object is provided as the key this argument is ignored.\n     *\n     * @return {Phaser.Data.DataManager} This DataManager object.\n     */\n    set: function (key, data)\n    {\n        if (this._frozen)\n        {\n            return this;\n        }\n\n        if (typeof key === 'string')\n        {\n            return this.setValue(key, data);\n        }\n        else\n        {\n            for (var entry in key)\n            {\n                this.setValue(entry, key[entry]);\n            }\n        }\n\n        return this;\n    },\n\n    /**\n     * Internal value setter, called automatically by the `set` method.\n     *\n     * @method Phaser.Data.DataManager#setValue\n     * @fires Phaser.Data.Events#SET_DATA\n     * @fires Phaser.Data.Events#CHANGE_DATA\n     * @fires Phaser.Data.Events#CHANGE_DATA_KEY\n     * @private\n     * @since 3.10.0\n     *\n     * @param {string} key - The key to set the value for.\n     * @param {*} data - The value to set.\n     *\n     * @return {Phaser.Data.DataManager} This DataManager object.\n     */\n    setValue: function (key, data)\n    {\n        if (this._frozen)\n        {\n            return this;\n        }\n\n        if (this.has(key))\n        {\n            //  Hit the key getter, which will in turn emit the events.\n            this.values[key] = data;\n        }\n        else\n        {\n            var _this = this;\n            var list = this.list;\n            var events = this.events;\n            var parent = this.parent;\n\n            Object.defineProperty(this.values, key, {\n\n                enumerable: true,\n                \n                configurable: true,\n\n                get: function ()\n                {\n                    return list[key];\n                },\n\n                set: function (value)\n                {\n                    if (!_this._frozen)\n                    {\n                        var previousValue = list[key];\n                        list[key] = value;\n\n                        events.emit(Events.CHANGE_DATA, parent, key, value, previousValue);\n                        events.emit(Events.CHANGE_DATA_KEY + key, parent, value, previousValue);\n                    }\n                }\n\n            });\n\n            list[key] = data;\n\n            events.emit(Events.SET_DATA, parent, key, data);\n        }\n\n        return this;\n    },\n\n    /**\n     * Passes all data entries to the given callback.\n     *\n     * @method Phaser.Data.DataManager#each\n     * @since 3.0.0\n     *\n     * @param {DataEachCallback} callback - The function to call.\n     * @param {*} [context] - Value to use as `this` when executing callback.\n     * @param {...*} [args] - Additional arguments that will be passed to the callback, after the game object, key, and data.\n     *\n     * @return {Phaser.Data.DataManager} This DataManager object.\n     */\n    each: function (callback, context)\n    {\n        var args = [ this.parent, null, undefined ];\n\n        for (var i = 1; i < arguments.length; i++)\n        {\n            args.push(arguments[i]);\n        }\n\n        for (var key in this.list)\n        {\n            args[1] = key;\n            args[2] = this.list[key];\n\n            callback.apply(context, args);\n        }\n\n        return this;\n    },\n\n    /**\n     * Merge the given object of key value pairs into this DataManager.\n     *\n     * Any newly created values will emit a `setdata` event. Any updated values (see the `overwrite` argument)\n     * will emit a `changedata` event.\n     *\n     * @method Phaser.Data.DataManager#merge\n     * @fires Phaser.Data.Events#SET_DATA\n     * @fires Phaser.Data.Events#CHANGE_DATA\n     * @fires Phaser.Data.Events#CHANGE_DATA_KEY\n     * @since 3.0.0\n     *\n     * @param {Object.<string, *>} data - The data to merge.\n     * @param {boolean} [overwrite=true] - Whether to overwrite existing data. Defaults to true.\n     *\n     * @return {Phaser.Data.DataManager} This DataManager object.\n     */\n    merge: function (data, overwrite)\n    {\n        if (overwrite === undefined) { overwrite = true; }\n\n        //  Merge data from another component into this one\n        for (var key in data)\n        {\n            if (data.hasOwnProperty(key) && (overwrite || (!overwrite && !this.has(key))))\n            {\n                this.setValue(key, data[key]);\n            }\n        }\n\n        return this;\n    },\n\n    /**\n     * Remove the value for the given key.\n     *\n     * If the key is found in this Data Manager it is removed from the internal lists and a\n     * `removedata` event is emitted.\n     * \n     * You can also pass in an array of keys, in which case all keys in the array will be removed:\n     * \n     * ```javascript\n     * this.data.remove([ 'gold', 'armor', 'health' ]);\n     * ```\n     *\n     * @method Phaser.Data.DataManager#remove\n     * @fires Phaser.Data.Events#REMOVE_DATA\n     * @since 3.0.0\n     *\n     * @param {(string|string[])} key - The key to remove, or an array of keys to remove.\n     *\n     * @return {Phaser.Data.DataManager} This DataManager object.\n     */\n    remove: function (key)\n    {\n        if (this._frozen)\n        {\n            return this;\n        }\n\n        if (Array.isArray(key))\n        {\n            for (var i = 0; i < key.length; i++)\n            {\n                this.removeValue(key[i]);\n            }\n        }\n        else\n        {\n            return this.removeValue(key);\n        }\n\n        return this;\n    },\n\n    /**\n     * Internal value remover, called automatically by the `remove` method.\n     *\n     * @method Phaser.Data.DataManager#removeValue\n     * @private\n     * @fires Phaser.Data.Events#REMOVE_DATA\n     * @since 3.10.0\n     *\n     * @param {string} key - The key to set the value for.\n     *\n     * @return {Phaser.Data.DataManager} This DataManager object.\n     */\n    removeValue: function (key)\n    {\n        if (this.has(key))\n        {\n            var data = this.list[key];\n\n            delete this.list[key];\n            delete this.values[key];\n\n            this.events.emit(Events.REMOVE_DATA, this.parent, key, data);\n        }\n\n        return this;\n    },\n\n    /**\n     * Retrieves the data associated with the given 'key', deletes it from this Data Manager, then returns it.\n     *\n     * @method Phaser.Data.DataManager#pop\n     * @fires Phaser.Data.Events#REMOVE_DATA\n     * @since 3.0.0\n     *\n     * @param {string} key - The key of the value to retrieve and delete.\n     *\n     * @return {*} The value of the given key.\n     */\n    pop: function (key)\n    {\n        var data = undefined;\n\n        if (!this._frozen && this.has(key))\n        {\n            data = this.list[key];\n\n            delete this.list[key];\n            delete this.values[key];\n\n            this.events.emit(Events.REMOVE_DATA, this.parent, key, data);\n        }\n\n        return data;\n    },\n\n    /**\n     * Determines whether the given key is set in this Data Manager.\n     * \n     * Please note that the keys are case-sensitive and must be valid JavaScript Object property strings.\n     * This means the keys `gold` and `Gold` are treated as two unique values within the Data Manager.\n     *\n     * @method Phaser.Data.DataManager#has\n     * @since 3.0.0\n     *\n     * @param {string} key - The key to check.\n     *\n     * @return {boolean} Returns `true` if the key exists, otherwise `false`.\n     */\n    has: function (key)\n    {\n        return this.list.hasOwnProperty(key);\n    },\n\n    /**\n     * Freeze or unfreeze this Data Manager. A frozen Data Manager will block all attempts\n     * to create new values or update existing ones.\n     *\n     * @method Phaser.Data.DataManager#setFreeze\n     * @since 3.0.0\n     *\n     * @param {boolean} value - Whether to freeze or unfreeze the Data Manager.\n     *\n     * @return {Phaser.Data.DataManager} This DataManager object.\n     */\n    setFreeze: function (value)\n    {\n        this._frozen = value;\n\n        return this;\n    },\n\n    /**\n     * Delete all data in this Data Manager and unfreeze it.\n     *\n     * @method Phaser.Data.DataManager#reset\n     * @since 3.0.0\n     *\n     * @return {Phaser.Data.DataManager} This DataManager object.\n     */\n    reset: function ()\n    {\n        for (var key in this.list)\n        {\n            delete this.list[key];\n            delete this.values[key];\n        }\n\n        this._frozen = false;\n\n        return this;\n    },\n\n    /**\n     * Destroy this data manager.\n     *\n     * @method Phaser.Data.DataManager#destroy\n     * @since 3.0.0\n     */\n    destroy: function ()\n    {\n        this.reset();\n\n        this.events.off(Events.CHANGE_DATA);\n        this.events.off(Events.SET_DATA);\n        this.events.off(Events.REMOVE_DATA);\n\n        this.parent = null;\n    },\n\n    /**\n     * Gets or sets the frozen state of this Data Manager.\n     * A frozen Data Manager will block all attempts to create new values or update existing ones.\n     *\n     * @name Phaser.Data.DataManager#freeze\n     * @type {boolean}\n     * @since 3.0.0\n     */\n    freeze: {\n\n        get: function ()\n        {\n            return this._frozen;\n        },\n\n        set: function (value)\n        {\n            this._frozen = (value) ? true : false;\n        }\n\n    },\n\n    /**\n     * Return the total number of entries in this Data Manager.\n     *\n     * @name Phaser.Data.DataManager#count\n     * @type {integer}\n     * @since 3.0.0\n     */\n    count: {\n\n        get: function ()\n        {\n            var i = 0;\n\n            for (var key in this.list)\n            {\n                if (this.list[key] !== undefined)\n                {\n                    i++;\n                }\n            }\n\n            return i;\n        }\n\n    }\n\n});\n\nmodule.exports = DataManager;\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * The Change Data Event.\n * \n * This event is dispatched by a Data Manager when an item in the data store is changed.\n * \n * Game Objects with data enabled have an instance of a Data Manager under the `data` property. So, to listen for\n * a change data event from a Game Object you would use: `sprite.data.on('changedata', listener)`.\n * \n * This event is dispatched for all items that change in the Data Manager.\n * To listen for the change of a specific item, use the `CHANGE_DATA_KEY_EVENT` event.\n *\n * @event Phaser.Data.Events#CHANGE_DATA\n * @since 3.0.0\n * \n * @param {any} parent - A reference to the object that the Data Manager responsible for this event belongs to.\n * @param {string} key - The unique key of the data item within the Data Manager.\n * @param {any} value - The new value of the item in the Data Manager.\n * @param {any} previousValue - The previous value of the item in the Data Manager.\n */\nmodule.exports = 'changedata';\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * The Change Data Key Event.\n * \n * This event is dispatched by a Data Manager when an item in the data store is changed.\n * \n * Game Objects with data enabled have an instance of a Data Manager under the `data` property. So, to listen for\n * the change of a specific data item from a Game Object you would use: `sprite.data.on('changedata-key', listener)`,\n * where `key` is the unique string key of the data item. For example, if you have a data item stored called `gold`\n * then you can listen for `sprite.data.on('changedata-gold')`.\n *\n * @event Phaser.Data.Events#CHANGE_DATA_KEY\n * @since 3.16.1\n * \n * @param {any} parent - A reference to the object that owns the instance of the Data Manager responsible for this event.\n * @param {string} key - The unique key of the data item within the Data Manager.\n * @param {any} value - The item that was updated in the Data Manager. This can be of any data type, i.e. a string, boolean, number, object or instance.\n * @param {any} previousValue - The previous item that was updated in the Data Manager. This can be of any data type, i.e. a string, boolean, number, object or instance.\n */\nmodule.exports = 'changedata-';\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * The Remove Data Event.\n * \n * This event is dispatched by a Data Manager when an item is removed from it.\n * \n * Game Objects with data enabled have an instance of a Data Manager under the `data` property. So, to listen for\n * the removal of a data item on a Game Object you would use: `sprite.data.on('removedata', listener)`.\n *\n * @event Phaser.Data.Events#REMOVE_DATA\n * @since 3.0.0\n * \n * @param {any} parent - A reference to the object that owns the instance of the Data Manager responsible for this event.\n * @param {string} key - The unique key of the data item within the Data Manager.\n * @param {any} data - The item that was removed from the Data Manager. This can be of any data type, i.e. a string, boolean, number, object or instance.\n */\nmodule.exports = 'removedata';\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * The Set Data Event.\n * \n * This event is dispatched by a Data Manager when a new item is added to the data store.\n * \n * Game Objects with data enabled have an instance of a Data Manager under the `data` property. So, to listen for\n * the addition of a new data item on a Game Object you would use: `sprite.data.on('setdata', listener)`.\n *\n * @event Phaser.Data.Events#SET_DATA\n * @since 3.0.0\n * \n * @param {any} parent - A reference to the object that owns the instance of the Data Manager responsible for this event.\n * @param {string} key - The unique key of the data item within the Data Manager.\n * @param {any} data - The item that was added to the Data Manager. This can be of any data type, i.e. a string, boolean, number, object or instance.\n */\nmodule.exports = 'setdata';\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * @namespace Phaser.Data.Events\n */\n\nmodule.exports = {\n\n    CHANGE_DATA: require('./CHANGE_DATA_EVENT'),\n    CHANGE_DATA_KEY: require('./CHANGE_DATA_KEY_EVENT'),\n    REMOVE_DATA: require('./REMOVE_DATA_EVENT'),\n    SET_DATA: require('./SET_DATA_EVENT')\n\n};\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\nvar BlendModes = require('../renderer/BlendModes');\nvar GetAdvancedValue = require('../utils/object/GetAdvancedValue');\nvar ScaleModes = require('../renderer/ScaleModes');\n\n/**\n * Builds a Game Object using the provided configuration object.\n *\n * @function Phaser.GameObjects.BuildGameObject\n * @since 3.0.0\n *\n * @param {Phaser.Scene} scene - A reference to the Scene.\n * @param {Phaser.GameObjects.GameObject} gameObject - The initial GameObject.\n * @param {Phaser.Types.GameObjects.GameObjectConfig} config - The config to build the GameObject with.\n *\n * @return {Phaser.GameObjects.GameObject} The built Game Object.\n */\nvar BuildGameObject = function (scene, gameObject, config)\n{\n    //  Position\n\n    gameObject.x = GetAdvancedValue(config, 'x', 0);\n    gameObject.y = GetAdvancedValue(config, 'y', 0);\n    gameObject.depth = GetAdvancedValue(config, 'depth', 0);\n\n    //  Flip\n\n    gameObject.flipX = GetAdvancedValue(config, 'flipX', false);\n    gameObject.flipY = GetAdvancedValue(config, 'flipY', false);\n\n    //  Scale\n    //  Either: { scale: 2 } or { scale: { x: 2, y: 2 }}\n\n    var scale = GetAdvancedValue(config, 'scale', null);\n\n    if (typeof scale === 'number')\n    {\n        gameObject.setScale(scale);\n    }\n    else if (scale !== null)\n    {\n        gameObject.scaleX = GetAdvancedValue(scale, 'x', 1);\n        gameObject.scaleY = GetAdvancedValue(scale, 'y', 1);\n    }\n\n    //  ScrollFactor\n    //  Either: { scrollFactor: 2 } or { scrollFactor: { x: 2, y: 2 }}\n\n    var scrollFactor = GetAdvancedValue(config, 'scrollFactor', null);\n\n    if (typeof scrollFactor === 'number')\n    {\n        gameObject.setScrollFactor(scrollFactor);\n    }\n    else if (scrollFactor !== null)\n    {\n        gameObject.scrollFactorX = GetAdvancedValue(scrollFactor, 'x', 1);\n        gameObject.scrollFactorY = GetAdvancedValue(scrollFactor, 'y', 1);\n    }\n\n    //  Rotation\n\n    gameObject.rotation = GetAdvancedValue(config, 'rotation', 0);\n\n    var angle = GetAdvancedValue(config, 'angle', null);\n\n    if (angle !== null)\n    {\n        gameObject.angle = angle;\n    }\n\n    //  Alpha\n\n    gameObject.alpha = GetAdvancedValue(config, 'alpha', 1);\n\n    //  Origin\n    //  Either: { origin: 0.5 } or { origin: { x: 0.5, y: 0.5 }}\n\n    var origin = GetAdvancedValue(config, 'origin', null);\n\n    if (typeof origin === 'number')\n    {\n        gameObject.setOrigin(origin);\n    }\n    else if (origin !== null)\n    {\n        var ox = GetAdvancedValue(origin, 'x', 0.5);\n        var oy = GetAdvancedValue(origin, 'y', 0.5);\n\n        gameObject.setOrigin(ox, oy);\n    }\n\n    //  ScaleMode\n\n    gameObject.scaleMode = GetAdvancedValue(config, 'scaleMode', ScaleModes.DEFAULT);\n\n    //  BlendMode\n\n    gameObject.blendMode = GetAdvancedValue(config, 'blendMode', BlendModes.NORMAL);\n\n    //  Visible\n\n    gameObject.visible = GetAdvancedValue(config, 'visible', true);\n\n    //  Add to Scene\n\n    var add = GetAdvancedValue(config, 'add', true);\n\n    if (add)\n    {\n        scene.sys.displayList.add(gameObject);\n    }\n\n    if (gameObject.preUpdate)\n    {\n        scene.sys.updateList.add(gameObject);\n    }\n\n    return gameObject;\n};\n\nmodule.exports = BuildGameObject;\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\nvar Class = require('../utils/Class');\nvar ComponentsToJSON = require('./components/ToJSON');\nvar DataManager = require('../data/DataManager');\nvar EventEmitter = require('eventemitter3');\nvar Events = require('./events');\n\n/**\n * @classdesc\n * The base class that all Game Objects extend.\n * You don't create GameObjects directly and they cannot be added to the display list.\n * Instead, use them as the base for your own custom classes.\n *\n * @class GameObject\n * @memberof Phaser.GameObjects\n * @extends Phaser.Events.EventEmitter\n * @constructor\n * @since 3.0.0\n *\n * @param {Phaser.Scene} scene - The Scene to which this Game Object belongs.\n * @param {string} type - A textual representation of the type of Game Object, i.e. `sprite`.\n */\nvar GameObject = new Class({\n\n    Extends: EventEmitter,\n\n    initialize:\n\n    function GameObject (scene, type)\n    {\n        EventEmitter.call(this);\n\n        /**\n         * The Scene to which this Game Object belongs.\n         * Game Objects can only belong to one Scene.\n         *\n         * @name Phaser.GameObjects.GameObject#scene\n         * @type {Phaser.Scene}\n         * @protected\n         * @since 3.0.0\n         */\n        this.scene = scene;\n\n        /**\n         * A textual representation of this Game Object, i.e. `sprite`.\n         * Used internally by Phaser but is available for your own custom classes to populate.\n         *\n         * @name Phaser.GameObjects.GameObject#type\n         * @type {string}\n         * @since 3.0.0\n         */\n        this.type = type;\n\n        /**\n         * The current state of this Game Object.\n         * \n         * Phaser itself will never modify this value, although plugins may do so.\n         * \n         * Use this property to track the state of a Game Object during its lifetime. For example, it could move from\n         * a state of 'moving', to 'attacking', to 'dead'. The state value should be an integer (ideally mapped to a constant\n         * in your game code), or a string. These are recommended to keep it light and simple, with fast comparisons.\n         * If you need to store complex data about your Game Object, look at using the Data Component instead.\n         *\n         * @name Phaser.GameObjects.GameObject#state\n         * @type {(integer|string)}\n         * @since 3.16.0\n         */\n        this.state = 0;\n\n        /**\n         * The parent Container of this Game Object, if it has one.\n         *\n         * @name Phaser.GameObjects.GameObject#parentContainer\n         * @type {Phaser.GameObjects.Container}\n         * @since 3.4.0\n         */\n        this.parentContainer = null;\n\n        /**\n         * The name of this Game Object.\n         * Empty by default and never populated by Phaser, this is left for developers to use.\n         *\n         * @name Phaser.GameObjects.GameObject#name\n         * @type {string}\n         * @default ''\n         * @since 3.0.0\n         */\n        this.name = '';\n\n        /**\n         * The active state of this Game Object.\n         * A Game Object with an active state of `true` is processed by the Scenes UpdateList, if added to it.\n         * An active object is one which is having its logic and internal systems updated.\n         *\n         * @name Phaser.GameObjects.GameObject#active\n         * @type {boolean}\n         * @default true\n         * @since 3.0.0\n         */\n        this.active = true;\n\n        /**\n         * The Tab Index of the Game Object.\n         * Reserved for future use by plugins and the Input Manager.\n         *\n         * @name Phaser.GameObjects.GameObject#tabIndex\n         * @type {integer}\n         * @default -1\n         * @since 3.0.0\n         */\n        this.tabIndex = -1;\n\n        /**\n         * A Data Manager.\n         * It allows you to store, query and get key/value paired information specific to this Game Object.\n         * `null` by default. Automatically created if you use `getData` or `setData` or `setDataEnabled`.\n         *\n         * @name Phaser.GameObjects.GameObject#data\n         * @type {Phaser.Data.DataManager}\n         * @default null\n         * @since 3.0.0\n         */\n        this.data = null;\n\n        /**\n         * The flags that are compared against `RENDER_MASK` to determine if this Game Object will render or not.\n         * The bits are 0001 | 0010 | 0100 | 1000 set by the components Visible, Alpha, Transform and Texture respectively.\n         * If those components are not used by your custom class then you can use this bitmask as you wish.\n         *\n         * @name Phaser.GameObjects.GameObject#renderFlags\n         * @type {integer}\n         * @default 15\n         * @since 3.0.0\n         */\n        this.renderFlags = 15;\n\n        /**\n         * A bitmask that controls if this Game Object is drawn by a Camera or not.\n         * Not usually set directly, instead call `Camera.ignore`, however you can\n         * set this property directly using the Camera.id property:\n         *\n         * @example\n         * this.cameraFilter |= camera.id\n         *\n         * @name Phaser.GameObjects.GameObject#cameraFilter\n         * @type {number}\n         * @default 0\n         * @since 3.0.0\n         */\n        this.cameraFilter = 0;\n\n        /**\n         * If this Game Object is enabled for input then this property will contain an InteractiveObject instance.\n         * Not usually set directly. Instead call `GameObject.setInteractive()`.\n         *\n         * @name Phaser.GameObjects.GameObject#input\n         * @type {?Phaser.Types.Input.InteractiveObject}\n         * @default null\n         * @since 3.0.0\n         */\n        this.input = null;\n\n        /**\n         * If this Game Object is enabled for physics then this property will contain a reference to a Physics Body.\n         *\n         * @name Phaser.GameObjects.GameObject#body\n         * @type {?(object|Phaser.Physics.Arcade.Body|Phaser.Physics.Impact.Body)}\n         * @default null\n         * @since 3.0.0\n         */\n        this.body = null;\n\n        /**\n         * This Game Object will ignore all calls made to its destroy method if this flag is set to `true`.\n         * This includes calls that may come from a Group, Container or the Scene itself.\n         * While it allows you to persist a Game Object across Scenes, please understand you are entirely\n         * responsible for managing references to and from this Game Object.\n         *\n         * @name Phaser.GameObjects.GameObject#ignoreDestroy\n         * @type {boolean}\n         * @default false\n         * @since 3.5.0\n         */\n        this.ignoreDestroy = false;\n\n        //  Tell the Scene to re-sort the children\n        scene.sys.queueDepthSort();\n    },\n\n    /**\n     * Sets the `active` property of this Game Object and returns this Game Object for further chaining.\n     * A Game Object with its `active` property set to `true` will be updated by the Scenes UpdateList.\n     *\n     * @method Phaser.GameObjects.GameObject#setActive\n     * @since 3.0.0\n     *\n     * @param {boolean} value - True if this Game Object should be set as active, false if not.\n     *\n     * @return {this} This GameObject.\n     */\n    setActive: function (value)\n    {\n        this.active = value;\n\n        return this;\n    },\n\n    /**\n     * Sets the `name` property of this Game Object and returns this Game Object for further chaining.\n     * The `name` property is not populated by Phaser and is presented for your own use.\n     *\n     * @method Phaser.GameObjects.GameObject#setName\n     * @since 3.0.0\n     *\n     * @param {string} value - The name to be given to this Game Object.\n     *\n     * @return {this} This GameObject.\n     */\n    setName: function (value)\n    {\n        this.name = value;\n\n        return this;\n    },\n\n    /**\n     * Sets the current state of this Game Object.\n     * \n     * Phaser itself will never modify the State of a Game Object, although plugins may do so.\n     * \n     * For example, a Game Object could change from a state of 'moving', to 'attacking', to 'dead'.\n     * The state value should typically be an integer (ideally mapped to a constant\n     * in your game code), but could also be a string. It is recommended to keep it light and simple.\n     * If you need to store complex data about your Game Object, look at using the Data Component instead.\n     *\n     * @method Phaser.GameObjects.GameObject#setState\n     * @since 3.16.0\n     *\n     * @param {(integer|string)} value - The state of the Game Object.\n     *\n     * @return {this} This GameObject.\n     */\n    setState: function (value)\n    {\n        this.state = value;\n\n        return this;\n    },\n\n    /**\n     * Adds a Data Manager component to this Game Object.\n     *\n     * @method Phaser.GameObjects.GameObject#setDataEnabled\n     * @since 3.0.0\n     * @see Phaser.Data.DataManager\n     *\n     * @return {this} This GameObject.\n     */\n    setDataEnabled: function ()\n    {\n        if (!this.data)\n        {\n            this.data = new DataManager(this);\n        }\n\n        return this;\n    },\n\n    /**\n     * Allows you to store a key value pair within this Game Objects Data Manager.\n     *\n     * If the Game Object has not been enabled for data (via `setDataEnabled`) then it will be enabled\n     * before setting the value.\n     *\n     * If the key doesn't already exist in the Data Manager then it is created.\n     *\n     * ```javascript\n     * sprite.setData('name', 'Red Gem Stone');\n     * ```\n     *\n     * You can also pass in an object of key value pairs as the first argument:\n     *\n     * ```javascript\n     * sprite.setData({ name: 'Red Gem Stone', level: 2, owner: 'Link', gold: 50 });\n     * ```\n     *\n     * To get a value back again you can call `getData`:\n     *\n     * ```javascript\n     * sprite.getData('gold');\n     * ```\n     *\n     * Or you can access the value directly via the `values` property, where it works like any other variable:\n     *\n     * ```javascript\n     * sprite.data.values.gold += 50;\n     * ```\n     *\n     * When the value is first set, a `setdata` event is emitted from this Game Object.\n     *\n     * If the key already exists, a `changedata` event is emitted instead, along an event named after the key.\n     * For example, if you updated an existing key called `PlayerLives` then it would emit the event `changedata-PlayerLives`.\n     * These events will be emitted regardless if you use this method to set the value, or the direct `values` setter.\n     *\n     * Please note that the data keys are case-sensitive and must be valid JavaScript Object property strings.\n     * This means the keys `gold` and `Gold` are treated as two unique values within the Data Manager.\n     *\n     * @method Phaser.GameObjects.GameObject#setData\n     * @since 3.0.0\n     *\n     * @param {(string|object)} key - The key to set the value for. Or an object of key value pairs. If an object the `data` argument is ignored.\n     * @param {*} [data] - The value to set for the given key. If an object is provided as the key this argument is ignored.\n     *\n     * @return {this} This GameObject.\n     */\n    setData: function (key, value)\n    {\n        if (!this.data)\n        {\n            this.data = new DataManager(this);\n        }\n\n        this.data.set(key, value);\n\n        return this;\n    },\n\n    /**\n     * Retrieves the value for the given key in this Game Objects Data Manager, or undefined if it doesn't exist.\n     *\n     * You can also access values via the `values` object. For example, if you had a key called `gold` you can do either:\n     *\n     * ```javascript\n     * sprite.getData('gold');\n     * ```\n     *\n     * Or access the value directly:\n     *\n     * ```javascript\n     * sprite.data.values.gold;\n     * ```\n     *\n     * You can also pass in an array of keys, in which case an array of values will be returned:\n     *\n     * ```javascript\n     * sprite.getData([ 'gold', 'armor', 'health' ]);\n     * ```\n     *\n     * This approach is useful for destructuring arrays in ES6.\n     *\n     * @method Phaser.GameObjects.GameObject#getData\n     * @since 3.0.0\n     *\n     * @param {(string|string[])} key - The key of the value to retrieve, or an array of keys.\n     *\n     * @return {*} The value belonging to the given key, or an array of values, the order of which will match the input array.\n     */\n    getData: function (key)\n    {\n        if (!this.data)\n        {\n            this.data = new DataManager(this);\n        }\n\n        return this.data.get(key);\n    },\n\n    /**\n     * Pass this Game Object to the Input Manager to enable it for Input.\n     *\n     * Input works by using hit areas, these are nearly always geometric shapes, such as rectangles or circles, that act as the hit area\n     * for the Game Object. However, you can provide your own hit area shape and callback, should you wish to handle some more advanced\n     * input detection.\n     *\n     * If no arguments are provided it will try and create a rectangle hit area based on the texture frame the Game Object is using. If\n     * this isn't a texture-bound object, such as a Graphics or BitmapText object, this will fail, and you'll need to provide a specific\n     * shape for it to use.\n     *\n     * You can also provide an Input Configuration Object as the only argument to this method.\n     *\n     * @method Phaser.GameObjects.GameObject#setInteractive\n     * @since 3.0.0\n     *\n     * @param {(Phaser.Types.Input.InputConfiguration|any)} [shape] - Either an input configuration object, or a geometric shape that defines the hit area for the Game Object. If not specified a Rectangle will be used.\n     * @param {Phaser.Types.Input.HitAreaCallback} [callback] - A callback to be invoked when the Game Object is interacted with. If you provide a shape you must also provide a callback.\n     * @param {boolean} [dropZone=false] - Should this Game Object be treated as a drop zone target?\n     *\n     * @return {this} This GameObject.\n     */\n    setInteractive: function (shape, callback, dropZone)\n    {\n        this.scene.sys.input.enable(this, shape, callback, dropZone);\n\n        return this;\n    },\n\n    /**\n     * If this Game Object has previously been enabled for input, this will disable it.\n     *\n     * An object that is disabled for input stops processing or being considered for\n     * input events, but can be turned back on again at any time by simply calling\n     * `setInteractive()` with no arguments provided.\n     *\n     * If want to completely remove interaction from this Game Object then use `removeInteractive` instead.\n     *\n     * @method Phaser.GameObjects.GameObject#disableInteractive\n     * @since 3.7.0\n     *\n     * @return {this} This GameObject.\n     */\n    disableInteractive: function ()\n    {\n        if (this.input)\n        {\n            this.input.enabled = false;\n        }\n\n        return this;\n    },\n\n    /**\n     * If this Game Object has previously been enabled for input, this will queue it\n     * for removal, causing it to no longer be interactive. The removal happens on\n     * the next game step, it is not immediate.\n     *\n     * The Interactive Object that was assigned to this Game Object will be destroyed,\n     * removed from the Input Manager and cleared from this Game Object.\n     *\n     * If you wish to re-enable this Game Object at a later date you will need to\n     * re-create its InteractiveObject by calling `setInteractive` again.\n     *\n     * If you wish to only temporarily stop an object from receiving input then use\n     * `disableInteractive` instead, as that toggles the interactive state, where-as\n     * this erases it completely.\n     * \n     * If you wish to resize a hit area, don't remove and then set it as being\n     * interactive. Instead, access the hitarea object directly and resize the shape\n     * being used. I.e.: `sprite.input.hitArea.setSize(width, height)` (assuming the\n     * shape is a Rectangle, which it is by default.)\n     *\n     * @method Phaser.GameObjects.GameObject#removeInteractive\n     * @since 3.7.0\n     *\n     * @return {this} This GameObject.\n     */\n    removeInteractive: function ()\n    {\n        this.scene.sys.input.clear(this);\n\n        this.input = undefined;\n\n        return this;\n    },\n\n    /**\n     * To be overridden by custom GameObjects. Allows base objects to be used in a Pool.\n     *\n     * @method Phaser.GameObjects.GameObject#update\n     * @since 3.0.0\n     *\n     * @param {...*} [args] - args\n     */\n    update: function ()\n    {\n    },\n\n    /**\n     * Returns a JSON representation of the Game Object.\n     *\n     * @method Phaser.GameObjects.GameObject#toJSON\n     * @since 3.0.0\n     *\n     * @return {Phaser.Types.GameObjects.JSONGameObject} A JSON representation of the Game Object.\n     */\n    toJSON: function ()\n    {\n        return ComponentsToJSON(this);\n    },\n\n    /**\n     * Compares the renderMask with the renderFlags to see if this Game Object will render or not.\n     * Also checks the Game Object against the given Cameras exclusion list.\n     *\n     * @method Phaser.GameObjects.GameObject#willRender\n     * @since 3.0.0\n     *\n     * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera to check against this Game Object.\n     *\n     * @return {boolean} True if the Game Object should be rendered, otherwise false.\n     */\n    willRender: function (camera)\n    {\n        return !(GameObject.RENDER_MASK !== this.renderFlags || (this.cameraFilter !== 0 && (this.cameraFilter & camera.id)));\n    },\n\n    /**\n     * Returns an array containing the display list index of either this Game Object, or if it has one,\n     * its parent Container. It then iterates up through all of the parent containers until it hits the\n     * root of the display list (which is index 0 in the returned array).\n     *\n     * Used internally by the InputPlugin but also useful if you wish to find out the display depth of\n     * this Game Object and all of its ancestors.\n     *\n     * @method Phaser.GameObjects.GameObject#getIndexList\n     * @since 3.4.0\n     *\n     * @return {integer[]} An array of display list position indexes.\n     */\n    getIndexList: function ()\n    {\n        // eslint-disable-next-line consistent-this\n        var child = this;\n        var parent = this.parentContainer;\n\n        var indexes = [];\n\n        while (parent)\n        {\n            // indexes.unshift([parent.getIndex(child), parent.name]);\n            indexes.unshift(parent.getIndex(child));\n\n            child = parent;\n\n            if (!parent.parentContainer)\n            {\n                break;\n            }\n            else\n            {\n                parent = parent.parentContainer;\n            }\n        }\n\n        // indexes.unshift([this.scene.sys.displayList.getIndex(child), 'root']);\n        indexes.unshift(this.scene.sys.displayList.getIndex(child));\n\n        return indexes;\n    },\n\n    /**\n     * Destroys this Game Object removing it from the Display List and Update List and\n     * severing all ties to parent resources.\n     *\n     * Also removes itself from the Input Manager and Physics Manager if previously enabled.\n     *\n     * Use this to remove a Game Object from your game if you don't ever plan to use it again.\n     * As long as no reference to it exists within your own code it should become free for\n     * garbage collection by the browser.\n     *\n     * If you just want to temporarily disable an object then look at using the\n     * Game Object Pool instead of destroying it, as destroyed objects cannot be resurrected.\n     *\n     * @method Phaser.GameObjects.GameObject#destroy\n     * @fires Phaser.GameObjects.Events#DESTROY\n     * @since 3.0.0\n     *\n     * @param {boolean} [fromScene=false] - Is this Game Object being destroyed as the result of a Scene shutdown?\n     */\n    destroy: function (fromScene)\n    {\n        if (fromScene === undefined) { fromScene = false; }\n\n        //  This Game Object has already been destroyed\n        if (!this.scene || this.ignoreDestroy)\n        {\n            return;\n        }\n\n        if (this.preDestroy)\n        {\n            this.preDestroy.call(this);\n        }\n\n        this.emit(Events.DESTROY, this);\n\n        var sys = this.scene.sys;\n\n        if (!fromScene)\n        {\n            sys.displayList.remove(this);\n            sys.updateList.remove(this);\n        }\n\n        if (this.input)\n        {\n            sys.input.clear(this);\n            this.input = undefined;\n        }\n\n        if (this.data)\n        {\n            this.data.destroy();\n\n            this.data = undefined;\n        }\n\n        if (this.body)\n        {\n            this.body.destroy();\n            this.body = undefined;\n        }\n\n        //  Tell the Scene to re-sort the children\n        if (!fromScene)\n        {\n            sys.queueDepthSort();\n        }\n\n        this.active = false;\n        this.visible = false;\n\n        this.scene = undefined;\n\n        this.parentContainer = undefined;\n\n        this.removeAllListeners();\n    }\n\n});\n\n/**\n * The bitmask that `GameObject.renderFlags` is compared against to determine if the Game Object will render or not.\n *\n * @constant {integer} RENDER_MASK\n * @memberof Phaser.GameObjects.GameObject\n * @default\n */\nGameObject.RENDER_MASK = 15;\n\nmodule.exports = GameObject;\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * Provides methods used for calculating and setting the size of a non-Frame based Game Object.\n * Should be applied as a mixin and not used directly.\n * \n * @namespace Phaser.GameObjects.Components.ComputedSize\n * @since 3.0.0\n */\n\nvar ComputedSize = {\n\n    /**\n     * The native (un-scaled) width of this Game Object.\n     * \n     * Changing this value will not change the size that the Game Object is rendered in-game.\n     * For that you need to either set the scale of the Game Object (`setScale`) or use\n     * the `displayWidth` property.\n     * \n     * @name Phaser.GameObjects.Components.ComputedSize#width\n     * @type {number}\n     * @since 3.0.0\n     */\n    width: 0,\n\n    /**\n     * The native (un-scaled) height of this Game Object.\n     * \n     * Changing this value will not change the size that the Game Object is rendered in-game.\n     * For that you need to either set the scale of the Game Object (`setScale`) or use\n     * the `displayHeight` property.\n     * \n     * @name Phaser.GameObjects.Components.ComputedSize#height\n     * @type {number}\n     * @since 3.0.0\n     */\n    height: 0,\n\n    /**\n     * The displayed width of this Game Object.\n     * \n     * This value takes into account the scale factor.\n     * \n     * Setting this value will adjust the Game Object's scale property.\n     * \n     * @name Phaser.GameObjects.Components.ComputedSize#displayWidth\n     * @type {number}\n     * @since 3.0.0\n     */\n    displayWidth: {\n\n        get: function ()\n        {\n            return this.scaleX * this.width;\n        },\n\n        set: function (value)\n        {\n            this.scaleX = value / this.width;\n        }\n\n    },\n\n    /**\n     * The displayed height of this Game Object.\n     * \n     * This value takes into account the scale factor.\n     * \n     * Setting this value will adjust the Game Object's scale property.\n     * \n     * @name Phaser.GameObjects.Components.ComputedSize#displayHeight\n     * @type {number}\n     * @since 3.0.0\n     */\n    displayHeight: {\n\n        get: function ()\n        {\n            return this.scaleY * this.height;\n        },\n\n        set: function (value)\n        {\n            this.scaleY = value / this.height;\n        }\n\n    },\n\n    /**\n     * Sets the internal size of this Game Object, as used for frame or physics body creation.\n     * \n     * This will not change the size that the Game Object is rendered in-game.\n     * For that you need to either set the scale of the Game Object (`setScale`) or call the\n     * `setDisplaySize` method, which is the same thing as changing the scale but allows you\n     * to do so by giving pixel values.\n     * \n     * If you have enabled this Game Object for input, changing the size will _not_ change the\n     * size of the hit area. To do this you should adjust the `input.hitArea` object directly.\n     * \n     * @method Phaser.GameObjects.Components.ComputedSize#setSize\n     * @since 3.4.0\n     *\n     * @param {number} width - The width of this Game Object.\n     * @param {number} height - The height of this Game Object.\n     * \n     * @return {this} This Game Object instance.\n     */\n    setSize: function (width, height)\n    {\n        this.width = width;\n        this.height = height;\n\n        return this;\n    },\n\n    /**\n     * Sets the display size of this Game Object.\n     * \n     * Calling this will adjust the scale.\n     * \n     * @method Phaser.GameObjects.Components.ComputedSize#setDisplaySize\n     * @since 3.4.0\n     *\n     * @param {number} width - The width of this Game Object.\n     * @param {number} height - The height of this Game Object.\n     * \n     * @return {this} This Game Object instance.\n     */\n    setDisplaySize: function (width, height)\n    {\n        this.displayWidth = width;\n        this.displayHeight = height;\n\n        return this;\n    }\n\n};\n\nmodule.exports = ComputedSize;\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * Provides methods used for setting the depth of a Game Object.\n * Should be applied as a mixin and not used directly.\n * \n * @namespace Phaser.GameObjects.Components.Depth\n * @since 3.0.0\n */\n\nvar Depth = {\n\n    /**\n     * Private internal value. Holds the depth of the Game Object.\n     * \n     * @name Phaser.GameObjects.Components.Depth#_depth\n     * @type {integer}\n     * @private\n     * @default 0\n     * @since 3.0.0\n     */\n    _depth: 0,\n\n    /**\n     * The depth of this Game Object within the Scene.\n     * \n     * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order\n     * of Game Objects, without actually moving their position in the display list.\n     *\n     * The depth starts from zero (the default value) and increases from that point. A Game Object with a higher depth\n     * value will always render in front of one with a lower value.\n     *\n     * Setting the depth will queue a depth sort event within the Scene.\n     * \n     * @name Phaser.GameObjects.Components.Depth#depth\n     * @type {number}\n     * @since 3.0.0\n     */\n    depth: {\n\n        get: function ()\n        {\n            return this._depth;\n        },\n\n        set: function (value)\n        {\n            this.scene.sys.queueDepthSort();\n            this._depth = value;\n        }\n\n    },\n\n    /**\n     * The depth of this Game Object within the Scene.\n     * \n     * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order\n     * of Game Objects, without actually moving their position in the display list.\n     *\n     * The depth starts from zero (the default value) and increases from that point. A Game Object with a higher depth\n     * value will always render in front of one with a lower value.\n     *\n     * Setting the depth will queue a depth sort event within the Scene.\n     * \n     * @method Phaser.GameObjects.Components.Depth#setDepth\n     * @since 3.0.0\n     *\n     * @param {integer} value - The depth of this Game Object.\n     * \n     * @return {this} This Game Object instance.\n     */\n    setDepth: function (value)\n    {\n        if (value === undefined) { value = 0; }\n\n        this.depth = value;\n\n        return this;\n    }\n\n};\n\nmodule.exports = Depth;\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * Provides methods used for visually flipping a Game Object.\n * Should be applied as a mixin and not used directly.\n * \n * @namespace Phaser.GameObjects.Components.Flip\n * @since 3.0.0\n */\n\nvar Flip = {\n\n    /**\n     * The horizontally flipped state of the Game Object.\n     * \n     * A Game Object that is flipped horizontally will render inversed on the horizontal axis.\n     * Flipping always takes place from the middle of the texture and does not impact the scale value.\n     * If this Game Object has a physics body, it will not change the body. This is a rendering toggle only.\n     * \n     * @name Phaser.GameObjects.Components.Flip#flipX\n     * @type {boolean}\n     * @default false\n     * @since 3.0.0\n     */\n    flipX: false,\n\n    /**\n     * The vertically flipped state of the Game Object.\n     * \n     * A Game Object that is flipped vertically will render inversed on the vertical axis (i.e. upside down)\n     * Flipping always takes place from the middle of the texture and does not impact the scale value.\n     * If this Game Object has a physics body, it will not change the body. This is a rendering toggle only.\n     * \n     * @name Phaser.GameObjects.Components.Flip#flipY\n     * @type {boolean}\n     * @default false\n     * @since 3.0.0\n     */\n    flipY: false,\n\n    /**\n     * Toggles the horizontal flipped state of this Game Object.\n     * \n     * A Game Object that is flipped horizontally will render inversed on the horizontal axis.\n     * Flipping always takes place from the middle of the texture and does not impact the scale value.\n     * If this Game Object has a physics body, it will not change the body. This is a rendering toggle only.\n     * \n     * @method Phaser.GameObjects.Components.Flip#toggleFlipX\n     * @since 3.0.0\n     * \n     * @return {this} This Game Object instance.\n     */\n    toggleFlipX: function ()\n    {\n        this.flipX = !this.flipX;\n\n        return this;\n    },\n\n    /**\n     * Toggles the vertical flipped state of this Game Object.\n     * \n     * @method Phaser.GameObjects.Components.Flip#toggleFlipY\n     * @since 3.0.0\n     * \n     * @return {this} This Game Object instance.\n     */\n    toggleFlipY: function ()\n    {\n        this.flipY = !this.flipY;\n\n        return this;\n    },\n\n    /**\n     * Sets the horizontal flipped state of this Game Object.\n     * \n     * A Game Object that is flipped horizontally will render inversed on the horizontal axis.\n     * Flipping always takes place from the middle of the texture and does not impact the scale value.\n     * If this Game Object has a physics body, it will not change the body. This is a rendering toggle only.\n     * \n     * @method Phaser.GameObjects.Components.Flip#setFlipX\n     * @since 3.0.0\n     *\n     * @param {boolean} value - The flipped state. `false` for no flip, or `true` to be flipped.\n     * \n     * @return {this} This Game Object instance.\n     */\n    setFlipX: function (value)\n    {\n        this.flipX = value;\n\n        return this;\n    },\n\n    /**\n     * Sets the vertical flipped state of this Game Object.\n     * \n     * @method Phaser.GameObjects.Components.Flip#setFlipY\n     * @since 3.0.0\n     *\n     * @param {boolean} value - The flipped state. `false` for no flip, or `true` to be flipped.\n     * \n     * @return {this} This Game Object instance.\n     */\n    setFlipY: function (value)\n    {\n        this.flipY = value;\n\n        return this;\n    },\n\n    /**\n     * Sets the horizontal and vertical flipped state of this Game Object.\n     * \n     * A Game Object that is flipped will render inversed on the flipped axis.\n     * Flipping always takes place from the middle of the texture and does not impact the scale value.\n     * If this Game Object has a physics body, it will not change the body. This is a rendering toggle only.\n     * \n     * @method Phaser.GameObjects.Components.Flip#setFlip\n     * @since 3.0.0\n     *\n     * @param {boolean} x - The horizontal flipped state. `false` for no flip, or `true` to be flipped.\n     * @param {boolean} y - The horizontal flipped state. `false` for no flip, or `true` to be flipped.\n     * \n     * @return {this} This Game Object instance.\n     */\n    setFlip: function (x, y)\n    {\n        this.flipX = x;\n        this.flipY = y;\n\n        return this;\n    },\n\n    /**\n     * Resets the horizontal and vertical flipped state of this Game Object back to their default un-flipped state.\n     * \n     * @method Phaser.GameObjects.Components.Flip#resetFlip\n     * @since 3.0.0\n     *\n     * @return {this} This Game Object instance.\n     */\n    resetFlip: function ()\n    {\n        this.flipX = false;\n        this.flipY = false;\n\n        return this;\n    }\n\n};\n\nmodule.exports = Flip;\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * Provides methods used for getting and setting the Scroll Factor of a Game Object.\n *\n * @namespace Phaser.GameObjects.Components.ScrollFactor\n * @since 3.0.0\n */\n\nvar ScrollFactor = {\n\n    /**\n     * The horizontal scroll factor of this Game Object.\n     *\n     * The scroll factor controls the influence of the movement of a Camera upon this Game Object.\n     *\n     * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.\n     * It does not change the Game Objects actual position values.\n     *\n     * A value of 1 means it will move exactly in sync with a camera.\n     * A value of 0 means it will not move at all, even if the camera moves.\n     * Other values control the degree to which the camera movement is mapped to this Game Object.\n     * \n     * Please be aware that scroll factor values other than 1 are not taken in to consideration when\n     * calculating physics collisions. Bodies always collide based on their world position, but changing\n     * the scroll factor is a visual adjustment to where the textures are rendered, which can offset\n     * them from physics bodies if not accounted for in your code.\n     *\n     * @name Phaser.GameObjects.Components.ScrollFactor#scrollFactorX\n     * @type {number}\n     * @default 1\n     * @since 3.0.0\n     */\n    scrollFactorX: 1,\n\n    /**\n     * The vertical scroll factor of this Game Object.\n     *\n     * The scroll factor controls the influence of the movement of a Camera upon this Game Object.\n     *\n     * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.\n     * It does not change the Game Objects actual position values.\n     *\n     * A value of 1 means it will move exactly in sync with a camera.\n     * A value of 0 means it will not move at all, even if the camera moves.\n     * Other values control the degree to which the camera movement is mapped to this Game Object.\n     * \n     * Please be aware that scroll factor values other than 1 are not taken in to consideration when\n     * calculating physics collisions. Bodies always collide based on their world position, but changing\n     * the scroll factor is a visual adjustment to where the textures are rendered, which can offset\n     * them from physics bodies if not accounted for in your code.\n     *\n     * @name Phaser.GameObjects.Components.ScrollFactor#scrollFactorY\n     * @type {number}\n     * @default 1\n     * @since 3.0.0\n     */\n    scrollFactorY: 1,\n\n    /**\n     * Sets the scroll factor of this Game Object.\n     *\n     * The scroll factor controls the influence of the movement of a Camera upon this Game Object.\n     *\n     * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.\n     * It does not change the Game Objects actual position values.\n     *\n     * A value of 1 means it will move exactly in sync with a camera.\n     * A value of 0 means it will not move at all, even if the camera moves.\n     * Other values control the degree to which the camera movement is mapped to this Game Object.\n     * \n     * Please be aware that scroll factor values other than 1 are not taken in to consideration when\n     * calculating physics collisions. Bodies always collide based on their world position, but changing\n     * the scroll factor is a visual adjustment to where the textures are rendered, which can offset\n     * them from physics bodies if not accounted for in your code.\n     *\n     * @method Phaser.GameObjects.Components.ScrollFactor#setScrollFactor\n     * @since 3.0.0\n     *\n     * @param {number} x - The horizontal scroll factor of this Game Object.\n     * @param {number} [y=x] - The vertical scroll factor of this Game Object. If not set it will use the `x` value.\n     *\n     * @return {this} This Game Object instance.\n     */\n    setScrollFactor: function (x, y)\n    {\n        if (y === undefined) { y = x; }\n\n        this.scrollFactorX = x;\n        this.scrollFactorY = y;\n\n        return this;\n    }\n\n};\n\nmodule.exports = ScrollFactor;\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * Build a JSON representation of the given Game Object.\n *\n * This is typically extended further by Game Object specific implementations.\n *\n * @method Phaser.GameObjects.Components.ToJSON\n * @since 3.0.0\n *\n * @param {Phaser.GameObjects.GameObject} gameObject - The Game Object to export as JSON.\n *\n * @return {Phaser.Types.GameObjects.JSONGameObject} A JSON representation of the Game Object.\n */\nvar ToJSON = function (gameObject)\n{\n    var out = {\n        name: gameObject.name,\n        type: gameObject.type,\n        x: gameObject.x,\n        y: gameObject.y,\n        depth: gameObject.depth,\n        scale: {\n            x: gameObject.scaleX,\n            y: gameObject.scaleY\n        },\n        origin: {\n            x: gameObject.originX,\n            y: gameObject.originY\n        },\n        flipX: gameObject.flipX,\n        flipY: gameObject.flipY,\n        rotation: gameObject.rotation,\n        alpha: gameObject.alpha,\n        visible: gameObject.visible,\n        scaleMode: gameObject.scaleMode,\n        blendMode: gameObject.blendMode,\n        textureKey: '',\n        frameKey: '',\n        data: {}\n    };\n\n    if (gameObject.texture)\n    {\n        out.textureKey = gameObject.texture.key;\n        out.frameKey = gameObject.frame.name;\n    }\n\n    return out;\n};\n\nmodule.exports = ToJSON;\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\nvar MATH_CONST = require('../../math/const');\nvar TransformMatrix = require('./TransformMatrix');\nvar WrapAngle = require('../../math/angle/Wrap');\nvar WrapAngleDegrees = require('../../math/angle/WrapDegrees');\n\n//  global bitmask flag for GameObject.renderMask (used by Scale)\nvar _FLAG = 4; // 0100\n\n/**\n * Provides methods used for getting and setting the position, scale and rotation of a Game Object.\n *\n * @namespace Phaser.GameObjects.Components.Transform\n * @since 3.0.0\n */\n\nvar Transform = {\n\n    /**\n     * Private internal value. Holds the horizontal scale value.\n     * \n     * @name Phaser.GameObjects.Components.Transform#_scaleX\n     * @type {number}\n     * @private\n     * @default 1\n     * @since 3.0.0\n     */\n    _scaleX: 1,\n\n    /**\n     * Private internal value. Holds the vertical scale value.\n     * \n     * @name Phaser.GameObjects.Components.Transform#_scaleY\n     * @type {number}\n     * @private\n     * @default 1\n     * @since 3.0.0\n     */\n    _scaleY: 1,\n\n    /**\n     * Private internal value. Holds the rotation value in radians.\n     * \n     * @name Phaser.GameObjects.Components.Transform#_rotation\n     * @type {number}\n     * @private\n     * @default 0\n     * @since 3.0.0\n     */\n    _rotation: 0,\n\n    /**\n     * The x position of this Game Object.\n     *\n     * @name Phaser.GameObjects.Components.Transform#x\n     * @type {number}\n     * @default 0\n     * @since 3.0.0\n     */\n    x: 0,\n\n    /**\n     * The y position of this Game Object.\n     *\n     * @name Phaser.GameObjects.Components.Transform#y\n     * @type {number}\n     * @default 0\n     * @since 3.0.0\n     */\n    y: 0,\n\n    /**\n     * The z position of this Game Object.\n     * Note: Do not use this value to set the z-index, instead see the `depth` property.\n     *\n     * @name Phaser.GameObjects.Components.Transform#z\n     * @type {number}\n     * @default 0\n     * @since 3.0.0\n     */\n    z: 0,\n\n    /**\n     * The w position of this Game Object.\n     *\n     * @name Phaser.GameObjects.Components.Transform#w\n     * @type {number}\n     * @default 0\n     * @since 3.0.0\n     */\n    w: 0,\n\n    /**\n     * This is a special setter that allows you to set both the horizontal and vertical scale of this Game Object\n     * to the same value, at the same time. When reading this value the result returned is `(scaleX + scaleY) / 2`.\n     * \n     * Use of this property implies you wish the horizontal and vertical scales to be equal to each other. If this\n     * isn't the case, use the `scaleX` or `scaleY` properties instead.\n     *\n     * @name Phaser.GameObjects.Components.Transform#scale\n     * @type {number}\n     * @default 1\n     * @since 3.18.0\n     */\n    scale: {\n\n        get: function ()\n        {\n            return (this._scaleX + this._scaleY) / 2;\n        },\n\n        set: function (value)\n        {\n            this._scaleX = value;\n            this._scaleY = value;\n\n            if (value === 0)\n            {\n                this.renderFlags &= ~_FLAG;\n            }\n            else\n            {\n                this.renderFlags |= _FLAG;\n            }\n        }\n\n    },\n\n    /**\n     * The horizontal scale of this Game Object.\n     *\n     * @name Phaser.GameObjects.Components.Transform#scaleX\n     * @type {number}\n     * @default 1\n     * @since 3.0.0\n     */\n    scaleX: {\n\n        get: function ()\n        {\n            return this._scaleX;\n        },\n\n        set: function (value)\n        {\n            this._scaleX = value;\n\n            if (value === 0)\n            {\n                this.renderFlags &= ~_FLAG;\n            }\n            else\n            {\n                this.renderFlags |= _FLAG;\n            }\n        }\n\n    },\n\n    /**\n     * The vertical scale of this Game Object.\n     *\n     * @name Phaser.GameObjects.Components.Transform#scaleY\n     * @type {number}\n     * @default 1\n     * @since 3.0.0\n     */\n    scaleY: {\n\n        get: function ()\n        {\n            return this._scaleY;\n        },\n\n        set: function (value)\n        {\n            this._scaleY = value;\n\n            if (value === 0)\n            {\n                this.renderFlags &= ~_FLAG;\n            }\n            else\n            {\n                this.renderFlags |= _FLAG;\n            }\n        }\n\n    },\n\n    /**\n     * The angle of this Game Object as expressed in degrees.\n     * \n     * Phaser uses a right-hand clockwise rotation system, where 0 is right, 90 is down, 180/-180 is left\n     * and -90 is up.\n     *\n     * If you prefer to work in radians, see the `rotation` property instead.\n     *\n     * @name Phaser.GameObjects.Components.Transform#angle\n     * @type {integer}\n     * @default 0\n     * @since 3.0.0\n     */\n    angle: {\n\n        get: function ()\n        {\n            return WrapAngleDegrees(this._rotation * MATH_CONST.RAD_TO_DEG);\n        },\n\n        set: function (value)\n        {\n            //  value is in degrees\n            this.rotation = WrapAngleDegrees(value) * MATH_CONST.DEG_TO_RAD;\n        }\n    },\n\n    /**\n     * The angle of this Game Object in radians.\n     * \n     * Phaser uses a right-hand clockwise rotation system, where 0 is right, 90 is down, 180/-180 is left\n     * and -90 is up.\n     *\n     * If you prefer to work in degrees, see the `angle` property instead.\n     *\n     * @name Phaser.GameObjects.Components.Transform#rotation\n     * @type {number}\n     * @default 1\n     * @since 3.0.0\n     */\n    rotation: {\n\n        get: function ()\n        {\n            return this._rotation;\n        },\n\n        set: function (value)\n        {\n            //  value is in radians\n            this._rotation = WrapAngle(value);\n        }\n    },\n\n    /**\n     * Sets the position of this Game Object.\n     *\n     * @method Phaser.GameObjects.Components.Transform#setPosition\n     * @since 3.0.0\n     *\n     * @param {number} [x=0] - The x position of this Game Object.\n     * @param {number} [y=x] - The y position of this Game Object. If not set it will use the `x` value.\n     * @param {number} [z=0] - The z position of this Game Object.\n     * @param {number} [w=0] - The w position of this Game Object.\n     *\n     * @return {this} This Game Object instance.\n     */\n    setPosition: function (x, y, z, w)\n    {\n        if (x === undefined) { x = 0; }\n        if (y === undefined) { y = x; }\n        if (z === undefined) { z = 0; }\n        if (w === undefined) { w = 0; }\n\n        this.x = x;\n        this.y = y;\n        this.z = z;\n        this.w = w;\n\n        return this;\n    },\n\n    /**\n     * Sets the position of this Game Object to be a random position within the confines of\n     * the given area.\n     * \n     * If no area is specified a random position between 0 x 0 and the game width x height is used instead.\n     *\n     * The position does not factor in the size of this Game Object, meaning that only the origin is\n     * guaranteed to be within the area.\n     *\n     * @method Phaser.GameObjects.Components.Transform#setRandomPosition\n     * @since 3.8.0\n     *\n     * @param {number} [x=0] - The x position of the top-left of the random area.\n     * @param {number} [y=0] - The y position of the top-left of the random area.\n     * @param {number} [width] - The width of the random area.\n     * @param {number} [height] - The height of the random area.\n     *\n     * @return {this} This Game Object instance.\n     */\n    setRandomPosition: function (x, y, width, height)\n    {\n        if (x === undefined) { x = 0; }\n        if (y === undefined) { y = 0; }\n        if (width === undefined) { width = this.scene.sys.scale.width; }\n        if (height === undefined) { height = this.scene.sys.scale.height; }\n\n        this.x = x + (Math.random() * width);\n        this.y = y + (Math.random() * height);\n\n        return this;\n    },\n\n    /**\n     * Sets the rotation of this Game Object.\n     *\n     * @method Phaser.GameObjects.Components.Transform#setRotation\n     * @since 3.0.0\n     *\n     * @param {number} [radians=0] - The rotation of this Game Object, in radians.\n     *\n     * @return {this} This Game Object instance.\n     */\n    setRotation: function (radians)\n    {\n        if (radians === undefined) { radians = 0; }\n\n        this.rotation = radians;\n\n        return this;\n    },\n\n    /**\n     * Sets the angle of this Game Object.\n     *\n     * @method Phaser.GameObjects.Components.Transform#setAngle\n     * @since 3.0.0\n     *\n     * @param {number} [degrees=0] - The rotation of this Game Object, in degrees.\n     *\n     * @return {this} This Game Object instance.\n     */\n    setAngle: function (degrees)\n    {\n        if (degrees === undefined) { degrees = 0; }\n\n        this.angle = degrees;\n\n        return this;\n    },\n\n    /**\n     * Sets the scale of this Game Object.\n     *\n     * @method Phaser.GameObjects.Components.Transform#setScale\n     * @since 3.0.0\n     *\n     * @param {number} x - The horizontal scale of this Game Object.\n     * @param {number} [y=x] - The vertical scale of this Game Object. If not set it will use the `x` value.\n     *\n     * @return {this} This Game Object instance.\n     */\n    setScale: function (x, y)\n    {\n        if (x === undefined) { x = 1; }\n        if (y === undefined) { y = x; }\n\n        this.scaleX = x;\n        this.scaleY = y;\n\n        return this;\n    },\n\n    /**\n     * Sets the x position of this Game Object.\n     *\n     * @method Phaser.GameObjects.Components.Transform#setX\n     * @since 3.0.0\n     *\n     * @param {number} [value=0] - The x position of this Game Object.\n     *\n     * @return {this} This Game Object instance.\n     */\n    setX: function (value)\n    {\n        if (value === undefined) { value = 0; }\n\n        this.x = value;\n\n        return this;\n    },\n\n    /**\n     * Sets the y position of this Game Object.\n     *\n     * @method Phaser.GameObjects.Components.Transform#setY\n     * @since 3.0.0\n     *\n     * @param {number} [value=0] - The y position of this Game Object.\n     *\n     * @return {this} This Game Object instance.\n     */\n    setY: function (value)\n    {\n        if (value === undefined) { value = 0; }\n\n        this.y = value;\n\n        return this;\n    },\n\n    /**\n     * Sets the z position of this Game Object.\n     *\n     * @method Phaser.GameObjects.Components.Transform#setZ\n     * @since 3.0.0\n     *\n     * @param {number} [value=0] - The z position of this Game Object.\n     *\n     * @return {this} This Game Object instance.\n     */\n    setZ: function (value)\n    {\n        if (value === undefined) { value = 0; }\n\n        this.z = value;\n\n        return this;\n    },\n\n    /**\n     * Sets the w position of this Game Object.\n     *\n     * @method Phaser.GameObjects.Components.Transform#setW\n     * @since 3.0.0\n     *\n     * @param {number} [value=0] - The w position of this Game Object.\n     *\n     * @return {this} This Game Object instance.\n     */\n    setW: function (value)\n    {\n        if (value === undefined) { value = 0; }\n\n        this.w = value;\n\n        return this;\n    },\n\n    /**\n     * Gets the local transform matrix for this Game Object.\n     *\n     * @method Phaser.GameObjects.Components.Transform#getLocalTransformMatrix\n     * @since 3.4.0\n     *\n     * @param {Phaser.GameObjects.Components.TransformMatrix} [tempMatrix] - The matrix to populate with the values from this Game Object.\n     *\n     * @return {Phaser.GameObjects.Components.TransformMatrix} The populated Transform Matrix.\n     */\n    getLocalTransformMatrix: function (tempMatrix)\n    {\n        if (tempMatrix === undefined) { tempMatrix = new TransformMatrix(); }\n\n        return tempMatrix.applyITRS(this.x, this.y, this._rotation, this._scaleX, this._scaleY);\n    },\n\n    /**\n     * Gets the world transform matrix for this Game Object, factoring in any parent Containers.\n     *\n     * @method Phaser.GameObjects.Components.Transform#getWorldTransformMatrix\n     * @since 3.4.0\n     *\n     * @param {Phaser.GameObjects.Components.TransformMatrix} [tempMatrix] - The matrix to populate with the values from this Game Object.\n     * @param {Phaser.GameObjects.Components.TransformMatrix} [parentMatrix] - A temporary matrix to hold parent values during the calculations.\n     *\n     * @return {Phaser.GameObjects.Components.TransformMatrix} The populated Transform Matrix.\n     */\n    getWorldTransformMatrix: function (tempMatrix, parentMatrix)\n    {\n        if (tempMatrix === undefined) { tempMatrix = new TransformMatrix(); }\n        if (parentMatrix === undefined) { parentMatrix = new TransformMatrix(); }\n\n        var parent = this.parentContainer;\n\n        if (!parent)\n        {\n            return this.getLocalTransformMatrix(tempMatrix);\n        }\n\n        tempMatrix.applyITRS(this.x, this.y, this._rotation, this._scaleX, this._scaleY);\n\n        while (parent)\n        {\n            parentMatrix.applyITRS(parent.x, parent.y, parent._rotation, parent._scaleX, parent._scaleY);\n\n            parentMatrix.multiply(tempMatrix, tempMatrix);\n\n            parent = parent.parentContainer;\n        }\n\n        return tempMatrix;\n    },\n\n    /**\n     * Gets the sum total rotation of all of this Game Objects parent Containers.\n     * \n     * The returned value is in radians and will be zero if this Game Object has no parent container.\n     *\n     * @method Phaser.GameObjects.Components.Transform#getParentRotation\n     * @since 3.18.0\n     *\n     * @return {number} The sum total rotation, in radians, of all parent containers of this Game Object.\n     */\n    getParentRotation: function ()\n    {\n        var rotation = 0;\n\n        var parent = this.parentContainer;\n\n        while (parent)\n        {\n            rotation += parent.rotation;\n\n            parent = parent.parentContainer;\n        }\n\n        return rotation;\n    }\n\n};\n\nmodule.exports = Transform;\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\nvar Class = require('../../utils/Class');\nvar MATH_CONST = require('../../math/const');\nvar Vector2 = require('../../math/Vector2');\n\n/**\n * @classdesc\n * A Matrix used for display transformations for rendering.\n *\n * It is represented like so:\n *\n * ```\n * | a | c | tx |\n * | b | d | ty |\n * | 0 | 0 | 1  |\n * ```\n *\n * @class TransformMatrix\n * @memberof Phaser.GameObjects.Components\n * @constructor\n * @since 3.0.0\n *\n * @param {number} [a=1] - The Scale X value.\n * @param {number} [b=0] - The Skew Y value.\n * @param {number} [c=0] - The Skew X value.\n * @param {number} [d=1] - The Scale Y value.\n * @param {number} [tx=0] - The Translate X value.\n * @param {number} [ty=0] - The Translate Y value.\n */\nvar TransformMatrix = new Class({\n\n    initialize:\n\n    function TransformMatrix (a, b, c, d, tx, ty)\n    {\n        if (a === undefined) { a = 1; }\n        if (b === undefined) { b = 0; }\n        if (c === undefined) { c = 0; }\n        if (d === undefined) { d = 1; }\n        if (tx === undefined) { tx = 0; }\n        if (ty === undefined) { ty = 0; }\n\n        /**\n         * The matrix values.\n         *\n         * @name Phaser.GameObjects.Components.TransformMatrix#matrix\n         * @type {Float32Array}\n         * @since 3.0.0\n         */\n        this.matrix = new Float32Array([ a, b, c, d, tx, ty, 0, 0, 1 ]);\n\n        /**\n         * The decomposed matrix.\n         *\n         * @name Phaser.GameObjects.Components.TransformMatrix#decomposedMatrix\n         * @type {object}\n         * @since 3.0.0\n         */\n        this.decomposedMatrix = {\n            translateX: 0,\n            translateY: 0,\n            scaleX: 1,\n            scaleY: 1,\n            rotation: 0\n        };\n    },\n\n    /**\n     * The Scale X value.\n     *\n     * @name Phaser.GameObjects.Components.TransformMatrix#a\n     * @type {number}\n     * @since 3.4.0\n     */\n    a: {\n\n        get: function ()\n        {\n            return this.matrix[0];\n        },\n\n        set: function (value)\n        {\n            this.matrix[0] = value;\n        }\n\n    },\n\n    /**\n     * The Skew Y value.\n     *\n     * @name Phaser.GameObjects.Components.TransformMatrix#b\n     * @type {number}\n     * @since 3.4.0\n     */\n    b: {\n\n        get: function ()\n        {\n            return this.matrix[1];\n        },\n\n        set: function (value)\n        {\n            this.matrix[1] = value;\n        }\n\n    },\n\n    /**\n     * The Skew X value.\n     *\n     * @name Phaser.GameObjects.Components.TransformMatrix#c\n     * @type {number}\n     * @since 3.4.0\n     */\n    c: {\n\n        get: function ()\n        {\n            return this.matrix[2];\n        },\n\n        set: function (value)\n        {\n            this.matrix[2] = value;\n        }\n\n    },\n\n    /**\n     * The Scale Y value.\n     *\n     * @name Phaser.GameObjects.Components.TransformMatrix#d\n     * @type {number}\n     * @since 3.4.0\n     */\n    d: {\n\n        get: function ()\n        {\n            return this.matrix[3];\n        },\n\n        set: function (value)\n        {\n            this.matrix[3] = value;\n        }\n\n    },\n\n    /**\n     * The Translate X value.\n     *\n     * @name Phaser.GameObjects.Components.TransformMatrix#e\n     * @type {number}\n     * @since 3.11.0\n     */\n    e: {\n\n        get: function ()\n        {\n            return this.matrix[4];\n        },\n\n        set: function (value)\n        {\n            this.matrix[4] = value;\n        }\n\n    },\n\n    /**\n     * The Translate Y value.\n     *\n     * @name Phaser.GameObjects.Components.TransformMatrix#f\n     * @type {number}\n     * @since 3.11.0\n     */\n    f: {\n\n        get: function ()\n        {\n            return this.matrix[5];\n        },\n\n        set: function (value)\n        {\n            this.matrix[5] = value;\n        }\n\n    },\n\n    /**\n     * The Translate X value.\n     *\n     * @name Phaser.GameObjects.Components.TransformMatrix#tx\n     * @type {number}\n     * @since 3.4.0\n     */\n    tx: {\n\n        get: function ()\n        {\n            return this.matrix[4];\n        },\n\n        set: function (value)\n        {\n            this.matrix[4] = value;\n        }\n\n    },\n\n    /**\n     * The Translate Y value.\n     *\n     * @name Phaser.GameObjects.Components.TransformMatrix#ty\n     * @type {number}\n     * @since 3.4.0\n     */\n    ty: {\n\n        get: function ()\n        {\n            return this.matrix[5];\n        },\n\n        set: function (value)\n        {\n            this.matrix[5] = value;\n        }\n\n    },\n\n    /**\n     * The rotation of the Matrix. Value is in radians.\n     *\n     * @name Phaser.GameObjects.Components.TransformMatrix#rotation\n     * @type {number}\n     * @readonly\n     * @since 3.4.0\n     */\n    rotation: {\n\n        get: function ()\n        {\n            return Math.acos(this.a / this.scaleX) * ((Math.atan(-this.c / this.a) < 0) ? -1 : 1);\n        }\n\n    },\n\n    /**\n     * The rotation of the Matrix, normalized to be within the Phaser right-handed\n     * clockwise rotation space. Value is in radians.\n     *\n     * @name Phaser.GameObjects.Components.TransformMatrix#rotationNormalized\n     * @type {number}\n     * @readonly\n     * @since 3.19.0\n     */\n    rotationNormalized: {\n\n        get: function ()\n        {\n            var matrix = this.matrix;\n\n            var a = matrix[0];\n            var b = matrix[1];\n            var c = matrix[2];\n            var d = matrix[3];\n\n            if (a || b)\n            {\n                // var r = Math.sqrt(a * a + b * b);\n    \n                return (b > 0) ? Math.acos(a / this.scaleX) : -Math.acos(a / this.scaleX);\n            }\n            else if (c || d)\n            {\n                // var s = Math.sqrt(c * c + d * d);\n    \n                return MATH_CONST.TAU - ((d > 0) ? Math.acos(-c / this.scaleY) : -Math.acos(c / this.scaleY));\n            }\n            else\n            {\n                return 0;\n            }\n        }\n\n    },\n\n    /**\n     * The decomposed horizontal scale of the Matrix. This value is always positive.\n     *\n     * @name Phaser.GameObjects.Components.TransformMatrix#scaleX\n     * @type {number}\n     * @readonly\n     * @since 3.4.0\n     */\n    scaleX: {\n\n        get: function ()\n        {\n            return Math.sqrt((this.a * this.a) + (this.b * this.b));\n        }\n\n    },\n\n    /**\n     * The decomposed vertical scale of the Matrix. This value is always positive.\n     *\n     * @name Phaser.GameObjects.Components.TransformMatrix#scaleY\n     * @type {number}\n     * @readonly\n     * @since 3.4.0\n     */\n    scaleY: {\n\n        get: function ()\n        {\n            return Math.sqrt((this.c * this.c) + (this.d * this.d));\n        }\n\n    },\n\n    /**\n     * Reset the Matrix to an identity matrix.\n     *\n     * @method Phaser.GameObjects.Components.TransformMatrix#loadIdentity\n     * @since 3.0.0\n     *\n     * @return {this} This TransformMatrix.\n     */\n    loadIdentity: function ()\n    {\n        var matrix = this.matrix;\n\n        matrix[0] = 1;\n        matrix[1] = 0;\n        matrix[2] = 0;\n        matrix[3] = 1;\n        matrix[4] = 0;\n        matrix[5] = 0;\n\n        return this;\n    },\n\n    /**\n     * Translate the Matrix.\n     *\n     * @method Phaser.GameObjects.Components.TransformMatrix#translate\n     * @since 3.0.0\n     *\n     * @param {number} x - The horizontal translation value.\n     * @param {number} y - The vertical translation value.\n     *\n     * @return {this} This TransformMatrix.\n     */\n    translate: function (x, y)\n    {\n        var matrix = this.matrix;\n\n        matrix[4] = matrix[0] * x + matrix[2] * y + matrix[4];\n        matrix[5] = matrix[1] * x + matrix[3] * y + matrix[5];\n\n        return this;\n    },\n\n    /**\n     * Scale the Matrix.\n     *\n     * @method Phaser.GameObjects.Components.TransformMatrix#scale\n     * @since 3.0.0\n     *\n     * @param {number} x - The horizontal scale value.\n     * @param {number} y - The vertical scale value.\n     *\n     * @return {this} This TransformMatrix.\n     */\n    scale: function (x, y)\n    {\n        var matrix = this.matrix;\n\n        matrix[0] *= x;\n        matrix[1] *= x;\n        matrix[2] *= y;\n        matrix[3] *= y;\n\n        return this;\n    },\n\n    /**\n     * Rotate the Matrix.\n     *\n     * @method Phaser.GameObjects.Components.TransformMatrix#rotate\n     * @since 3.0.0\n     *\n     * @param {number} angle - The angle of rotation in radians.\n     *\n     * @return {this} This TransformMatrix.\n     */\n    rotate: function (angle)\n    {\n        var sin = Math.sin(angle);\n        var cos = Math.cos(angle);\n\n        var matrix = this.matrix;\n\n        var a = matrix[0];\n        var b = matrix[1];\n        var c = matrix[2];\n        var d = matrix[3];\n\n        matrix[0] = a * cos + c * sin;\n        matrix[1] = b * cos + d * sin;\n        matrix[2] = a * -sin + c * cos;\n        matrix[3] = b * -sin + d * cos;\n\n        return this;\n    },\n\n    /**\n     * Multiply this Matrix by the given Matrix.\n     * \n     * If an `out` Matrix is given then the results will be stored in it.\n     * If it is not given, this matrix will be updated in place instead.\n     * Use an `out` Matrix if you do not wish to mutate this matrix.\n     *\n     * @method Phaser.GameObjects.Components.TransformMatrix#multiply\n     * @since 3.0.0\n     *\n     * @param {Phaser.GameObjects.Components.TransformMatrix} rhs - The Matrix to multiply by.\n     * @param {Phaser.GameObjects.Components.TransformMatrix} [out] - An optional Matrix to store the results in.\n     *\n     * @return {Phaser.GameObjects.Components.TransformMatrix} Either this TransformMatrix, or the `out` Matrix, if given in the arguments.\n     */\n    multiply: function (rhs, out)\n    {\n        var matrix = this.matrix;\n        var source = rhs.matrix;\n\n        var localA = matrix[0];\n        var localB = matrix[1];\n        var localC = matrix[2];\n        var localD = matrix[3];\n        var localE = matrix[4];\n        var localF = matrix[5];\n\n        var sourceA = source[0];\n        var sourceB = source[1];\n        var sourceC = source[2];\n        var sourceD = source[3];\n        var sourceE = source[4];\n        var sourceF = source[5];\n\n        var destinationMatrix = (out === undefined) ? this : out;\n\n        destinationMatrix.a = (sourceA * localA) + (sourceB * localC);\n        destinationMatrix.b = (sourceA * localB) + (sourceB * localD);\n        destinationMatrix.c = (sourceC * localA) + (sourceD * localC);\n        destinationMatrix.d = (sourceC * localB) + (sourceD * localD);\n        destinationMatrix.e = (sourceE * localA) + (sourceF * localC) + localE;\n        destinationMatrix.f = (sourceE * localB) + (sourceF * localD) + localF;\n\n        return destinationMatrix;\n    },\n\n    /**\n     * Multiply this Matrix by the matrix given, including the offset.\n     * \n     * The offsetX is added to the tx value: `offsetX * a + offsetY * c + tx`.\n     * The offsetY is added to the ty value: `offsetY * b + offsetY * d + ty`.\n     *\n     * @method Phaser.GameObjects.Components.TransformMatrix#multiplyWithOffset\n     * @since 3.11.0\n     *\n     * @param {Phaser.GameObjects.Components.TransformMatrix} src - The source Matrix to copy from.\n     * @param {number} offsetX - Horizontal offset to factor in to the multiplication.\n     * @param {number} offsetY - Vertical offset to factor in to the multiplication.\n     *\n     * @return {this} This TransformMatrix.\n     */\n    multiplyWithOffset: function (src, offsetX, offsetY)\n    {\n        var matrix = this.matrix;\n        var otherMatrix = src.matrix;\n\n        var a0 = matrix[0];\n        var b0 = matrix[1];\n        var c0 = matrix[2];\n        var d0 = matrix[3];\n        var tx0 = matrix[4];\n        var ty0 = matrix[5];\n\n        var pse = offsetX * a0 + offsetY * c0 + tx0;\n        var psf = offsetX * b0 + offsetY * d0 + ty0;\n\n        var a1 = otherMatrix[0];\n        var b1 = otherMatrix[1];\n        var c1 = otherMatrix[2];\n        var d1 = otherMatrix[3];\n        var tx1 = otherMatrix[4];\n        var ty1 = otherMatrix[5];\n\n        matrix[0] = a1 * a0 + b1 * c0;\n        matrix[1] = a1 * b0 + b1 * d0;\n        matrix[2] = c1 * a0 + d1 * c0;\n        matrix[3] = c1 * b0 + d1 * d0;\n        matrix[4] = tx1 * a0 + ty1 * c0 + pse;\n        matrix[5] = tx1 * b0 + ty1 * d0 + psf;\n\n        return this;\n    },\n\n    /**\n     * Transform the Matrix.\n     *\n     * @method Phaser.GameObjects.Components.TransformMatrix#transform\n     * @since 3.0.0\n     *\n     * @param {number} a - The Scale X value.\n     * @param {number} b - The Shear Y value.\n     * @param {number} c - The Shear X value.\n     * @param {number} d - The Scale Y value.\n     * @param {number} tx - The Translate X value.\n     * @param {number} ty - The Translate Y value.\n     *\n     * @return {this} This TransformMatrix.\n     */\n    transform: function (a, b, c, d, tx, ty)\n    {\n        var matrix = this.matrix;\n\n        var a0 = matrix[0];\n        var b0 = matrix[1];\n        var c0 = matrix[2];\n        var d0 = matrix[3];\n        var tx0 = matrix[4];\n        var ty0 = matrix[5];\n\n        matrix[0] = a * a0 + b * c0;\n        matrix[1] = a * b0 + b * d0;\n        matrix[2] = c * a0 + d * c0;\n        matrix[3] = c * b0 + d * d0;\n        matrix[4] = tx * a0 + ty * c0 + tx0;\n        matrix[5] = tx * b0 + ty * d0 + ty0;\n\n        return this;\n    },\n\n    /**\n     * Transform a point using this Matrix.\n     *\n     * @method Phaser.GameObjects.Components.TransformMatrix#transformPoint\n     * @since 3.0.0\n     *\n     * @param {number} x - The x coordinate of the point to transform.\n     * @param {number} y - The y coordinate of the point to transform.\n     * @param {(Phaser.Geom.Point|Phaser.Math.Vector2|object)} point - The Point object to store the transformed coordinates.\n     *\n     * @return {(Phaser.Geom.Point|Phaser.Math.Vector2|object)} The Point containing the transformed coordinates.\n     */\n    transformPoint: function (x, y, point)\n    {\n        if (point === undefined) { point = { x: 0, y: 0 }; }\n\n        var matrix = this.matrix;\n\n        var a = matrix[0];\n        var b = matrix[1];\n        var c = matrix[2];\n        var d = matrix[3];\n        var tx = matrix[4];\n        var ty = matrix[5];\n\n        point.x = x * a + y * c + tx;\n        point.y = x * b + y * d + ty;\n\n        return point;\n    },\n\n    /**\n     * Invert the Matrix.\n     *\n     * @method Phaser.GameObjects.Components.TransformMatrix#invert\n     * @since 3.0.0\n     *\n     * @return {this} This TransformMatrix.\n     */\n    invert: function ()\n    {\n        var matrix = this.matrix;\n\n        var a = matrix[0];\n        var b = matrix[1];\n        var c = matrix[2];\n        var d = matrix[3];\n        var tx = matrix[4];\n        var ty = matrix[5];\n\n        var n = a * d - b * c;\n\n        matrix[0] = d / n;\n        matrix[1] = -b / n;\n        matrix[2] = -c / n;\n        matrix[3] = a / n;\n        matrix[4] = (c * ty - d * tx) / n;\n        matrix[5] = -(a * ty - b * tx) / n;\n\n        return this;\n    },\n\n    /**\n     * Set the values of this Matrix to copy those of the matrix given.\n     *\n     * @method Phaser.GameObjects.Components.TransformMatrix#copyFrom\n     * @since 3.11.0\n     *\n     * @param {Phaser.GameObjects.Components.TransformMatrix} src - The source Matrix to copy from.\n     *\n     * @return {this} This TransformMatrix.\n     */\n    copyFrom: function (src)\n    {\n        var matrix = this.matrix;\n\n        matrix[0] = src.a;\n        matrix[1] = src.b;\n        matrix[2] = src.c;\n        matrix[3] = src.d;\n        matrix[4] = src.e;\n        matrix[5] = src.f;\n\n        return this;\n    },\n\n    /**\n     * Set the values of this Matrix to copy those of the array given.\n     * Where array indexes 0, 1, 2, 3, 4 and 5 are mapped to a, b, c, d, e and f.\n     *\n     * @method Phaser.GameObjects.Components.TransformMatrix#copyFromArray\n     * @since 3.11.0\n     *\n     * @param {array} src - The array of values to set into this matrix.\n     *\n     * @return {this} This TransformMatrix.\n     */\n    copyFromArray: function (src)\n    {\n        var matrix = this.matrix;\n\n        matrix[0] = src[0];\n        matrix[1] = src[1];\n        matrix[2] = src[2];\n        matrix[3] = src[3];\n        matrix[4] = src[4];\n        matrix[5] = src[5];\n\n        return this;\n    },\n\n    /**\n     * Copy the values from this Matrix to the given Canvas Rendering Context.\n     * This will use the Context.transform method.\n     *\n     * @method Phaser.GameObjects.Components.TransformMatrix#copyToContext\n     * @since 3.12.0\n     *\n     * @param {CanvasRenderingContext2D} ctx - The Canvas Rendering Context to copy the matrix values to.\n     *\n     * @return {CanvasRenderingContext2D} The Canvas Rendering Context.\n     */\n    copyToContext: function (ctx)\n    {\n        var matrix = this.matrix;\n\n        ctx.transform(matrix[0], matrix[1], matrix[2], matrix[3], matrix[4], matrix[5]);\n\n        return ctx;\n    },\n\n    /**\n     * Copy the values from this Matrix to the given Canvas Rendering Context.\n     * This will use the Context.setTransform method.\n     *\n     * @method Phaser.GameObjects.Components.TransformMatrix#setToContext\n     * @since 3.12.0\n     *\n     * @param {CanvasRenderingContext2D} ctx - The Canvas Rendering Context to copy the matrix values to.\n     *\n     * @return {CanvasRenderingContext2D} The Canvas Rendering Context.\n     */\n    setToContext: function (ctx)\n    {\n        var matrix = this.matrix;\n\n        ctx.setTransform(matrix[0], matrix[1], matrix[2], matrix[3], matrix[4], matrix[5]);\n\n        return ctx;\n    },\n\n    /**\n     * Copy the values in this Matrix to the array given.\n     * \n     * Where array indexes 0, 1, 2, 3, 4 and 5 are mapped to a, b, c, d, e and f.\n     *\n     * @method Phaser.GameObjects.Components.TransformMatrix#copyToArray\n     * @since 3.12.0\n     *\n     * @param {array} [out] - The array to copy the matrix values in to.\n     *\n     * @return {array} An array where elements 0 to 5 contain the values from this matrix.\n     */\n    copyToArray: function (out)\n    {\n        var matrix = this.matrix;\n\n        if (out === undefined)\n        {\n            out = [ matrix[0], matrix[1], matrix[2], matrix[3], matrix[4], matrix[5] ];\n        }\n        else\n        {\n            out[0] = matrix[0];\n            out[1] = matrix[1];\n            out[2] = matrix[2];\n            out[3] = matrix[3];\n            out[4] = matrix[4];\n            out[5] = matrix[5];\n        }\n\n        return out;\n    },\n\n    /**\n     * Set the values of this Matrix.\n     *\n     * @method Phaser.GameObjects.Components.TransformMatrix#setTransform\n     * @since 3.0.0\n     *\n     * @param {number} a - The Scale X value.\n     * @param {number} b - The Shear Y value.\n     * @param {number} c - The Shear X value.\n     * @param {number} d - The Scale Y value.\n     * @param {number} tx - The Translate X value.\n     * @param {number} ty - The Translate Y value.\n     *\n     * @return {this} This TransformMatrix.\n     */\n    setTransform: function (a, b, c, d, tx, ty)\n    {\n        var matrix = this.matrix;\n\n        matrix[0] = a;\n        matrix[1] = b;\n        matrix[2] = c;\n        matrix[3] = d;\n        matrix[4] = tx;\n        matrix[5] = ty;\n\n        return this;\n    },\n\n    /**\n     * Decompose this Matrix into its translation, scale and rotation values using QR decomposition.\n     * \n     * The result must be applied in the following order to reproduce the current matrix:\n     * \n     * translate -> rotate -> scale\n     *\n     * @method Phaser.GameObjects.Components.TransformMatrix#decomposeMatrix\n     * @since 3.0.0\n     *\n     * @return {object} The decomposed Matrix.\n     */\n    decomposeMatrix: function ()\n    {\n        var decomposedMatrix = this.decomposedMatrix;\n\n        var matrix = this.matrix;\n\n        //  a = scale X (1)\n        //  b = shear Y (0)\n        //  c = shear X (0)\n        //  d = scale Y (1)\n\n        var a = matrix[0];\n        var b = matrix[1];\n        var c = matrix[2];\n        var d = matrix[3];\n\n        var determ = a * d - b * c;\n\n        decomposedMatrix.translateX = matrix[4];\n        decomposedMatrix.translateY = matrix[5];\n\n        if (a || b)\n        {\n            var r = Math.sqrt(a * a + b * b);\n\n            decomposedMatrix.rotation = (b > 0) ? Math.acos(a / r) : -Math.acos(a / r);\n            decomposedMatrix.scaleX = r;\n            decomposedMatrix.scaleY = determ / r;\n        }\n        else if (c || d)\n        {\n            var s = Math.sqrt(c * c + d * d);\n\n            decomposedMatrix.rotation = Math.PI * 0.5 - (d > 0 ? Math.acos(-c / s) : -Math.acos(c / s));\n            decomposedMatrix.scaleX = determ / s;\n            decomposedMatrix.scaleY = s;\n        }\n        else\n        {\n            decomposedMatrix.rotation = 0;\n            decomposedMatrix.scaleX = 0;\n            decomposedMatrix.scaleY = 0;\n        }\n\n        return decomposedMatrix;\n    },\n\n    /**\n     * Apply the identity, translate, rotate and scale operations on the Matrix.\n     *\n     * @method Phaser.GameObjects.Components.TransformMatrix#applyITRS\n     * @since 3.0.0\n     *\n     * @param {number} x - The horizontal translation.\n     * @param {number} y - The vertical translation.\n     * @param {number} rotation - The angle of rotation in radians.\n     * @param {number} scaleX - The horizontal scale.\n     * @param {number} scaleY - The vertical scale.\n     *\n     * @return {this} This TransformMatrix.\n     */\n    applyITRS: function (x, y, rotation, scaleX, scaleY)\n    {\n        var matrix = this.matrix;\n\n        var radianSin = Math.sin(rotation);\n        var radianCos = Math.cos(rotation);\n\n        // Translate\n        matrix[4] = x;\n        matrix[5] = y;\n\n        // Rotate and Scale\n        matrix[0] = radianCos * scaleX;\n        matrix[1] = radianSin * scaleX;\n        matrix[2] = -radianSin * scaleY;\n        matrix[3] = radianCos * scaleY;\n\n        return this;\n    },\n\n    /**\n     * Takes the `x` and `y` values and returns a new position in the `output` vector that is the inverse of\n     * the current matrix with its transformation applied.\n     * \n     * Can be used to translate points from world to local space.\n     *\n     * @method Phaser.GameObjects.Components.TransformMatrix#applyInverse\n     * @since 3.12.0\n     *\n     * @param {number} x - The x position to translate.\n     * @param {number} y - The y position to translate.\n     * @param {Phaser.Math.Vector2} [output] - A Vector2, or point-like object, to store the results in.\n     *\n     * @return {Phaser.Math.Vector2} The coordinates, inverse-transformed through this matrix.\n     */\n    applyInverse: function (x, y, output)\n    {\n        if (output === undefined) { output = new Vector2(); }\n\n        var matrix = this.matrix;\n\n        var a = matrix[0];\n        var b = matrix[1];\n        var c = matrix[2];\n        var d = matrix[3];\n        var tx = matrix[4];\n        var ty = matrix[5];\n\n        var id = 1 / ((a * d) + (c * -b));\n\n        output.x = (d * id * x) + (-c * id * y) + (((ty * c) - (tx * d)) * id);\n        output.y = (a * id * y) + (-b * id * x) + (((-ty * a) + (tx * b)) * id);\n\n        return output;\n    },\n\n    /**\n     * Returns the X component of this matrix multiplied by the given values.\n     * This is the same as `x * a + y * c + e`.\n     *\n     * @method Phaser.GameObjects.Components.TransformMatrix#getX\n     * @since 3.12.0\n     * \n     * @param {number} x - The x value.\n     * @param {number} y - The y value.\n     *\n     * @return {number} The calculated x value.\n     */\n    getX: function (x, y)\n    {\n        return x * this.a + y * this.c + this.e;\n    },\n\n    /**\n     * Returns the Y component of this matrix multiplied by the given values.\n     * This is the same as `x * b + y * d + f`.\n     *\n     * @method Phaser.GameObjects.Components.TransformMatrix#getY\n     * @since 3.12.0\n     * \n     * @param {number} x - The x value.\n     * @param {number} y - The y value.\n     *\n     * @return {number} The calculated y value.\n     */\n    getY: function (x, y)\n    {\n        return x * this.b + y * this.d + this.f;\n    },\n\n    /**\n     * Returns a string that can be used in a CSS Transform call as a `matrix` property.\n     *\n     * @method Phaser.GameObjects.Components.TransformMatrix#getCSSMatrix\n     * @since 3.12.0\n     *\n     * @return {string} A string containing the CSS Transform matrix values.\n     */\n    getCSSMatrix: function ()\n    {\n        var m = this.matrix;\n\n        return 'matrix(' + m[0] + ',' + m[1] + ',' + m[2] + ',' + m[3] + ',' + m[4] + ',' + m[5] + ')';\n    },\n\n    /**\n     * Destroys this Transform Matrix.\n     *\n     * @method Phaser.GameObjects.Components.TransformMatrix#destroy\n     * @since 3.4.0\n     */\n    destroy: function ()\n    {\n        this.matrix = null;\n        this.decomposedMatrix = null;\n    }\n\n});\n\nmodule.exports = TransformMatrix;\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n//  bitmask flag for GameObject.renderMask\nvar _FLAG = 1; // 0001\n\n/**\n * Provides methods used for setting the visibility of a Game Object.\n * Should be applied as a mixin and not used directly.\n * \n * @namespace Phaser.GameObjects.Components.Visible\n * @since 3.0.0\n */\n\nvar Visible = {\n\n    /**\n     * Private internal value. Holds the visible value.\n     * \n     * @name Phaser.GameObjects.Components.Visible#_visible\n     * @type {boolean}\n     * @private\n     * @default true\n     * @since 3.0.0\n     */\n    _visible: true,\n\n    /**\n     * The visible state of the Game Object.\n     * \n     * An invisible Game Object will skip rendering, but will still process update logic.\n     * \n     * @name Phaser.GameObjects.Components.Visible#visible\n     * @type {boolean}\n     * @since 3.0.0\n     */\n    visible: {\n\n        get: function ()\n        {\n            return this._visible;\n        },\n\n        set: function (value)\n        {\n            if (value)\n            {\n                this._visible = true;\n                this.renderFlags |= _FLAG;\n            }\n            else\n            {\n                this._visible = false;\n                this.renderFlags &= ~_FLAG;\n            }\n        }\n\n    },\n\n    /**\n     * Sets the visibility of this Game Object.\n     * \n     * An invisible Game Object will skip rendering, but will still process update logic.\n     *\n     * @method Phaser.GameObjects.Components.Visible#setVisible\n     * @since 3.0.0\n     *\n     * @param {boolean} value - The visible state of the Game Object.\n     * \n     * @return {this} This Game Object instance.\n     */\n    setVisible: function (value)\n    {\n        this.visible = value;\n\n        return this;\n    }\n};\n\nmodule.exports = Visible;\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * The Game Object Destroy Event.\n * \n * This event is dispatched when a Game Object instance is being destroyed.\n * \n * Listen for it on a Game Object instance using `GameObject.on('destroy', listener)`.\n *\n * @event Phaser.GameObjects.Events#DESTROY\n * @since 3.0.0\n * \n * @param {Phaser.GameObjects.GameObject} gameObject - The Game Object which is being destroyed.\n */\nmodule.exports = 'destroy';\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * @namespace Phaser.GameObjects.Events\n */\n\nmodule.exports = { DESTROY: require('./DESTROY_EVENT') };\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\nvar Class = require('../utils/Class');\nvar CONST = require('./const');\nvar Events = require('./events');\nvar GetFastValue = require('../utils/object/GetFastValue');\nvar GetURL = require('./GetURL');\nvar MergeXHRSettings = require('./MergeXHRSettings');\nvar XHRLoader = require('./XHRLoader');\nvar XHRSettings = require('./XHRSettings');\n\n/**\n * @classdesc\n * The base File class used by all File Types that the Loader can support.\n * You shouldn't create an instance of a File directly, but should extend it with your own class, setting a custom type and processing methods.\n *\n * @class File\n * @memberof Phaser.Loader\n * @constructor\n * @since 3.0.0\n *\n * @param {Phaser.Loader.LoaderPlugin} loader - The Loader that is going to load this File.\n * @param {Phaser.Types.Loader.FileConfig} fileConfig - The file configuration object, as created by the file type.\n */\nvar File = new Class({\n\n    initialize:\n\n    function File (loader, fileConfig)\n    {\n        /**\n         * A reference to the Loader that is going to load this file.\n         *\n         * @name Phaser.Loader.File#loader\n         * @type {Phaser.Loader.LoaderPlugin}\n         * @since 3.0.0\n         */\n        this.loader = loader;\n\n        /**\n         * A reference to the Cache, or Texture Manager, that is going to store this file if it loads.\n         *\n         * @name Phaser.Loader.File#cache\n         * @type {(Phaser.Cache.BaseCache|Phaser.Textures.TextureManager)}\n         * @since 3.7.0\n         */\n        this.cache = GetFastValue(fileConfig, 'cache', false);\n\n        /**\n         * The file type string (image, json, etc) for sorting within the Loader.\n         *\n         * @name Phaser.Loader.File#type\n         * @type {string}\n         * @since 3.0.0\n         */\n        this.type = GetFastValue(fileConfig, 'type', false);\n\n        /**\n         * Unique cache key (unique within its file type)\n         *\n         * @name Phaser.Loader.File#key\n         * @type {string}\n         * @since 3.0.0\n         */\n        this.key = GetFastValue(fileConfig, 'key', false);\n\n        var loadKey = this.key;\n\n        if (loader.prefix && loader.prefix !== '')\n        {\n            this.key = loader.prefix + loadKey;\n        }\n\n        if (!this.type || !this.key)\n        {\n            throw new Error('Error calling \\'Loader.' + this.type + '\\' invalid key provided.');\n        }\n\n        /**\n         * The URL of the file, not including baseURL.\n         * Automatically has Loader.path prepended to it.\n         *\n         * @name Phaser.Loader.File#url\n         * @type {string}\n         * @since 3.0.0\n         */\n        this.url = GetFastValue(fileConfig, 'url');\n\n        if (this.url === undefined)\n        {\n            this.url = loader.path + loadKey + '.' + GetFastValue(fileConfig, 'extension', '');\n        }\n        else if (typeof(this.url) !== 'function')\n        {\n            this.url = loader.path + this.url;\n        }\n\n        /**\n         * The final URL this file will load from, including baseURL and path.\n         * Set automatically when the Loader calls 'load' on this file.\n         *\n         * @name Phaser.Loader.File#src\n         * @type {string}\n         * @since 3.0.0\n         */\n        this.src = '';\n\n        /**\n         * The merged XHRSettings for this file.\n         *\n         * @name Phaser.Loader.File#xhrSettings\n         * @type {Phaser.Types.Loader.XHRSettingsObject}\n         * @since 3.0.0\n         */\n        this.xhrSettings = XHRSettings(GetFastValue(fileConfig, 'responseType', undefined));\n\n        if (GetFastValue(fileConfig, 'xhrSettings', false))\n        {\n            this.xhrSettings = MergeXHRSettings(this.xhrSettings, GetFastValue(fileConfig, 'xhrSettings', {}));\n        }\n\n        /**\n         * The XMLHttpRequest instance (as created by XHR Loader) that is loading this File.\n         *\n         * @name Phaser.Loader.File#xhrLoader\n         * @type {?XMLHttpRequest}\n         * @since 3.0.0\n         */\n        this.xhrLoader = null;\n\n        /**\n         * The current state of the file. One of the FILE_CONST values.\n         *\n         * @name Phaser.Loader.File#state\n         * @type {integer}\n         * @since 3.0.0\n         */\n        this.state = (typeof(this.url) === 'function') ? CONST.FILE_POPULATED : CONST.FILE_PENDING;\n\n        /**\n         * The total size of this file.\n         * Set by onProgress and only if loading via XHR.\n         *\n         * @name Phaser.Loader.File#bytesTotal\n         * @type {number}\n         * @default 0\n         * @since 3.0.0\n         */\n        this.bytesTotal = 0;\n\n        /**\n         * Updated as the file loads.\n         * Only set if loading via XHR.\n         *\n         * @name Phaser.Loader.File#bytesLoaded\n         * @type {number}\n         * @default -1\n         * @since 3.0.0\n         */\n        this.bytesLoaded = -1;\n\n        /**\n         * A percentage value between 0 and 1 indicating how much of this file has loaded.\n         * Only set if loading via XHR.\n         *\n         * @name Phaser.Loader.File#percentComplete\n         * @type {number}\n         * @default -1\n         * @since 3.0.0\n         */\n        this.percentComplete = -1;\n\n        /**\n         * For CORs based loading.\n         * If this is undefined then the File will check BaseLoader.crossOrigin and use that (if set)\n         *\n         * @name Phaser.Loader.File#crossOrigin\n         * @type {(string|undefined)}\n         * @since 3.0.0\n         */\n        this.crossOrigin = undefined;\n\n        /**\n         * The processed file data, stored here after the file has loaded.\n         *\n         * @name Phaser.Loader.File#data\n         * @type {*}\n         * @since 3.0.0\n         */\n        this.data = undefined;\n\n        /**\n         * A config object that can be used by file types to store transitional data.\n         *\n         * @name Phaser.Loader.File#config\n         * @type {*}\n         * @since 3.0.0\n         */\n        this.config = GetFastValue(fileConfig, 'config', {});\n\n        /**\n         * If this is a multipart file, i.e. an atlas and its json together, then this is a reference\n         * to the parent MultiFile. Set and used internally by the Loader or specific file types.\n         *\n         * @name Phaser.Loader.File#multiFile\n         * @type {?Phaser.Loader.MultiFile}\n         * @since 3.7.0\n         */\n        this.multiFile;\n\n        /**\n         * Does this file have an associated linked file? Such as an image and a normal map.\n         * Atlases and Bitmap Fonts use the multiFile, because those files need loading together but aren't\n         * actually bound by data, where-as a linkFile is.\n         *\n         * @name Phaser.Loader.File#linkFile\n         * @type {?Phaser.Loader.File}\n         * @since 3.7.0\n         */\n        this.linkFile;\n    },\n\n    /**\n     * Links this File with another, so they depend upon each other for loading and processing.\n     *\n     * @method Phaser.Loader.File#setLink\n     * @since 3.7.0\n     *\n     * @param {Phaser.Loader.File} fileB - The file to link to this one.\n     */\n    setLink: function (fileB)\n    {\n        this.linkFile = fileB;\n\n        fileB.linkFile = this;\n    },\n\n    /**\n     * Resets the XHRLoader instance this file is using.\n     *\n     * @method Phaser.Loader.File#resetXHR\n     * @since 3.0.0\n     */\n    resetXHR: function ()\n    {\n        if (this.xhrLoader)\n        {\n            this.xhrLoader.onload = undefined;\n            this.xhrLoader.onerror = undefined;\n            this.xhrLoader.onprogress = undefined;\n        }\n    },\n\n    /**\n     * Called by the Loader, starts the actual file downloading.\n     * During the load the methods onLoad, onError and onProgress are called, based on the XHR events.\n     * You shouldn't normally call this method directly, it's meant to be invoked by the Loader.\n     *\n     * @method Phaser.Loader.File#load\n     * @since 3.0.0\n     */\n    load: function ()\n    {\n        if (this.state === CONST.FILE_POPULATED)\n        {\n            //  Can happen for example in a JSONFile if they've provided a JSON object instead of a URL\n            this.loader.nextFile(this, true);\n        }\n        else\n        {\n            this.src = GetURL(this, this.loader.baseURL);\n\n            if (this.src.indexOf('data:') === 0)\n            {\n                console.warn('Local data URIs are not supported: ' + this.key);\n            }\n            else\n            {\n                //  The creation of this XHRLoader starts the load process going.\n                //  It will automatically call the following, based on the load outcome:\n                //  \n                // xhr.onload = this.onLoad\n                // xhr.onerror = this.onError\n                // xhr.onprogress = this.onProgress\n\n                this.xhrLoader = XHRLoader(this, this.loader.xhr);\n            }\n        }\n    },\n\n    /**\n     * Called when the file finishes loading, is sent a DOM ProgressEvent.\n     *\n     * @method Phaser.Loader.File#onLoad\n     * @since 3.0.0\n     *\n     * @param {XMLHttpRequest} xhr - The XMLHttpRequest that caused this onload event.\n     * @param {ProgressEvent} event - The DOM ProgressEvent that resulted from this load.\n     */\n    onLoad: function (xhr, event)\n    {\n        var localFileOk = ((xhr.responseURL && xhr.responseURL.indexOf('file://') === 0 && event.target.status === 0));\n\n        var success = !(event.target && event.target.status !== 200) || localFileOk;\n\n        //  Handle HTTP status codes of 4xx and 5xx as errors, even if xhr.onerror was not called.\n        if (xhr.readyState === 4 && xhr.status >= 400 && xhr.status <= 599)\n        {\n            success = false;\n        }\n\n        this.resetXHR();\n\n        this.loader.nextFile(this, success);\n    },\n\n    /**\n     * Called if the file errors while loading, is sent a DOM ProgressEvent.\n     *\n     * @method Phaser.Loader.File#onError\n     * @since 3.0.0\n     *\n     * @param {XMLHttpRequest} xhr - The XMLHttpRequest that caused this onload event.\n     * @param {ProgressEvent} event - The DOM ProgressEvent that resulted from this error.\n     */\n    onError: function ()\n    {\n        this.resetXHR();\n\n        this.loader.nextFile(this, false);\n    },\n\n    /**\n     * Called during the file load progress. Is sent a DOM ProgressEvent.\n     *\n     * @method Phaser.Loader.File#onProgress\n     * @fires Phaser.Loader.Events#FILE_PROGRESS\n     * @since 3.0.0\n     *\n     * @param {ProgressEvent} event - The DOM ProgressEvent.\n     */\n    onProgress: function (event)\n    {\n        if (event.lengthComputable)\n        {\n            this.bytesLoaded = event.loaded;\n            this.bytesTotal = event.total;\n\n            this.percentComplete = Math.min((this.bytesLoaded / this.bytesTotal), 1);\n\n            this.loader.emit(Events.FILE_PROGRESS, this, this.percentComplete);\n        }\n    },\n\n    /**\n     * Usually overridden by the FileTypes and is called by Loader.nextFile.\n     * This method controls what extra work this File does with its loaded data, for example a JSON file will parse itself during this stage.\n     *\n     * @method Phaser.Loader.File#onProcess\n     * @since 3.0.0\n     */\n    onProcess: function ()\n    {\n        this.state = CONST.FILE_PROCESSING;\n\n        this.onProcessComplete();\n    },\n\n    /**\n     * Called when the File has completed processing.\n     * Checks on the state of its multifile, if set.\n     *\n     * @method Phaser.Loader.File#onProcessComplete\n     * @since 3.7.0\n     */\n    onProcessComplete: function ()\n    {\n        this.state = CONST.FILE_COMPLETE;\n\n        if (this.multiFile)\n        {\n            this.multiFile.onFileComplete(this);\n        }\n\n        this.loader.fileProcessComplete(this);\n    },\n\n    /**\n     * Called when the File has completed processing but it generated an error.\n     * Checks on the state of its multifile, if set.\n     *\n     * @method Phaser.Loader.File#onProcessError\n     * @since 3.7.0\n     */\n    onProcessError: function ()\n    {\n        this.state = CONST.FILE_ERRORED;\n\n        if (this.multiFile)\n        {\n            this.multiFile.onFileFailed(this);\n        }\n\n        this.loader.fileProcessComplete(this);\n    },\n\n    /**\n     * Checks if a key matching the one used by this file exists in the target Cache or not.\n     * This is called automatically by the LoaderPlugin to decide if the file can be safely\n     * loaded or will conflict.\n     *\n     * @method Phaser.Loader.File#hasCacheConflict\n     * @since 3.7.0\n     *\n     * @return {boolean} `true` if adding this file will cause a conflict, otherwise `false`.\n     */\n    hasCacheConflict: function ()\n    {\n        return (this.cache && this.cache.exists(this.key));\n    },\n\n    /**\n     * Adds this file to its target cache upon successful loading and processing.\n     * This method is often overridden by specific file types.\n     *\n     * @method Phaser.Loader.File#addToCache\n     * @since 3.7.0\n     */\n    addToCache: function ()\n    {\n        if (this.cache)\n        {\n            this.cache.add(this.key, this.data);\n        }\n\n        this.pendingDestroy();\n    },\n\n    /**\n     * Called once the file has been added to its cache and is now ready for deletion from the Loader.\n     * It will emit a `filecomplete` event from the LoaderPlugin.\n     *\n     * @method Phaser.Loader.File#pendingDestroy\n     * @fires Phaser.Loader.Events#FILE_COMPLETE\n     * @fires Phaser.Loader.Events#FILE_KEY_COMPLETE\n     * @since 3.7.0\n     */\n    pendingDestroy: function (data)\n    {\n        if (data === undefined) { data = this.data; }\n\n        var key = this.key;\n        var type = this.type;\n\n        this.loader.emit(Events.FILE_COMPLETE, key, type, data);\n        this.loader.emit(Events.FILE_KEY_COMPLETE + type + '-' + key, key, type, data);\n\n        this.loader.flagForRemoval(this);\n    },\n\n    /**\n     * Destroy this File and any references it holds.\n     *\n     * @method Phaser.Loader.File#destroy\n     * @since 3.7.0\n     */\n    destroy: function ()\n    {\n        this.loader = null;\n        this.cache = null;\n        this.xhrSettings = null;\n        this.multiFile = null;\n        this.linkFile = null;\n        this.data = null;\n    }\n\n});\n\n/**\n * Static method for creating object URL using URL API and setting it as image 'src' attribute.\n * If URL API is not supported (usually on old browsers) it falls back to creating Base64 encoded url using FileReader.\n *\n * @method Phaser.Loader.File.createObjectURL\n * @static\n * @since 3.7.0\n * \n * @param {HTMLImageElement} image - Image object which 'src' attribute should be set to object URL.\n * @param {Blob} blob - A Blob object to create an object URL for.\n * @param {string} defaultType - Default mime type used if blob type is not available.\n */\nFile.createObjectURL = function (image, blob, defaultType)\n{\n    if (typeof URL === 'function')\n    {\n        image.src = URL.createObjectURL(blob);\n    }\n    else\n    {\n        var reader = new FileReader();\n\n        reader.onload = function ()\n        {\n            image.removeAttribute('crossOrigin');\n            image.src = 'data:' + (blob.type || defaultType) + ';base64,' + reader.result.split(',')[1];\n        };\n\n        reader.onerror = image.onerror;\n\n        reader.readAsDataURL(blob);\n    }\n};\n\n/**\n * Static method for releasing an existing object URL which was previously created\n * by calling {@link File#createObjectURL} method.\n *\n * @method Phaser.Loader.File.revokeObjectURL\n * @static\n * @since 3.7.0\n * \n * @param {HTMLImageElement} image - Image object which 'src' attribute should be revoked.\n */\nFile.revokeObjectURL = function (image)\n{\n    if (typeof URL === 'function')\n    {\n        URL.revokeObjectURL(image.src);\n    }\n};\n\nmodule.exports = File;\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\nvar types = {};\n\n/**\n * @namespace Phaser.Loader.FileTypesManager\n */\n\nvar FileTypesManager = {\n\n    /**\n     * Static method called when a LoaderPlugin is created.\n     * \n     * Loops through the local types object and injects all of them as\n     * properties into the LoaderPlugin instance.\n     *\n     * @method Phaser.Loader.FileTypesManager.install\n     * @since 3.0.0\n     * \n     * @param {Phaser.Loader.LoaderPlugin} loader - The LoaderPlugin to install the types into.\n     */\n    install: function (loader)\n    {\n        for (var key in types)\n        {\n            loader[key] = types[key];\n        }\n    },\n\n    /**\n     * Static method called directly by the File Types.\n     * \n     * The key is a reference to the function used to load the files via the Loader, i.e. `image`.\n     *\n     * @method Phaser.Loader.FileTypesManager.register\n     * @since 3.0.0\n     * \n     * @param {string} key - The key that will be used as the method name in the LoaderPlugin.\n     * @param {function} factoryFunction - The function that will be called when LoaderPlugin.key is invoked.\n     */\n    register: function (key, factoryFunction)\n    {\n        types[key] = factoryFunction;\n    },\n\n    /**\n     * Removed all associated file types.\n     *\n     * @method Phaser.Loader.FileTypesManager.destroy\n     * @since 3.0.0\n     */\n    destroy: function ()\n    {\n        types = {};\n    }\n\n};\n\nmodule.exports = FileTypesManager;\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * Given a File and a baseURL value this returns the URL the File will use to download from.\n *\n * @function Phaser.Loader.GetURL\n * @since 3.0.0\n *\n * @param {Phaser.Loader.File} file - The File object.\n * @param {string} baseURL - A default base URL.\n *\n * @return {string} The URL the File will use.\n */\nvar GetURL = function (file, baseURL)\n{\n    if (!file.url)\n    {\n        return false;\n    }\n\n    if (file.url.match(/^(?:blob:|data:|http:\\/\\/|https:\\/\\/|\\/\\/)/))\n    {\n        return file.url;\n    }\n    else\n    {\n        return baseURL + file.url;\n    }\n};\n\nmodule.exports = GetURL;\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\nvar Extend = require('../utils/object/Extend');\nvar XHRSettings = require('./XHRSettings');\n\n/**\n * Takes two XHRSettings Objects and creates a new XHRSettings object from them.\n *\n * The new object is seeded by the values given in the global settings, but any setting in\n * the local object overrides the global ones.\n *\n * @function Phaser.Loader.MergeXHRSettings\n * @since 3.0.0\n *\n * @param {Phaser.Types.Loader.XHRSettingsObject} global - The global XHRSettings object.\n * @param {Phaser.Types.Loader.XHRSettingsObject} local - The local XHRSettings object.\n *\n * @return {Phaser.Types.Loader.XHRSettingsObject} A newly formed XHRSettings object.\n */\nvar MergeXHRSettings = function (global, local)\n{\n    var output = (global === undefined) ? XHRSettings() : Extend({}, global);\n\n    if (local)\n    {\n        for (var setting in local)\n        {\n            if (local[setting] !== undefined)\n            {\n                output[setting] = local[setting];\n            }\n        }\n    }\n\n    return output;\n};\n\nmodule.exports = MergeXHRSettings;\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\nvar Class = require('../utils/Class');\n\n/**\n * @classdesc\n * A MultiFile is a special kind of parent that contains two, or more, Files as children and looks after\n * the loading and processing of them all. It is commonly extended and used as a base class for file types such as AtlasJSON or BitmapFont.\n * \n * You shouldn't create an instance of a MultiFile directly, but should extend it with your own class, setting a custom type and processing methods.\n *\n * @class MultiFile\n * @memberof Phaser.Loader\n * @constructor\n * @since 3.7.0\n *\n * @param {Phaser.Loader.LoaderPlugin} loader - The Loader that is going to load this File.\n * @param {string} type - The file type string for sorting within the Loader.\n * @param {string} key - The key of the file within the loader.\n * @param {Phaser.Loader.File[]} files - An array of Files that make-up this MultiFile.\n */\nvar MultiFile = new Class({\n\n    initialize:\n\n    function MultiFile (loader, type, key, files)\n    {\n        /**\n         * A reference to the Loader that is going to load this file.\n         *\n         * @name Phaser.Loader.MultiFile#loader\n         * @type {Phaser.Loader.LoaderPlugin}\n         * @since 3.7.0\n         */\n        this.loader = loader;\n\n        /**\n         * The file type string for sorting within the Loader.\n         *\n         * @name Phaser.Loader.MultiFile#type\n         * @type {string}\n         * @since 3.7.0\n         */\n        this.type = type;\n\n        /**\n         * Unique cache key (unique within its file type)\n         *\n         * @name Phaser.Loader.MultiFile#key\n         * @type {string}\n         * @since 3.7.0\n         */\n        this.key = key;\n\n        /**\n         * Array of files that make up this MultiFile.\n         *\n         * @name Phaser.Loader.MultiFile#files\n         * @type {Phaser.Loader.File[]}\n         * @since 3.7.0\n         */\n        this.files = files;\n\n        /**\n         * The completion status of this MultiFile.\n         *\n         * @name Phaser.Loader.MultiFile#complete\n         * @type {boolean}\n         * @default false\n         * @since 3.7.0\n         */\n        this.complete = false;\n\n        /**\n         * The number of files to load.\n         *\n         * @name Phaser.Loader.MultiFile#pending\n         * @type {integer}\n         * @since 3.7.0\n         */\n\n        this.pending = files.length;\n\n        /**\n         * The number of files that failed to load.\n         *\n         * @name Phaser.Loader.MultiFile#failed\n         * @type {integer}\n         * @default 0\n         * @since 3.7.0\n         */\n        this.failed = 0;\n\n        /**\n         * A storage container for transient data that the loading files need.\n         *\n         * @name Phaser.Loader.MultiFile#config\n         * @type {any}\n         * @since 3.7.0\n         */\n        this.config = {};\n\n        //  Link the files\n        for (var i = 0; i < files.length; i++)\n        {\n            files[i].multiFile = this;\n        }\n    },\n\n    /**\n     * Checks if this MultiFile is ready to process its children or not.\n     *\n     * @method Phaser.Loader.MultiFile#isReadyToProcess\n     * @since 3.7.0\n     *\n     * @return {boolean} `true` if all children of this MultiFile have loaded, otherwise `false`.\n     */\n    isReadyToProcess: function ()\n    {\n        return (this.pending === 0 && this.failed === 0 && !this.complete);\n    },\n\n    /**\n     * Adds another child to this MultiFile, increases the pending count and resets the completion status.\n     *\n     * @method Phaser.Loader.MultiFile#addToMultiFile\n     * @since 3.7.0\n     *\n     * @param {Phaser.Loader.File} files - The File to add to this MultiFile.\n     *\n     * @return {Phaser.Loader.MultiFile} This MultiFile instance.\n     */\n    addToMultiFile: function (file)\n    {\n        this.files.push(file);\n\n        file.multiFile = this;\n\n        this.pending++;\n\n        this.complete = false;\n\n        return this;\n    },\n\n    /**\n     * Called by each File when it finishes loading.\n     *\n     * @method Phaser.Loader.MultiFile#onFileComplete\n     * @since 3.7.0\n     *\n     * @param {Phaser.Loader.File} file - The File that has completed processing.\n     */\n    onFileComplete: function (file)\n    {\n        var index = this.files.indexOf(file);\n\n        if (index !== -1)\n        {\n            this.pending--;\n        }\n    },\n\n    /**\n     * Called by each File that fails to load.\n     *\n     * @method Phaser.Loader.MultiFile#onFileFailed\n     * @since 3.7.0\n     *\n     * @param {Phaser.Loader.File} file - The File that has failed to load.\n     */\n    onFileFailed: function (file)\n    {\n        var index = this.files.indexOf(file);\n\n        if (index !== -1)\n        {\n            this.failed++;\n        }\n    }\n\n});\n\nmodule.exports = MultiFile;\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\nvar MergeXHRSettings = require('./MergeXHRSettings');\n\n/**\n * Creates a new XMLHttpRequest (xhr) object based on the given File and XHRSettings\n * and starts the download of it. It uses the Files own XHRSettings and merges them\n * with the global XHRSettings object to set the xhr values before download.\n *\n * @function Phaser.Loader.XHRLoader\n * @since 3.0.0\n *\n * @param {Phaser.Loader.File} file - The File to download.\n * @param {Phaser.Types.Loader.XHRSettingsObject} globalXHRSettings - The global XHRSettings object.\n *\n * @return {XMLHttpRequest} The XHR object.\n */\nvar XHRLoader = function (file, globalXHRSettings)\n{\n    var config = MergeXHRSettings(globalXHRSettings, file.xhrSettings);\n\n    var xhr = new XMLHttpRequest();\n\n    xhr.open('GET', file.src, config.async, config.user, config.password);\n\n    xhr.responseType = file.xhrSettings.responseType;\n    xhr.timeout = config.timeout;\n\n    if (config.header && config.headerValue)\n    {\n        xhr.setRequestHeader(config.header, config.headerValue);\n    }\n\n    if (config.requestedWith)\n    {\n        xhr.setRequestHeader('X-Requested-With', config.requestedWith);\n    }\n\n    if (config.overrideMimeType)\n    {\n        xhr.overrideMimeType(config.overrideMimeType);\n    }\n\n    // After a successful request, the xhr.response property will contain the requested data as a DOMString, ArrayBuffer, Blob, or Document (depending on what was set for responseType.)\n\n    xhr.onload = file.onLoad.bind(file, xhr);\n    xhr.onerror = file.onError.bind(file, xhr);\n    xhr.onprogress = file.onProgress.bind(file);\n\n    //  This is the only standard method, the ones above are browser additions (maybe not universal?)\n    // xhr.onreadystatechange\n\n    xhr.send();\n\n    return xhr;\n};\n\nmodule.exports = XHRLoader;\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * Creates an XHRSettings Object with default values.\n *\n * @function Phaser.Loader.XHRSettings\n * @since 3.0.0\n *\n * @param {XMLHttpRequestResponseType} [responseType=''] - The responseType, such as 'text'.\n * @param {boolean} [async=true] - Should the XHR request use async or not?\n * @param {string} [user=''] - Optional username for the XHR request.\n * @param {string} [password=''] - Optional password for the XHR request.\n * @param {integer} [timeout=0] - Optional XHR timeout value.\n *\n * @return {Phaser.Types.Loader.XHRSettingsObject} The XHRSettings object as used by the Loader.\n */\nvar XHRSettings = function (responseType, async, user, password, timeout)\n{\n    if (responseType === undefined) { responseType = ''; }\n    if (async === undefined) { async = true; }\n    if (user === undefined) { user = ''; }\n    if (password === undefined) { password = ''; }\n    if (timeout === undefined) { timeout = 0; }\n\n    // Before sending a request, set the xhr.responseType to \"text\",\n    // \"arraybuffer\", \"blob\", or \"document\", depending on your data needs.\n    // Note, setting xhr.responseType = '' (or omitting) will default the response to \"text\".\n\n    return {\n\n        //  Ignored by the Loader, only used by File.\n        responseType: responseType,\n\n        async: async,\n\n        //  credentials\n        user: user,\n        password: password,\n\n        //  timeout in ms (0 = no timeout)\n        timeout: timeout,\n\n        //  setRequestHeader\n        header: undefined,\n        headerValue: undefined,\n        requestedWith: false,\n\n        //  overrideMimeType\n        overrideMimeType: undefined\n\n    };\n};\n\nmodule.exports = XHRSettings;\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\nvar FILE_CONST = {\n\n    /**\n     * The Loader is idle.\n     * \n     * @name Phaser.Loader.LOADER_IDLE\n     * @type {integer}\n     * @since 3.0.0\n     */\n    LOADER_IDLE: 0,\n\n    /**\n     * The Loader is actively loading.\n     * \n     * @name Phaser.Loader.LOADER_LOADING\n     * @type {integer}\n     * @since 3.0.0\n     */\n    LOADER_LOADING: 1,\n\n    /**\n     * The Loader is processing files is has loaded.\n     * \n     * @name Phaser.Loader.LOADER_PROCESSING\n     * @type {integer}\n     * @since 3.0.0\n     */\n    LOADER_PROCESSING: 2,\n\n    /**\n     * The Loader has completed loading and processing.\n     * \n     * @name Phaser.Loader.LOADER_COMPLETE\n     * @type {integer}\n     * @since 3.0.0\n     */\n    LOADER_COMPLETE: 3,\n\n    /**\n     * The Loader is shutting down.\n     * \n     * @name Phaser.Loader.LOADER_SHUTDOWN\n     * @type {integer}\n     * @since 3.0.0\n     */\n    LOADER_SHUTDOWN: 4,\n\n    /**\n     * The Loader has been destroyed.\n     * \n     * @name Phaser.Loader.LOADER_DESTROYED\n     * @type {integer}\n     * @since 3.0.0\n     */\n    LOADER_DESTROYED: 5,\n\n    /**\n     * File is in the load queue but not yet started\n     * \n     * @name Phaser.Loader.FILE_PENDING\n     * @type {integer}\n     * @since 3.0.0\n     */\n    FILE_PENDING: 10,\n\n    /**\n     * File has been started to load by the loader (onLoad called)\n     * \n     * @name Phaser.Loader.FILE_LOADING\n     * @type {integer}\n     * @since 3.0.0\n     */\n    FILE_LOADING: 11,\n\n    /**\n     * File has loaded successfully, awaiting processing    \n     * \n     * @name Phaser.Loader.FILE_LOADED\n     * @type {integer}\n     * @since 3.0.0\n     */\n    FILE_LOADED: 12,\n\n    /**\n     * File failed to load\n     * \n     * @name Phaser.Loader.FILE_FAILED\n     * @type {integer}\n     * @since 3.0.0\n     */\n    FILE_FAILED: 13,\n\n    /**\n     * File is being processed (onProcess callback)\n     * \n     * @name Phaser.Loader.FILE_PROCESSING\n     * @type {integer}\n     * @since 3.0.0\n     */\n    FILE_PROCESSING: 14,\n\n    /**\n     * The File has errored somehow during processing.\n     * \n     * @name Phaser.Loader.FILE_ERRORED\n     * @type {integer}\n     * @since 3.0.0\n     */\n    FILE_ERRORED: 16,\n\n    /**\n     * File has finished processing.\n     * \n     * @name Phaser.Loader.FILE_COMPLETE\n     * @type {integer}\n     * @since 3.0.0\n     */\n    FILE_COMPLETE: 17,\n\n    /**\n     * File has been destroyed\n     * \n     * @name Phaser.Loader.FILE_DESTROYED\n     * @type {integer}\n     * @since 3.0.0\n     */\n    FILE_DESTROYED: 18,\n\n    /**\n     * File was populated from local data and doesn't need an HTTP request\n     * \n     * @name Phaser.Loader.FILE_POPULATED\n     * @type {integer}\n     * @since 3.0.0\n     */\n    FILE_POPULATED: 19\n\n};\n\nmodule.exports = FILE_CONST;\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * The Loader Plugin Add File Event.\n * \n * This event is dispatched when a new file is successfully added to the Loader and placed into the load queue.\n * \n * Listen to it from a Scene using: `this.load.on('addfile', listener)`.\n * \n * If you add lots of files to a Loader from a `preload` method, it will dispatch this event for each one of them.\n *\n * @event Phaser.Loader.Events#ADD\n * @since 3.0.0\n * \n * @param {string} key - The unique key of the file that was added to the Loader.\n * @param {string} type - The [file type]{@link Phaser.Loader.File#type} string of the file that was added to the Loader, i.e. `image`.\n * @param {Phaser.Loader.LoaderPlugin} loader - A reference to the Loader Plugin that dispatched this event.\n * @param {Phaser.Loader.File} file - A reference to the File which was added to the Loader.\n */\nmodule.exports = 'addfile';\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * The Loader Plugin Complete Event.\n * \n * This event is dispatched when the Loader has fully processed everything in the load queue.\n * By this point every loaded file will now be in its associated cache and ready for use.\n * \n * Listen to it from a Scene using: `this.load.on('complete', listener)`.\n *\n * @event Phaser.Loader.Events#COMPLETE\n * @since 3.0.0\n * \n * @param {Phaser.Loader.LoaderPlugin} loader - A reference to the Loader Plugin that dispatched this event.\n * @param {integer} totalComplete - The total number of files that successfully loaded.\n * @param {integer} totalFailed - The total number of files that failed to load.\n */\nmodule.exports = 'complete';\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * The File Load Complete Event.\n * \n * This event is dispatched by the Loader Plugin when any file in the queue finishes loading.\n * \n * Listen to it from a Scene using: `this.load.on('filecomplete', listener)`.\n * \n * You can also listen for the completion of a specific file. See the [FILE_KEY_COMPLETE]{@linkcode Phaser.Loader.Events#event:FILE_KEY_COMPLETE} event.\n *\n * @event Phaser.Loader.Events#FILE_COMPLETE\n * @since 3.0.0\n * \n * @param {string} key - The key of the file that just loaded and finished processing.\n * @param {string} type - The [file type]{@link Phaser.Loader.File#type} of the file that just loaded, i.e. `image`.\n * @param {any} data - The raw data the file contained.\n */\nmodule.exports = 'filecomplete';\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * The File Load Complete Event.\n * \n * This event is dispatched by the Loader Plugin when any file in the queue finishes loading.\n * \n * It uses a special dynamic event name constructed from the key and type of the file.\n * \n * For example, if you have loaded an `image` with a key of `monster`, you can listen for it\n * using the following:\n *\n * ```javascript\n * this.load.on('filecomplete-image-monster', function (key, type, data) {\n *     // Your handler code\n * });\n * ```\n *\n * Or, if you have loaded a texture `atlas` with a key of `Level1`:\n * \n * ```javascript\n * this.load.on('filecomplete-atlas-Level1', function (key, type, data) {\n *     // Your handler code\n * });\n * ```\n * \n * Or, if you have loaded a sprite sheet with a key of `Explosion` and a prefix of `GAMEOVER`:\n * \n * ```javascript\n * this.load.on('filecomplete-spritesheet-GAMEOVERExplosion', function (key, type, data) {\n *     // Your handler code\n * });\n * ```\n * \n * You can also listen for the generic completion of files. See the [FILE_COMPLETE]{@linkcode Phaser.Loader.Events#event:FILE_COMPLETE} event.\n *\n * @event Phaser.Loader.Events#FILE_KEY_COMPLETE\n * @since 3.0.0\n * \n * @param {string} key - The key of the file that just loaded and finished processing.\n * @param {string} type - The [file type]{@link Phaser.Loader.File#type} of the file that just loaded, i.e. `image`.\n * @param {any} data - The raw data the file contained.\n */\nmodule.exports = 'filecomplete-';\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * The File Load Error Event.\n * \n * This event is dispatched by the Loader Plugin when a file fails to load.\n * \n * Listen to it from a Scene using: `this.load.on('loaderror', listener)`.\n *\n * @event Phaser.Loader.Events#FILE_LOAD_ERROR\n * @since 3.0.0\n * \n * @param {Phaser.Loader.File} file - A reference to the File which errored during load.\n */\nmodule.exports = 'loaderror';\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * The File Load Event.\n * \n * This event is dispatched by the Loader Plugin when a file finishes loading,\n * but _before_ it is processed and added to the internal Phaser caches.\n * \n * Listen to it from a Scene using: `this.load.on('load', listener)`.\n *\n * @event Phaser.Loader.Events#FILE_LOAD\n * @since 3.0.0\n * \n * @param {Phaser.Loader.File} file - A reference to the File which just finished loading.\n */\nmodule.exports = 'load';\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * The File Load Progress Event.\n * \n * This event is dispatched by the Loader Plugin during the load of a file, if the browser receives a DOM ProgressEvent and\n * the `lengthComputable` event property is true. Depending on the size of the file and browser in use, this may, or may not happen.\n * \n * Listen to it from a Scene using: `this.load.on('fileprogress', listener)`.\n *\n * @event Phaser.Loader.Events#FILE_PROGRESS\n * @since 3.0.0\n * \n * @param {Phaser.Loader.File} file - A reference to the File which errored during load.\n * @param {number} percentComplete - A value between 0 and 1 indicating how 'complete' this file is.\n */\nmodule.exports = 'fileprogress';\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * The Loader Plugin Post Process Event.\n * \n * This event is dispatched by the Loader Plugin when the Loader has finished loading everything in the load queue.\n * It is dispatched before the internal lists are cleared and each File is destroyed.\n * \n * Use this hook to perform any last minute processing of files that can only happen once the\n * Loader has completed, but prior to it emitting the `complete` event.\n * \n * Listen to it from a Scene using: `this.load.on('postprocess', listener)`.\n *\n * @event Phaser.Loader.Events#POST_PROCESS\n * @since 3.0.0\n * \n * @param {Phaser.Loader.LoaderPlugin} loader - A reference to the Loader Plugin that dispatched this event.\n */\nmodule.exports = 'postprocess';\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * The Loader Plugin Progress Event.\n * \n * This event is dispatched when the Loader updates its load progress, typically as a result of a file having completed loading.\n * \n * Listen to it from a Scene using: `this.load.on('progress', listener)`.\n *\n * @event Phaser.Loader.Events#PROGRESS\n * @since 3.0.0\n * \n * @param {number} progress - The current progress of the load. A value between 0 and 1.\n */\nmodule.exports = 'progress';\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * The Loader Plugin Start Event.\n * \n * This event is dispatched when the Loader starts running. At this point load progress is zero.\n * \n * This event is dispatched even if there aren't any files in the load queue.\n * \n * Listen to it from a Scene using: `this.load.on('start', listener)`.\n *\n * @event Phaser.Loader.Events#START\n * @since 3.0.0\n * \n * @param {Phaser.Loader.LoaderPlugin} loader - A reference to the Loader Plugin that dispatched this event.\n */\nmodule.exports = 'start';\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * @namespace Phaser.Loader.Events\n */\n\nmodule.exports = {\n\n    ADD: require('./ADD_EVENT'),\n    COMPLETE: require('./COMPLETE_EVENT'),\n    FILE_COMPLETE: require('./FILE_COMPLETE_EVENT'),\n    FILE_KEY_COMPLETE: require('./FILE_KEY_COMPLETE_EVENT'),\n    FILE_LOAD_ERROR: require('./FILE_LOAD_ERROR_EVENT'),\n    FILE_LOAD: require('./FILE_LOAD_EVENT'),\n    FILE_PROGRESS: require('./FILE_PROGRESS_EVENT'),\n    POST_PROCESS: require('./POST_PROCESS_EVENT'),\n    PROGRESS: require('./PROGRESS_EVENT'),\n    START: require('./START_EVENT')\n\n};\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\nvar Class = require('../../utils/Class');\nvar CONST = require('../const');\nvar File = require('../File');\nvar FileTypesManager = require('../FileTypesManager');\nvar GetFastValue = require('../../utils/object/GetFastValue');\nvar IsPlainObject = require('../../utils/object/IsPlainObject');\n\n/**\n * @classdesc\n * A single Image File suitable for loading by the Loader.\n *\n * These are created when you use the Phaser.Loader.LoaderPlugin#image method and are not typically created directly.\n * \n * For documentation about what all the arguments and configuration options mean please see Phaser.Loader.LoaderPlugin#image.\n *\n * @class ImageFile\n * @extends Phaser.Loader.File\n * @memberof Phaser.Loader.FileTypes\n * @constructor\n * @since 3.0.0\n *\n * @param {Phaser.Loader.LoaderPlugin} loader - A reference to the Loader that is responsible for this file.\n * @param {(string|Phaser.Types.Loader.FileTypes.ImageFileConfig)} key - The key to use for this file, or a file configuration object.\n * @param {string|string[]} [url] - The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.png`, i.e. if `key` was \"alien\" then the URL will be \"alien.png\".\n * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - Extra XHR Settings specifically for this file.\n * @param {Phaser.Types.Loader.FileTypes.ImageFrameConfig} [frameConfig] - The frame configuration object. Only provided for, and used by, Sprite Sheets.\n */\nvar ImageFile = new Class({\n\n    Extends: File,\n\n    initialize:\n\n    function ImageFile (loader, key, url, xhrSettings, frameConfig)\n    {\n        var extension = 'png';\n        var normalMapURL;\n\n        if (IsPlainObject(key))\n        {\n            var config = key;\n\n            key = GetFastValue(config, 'key');\n            url = GetFastValue(config, 'url');\n            normalMapURL = GetFastValue(config, 'normalMap');\n            xhrSettings = GetFastValue(config, 'xhrSettings');\n            extension = GetFastValue(config, 'extension', extension);\n            frameConfig = GetFastValue(config, 'frameConfig');\n        }\n\n        if (Array.isArray(url))\n        {\n            normalMapURL = url[1];\n            url = url[0];\n        }\n\n        var fileConfig = {\n            type: 'image',\n            cache: loader.textureManager,\n            extension: extension,\n            responseType: 'blob',\n            key: key,\n            url: url,\n            xhrSettings: xhrSettings,\n            config: frameConfig\n        };\n\n        File.call(this, loader, fileConfig);\n\n        //  Do we have a normal map to load as well?\n        if (normalMapURL)\n        {\n            var normalMap = new ImageFile(loader, this.key, normalMapURL, xhrSettings, frameConfig);\n\n            normalMap.type = 'normalMap';\n\n            this.setLink(normalMap);\n\n            loader.addFile(normalMap);\n        }\n    },\n\n    /**\n     * Called automatically by Loader.nextFile.\n     * This method controls what extra work this File does with its loaded data.\n     *\n     * @method Phaser.Loader.FileTypes.ImageFile#onProcess\n     * @since 3.7.0\n     */\n    onProcess: function ()\n    {\n        this.state = CONST.FILE_PROCESSING;\n\n        this.data = new Image();\n\n        this.data.crossOrigin = this.crossOrigin;\n\n        var _this = this;\n\n        this.data.onload = function ()\n        {\n            File.revokeObjectURL(_this.data);\n\n            _this.onProcessComplete();\n        };\n\n        this.data.onerror = function ()\n        {\n            File.revokeObjectURL(_this.data);\n\n            _this.onProcessError();\n        };\n\n        File.createObjectURL(this.data, this.xhrLoader.response, 'image/png');\n    },\n\n    /**\n     * Adds this file to its target cache upon successful loading and processing.\n     *\n     * @method Phaser.Loader.FileTypes.ImageFile#addToCache\n     * @since 3.7.0\n     */\n    addToCache: function ()\n    {\n        var texture;\n        var linkFile = this.linkFile;\n\n        if (linkFile && linkFile.state === CONST.FILE_COMPLETE)\n        {\n            if (this.type === 'image')\n            {\n                texture = this.cache.addImage(this.key, this.data, linkFile.data);\n            }\n            else\n            {\n                texture = this.cache.addImage(linkFile.key, linkFile.data, this.data);\n            }\n\n            this.pendingDestroy(texture);\n\n            linkFile.pendingDestroy(texture);\n        }\n        else if (!linkFile)\n        {\n            texture = this.cache.addImage(this.key, this.data);\n\n            this.pendingDestroy(texture);\n        }\n    }\n\n});\n\n/**\n * Adds an Image, or array of Images, to the current load queue.\n *\n * You can call this method from within your Scene's `preload`, along with any other files you wish to load:\n * \n * ```javascript\n * function preload ()\n * {\n *     this.load.image('logo', 'images/phaserLogo.png');\n * }\n * ```\n *\n * The file is **not** loaded right away. It is added to a queue ready to be loaded either when the loader starts,\n * or if it's already running, when the next free load slot becomes available. This happens automatically if you\n * are calling this from within the Scene's `preload` method, or a related callback. Because the file is queued\n * it means you cannot use the file immediately after calling this method, but must wait for the file to complete.\n * The typical flow for a Phaser Scene is that you load assets in the Scene's `preload` method and then when the\n * Scene's `create` method is called you are guaranteed that all of those assets are ready for use and have been\n * loaded.\n * \n * Phaser can load all common image types: png, jpg, gif and any other format the browser can natively handle.\n * If you try to load an animated gif only the first frame will be rendered. Browsers do not natively support playback\n * of animated gifs to Canvas elements.\n *\n * The key must be a unique String. It is used to add the file to the global Texture Manager upon a successful load.\n * The key should be unique both in terms of files being loaded and files already present in the Texture Manager.\n * Loading a file using a key that is already taken will result in a warning. If you wish to replace an existing file\n * then remove it from the Texture Manager first, before loading a new one.\n *\n * Instead of passing arguments you can pass a configuration object, such as:\n * \n * ```javascript\n * this.load.image({\n *     key: 'logo',\n *     url: 'images/AtariLogo.png'\n * });\n * ```\n *\n * See the documentation for `Phaser.Types.Loader.FileTypes.ImageFileConfig` for more details.\n *\n * Once the file has finished loading you can use it as a texture for a Game Object by referencing its key:\n * \n * ```javascript\n * this.load.image('logo', 'images/AtariLogo.png');\n * // and later in your game ...\n * this.add.image(x, y, 'logo');\n * ```\n *\n * If you have specified a prefix in the loader, via `Loader.setPrefix` then this value will be prepended to this files\n * key. For example, if the prefix was `MENU.` and the key was `Background` the final key will be `MENU.Background` and\n * this is what you would use to retrieve the image from the Texture Manager.\n *\n * The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.\n *\n * If the URL isn't specified the Loader will take the key and create a filename from that. For example if the key is \"alien\"\n * and no URL is given then the Loader will set the URL to be \"alien.png\". It will always add `.png` as the extension, although\n * this can be overridden if using an object instead of method arguments. If you do not desire this action then provide a URL.\n *\n * Phaser also supports the automatic loading of associated normal maps. If you have a normal map to go with this image,\n * then you can specify it by providing an array as the `url` where the second element is the normal map:\n * \n * ```javascript\n * this.load.image('logo', [ 'images/AtariLogo.png', 'images/AtariLogo-n.png' ]);\n * ```\n *\n * Or, if you are using a config object use the `normalMap` property:\n * \n * ```javascript\n * this.load.image({\n *     key: 'logo',\n *     url: 'images/AtariLogo.png',\n *     normalMap: 'images/AtariLogo-n.png'\n * });\n * ```\n *\n * The normal map file is subject to the same conditions as the image file with regard to the path, baseURL, CORs and XHR Settings.\n * Normal maps are a WebGL only feature.\n *\n * Note: The ability to load this type of file will only be available if the Image File type has been built into Phaser.\n * It is available in the default build but can be excluded from custom builds.\n *\n * @method Phaser.Loader.LoaderPlugin#image\n * @fires Phaser.Loader.LoaderPlugin#addFileEvent\n * @since 3.0.0\n *\n * @param {(string|Phaser.Types.Loader.FileTypes.ImageFileConfig|Phaser.Types.Loader.FileTypes.ImageFileConfig[])} key - The key to use for this file, or a file configuration object, or array of them.\n * @param {string|string[]} [url] - The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.png`, i.e. if `key` was \"alien\" then the URL will be \"alien.png\".\n * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - An XHR Settings configuration object. Used in replacement of the Loaders default XHR Settings.\n *\n * @return {Phaser.Loader.LoaderPlugin} The Loader instance.\n */\nFileTypesManager.register('image', function (key, url, xhrSettings)\n{\n    if (Array.isArray(key))\n    {\n        for (var i = 0; i < key.length; i++)\n        {\n            //  If it's an array it has to be an array of Objects, so we get everything out of the 'key' object\n            this.addFile(new ImageFile(this, key[i]));\n        }\n    }\n    else\n    {\n        this.addFile(new ImageFile(this, key, url, xhrSettings));\n    }\n\n    return this;\n});\n\nmodule.exports = ImageFile;\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\nvar Class = require('../../utils/Class');\nvar CONST = require('../const');\nvar File = require('../File');\nvar FileTypesManager = require('../FileTypesManager');\nvar GetFastValue = require('../../utils/object/GetFastValue');\nvar GetValue = require('../../utils/object/GetValue');\nvar IsPlainObject = require('../../utils/object/IsPlainObject');\n\n/**\n * @classdesc\n * A single JSON File suitable for loading by the Loader.\n *\n * These are created when you use the Phaser.Loader.LoaderPlugin#json method and are not typically created directly.\n * \n * For documentation about what all the arguments and configuration options mean please see Phaser.Loader.LoaderPlugin#json.\n *\n * @class JSONFile\n * @extends Phaser.Loader.File\n * @memberof Phaser.Loader.FileTypes\n * @constructor\n * @since 3.0.0\n *\n * @param {Phaser.Loader.LoaderPlugin} loader - A reference to the Loader that is responsible for this file.\n * @param {(string|Phaser.Types.Loader.FileTypes.JSONFileConfig)} key - The key to use for this file, or a file configuration object.\n * @param {string} [url] - The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.json`, i.e. if `key` was \"alien\" then the URL will be \"alien.json\".\n * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - Extra XHR Settings specifically for this file.\n * @param {string} [dataKey] - When the JSON file loads only this property will be stored in the Cache.\n */\nvar JSONFile = new Class({\n\n    Extends: File,\n\n    initialize:\n\n    //  url can either be a string, in which case it is treated like a proper url, or an object, in which case it is treated as a ready-made JS Object\n    //  dataKey allows you to pluck a specific object out of the JSON and put just that into the cache, rather than the whole thing\n\n    function JSONFile (loader, key, url, xhrSettings, dataKey)\n    {\n        var extension = 'json';\n\n        if (IsPlainObject(key))\n        {\n            var config = key;\n\n            key = GetFastValue(config, 'key');\n            url = GetFastValue(config, 'url');\n            xhrSettings = GetFastValue(config, 'xhrSettings');\n            extension = GetFastValue(config, 'extension', extension);\n            dataKey = GetFastValue(config, 'dataKey', dataKey);\n        }\n\n        var fileConfig = {\n            type: 'json',\n            cache: loader.cacheManager.json,\n            extension: extension,\n            responseType: 'text',\n            key: key,\n            url: url,\n            xhrSettings: xhrSettings,\n            config: dataKey\n        };\n\n        File.call(this, loader, fileConfig);\n\n        if (IsPlainObject(url))\n        {\n            //  Object provided instead of a URL, so no need to actually load it (populate data with value)\n            if (dataKey)\n            {\n                this.data = GetValue(url, dataKey);\n            }\n            else\n            {\n                this.data = url;\n            }\n\n            this.state = CONST.FILE_POPULATED;\n        }\n    },\n\n    /**\n     * Called automatically by Loader.nextFile.\n     * This method controls what extra work this File does with its loaded data.\n     *\n     * @method Phaser.Loader.FileTypes.JSONFile#onProcess\n     * @since 3.7.0\n     */\n    onProcess: function ()\n    {\n        if (this.state !== CONST.FILE_POPULATED)\n        {\n            this.state = CONST.FILE_PROCESSING;\n\n            var json = JSON.parse(this.xhrLoader.responseText);\n\n            var key = this.config;\n\n            if (typeof key === 'string')\n            {\n                this.data = GetValue(json, key, json);\n            }\n            else\n            {\n                this.data = json;\n            }\n        }\n\n        this.onProcessComplete();\n    }\n\n});\n\n/**\n * Adds a JSON file, or array of JSON files, to the current load queue.\n *\n * You can call this method from within your Scene's `preload`, along with any other files you wish to load:\n * \n * ```javascript\n * function preload ()\n * {\n *     this.load.json('wavedata', 'files/AlienWaveData.json');\n * }\n * ```\n *\n * The file is **not** loaded right away. It is added to a queue ready to be loaded either when the loader starts,\n * or if it's already running, when the next free load slot becomes available. This happens automatically if you\n * are calling this from within the Scene's `preload` method, or a related callback. Because the file is queued\n * it means you cannot use the file immediately after calling this method, but must wait for the file to complete.\n * The typical flow for a Phaser Scene is that you load assets in the Scene's `preload` method and then when the\n * Scene's `create` method is called you are guaranteed that all of those assets are ready for use and have been\n * loaded.\n * \n * The key must be a unique String. It is used to add the file to the global JSON Cache upon a successful load.\n * The key should be unique both in terms of files being loaded and files already present in the JSON Cache.\n * Loading a file using a key that is already taken will result in a warning. If you wish to replace an existing file\n * then remove it from the JSON Cache first, before loading a new one.\n *\n * Instead of passing arguments you can pass a configuration object, such as:\n * \n * ```javascript\n * this.load.json({\n *     key: 'wavedata',\n *     url: 'files/AlienWaveData.json'\n * });\n * ```\n *\n * See the documentation for `Phaser.Types.Loader.FileTypes.JSONFileConfig` for more details.\n *\n * Once the file has finished loading you can access it from its Cache using its key:\n * \n * ```javascript\n * this.load.json('wavedata', 'files/AlienWaveData.json');\n * // and later in your game ...\n * var data = this.cache.json.get('wavedata');\n * ```\n *\n * If you have specified a prefix in the loader, via `Loader.setPrefix` then this value will be prepended to this files\n * key. For example, if the prefix was `LEVEL1.` and the key was `Waves` the final key will be `LEVEL1.Waves` and\n * this is what you would use to retrieve the text from the JSON Cache.\n *\n * The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.\n *\n * If the URL isn't specified the Loader will take the key and create a filename from that. For example if the key is \"data\"\n * and no URL is given then the Loader will set the URL to be \"data.json\". It will always add `.json` as the extension, although\n * this can be overridden if using an object instead of method arguments. If you do not desire this action then provide a URL.\n *\n * You can also optionally provide a `dataKey` to use. This allows you to extract only a part of the JSON and store it in the Cache,\n * rather than the whole file. For example, if your JSON data had a structure like this:\n * \n * ```json\n * {\n *     \"level1\": {\n *         \"baddies\": {\n *             \"aliens\": {},\n *             \"boss\": {}\n *         }\n *     },\n *     \"level2\": {},\n *     \"level3\": {}\n * }\n * ```\n *\n * And you only wanted to store the `boss` data in the Cache, then you could pass `level1.baddies.boss`as the `dataKey`.\n *\n * Note: The ability to load this type of file will only be available if the JSON File type has been built into Phaser.\n * It is available in the default build but can be excluded from custom builds.\n *\n * @method Phaser.Loader.LoaderPlugin#json\n * @fires Phaser.Loader.LoaderPlugin#addFileEvent\n * @since 3.0.0\n *\n * @param {(string|Phaser.Types.Loader.FileTypes.JSONFileConfig|Phaser.Types.Loader.FileTypes.JSONFileConfig[])} key - The key to use for this file, or a file configuration object, or array of them.\n * @param {string} [url] - The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.json`, i.e. if `key` was \"alien\" then the URL will be \"alien.json\".\n * @param {string} [dataKey] - When the JSON file loads only this property will be stored in the Cache.\n * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - An XHR Settings configuration object. Used in replacement of the Loaders default XHR Settings.\n *\n * @return {Phaser.Loader.LoaderPlugin} The Loader instance.\n */\nFileTypesManager.register('json', function (key, url, dataKey, xhrSettings)\n{\n    if (Array.isArray(key))\n    {\n        for (var i = 0; i < key.length; i++)\n        {\n            //  If it's an array it has to be an array of Objects, so we get everything out of the 'key' object\n            this.addFile(new JSONFile(this, key[i]));\n        }\n    }\n    else\n    {\n        this.addFile(new JSONFile(this, key, url, xhrSettings, dataKey));\n    }\n\n    return this;\n});\n\nmodule.exports = JSONFile;\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\nvar Class = require('../../utils/Class');\nvar CONST = require('../const');\nvar File = require('../File');\nvar FileTypesManager = require('../FileTypesManager');\nvar GetFastValue = require('../../utils/object/GetFastValue');\nvar IsPlainObject = require('../../utils/object/IsPlainObject');\n\n/**\n * @classdesc\n * A single Text File suitable for loading by the Loader.\n *\n * These are created when you use the Phaser.Loader.LoaderPlugin#text method and are not typically created directly.\n *\n * For documentation about what all the arguments and configuration options mean please see Phaser.Loader.LoaderPlugin#text.\n *\n * @class TextFile\n * @extends Phaser.Loader.File\n * @memberof Phaser.Loader.FileTypes\n * @constructor\n * @since 3.0.0\n *\n * @param {Phaser.Loader.LoaderPlugin} loader - A reference to the Loader that is responsible for this file.\n * @param {(string|Phaser.Types.Loader.FileTypes.TextFileConfig)} key - The key to use for this file, or a file configuration object.\n * @param {string} [url] - The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.txt`, i.e. if `key` was \"alien\" then the URL will be \"alien.txt\".\n * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - Extra XHR Settings specifically for this file.\n */\nvar TextFile = new Class({\n\n    Extends: File,\n\n    initialize:\n\n    function TextFile (loader, key, url, xhrSettings)\n    {\n        var extension = 'txt';\n\n        if (IsPlainObject(key))\n        {\n            var config = key;\n\n            key = GetFastValue(config, 'key');\n            url = GetFastValue(config, 'url');\n            xhrSettings = GetFastValue(config, 'xhrSettings');\n            extension = GetFastValue(config, 'extension', extension);\n        }\n\n        var fileConfig = {\n            type: 'text',\n            cache: loader.cacheManager.text,\n            extension: extension,\n            responseType: 'text',\n            key: key,\n            url: url,\n            xhrSettings: xhrSettings\n        };\n\n        File.call(this, loader, fileConfig);\n    },\n\n    /**\n     * Called automatically by Loader.nextFile.\n     * This method controls what extra work this File does with its loaded data.\n     *\n     * @method Phaser.Loader.FileTypes.TextFile#onProcess\n     * @since 3.7.0\n     */\n    onProcess: function ()\n    {\n        this.state = CONST.FILE_PROCESSING;\n\n        this.data = this.xhrLoader.responseText;\n\n        this.onProcessComplete();\n    }\n\n});\n\n/**\n * Adds a Text file, or array of Text files, to the current load queue.\n *\n * You can call this method from within your Scene's `preload`, along with any other files you wish to load:\n *\n * ```javascript\n * function preload ()\n * {\n *     this.load.text('story', 'files/IntroStory.txt');\n * }\n * ```\n *\n * The file is **not** loaded right away. It is added to a queue ready to be loaded either when the loader starts,\n * or if it's already running, when the next free load slot becomes available. This happens automatically if you\n * are calling this from within the Scene's `preload` method, or a related callback. Because the file is queued\n * it means you cannot use the file immediately after calling this method, but must wait for the file to complete.\n * The typical flow for a Phaser Scene is that you load assets in the Scene's `preload` method and then when the\n * Scene's `create` method is called you are guaranteed that all of those assets are ready for use and have been\n * loaded.\n *\n * The key must be a unique String. It is used to add the file to the global Text Cache upon a successful load.\n * The key should be unique both in terms of files being loaded and files already present in the Text Cache.\n * Loading a file using a key that is already taken will result in a warning. If you wish to replace an existing file\n * then remove it from the Text Cache first, before loading a new one.\n *\n * Instead of passing arguments you can pass a configuration object, such as:\n *\n * ```javascript\n * this.load.text({\n *     key: 'story',\n *     url: 'files/IntroStory.txt'\n * });\n * ```\n *\n * See the documentation for `Phaser.Types.Loader.FileTypes.TextFileConfig` for more details.\n *\n * Once the file has finished loading you can access it from its Cache using its key:\n *\n * ```javascript\n * this.load.text('story', 'files/IntroStory.txt');\n * // and later in your game ...\n * var data = this.cache.text.get('story');\n * ```\n *\n * If you have specified a prefix in the loader, via `Loader.setPrefix` then this value will be prepended to this files\n * key. For example, if the prefix was `LEVEL1.` and the key was `Story` the final key will be `LEVEL1.Story` and\n * this is what you would use to retrieve the text from the Text Cache.\n *\n * The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.\n *\n * If the URL isn't specified the Loader will take the key and create a filename from that. For example if the key is \"story\"\n * and no URL is given then the Loader will set the URL to be \"story.txt\". It will always add `.txt` as the extension, although\n * this can be overridden if using an object instead of method arguments. If you do not desire this action then provide a URL.\n *\n * Note: The ability to load this type of file will only be available if the Text File type has been built into Phaser.\n * It is available in the default build but can be excluded from custom builds.\n *\n * @method Phaser.Loader.LoaderPlugin#text\n * @fires Phaser.Loader.LoaderPlugin#addFileEvent\n * @since 3.0.0\n *\n * @param {(string|Phaser.Types.Loader.FileTypes.TextFileConfig|Phaser.Types.Loader.FileTypes.TextFileConfig[])} key - The key to use for this file, or a file configuration object, or array of them.\n * @param {string} [url] - The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.txt`, i.e. if `key` was \"alien\" then the URL will be \"alien.txt\".\n * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - An XHR Settings configuration object. Used in replacement of the Loaders default XHR Settings.\n *\n * @return {Phaser.Loader.LoaderPlugin} The Loader instance.\n */\nFileTypesManager.register('text', function (key, url, xhrSettings)\n{\n    if (Array.isArray(key))\n    {\n        for (var i = 0; i < key.length; i++)\n        {\n            //  If it's an array it has to be an array of Objects, so we get everything out of the 'key' object\n            this.addFile(new TextFile(this, key[i]));\n        }\n    }\n    else\n    {\n        this.addFile(new TextFile(this, key, url, xhrSettings));\n    }\n\n    return this;\n});\n\nmodule.exports = TextFile;\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * Calculate the mean average of the given values.\n *\n * @function Phaser.Math.Average\n * @since 3.0.0\n *\n * @param {number[]} values - The values to average.\n *\n * @return {number} The average value.\n */\nvar Average = function (values)\n{\n    var sum = 0;\n\n    for (var i = 0; i < values.length; i++)\n    {\n        sum += (+values[i]);\n    }\n\n    return sum / values.length;\n};\n\nmodule.exports = Average;\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\nvar Factorial = require('./Factorial');\n\n/**\n * [description]\n *\n * @function Phaser.Math.Bernstein\n * @since 3.0.0\n *\n * @param {number} n - [description]\n * @param {number} i - [description]\n *\n * @return {number} [description]\n */\nvar Bernstein = function (n, i)\n{\n    return Factorial(n) / Factorial(i) / Factorial(n - i);\n};\n\nmodule.exports = Bernstein;\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * Compute a random integer between the `min` and `max` values, inclusive.\n *\n * @function Phaser.Math.Between\n * @since 3.0.0\n *\n * @param {integer} min - The minimum value.\n * @param {integer} max - The maximum value.\n *\n * @return {integer} The random integer.\n */\nvar Between = function (min, max)\n{\n    return Math.floor(Math.random() * (max - min + 1) + min);\n};\n\nmodule.exports = Between;\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * Calculates a Catmull-Rom value.\n *\n * @function Phaser.Math.CatmullRom\n * @since 3.0.0\n *\n * @param {number} t - [description]\n * @param {number} p0 - [description]\n * @param {number} p1 - [description]\n * @param {number} p2 - [description]\n * @param {number} p3 - [description]\n *\n * @return {number} The Catmull-Rom value.\n */\nvar CatmullRom = function (t, p0, p1, p2, p3)\n{\n    var v0 = (p2 - p0) * 0.5;\n    var v1 = (p3 - p1) * 0.5;\n    var t2 = t * t;\n    var t3 = t * t2;\n\n    return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;\n};\n\nmodule.exports = CatmullRom;\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * Ceils to some place comparative to a `base`, default is 10 for decimal place.\n *\n * The `place` is represented by the power applied to `base` to get that place.\n *\n * @function Phaser.Math.CeilTo\n * @since 3.0.0\n *\n * @param {number} value - The value to round.\n * @param {number} [place=0] - The place to round to.\n * @param {integer} [base=10] - The base to round in. Default is 10 for decimal.\n *\n * @return {number} The rounded value.\n */\nvar CeilTo = function (value, place, base)\n{\n    if (place === undefined) { place = 0; }\n    if (base === undefined) { base = 10; }\n\n    var p = Math.pow(base, -place);\n\n    return Math.ceil(value * p) / p;\n};\n\nmodule.exports = CeilTo;\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * Force a value within the boundaries by clamping it to the range `min`, `max`.\n *\n * @function Phaser.Math.Clamp\n * @since 3.0.0\n *\n * @param {number} value - The value to be clamped.\n * @param {number} min - The minimum bounds.\n * @param {number} max - The maximum bounds.\n *\n * @return {number} The clamped value.\n */\nvar Clamp = function (value, min, max)\n{\n    return Math.max(min, Math.min(max, value));\n};\n\nmodule.exports = Clamp;\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\nvar CONST = require('./const');\n\n/**\n * Convert the given angle from degrees, to the equivalent angle in radians.\n *\n * @function Phaser.Math.DegToRad\n * @since 3.0.0\n *\n * @param {integer} degrees - The angle (in degrees) to convert to radians.\n *\n * @return {number} The given angle converted to radians.\n */\nvar DegToRad = function (degrees)\n{\n    return degrees * CONST.DEG_TO_RAD;\n};\n\nmodule.exports = DegToRad;\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * Calculates the positive difference of two given numbers.\n *\n * @function Phaser.Math.Difference\n * @since 3.0.0\n *\n * @param {number} a - The first number in the calculation.\n * @param {number} b - The second number in the calculation.\n *\n * @return {number} The positive difference of the two given numbers.\n */\nvar Difference = function (a, b)\n{\n    return Math.abs(a - b);\n};\n\nmodule.exports = Difference;\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * Calculates the factorial of a given number for integer values greater than 0.\n *\n * @function Phaser.Math.Factorial\n * @since 3.0.0\n *\n * @param {number} value - A positive integer to calculate the factorial of.\n *\n * @return {number} The factorial of the given number.\n */\nvar Factorial = function (value)\n{\n    if (value === 0)\n    {\n        return 1;\n    }\n\n    var res = value;\n\n    while (--value)\n    {\n        res *= value;\n    }\n\n    return res;\n};\n\nmodule.exports = Factorial;\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * Generate a random floating point number between the two given bounds, minimum inclusive, maximum exclusive.\n *\n * @function Phaser.Math.FloatBetween\n * @since 3.0.0\n *\n * @param {number} min - The lower bound for the float, inclusive.\n * @param {number} max - The upper bound for the float exclusive.\n *\n * @return {number} A random float within the given range.\n */\nvar FloatBetween = function (min, max)\n{\n    return Math.random() * (max - min) + min;\n};\n\nmodule.exports = FloatBetween;\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * Floors to some place comparative to a `base`, default is 10 for decimal place.\n *\n * The `place` is represented by the power applied to `base` to get that place.\n *\n * @function Phaser.Math.FloorTo\n * @since 3.0.0\n *\n * @param {number} value - The value to round.\n * @param {integer} [place=0] - The place to round to.\n * @param {integer} [base=10] - The base to round in. Default is 10 for decimal.\n *\n * @return {number} The rounded value.\n */\nvar FloorTo = function (value, place, base)\n{\n    if (place === undefined) { place = 0; }\n    if (base === undefined) { base = 10; }\n\n    var p = Math.pow(base, -place);\n\n    return Math.floor(value * p) / p;\n};\n\nmodule.exports = FloorTo;\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\nvar Clamp = require('./Clamp');\n\n/**\n * Return a value based on the range between `min` and `max` and the percentage given.\n *\n * @function Phaser.Math.FromPercent\n * @since 3.0.0\n *\n * @param {number} percent - A value between 0 and 1 representing the percentage.\n * @param {number} min - The minimum value.\n * @param {number} [max] - The maximum value.\n *\n * @return {number} The value that is `percent` percent between `min` and `max`.\n */\nvar FromPercent = function (percent, min, max)\n{\n    percent = Clamp(percent, 0, 1);\n\n    return (max - min) * percent;\n};\n\nmodule.exports = FromPercent;\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * Calculate the speed required to cover a distance in the time given.\n *\n * @function Phaser.Math.GetSpeed\n * @since 3.0.0\n *\n * @param {number} distance - The distance to travel in pixels.\n * @param {integer} time - The time, in ms, to cover the distance in.\n *\n * @return {number} The amount you will need to increment the position by each step in order to cover the distance in the time given.\n */\nvar GetSpeed = function (distance, time)\n{\n    return (distance / time) / 1000;\n};\n\nmodule.exports = GetSpeed;\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * Check if a given value is an even number.\n *\n * @function Phaser.Math.IsEven\n * @since 3.0.0\n *\n * @param {number} value - The number to perform the check with.\n *\n * @return {boolean} Whether the number is even or not.\n */\nvar IsEven = function (value)\n{\n    // Use abstract equality == for \"is number\" test\n\n    // eslint-disable-next-line eqeqeq\n    return (value == parseFloat(value)) ? !(value % 2) : void 0;\n};\n\nmodule.exports = IsEven;\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * Check if a given value is an even number using a strict type check.\n *\n * @function Phaser.Math.IsEvenStrict\n * @since 3.0.0\n *\n * @param {number} value - The number to perform the check with.\n *\n * @return {boolean} Whether the number is even or not.\n */\nvar IsEvenStrict = function (value)\n{\n    // Use strict equality === for \"is number\" test\n    return (value === parseFloat(value)) ? !(value % 2) : void 0;\n};\n\nmodule.exports = IsEvenStrict;\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * Calculates a linear (interpolation) value over t.\n *\n * @function Phaser.Math.Linear\n * @since 3.0.0\n *\n * @param {number} p0 - The first point.\n * @param {number} p1 - The second point.\n * @param {number} t - The percentage between p0 and p1 to return, represented as a number between 0 and 1.\n *\n * @return {number} The step t% of the way between p0 and p1.\n */\nvar Linear = function (p0, p1, t)\n{\n    return (p1 - p0) * t + p0;\n};\n\nmodule.exports = Linear;\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n//  Adapted from [gl-matrix](https://github.com/toji/gl-matrix) by toji\n//  and [vecmath](https://github.com/mattdesl/vecmath) by mattdesl\n\nvar Class = require('../utils/Class');\n\n/**\n * @classdesc\n * A three-dimensional matrix.\n *\n * Defaults to the identity matrix when instantiated.\n *\n * @class Matrix3\n * @memberof Phaser.Math\n * @constructor\n * @since 3.0.0\n *\n * @param {Phaser.Math.Matrix3} [m] - Optional Matrix3 to copy values from.\n */\nvar Matrix3 = new Class({\n\n    initialize:\n\n    function Matrix3 (m)\n    {\n        /**\n         * The matrix values.\n         *\n         * @name Phaser.Math.Matrix3#val\n         * @type {Float32Array}\n         * @since 3.0.0\n         */\n        this.val = new Float32Array(9);\n\n        if (m)\n        {\n            //  Assume Matrix3 with val:\n            this.copy(m);\n        }\n        else\n        {\n            //  Default to identity\n            this.identity();\n        }\n    },\n\n    /**\n     * Make a clone of this Matrix3.\n     *\n     * @method Phaser.Math.Matrix3#clone\n     * @since 3.0.0\n     *\n     * @return {Phaser.Math.Matrix3} A clone of this Matrix3.\n     */\n    clone: function ()\n    {\n        return new Matrix3(this);\n    },\n\n    /**\n     * This method is an alias for `Matrix3.copy`.\n     *\n     * @method Phaser.Math.Matrix3#set\n     * @since 3.0.0\n     *\n     * @param {Phaser.Math.Matrix3} src - The Matrix to set the values of this Matrix's from.\n     *\n     * @return {Phaser.Math.Matrix3} This Matrix3.\n     */\n    set: function (src)\n    {\n        return this.copy(src);\n    },\n\n    /**\n     * Copy the values of a given Matrix into this Matrix.\n     *\n     * @method Phaser.Math.Matrix3#copy\n     * @since 3.0.0\n     *\n     * @param {Phaser.Math.Matrix3} src - The Matrix to copy the values from.\n     *\n     * @return {Phaser.Math.Matrix3} This Matrix3.\n     */\n    copy: function (src)\n    {\n        var out = this.val;\n        var a = src.val;\n\n        out[0] = a[0];\n        out[1] = a[1];\n        out[2] = a[2];\n        out[3] = a[3];\n        out[4] = a[4];\n        out[5] = a[5];\n        out[6] = a[6];\n        out[7] = a[7];\n        out[8] = a[8];\n\n        return this;\n    },\n\n    /**\n     * Copy the values of a given Matrix4 into this Matrix3.\n     *\n     * @method Phaser.Math.Matrix3#fromMat4\n     * @since 3.0.0\n     *\n     * @param {Phaser.Math.Matrix4} m - The Matrix4 to copy the values from.\n     *\n     * @return {Phaser.Math.Matrix3} This Matrix3.\n     */\n    fromMat4: function (m)\n    {\n        var a = m.val;\n        var out = this.val;\n\n        out[0] = a[0];\n        out[1] = a[1];\n        out[2] = a[2];\n        out[3] = a[4];\n        out[4] = a[5];\n        out[5] = a[6];\n        out[6] = a[8];\n        out[7] = a[9];\n        out[8] = a[10];\n\n        return this;\n    },\n\n    /**\n     * Set the values of this Matrix from the given array.\n     *\n     * @method Phaser.Math.Matrix3#fromArray\n     * @since 3.0.0\n     *\n     * @param {array} a - The array to copy the values from.\n     *\n     * @return {Phaser.Math.Matrix3} This Matrix3.\n     */\n    fromArray: function (a)\n    {\n        var out = this.val;\n\n        out[0] = a[0];\n        out[1] = a[1];\n        out[2] = a[2];\n        out[3] = a[3];\n        out[4] = a[4];\n        out[5] = a[5];\n        out[6] = a[6];\n        out[7] = a[7];\n        out[8] = a[8];\n\n        return this;\n    },\n\n    /**\n     * Reset this Matrix to an identity (default) matrix.\n     *\n     * @method Phaser.Math.Matrix3#identity\n     * @since 3.0.0\n     *\n     * @return {Phaser.Math.Matrix3} This Matrix3.\n     */\n    identity: function ()\n    {\n        var out = this.val;\n\n        out[0] = 1;\n        out[1] = 0;\n        out[2] = 0;\n        out[3] = 0;\n        out[4] = 1;\n        out[5] = 0;\n        out[6] = 0;\n        out[7] = 0;\n        out[8] = 1;\n\n        return this;\n    },\n\n    /**\n     * Transpose this Matrix.\n     *\n     * @method Phaser.Math.Matrix3#transpose\n     * @since 3.0.0\n     *\n     * @return {Phaser.Math.Matrix3} This Matrix3.\n     */\n    transpose: function ()\n    {\n        var a = this.val;\n        var a01 = a[1];\n        var a02 = a[2];\n        var a12 = a[5];\n\n        a[1] = a[3];\n        a[2] = a[6];\n        a[3] = a01;\n        a[5] = a[7];\n        a[6] = a02;\n        a[7] = a12;\n\n        return this;\n    },\n\n    /**\n     * Invert this Matrix.\n     *\n     * @method Phaser.Math.Matrix3#invert\n     * @since 3.0.0\n     *\n     * @return {Phaser.Math.Matrix3} This Matrix3.\n     */\n    invert: function ()\n    {\n        var a = this.val;\n\n        var a00 = a[0];\n        var a01 = a[1];\n        var a02 = a[2];\n        var a10 = a[3];\n        var a11 = a[4];\n        var a12 = a[5];\n        var a20 = a[6];\n        var a21 = a[7];\n        var a22 = a[8];\n\n        var b01 = a22 * a11 - a12 * a21;\n        var b11 = -a22 * a10 + a12 * a20;\n        var b21 = a21 * a10 - a11 * a20;\n\n        // Calculate the determinant\n        var det = a00 * b01 + a01 * b11 + a02 * b21;\n\n        if (!det)\n        {\n            return null;\n        }\n\n        det = 1 / det;\n\n        a[0] = b01 * det;\n        a[1] = (-a22 * a01 + a02 * a21) * det;\n        a[2] = (a12 * a01 - a02 * a11) * det;\n        a[3] = b11 * det;\n        a[4] = (a22 * a00 - a02 * a20) * det;\n        a[5] = (-a12 * a00 + a02 * a10) * det;\n        a[6] = b21 * det;\n        a[7] = (-a21 * a00 + a01 * a20) * det;\n        a[8] = (a11 * a00 - a01 * a10) * det;\n\n        return this;\n    },\n\n    /**\n     * Calculate the adjoint, or adjugate, of this Matrix.\n     *\n     * @method Phaser.Math.Matrix3#adjoint\n     * @since 3.0.0\n     *\n     * @return {Phaser.Math.Matrix3} This Matrix3.\n     */\n    adjoint: function ()\n    {\n        var a = this.val;\n\n        var a00 = a[0];\n        var a01 = a[1];\n        var a02 = a[2];\n        var a10 = a[3];\n        var a11 = a[4];\n        var a12 = a[5];\n        var a20 = a[6];\n        var a21 = a[7];\n        var a22 = a[8];\n\n        a[0] = (a11 * a22 - a12 * a21);\n        a[1] = (a02 * a21 - a01 * a22);\n        a[2] = (a01 * a12 - a02 * a11);\n        a[3] = (a12 * a20 - a10 * a22);\n        a[4] = (a00 * a22 - a02 * a20);\n        a[5] = (a02 * a10 - a00 * a12);\n        a[6] = (a10 * a21 - a11 * a20);\n        a[7] = (a01 * a20 - a00 * a21);\n        a[8] = (a00 * a11 - a01 * a10);\n\n        return this;\n    },\n\n    /**\n     * Calculate the determinant of this Matrix.\n     *\n     * @method Phaser.Math.Matrix3#determinant\n     * @since 3.0.0\n     *\n     * @return {number} The determinant of this Matrix.\n     */\n    determinant: function ()\n    {\n        var a = this.val;\n\n        var a00 = a[0];\n        var a01 = a[1];\n        var a02 = a[2];\n        var a10 = a[3];\n        var a11 = a[4];\n        var a12 = a[5];\n        var a20 = a[6];\n        var a21 = a[7];\n        var a22 = a[8];\n\n        return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);\n    },\n\n    /**\n     * Multiply this Matrix by the given Matrix.\n     *\n     * @method Phaser.Math.Matrix3#multiply\n     * @since 3.0.0\n     *\n     * @param {Phaser.Math.Matrix3} src - The Matrix to multiply this Matrix by.\n     *\n     * @return {Phaser.Math.Matrix3} This Matrix3.\n     */\n    multiply: function (src)\n    {\n        var a = this.val;\n\n        var a00 = a[0];\n        var a01 = a[1];\n        var a02 = a[2];\n        var a10 = a[3];\n        var a11 = a[4];\n        var a12 = a[5];\n        var a20 = a[6];\n        var a21 = a[7];\n        var a22 = a[8];\n\n        var b = src.val;\n\n        var b00 = b[0];\n        var b01 = b[1];\n        var b02 = b[2];\n        var b10 = b[3];\n        var b11 = b[4];\n        var b12 = b[5];\n        var b20 = b[6];\n        var b21 = b[7];\n        var b22 = b[8];\n\n        a[0] = b00 * a00 + b01 * a10 + b02 * a20;\n        a[1] = b00 * a01 + b01 * a11 + b02 * a21;\n        a[2] = b00 * a02 + b01 * a12 + b02 * a22;\n\n        a[3] = b10 * a00 + b11 * a10 + b12 * a20;\n        a[4] = b10 * a01 + b11 * a11 + b12 * a21;\n        a[5] = b10 * a02 + b11 * a12 + b12 * a22;\n\n        a[6] = b20 * a00 + b21 * a10 + b22 * a20;\n        a[7] = b20 * a01 + b21 * a11 + b22 * a21;\n        a[8] = b20 * a02 + b21 * a12 + b22 * a22;\n\n        return this;\n    },\n\n    /**\n     * Translate this Matrix using the given Vector.\n     *\n     * @method Phaser.Math.Matrix3#translate\n     * @since 3.0.0\n     *\n     * @param {(Phaser.Math.Vector2|Phaser.Math.Vector3|Phaser.Math.Vector4)} v - The Vector to translate this Matrix with.\n     *\n     * @return {Phaser.Math.Matrix3} This Matrix3.\n     */\n    translate: function (v)\n    {\n        var a = this.val;\n        var x = v.x;\n        var y = v.y;\n\n        a[6] = x * a[0] + y * a[3] + a[6];\n        a[7] = x * a[1] + y * a[4] + a[7];\n        a[8] = x * a[2] + y * a[5] + a[8];\n\n        return this;\n    },\n\n    /**\n     * Apply a rotation transformation to this Matrix.\n     *\n     * @method Phaser.Math.Matrix3#rotate\n     * @since 3.0.0\n     *\n     * @param {number} rad - The angle in radians to rotate by.\n     *\n     * @return {Phaser.Math.Matrix3} This Matrix3.\n     */\n    rotate: function (rad)\n    {\n        var a = this.val;\n\n        var a00 = a[0];\n        var a01 = a[1];\n        var a02 = a[2];\n        var a10 = a[3];\n        var a11 = a[4];\n        var a12 = a[5];\n\n        var s = Math.sin(rad);\n        var c = Math.cos(rad);\n\n        a[0] = c * a00 + s * a10;\n        a[1] = c * a01 + s * a11;\n        a[2] = c * a02 + s * a12;\n\n        a[3] = c * a10 - s * a00;\n        a[4] = c * a11 - s * a01;\n        a[5] = c * a12 - s * a02;\n\n        return this;\n    },\n\n    /**\n     * Apply a scale transformation to this Matrix.\n     *\n     * Uses the `x` and `y` components of the given Vector to scale the Matrix.\n     *\n     * @method Phaser.Math.Matrix3#scale\n     * @since 3.0.0\n     *\n     * @param {(Phaser.Math.Vector2|Phaser.Math.Vector3|Phaser.Math.Vector4)} v - The Vector to scale this Matrix with.\n     *\n     * @return {Phaser.Math.Matrix3} This Matrix3.\n     */\n    scale: function (v)\n    {\n        var a = this.val;\n        var x = v.x;\n        var y = v.y;\n\n        a[0] = x * a[0];\n        a[1] = x * a[1];\n        a[2] = x * a[2];\n\n        a[3] = y * a[3];\n        a[4] = y * a[4];\n        a[5] = y * a[5];\n\n        return this;\n    },\n\n    /**\n     * Set the values of this Matrix from the given Quaternion.\n     *\n     * @method Phaser.Math.Matrix3#fromQuat\n     * @since 3.0.0\n     *\n     * @param {Phaser.Math.Quaternion} q - The Quaternion to set the values of this Matrix from.\n     *\n     * @return {Phaser.Math.Matrix3} This Matrix3.\n     */\n    fromQuat: function (q)\n    {\n        var x = q.x;\n        var y = q.y;\n        var z = q.z;\n        var w = q.w;\n\n        var x2 = x + x;\n        var y2 = y + y;\n        var z2 = z + z;\n\n        var xx = x * x2;\n        var xy = x * y2;\n        var xz = x * z2;\n\n        var yy = y * y2;\n        var yz = y * z2;\n        var zz = z * z2;\n\n        var wx = w * x2;\n        var wy = w * y2;\n        var wz = w * z2;\n\n        var out = this.val;\n\n        out[0] = 1 - (yy + zz);\n        out[3] = xy + wz;\n        out[6] = xz - wy;\n\n        out[1] = xy - wz;\n        out[4] = 1 - (xx + zz);\n        out[7] = yz + wx;\n\n        out[2] = xz + wy;\n        out[5] = yz - wx;\n        out[8] = 1 - (xx + yy);\n\n        return this;\n    },\n\n    /**\n     * [description]\n     *\n     * @method Phaser.Math.Matrix3#normalFromMat4\n     * @since 3.0.0\n     *\n     * @param {Phaser.Math.Matrix4} m - [description]\n     *\n     * @return {Phaser.Math.Matrix3} This Matrix3.\n     */\n    normalFromMat4: function (m)\n    {\n        var a = m.val;\n        var out = this.val;\n\n        var a00 = a[0];\n        var a01 = a[1];\n        var a02 = a[2];\n        var a03 = a[3];\n\n        var a10 = a[4];\n        var a11 = a[5];\n        var a12 = a[6];\n        var a13 = a[7];\n\n        var a20 = a[8];\n        var a21 = a[9];\n        var a22 = a[10];\n        var a23 = a[11];\n\n        var a30 = a[12];\n        var a31 = a[13];\n        var a32 = a[14];\n        var a33 = a[15];\n\n        var b00 = a00 * a11 - a01 * a10;\n        var b01 = a00 * a12 - a02 * a10;\n        var b02 = a00 * a13 - a03 * a10;\n        var b03 = a01 * a12 - a02 * a11;\n\n        var b04 = a01 * a13 - a03 * a11;\n        var b05 = a02 * a13 - a03 * a12;\n        var b06 = a20 * a31 - a21 * a30;\n        var b07 = a20 * a32 - a22 * a30;\n\n        var b08 = a20 * a33 - a23 * a30;\n        var b09 = a21 * a32 - a22 * a31;\n        var b10 = a21 * a33 - a23 * a31;\n        var b11 = a22 * a33 - a23 * a32;\n\n        // Calculate the determinant\n        var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\n        if (!det)\n        {\n            return null;\n        }\n\n        det = 1 / det;\n\n        out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;\n        out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;\n        out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;\n\n        out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;\n        out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;\n        out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;\n\n        out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;\n        out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;\n        out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;\n\n        return this;\n    }\n\n});\n\nmodule.exports = Matrix3;\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n//  Adapted from [gl-matrix](https://github.com/toji/gl-matrix) by toji\n//  and [vecmath](https://github.com/mattdesl/vecmath) by mattdesl\n\nvar Class = require('../utils/Class');\n\nvar EPSILON = 0.000001;\n\n/**\n * @classdesc\n * A four-dimensional matrix.\n *\n * @class Matrix4\n * @memberof Phaser.Math\n * @constructor\n * @since 3.0.0\n *\n * @param {Phaser.Math.Matrix4} [m] - Optional Matrix4 to copy values from.\n */\nvar Matrix4 = new Class({\n\n    initialize:\n\n    function Matrix4 (m)\n    {\n        /**\n         * The matrix values.\n         *\n         * @name Phaser.Math.Matrix4#val\n         * @type {Float32Array}\n         * @since 3.0.0\n         */\n        this.val = new Float32Array(16);\n\n        if (m)\n        {\n            //  Assume Matrix4 with val:\n            this.copy(m);\n        }\n        else\n        {\n            //  Default to identity\n            this.identity();\n        }\n    },\n\n    /**\n     * Make a clone of this Matrix4.\n     *\n     * @method Phaser.Math.Matrix4#clone\n     * @since 3.0.0\n     *\n     * @return {Phaser.Math.Matrix4} A clone of this Matrix4.\n     */\n    clone: function ()\n    {\n        return new Matrix4(this);\n    },\n\n    //  TODO - Should work with basic values\n\n    /**\n     * This method is an alias for `Matrix4.copy`.\n     *\n     * @method Phaser.Math.Matrix4#set\n     * @since 3.0.0\n     *\n     * @param {Phaser.Math.Matrix4} src - The Matrix to set the values of this Matrix's from.\n     *\n     * @return {Phaser.Math.Matrix4} This Matrix4.\n     */\n    set: function (src)\n    {\n        return this.copy(src);\n    },\n\n    /**\n     * Copy the values of a given Matrix into this Matrix.\n     *\n     * @method Phaser.Math.Matrix4#copy\n     * @since 3.0.0\n     *\n     * @param {Phaser.Math.Matrix4} src - The Matrix to copy the values from.\n     *\n     * @return {Phaser.Math.Matrix4} This Matrix4.\n     */\n    copy: function (src)\n    {\n        var out = this.val;\n        var a = src.val;\n\n        out[0] = a[0];\n        out[1] = a[1];\n        out[2] = a[2];\n        out[3] = a[3];\n        out[4] = a[4];\n        out[5] = a[5];\n        out[6] = a[6];\n        out[7] = a[7];\n        out[8] = a[8];\n        out[9] = a[9];\n        out[10] = a[10];\n        out[11] = a[11];\n        out[12] = a[12];\n        out[13] = a[13];\n        out[14] = a[14];\n        out[15] = a[15];\n\n        return this;\n    },\n\n    /**\n     * Set the values of this Matrix from the given array.\n     *\n     * @method Phaser.Math.Matrix4#fromArray\n     * @since 3.0.0\n     *\n     * @param {array} a - The array to copy the values from.\n     *\n     * @return {Phaser.Math.Matrix4} This Matrix4.\n     */\n    fromArray: function (a)\n    {\n        var out = this.val;\n\n        out[0] = a[0];\n        out[1] = a[1];\n        out[2] = a[2];\n        out[3] = a[3];\n        out[4] = a[4];\n        out[5] = a[5];\n        out[6] = a[6];\n        out[7] = a[7];\n        out[8] = a[8];\n        out[9] = a[9];\n        out[10] = a[10];\n        out[11] = a[11];\n        out[12] = a[12];\n        out[13] = a[13];\n        out[14] = a[14];\n        out[15] = a[15];\n\n        return this;\n    },\n\n    /**\n     * Reset this Matrix.\n     *\n     * Sets all values to `0`.\n     *\n     * @method Phaser.Math.Matrix4#zero\n     * @since 3.0.0\n     *\n     * @return {Phaser.Math.Matrix4} This Matrix4.\n     */\n    zero: function ()\n    {\n        var out = this.val;\n\n        out[0] = 0;\n        out[1] = 0;\n        out[2] = 0;\n        out[3] = 0;\n        out[4] = 0;\n        out[5] = 0;\n        out[6] = 0;\n        out[7] = 0;\n        out[8] = 0;\n        out[9] = 0;\n        out[10] = 0;\n        out[11] = 0;\n        out[12] = 0;\n        out[13] = 0;\n        out[14] = 0;\n        out[15] = 0;\n\n        return this;\n    },\n\n    /**\n     * Set the `x`, `y` and `z` values of this Matrix.\n     *\n     * @method Phaser.Math.Matrix4#xyz\n     * @since 3.0.0\n     *\n     * @param {number} x - The x value.\n     * @param {number} y - The y value.\n     * @param {number} z - The z value.\n     *\n     * @return {Phaser.Math.Matrix4} This Matrix4.\n     */\n    xyz: function (x, y, z)\n    {\n        this.identity();\n\n        var out = this.val;\n\n        out[12] = x;\n        out[13] = y;\n        out[14] = z;\n\n        return this;\n    },\n\n    /**\n     * Set the scaling values of this Matrix.\n     *\n     * @method Phaser.Math.Matrix4#scaling\n     * @since 3.0.0\n     *\n     * @param {number} x - The x scaling value.\n     * @param {number} y - The y scaling value.\n     * @param {number} z - The z scaling value.\n     *\n     * @return {Phaser.Math.Matrix4} This Matrix4.\n     */\n    scaling: function (x, y, z)\n    {\n        this.zero();\n\n        var out = this.val;\n\n        out[0] = x;\n        out[5] = y;\n        out[10] = z;\n        out[15] = 1;\n\n        return this;\n    },\n\n    /**\n     * Reset this Matrix to an identity (default) matrix.\n     *\n     * @method Phaser.Math.Matrix4#identity\n     * @since 3.0.0\n     *\n     * @return {Phaser.Math.Matrix4} This Matrix4.\n     */\n    identity: function ()\n    {\n        var out = this.val;\n\n        out[0] = 1;\n        out[1] = 0;\n        out[2] = 0;\n        out[3] = 0;\n        out[4] = 0;\n        out[5] = 1;\n        out[6] = 0;\n        out[7] = 0;\n        out[8] = 0;\n        out[9] = 0;\n        out[10] = 1;\n        out[11] = 0;\n        out[12] = 0;\n        out[13] = 0;\n        out[14] = 0;\n        out[15] = 1;\n\n        return this;\n    },\n\n    /**\n     * Transpose this Matrix.\n     *\n     * @method Phaser.Math.Matrix4#transpose\n     * @since 3.0.0\n     *\n     * @return {Phaser.Math.Matrix4} This Matrix4.\n     */\n    transpose: function ()\n    {\n        var a = this.val;\n\n        var a01 = a[1];\n        var a02 = a[2];\n        var a03 = a[3];\n        var a12 = a[6];\n        var a13 = a[7];\n        var a23 = a[11];\n\n        a[1] = a[4];\n        a[2] = a[8];\n        a[3] = a[12];\n        a[4] = a01;\n        a[6] = a[9];\n        a[7] = a[13];\n        a[8] = a02;\n        a[9] = a12;\n        a[11] = a[14];\n        a[12] = a03;\n        a[13] = a13;\n        a[14] = a23;\n\n        return this;\n    },\n\n    /**\n     * Invert this Matrix.\n     *\n     * @method Phaser.Math.Matrix4#invert\n     * @since 3.0.0\n     *\n     * @return {Phaser.Math.Matrix4} This Matrix4.\n     */\n    invert: function ()\n    {\n        var a = this.val;\n\n        var a00 = a[0];\n        var a01 = a[1];\n        var a02 = a[2];\n        var a03 = a[3];\n\n        var a10 = a[4];\n        var a11 = a[5];\n        var a12 = a[6];\n        var a13 = a[7];\n\n        var a20 = a[8];\n        var a21 = a[9];\n        var a22 = a[10];\n        var a23 = a[11];\n\n        var a30 = a[12];\n        var a31 = a[13];\n        var a32 = a[14];\n        var a33 = a[15];\n\n        var b00 = a00 * a11 - a01 * a10;\n        var b01 = a00 * a12 - a02 * a10;\n        var b02 = a00 * a13 - a03 * a10;\n        var b03 = a01 * a12 - a02 * a11;\n\n        var b04 = a01 * a13 - a03 * a11;\n        var b05 = a02 * a13 - a03 * a12;\n        var b06 = a20 * a31 - a21 * a30;\n        var b07 = a20 * a32 - a22 * a30;\n\n        var b08 = a20 * a33 - a23 * a30;\n        var b09 = a21 * a32 - a22 * a31;\n        var b10 = a21 * a33 - a23 * a31;\n        var b11 = a22 * a33 - a23 * a32;\n\n        // Calculate the determinant\n        var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\n        if (!det)\n        {\n            return null;\n        }\n\n        det = 1 / det;\n\n        a[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;\n        a[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;\n        a[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;\n        a[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;\n        a[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;\n        a[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;\n        a[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;\n        a[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;\n        a[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;\n        a[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;\n        a[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;\n        a[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;\n        a[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;\n        a[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;\n        a[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;\n        a[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;\n\n        return this;\n    },\n\n    /**\n     * Calculate the adjoint, or adjugate, of this Matrix.\n     *\n     * @method Phaser.Math.Matrix4#adjoint\n     * @since 3.0.0\n     *\n     * @return {Phaser.Math.Matrix4} This Matrix4.\n     */\n    adjoint: function ()\n    {\n        var a = this.val;\n\n        var a00 = a[0];\n        var a01 = a[1];\n        var a02 = a[2];\n        var a03 = a[3];\n\n        var a10 = a[4];\n        var a11 = a[5];\n        var a12 = a[6];\n        var a13 = a[7];\n\n        var a20 = a[8];\n        var a21 = a[9];\n        var a22 = a[10];\n        var a23 = a[11];\n\n        var a30 = a[12];\n        var a31 = a[13];\n        var a32 = a[14];\n        var a33 = a[15];\n\n        a[0] = (a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22));\n        a[1] = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));\n        a[2] = (a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12));\n        a[3] = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));\n        a[4] = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));\n        a[5] = (a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22));\n        a[6] = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));\n        a[7] = (a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12));\n        a[8] = (a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21));\n        a[9] = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));\n        a[10] = (a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11));\n        a[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));\n        a[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));\n        a[13] = (a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21));\n        a[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));\n        a[15] = (a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11));\n\n        return this;\n    },\n\n    /**\n     * Calculate the determinant of this Matrix.\n     *\n     * @method Phaser.Math.Matrix4#determinant\n     * @since 3.0.0\n     *\n     * @return {number} The determinant of this Matrix.\n     */\n    determinant: function ()\n    {\n        var a = this.val;\n\n        var a00 = a[0];\n        var a01 = a[1];\n        var a02 = a[2];\n        var a03 = a[3];\n\n        var a10 = a[4];\n        var a11 = a[5];\n        var a12 = a[6];\n        var a13 = a[7];\n\n        var a20 = a[8];\n        var a21 = a[9];\n        var a22 = a[10];\n        var a23 = a[11];\n\n        var a30 = a[12];\n        var a31 = a[13];\n        var a32 = a[14];\n        var a33 = a[15];\n\n        var b00 = a00 * a11 - a01 * a10;\n        var b01 = a00 * a12 - a02 * a10;\n        var b02 = a00 * a13 - a03 * a10;\n        var b03 = a01 * a12 - a02 * a11;\n        var b04 = a01 * a13 - a03 * a11;\n        var b05 = a02 * a13 - a03 * a12;\n        var b06 = a20 * a31 - a21 * a30;\n        var b07 = a20 * a32 - a22 * a30;\n        var b08 = a20 * a33 - a23 * a30;\n        var b09 = a21 * a32 - a22 * a31;\n        var b10 = a21 * a33 - a23 * a31;\n        var b11 = a22 * a33 - a23 * a32;\n\n        // Calculate the determinant\n        return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n    },\n\n    /**\n     * Multiply this Matrix by the given Matrix.\n     *\n     * @method Phaser.Math.Matrix4#multiply\n     * @since 3.0.0\n     *\n     * @param {Phaser.Math.Matrix4} src - The Matrix to multiply this Matrix by.\n     *\n     * @return {Phaser.Math.Matrix4} This Matrix4.\n     */\n    multiply: function (src)\n    {\n        var a = this.val;\n\n        var a00 = a[0];\n        var a01 = a[1];\n        var a02 = a[2];\n        var a03 = a[3];\n\n        var a10 = a[4];\n        var a11 = a[5];\n        var a12 = a[6];\n        var a13 = a[7];\n\n        var a20 = a[8];\n        var a21 = a[9];\n        var a22 = a[10];\n        var a23 = a[11];\n\n        var a30 = a[12];\n        var a31 = a[13];\n        var a32 = a[14];\n        var a33 = a[15];\n\n        var b = src.val;\n\n        // Cache only the current line of the second matrix\n        var b0 = b[0];\n        var b1 = b[1];\n        var b2 = b[2];\n        var b3 = b[3];\n\n        a[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n        a[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n        a[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n        a[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n\n        b0 = b[4];\n        b1 = b[5];\n        b2 = b[6];\n        b3 = b[7];\n\n        a[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n        a[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n        a[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n        a[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n\n        b0 = b[8];\n        b1 = b[9];\n        b2 = b[10];\n        b3 = b[11];\n\n        a[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n        a[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n        a[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n        a[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n\n        b0 = b[12];\n        b1 = b[13];\n        b2 = b[14];\n        b3 = b[15];\n\n        a[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n        a[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n        a[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n        a[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n\n        return this;\n    },\n\n    /**\n     * [description]\n     *\n     * @method Phaser.Math.Matrix4#multiplyLocal\n     * @since 3.0.0\n     *\n     * @param {Phaser.Math.Matrix4} src - [description]\n     *\n     * @return {Phaser.Math.Matrix4} This Matrix4.\n     */\n    multiplyLocal: function (src)\n    {\n        var a = [];\n        var m1 = this.val;\n        var m2 = src.val;\n\n        a[0] = m1[0] * m2[0] + m1[1] * m2[4] + m1[2] * m2[8] + m1[3] * m2[12];\n        a[1] = m1[0] * m2[1] + m1[1] * m2[5] + m1[2] * m2[9] + m1[3] * m2[13];\n        a[2] = m1[0] * m2[2] + m1[1] * m2[6] + m1[2] * m2[10] + m1[3] * m2[14];\n        a[3] = m1[0] * m2[3] + m1[1] * m2[7] + m1[2] * m2[11] + m1[3] * m2[15];\n\n        a[4] = m1[4] * m2[0] + m1[5] * m2[4] + m1[6] * m2[8] + m1[7] * m2[12];\n        a[5] = m1[4] * m2[1] + m1[5] * m2[5] + m1[6] * m2[9] + m1[7] * m2[13];\n        a[6] = m1[4] * m2[2] + m1[5] * m2[6] + m1[6] * m2[10] + m1[7] * m2[14];\n        a[7] = m1[4] * m2[3] + m1[5] * m2[7] + m1[6] * m2[11] + m1[7] * m2[15];\n\n        a[8] = m1[8] * m2[0] + m1[9] * m2[4] + m1[10] * m2[8] + m1[11] * m2[12];\n        a[9] = m1[8] * m2[1] + m1[9] * m2[5] + m1[10] * m2[9] + m1[11] * m2[13];\n        a[10] = m1[8] * m2[2] + m1[9] * m2[6] + m1[10] * m2[10] + m1[11] * m2[14];\n        a[11] = m1[8] * m2[3] + m1[9] * m2[7] + m1[10] * m2[11] + m1[11] * m2[15];\n\n        a[12] = m1[12] * m2[0] + m1[13] * m2[4] + m1[14] * m2[8] + m1[15] * m2[12];\n        a[13] = m1[12] * m2[1] + m1[13] * m2[5] + m1[14] * m2[9] + m1[15] * m2[13];\n        a[14] = m1[12] * m2[2] + m1[13] * m2[6] + m1[14] * m2[10] + m1[15] * m2[14];\n        a[15] = m1[12] * m2[3] + m1[13] * m2[7] + m1[14] * m2[11] + m1[15] * m2[15];\n\n        return this.fromArray(a);\n    },\n\n    /**\n     * Translate this Matrix using the given Vector.\n     *\n     * @method Phaser.Math.Matrix4#translate\n     * @since 3.0.0\n     *\n     * @param {(Phaser.Math.Vector3|Phaser.Math.Vector4)} v - The Vector to translate this Matrix with.\n     *\n     * @return {Phaser.Math.Matrix4} This Matrix4.\n     */\n    translate: function (v)\n    {\n        var x = v.x;\n        var y = v.y;\n        var z = v.z;\n        var a = this.val;\n\n        a[12] = a[0] * x + a[4] * y + a[8] * z + a[12];\n        a[13] = a[1] * x + a[5] * y + a[9] * z + a[13];\n        a[14] = a[2] * x + a[6] * y + a[10] * z + a[14];\n        a[15] = a[3] * x + a[7] * y + a[11] * z + a[15];\n\n        return this;\n    },\n\n    /**\n     * Translate this Matrix using the given values.\n     *\n     * @method Phaser.Math.Matrix4#translateXYZ\n     * @since 3.16.0\n     *\n     * @param {number} x - The x component.\n     * @param {number} y - The y component.\n     * @param {number} z - The z component.\n     *\n     * @return {Phaser.Math.Matrix4} This Matrix4.\n     */\n    translateXYZ: function (x, y, z)\n    {\n        var a = this.val;\n\n        a[12] = a[0] * x + a[4] * y + a[8] * z + a[12];\n        a[13] = a[1] * x + a[5] * y + a[9] * z + a[13];\n        a[14] = a[2] * x + a[6] * y + a[10] * z + a[14];\n        a[15] = a[3] * x + a[7] * y + a[11] * z + a[15];\n\n        return this;\n    },\n\n    /**\n     * Apply a scale transformation to this Matrix.\n     *\n     * Uses the `x`, `y` and `z` components of the given Vector to scale the Matrix.\n     *\n     * @method Phaser.Math.Matrix4#scale\n     * @since 3.0.0\n     *\n     * @param {(Phaser.Math.Vector3|Phaser.Math.Vector4)} v - The Vector to scale this Matrix with.\n     *\n     * @return {Phaser.Math.Matrix4} This Matrix4.\n     */\n    scale: function (v)\n    {\n        var x = v.x;\n        var y = v.y;\n        var z = v.z;\n        var a = this.val;\n\n        a[0] = a[0] * x;\n        a[1] = a[1] * x;\n        a[2] = a[2] * x;\n        a[3] = a[3] * x;\n\n        a[4] = a[4] * y;\n        a[5] = a[5] * y;\n        a[6] = a[6] * y;\n        a[7] = a[7] * y;\n\n        a[8] = a[8] * z;\n        a[9] = a[9] * z;\n        a[10] = a[10] * z;\n        a[11] = a[11] * z;\n\n        return this;\n    },\n\n    /**\n     * Apply a scale transformation to this Matrix.\n     *\n     * @method Phaser.Math.Matrix4#scaleXYZ\n     * @since 3.16.0\n     *\n     * @param {number} x - The x component.\n     * @param {number} y - The y component.\n     * @param {number} z - The z component.\n     *\n     * @return {Phaser.Math.Matrix4} This Matrix4.\n     */\n    scaleXYZ: function (x, y, z)\n    {\n        var a = this.val;\n\n        a[0] = a[0] * x;\n        a[1] = a[1] * x;\n        a[2] = a[2] * x;\n        a[3] = a[3] * x;\n\n        a[4] = a[4] * y;\n        a[5] = a[5] * y;\n        a[6] = a[6] * y;\n        a[7] = a[7] * y;\n\n        a[8] = a[8] * z;\n        a[9] = a[9] * z;\n        a[10] = a[10] * z;\n        a[11] = a[11] * z;\n\n        return this;\n    },\n\n    /**\n     * Derive a rotation matrix around the given axis.\n     *\n     * @method Phaser.Math.Matrix4#makeRotationAxis\n     * @since 3.0.0\n     *\n     * @param {(Phaser.Math.Vector3|Phaser.Math.Vector4)} axis - The rotation axis.\n     * @param {number} angle - The rotation angle in radians.\n     *\n     * @return {Phaser.Math.Matrix4} This Matrix4.\n     */\n    makeRotationAxis: function (axis, angle)\n    {\n        // Based on http://www.gamedev.net/reference/articles/article1199.asp\n\n        var c = Math.cos(angle);\n        var s = Math.sin(angle);\n        var t = 1 - c;\n        var x = axis.x;\n        var y = axis.y;\n        var z = axis.z;\n        var tx = t * x;\n        var ty = t * y;\n\n        this.fromArray([\n            tx * x + c, tx * y - s * z, tx * z + s * y, 0,\n            tx * y + s * z, ty * y + c, ty * z - s * x, 0,\n            tx * z - s * y, ty * z + s * x, t * z * z + c, 0,\n            0, 0, 0, 1\n        ]);\n\n        return this;\n    },\n\n    /**\n     * Apply a rotation transformation to this Matrix.\n     *\n     * @method Phaser.Math.Matrix4#rotate\n     * @since 3.0.0\n     *\n     * @param {number} rad - The angle in radians to rotate by.\n     * @param {Phaser.Math.Vector3} axis - The axis to rotate upon.\n     *\n     * @return {Phaser.Math.Matrix4} This Matrix4.\n     */\n    rotate: function (rad, axis)\n    {\n        var a = this.val;\n        var x = axis.x;\n        var y = axis.y;\n        var z = axis.z;\n        var len = Math.sqrt(x * x + y * y + z * z);\n\n        if (Math.abs(len) < EPSILON)\n        {\n            return null;\n        }\n\n        len = 1 / len;\n        x *= len;\n        y *= len;\n        z *= len;\n\n        var s = Math.sin(rad);\n        var c = Math.cos(rad);\n        var t = 1 - c;\n\n        var a00 = a[0];\n        var a01 = a[1];\n        var a02 = a[2];\n        var a03 = a[3];\n\n        var a10 = a[4];\n        var a11 = a[5];\n        var a12 = a[6];\n        var a13 = a[7];\n\n        var a20 = a[8];\n        var a21 = a[9];\n        var a22 = a[10];\n        var a23 = a[11];\n\n        // Construct the elements of the rotation matrix\n        var b00 = x * x * t + c;\n        var b01 = y * x * t + z * s;\n        var b02 = z * x * t - y * s;\n\n        var b10 = x * y * t - z * s;\n        var b11 = y * y * t + c;\n        var b12 = z * y * t + x * s;\n\n        var b20 = x * z * t + y * s;\n        var b21 = y * z * t - x * s;\n        var b22 = z * z * t + c;\n\n        // Perform rotation-specific matrix multiplication\n        a[0] = a00 * b00 + a10 * b01 + a20 * b02;\n        a[1] = a01 * b00 + a11 * b01 + a21 * b02;\n        a[2] = a02 * b00 + a12 * b01 + a22 * b02;\n        a[3] = a03 * b00 + a13 * b01 + a23 * b02;\n        a[4] = a00 * b10 + a10 * b11 + a20 * b12;\n        a[5] = a01 * b10 + a11 * b11 + a21 * b12;\n        a[6] = a02 * b10 + a12 * b11 + a22 * b12;\n        a[7] = a03 * b10 + a13 * b11 + a23 * b12;\n        a[8] = a00 * b20 + a10 * b21 + a20 * b22;\n        a[9] = a01 * b20 + a11 * b21 + a21 * b22;\n        a[10] = a02 * b20 + a12 * b21 + a22 * b22;\n        a[11] = a03 * b20 + a13 * b21 + a23 * b22;\n\n        return this;\n    },\n\n    /**\n     * Rotate this matrix on its X axis.\n     *\n     * @method Phaser.Math.Matrix4#rotateX\n     * @since 3.0.0\n     *\n     * @param {number} rad - The angle in radians to rotate by.\n     *\n     * @return {Phaser.Math.Matrix4} This Matrix4.\n     */\n    rotateX: function (rad)\n    {\n        var a = this.val;\n        var s = Math.sin(rad);\n        var c = Math.cos(rad);\n\n        var a10 = a[4];\n        var a11 = a[5];\n        var a12 = a[6];\n        var a13 = a[7];\n\n        var a20 = a[8];\n        var a21 = a[9];\n        var a22 = a[10];\n        var a23 = a[11];\n\n        // Perform axis-specific matrix multiplication\n        a[4] = a10 * c + a20 * s;\n        a[5] = a11 * c + a21 * s;\n        a[6] = a12 * c + a22 * s;\n        a[7] = a13 * c + a23 * s;\n        a[8] = a20 * c - a10 * s;\n        a[9] = a21 * c - a11 * s;\n        a[10] = a22 * c - a12 * s;\n        a[11] = a23 * c - a13 * s;\n\n        return this;\n    },\n\n    /**\n     * Rotate this matrix on its Y axis.\n     *\n     * @method Phaser.Math.Matrix4#rotateY\n     * @since 3.0.0\n     *\n     * @param {number} rad - The angle to rotate by, in radians.\n     *\n     * @return {Phaser.Math.Matrix4} This Matrix4.\n     */\n    rotateY: function (rad)\n    {\n        var a = this.val;\n        var s = Math.sin(rad);\n        var c = Math.cos(rad);\n\n        var a00 = a[0];\n        var a01 = a[1];\n        var a02 = a[2];\n        var a03 = a[3];\n\n        var a20 = a[8];\n        var a21 = a[9];\n        var a22 = a[10];\n        var a23 = a[11];\n\n        // Perform axis-specific matrix multiplication\n        a[0] = a00 * c - a20 * s;\n        a[1] = a01 * c - a21 * s;\n        a[2] = a02 * c - a22 * s;\n        a[3] = a03 * c - a23 * s;\n        a[8] = a00 * s + a20 * c;\n        a[9] = a01 * s + a21 * c;\n        a[10] = a02 * s + a22 * c;\n        a[11] = a03 * s + a23 * c;\n\n        return this;\n    },\n\n    /**\n     * Rotate this matrix on its Z axis.\n     *\n     * @method Phaser.Math.Matrix4#rotateZ\n     * @since 3.0.0\n     *\n     * @param {number} rad - The angle to rotate by, in radians.\n     *\n     * @return {Phaser.Math.Matrix4} This Matrix4.\n     */\n    rotateZ: function (rad)\n    {\n        var a = this.val;\n        var s = Math.sin(rad);\n        var c = Math.cos(rad);\n\n        var a00 = a[0];\n        var a01 = a[1];\n        var a02 = a[2];\n        var a03 = a[3];\n\n        var a10 = a[4];\n        var a11 = a[5];\n        var a12 = a[6];\n        var a13 = a[7];\n\n        // Perform axis-specific matrix multiplication\n        a[0] = a00 * c + a10 * s;\n        a[1] = a01 * c + a11 * s;\n        a[2] = a02 * c + a12 * s;\n        a[3] = a03 * c + a13 * s;\n        a[4] = a10 * c - a00 * s;\n        a[5] = a11 * c - a01 * s;\n        a[6] = a12 * c - a02 * s;\n        a[7] = a13 * c - a03 * s;\n\n        return this;\n    },\n\n    /**\n     * Set the values of this Matrix from the given rotation Quaternion and translation Vector.\n     *\n     * @method Phaser.Math.Matrix4#fromRotationTranslation\n     * @since 3.0.0\n     *\n     * @param {Phaser.Math.Quaternion} q - The Quaternion to set rotation from.\n     * @param {Phaser.Math.Vector3} v - The Vector to set translation from.\n     *\n     * @return {Phaser.Math.Matrix4} This Matrix4.\n     */\n    fromRotationTranslation: function (q, v)\n    {\n        // Quaternion math\n        var out = this.val;\n\n        var x = q.x;\n        var y = q.y;\n        var z = q.z;\n        var w = q.w;\n\n        var x2 = x + x;\n        var y2 = y + y;\n        var z2 = z + z;\n\n        var xx = x * x2;\n        var xy = x * y2;\n        var xz = x * z2;\n\n        var yy = y * y2;\n        var yz = y * z2;\n        var zz = z * z2;\n\n        var wx = w * x2;\n        var wy = w * y2;\n        var wz = w * z2;\n\n        out[0] = 1 - (yy + zz);\n        out[1] = xy + wz;\n        out[2] = xz - wy;\n        out[3] = 0;\n\n        out[4] = xy - wz;\n        out[5] = 1 - (xx + zz);\n        out[6] = yz + wx;\n        out[7] = 0;\n\n        out[8] = xz + wy;\n        out[9] = yz - wx;\n        out[10] = 1 - (xx + yy);\n        out[11] = 0;\n\n        out[12] = v.x;\n        out[13] = v.y;\n        out[14] = v.z;\n        out[15] = 1;\n\n        return this;\n    },\n\n    /**\n     * Set the values of this Matrix from the given Quaternion.\n     *\n     * @method Phaser.Math.Matrix4#fromQuat\n     * @since 3.0.0\n     *\n     * @param {Phaser.Math.Quaternion} q - The Quaternion to set the values of this Matrix from.\n     *\n     * @return {Phaser.Math.Matrix4} This Matrix4.\n     */\n    fromQuat: function (q)\n    {\n        var out = this.val;\n\n        var x = q.x;\n        var y = q.y;\n        var z = q.z;\n        var w = q.w;\n\n        var x2 = x + x;\n        var y2 = y + y;\n        var z2 = z + z;\n\n        var xx = x * x2;\n        var xy = x * y2;\n        var xz = x * z2;\n\n        var yy = y * y2;\n        var yz = y * z2;\n        var zz = z * z2;\n\n        var wx = w * x2;\n        var wy = w * y2;\n        var wz = w * z2;\n\n        out[0] = 1 - (yy + zz);\n        out[1] = xy + wz;\n        out[2] = xz - wy;\n        out[3] = 0;\n\n        out[4] = xy - wz;\n        out[5] = 1 - (xx + zz);\n        out[6] = yz + wx;\n        out[7] = 0;\n\n        out[8] = xz + wy;\n        out[9] = yz - wx;\n        out[10] = 1 - (xx + yy);\n        out[11] = 0;\n\n        out[12] = 0;\n        out[13] = 0;\n        out[14] = 0;\n        out[15] = 1;\n\n        return this;\n    },\n\n    /**\n     * Generate a frustum matrix with the given bounds.\n     *\n     * @method Phaser.Math.Matrix4#frustum\n     * @since 3.0.0\n     *\n     * @param {number} left - The left bound of the frustum.\n     * @param {number} right - The right bound of the frustum.\n     * @param {number} bottom - The bottom bound of the frustum.\n     * @param {number} top - The top bound of the frustum.\n     * @param {number} near - The near bound of the frustum.\n     * @param {number} far - The far bound of the frustum.\n     *\n     * @return {Phaser.Math.Matrix4} This Matrix4.\n     */\n    frustum: function (left, right, bottom, top, near, far)\n    {\n        var out = this.val;\n\n        var rl = 1 / (right - left);\n        var tb = 1 / (top - bottom);\n        var nf = 1 / (near - far);\n\n        out[0] = (near * 2) * rl;\n        out[1] = 0;\n        out[2] = 0;\n        out[3] = 0;\n\n        out[4] = 0;\n        out[5] = (near * 2) * tb;\n        out[6] = 0;\n        out[7] = 0;\n\n        out[8] = (right + left) * rl;\n        out[9] = (top + bottom) * tb;\n        out[10] = (far + near) * nf;\n        out[11] = -1;\n\n        out[12] = 0;\n        out[13] = 0;\n        out[14] = (far * near * 2) * nf;\n        out[15] = 0;\n\n        return this;\n    },\n\n    /**\n     * Generate a perspective projection matrix with the given bounds.\n     *\n     * @method Phaser.Math.Matrix4#perspective\n     * @since 3.0.0\n     *\n     * @param {number} fovy - Vertical field of view in radians\n     * @param {number} aspect - Aspect ratio. Typically viewport width  /height.\n     * @param {number} near - Near bound of the frustum.\n     * @param {number} far - Far bound of the frustum.\n     *\n     * @return {Phaser.Math.Matrix4} This Matrix4.\n     */\n    perspective: function (fovy, aspect, near, far)\n    {\n        var out = this.val;\n        var f = 1.0 / Math.tan(fovy / 2);\n        var nf = 1 / (near - far);\n\n        out[0] = f / aspect;\n        out[1] = 0;\n        out[2] = 0;\n        out[3] = 0;\n\n        out[4] = 0;\n        out[5] = f;\n        out[6] = 0;\n        out[7] = 0;\n\n        out[8] = 0;\n        out[9] = 0;\n        out[10] = (far + near) * nf;\n        out[11] = -1;\n\n        out[12] = 0;\n        out[13] = 0;\n        out[14] = (2 * far * near) * nf;\n        out[15] = 0;\n\n        return this;\n    },\n\n    /**\n     * Generate a perspective projection matrix with the given bounds.\n     *\n     * @method Phaser.Math.Matrix4#perspectiveLH\n     * @since 3.0.0\n     *\n     * @param {number} width - The width of the frustum.\n     * @param {number} height - The height of the frustum.\n     * @param {number} near - Near bound of the frustum.\n     * @param {number} far - Far bound of the frustum.\n     *\n     * @return {Phaser.Math.Matrix4} This Matrix4.\n     */\n    perspectiveLH: function (width, height, near, far)\n    {\n        var out = this.val;\n\n        out[0] = (2 * near) / width;\n        out[1] = 0;\n        out[2] = 0;\n        out[3] = 0;\n\n        out[4] = 0;\n        out[5] = (2 * near) / height;\n        out[6] = 0;\n        out[7] = 0;\n\n        out[8] = 0;\n        out[9] = 0;\n        out[10] = -far / (near - far);\n        out[11] = 1;\n\n        out[12] = 0;\n        out[13] = 0;\n        out[14] = (near * far) / (near - far);\n        out[15] = 0;\n\n        return this;\n    },\n\n    /**\n     * Generate an orthogonal projection matrix with the given bounds.\n     *\n     * @method Phaser.Math.Matrix4#ortho\n     * @since 3.0.0\n     *\n     * @param {number} left - The left bound of the frustum.\n     * @param {number} right - The right bound of the frustum.\n     * @param {number} bottom - The bottom bound of the frustum.\n     * @param {number} top - The top bound of the frustum.\n     * @param {number} near - The near bound of the frustum.\n     * @param {number} far - The far bound of the frustum.\n     *\n     * @return {Phaser.Math.Matrix4} This Matrix4.\n     */\n    ortho: function (left, right, bottom, top, near, far)\n    {\n        var out = this.val;\n        var lr = left - right;\n        var bt = bottom - top;\n        var nf = near - far;\n\n        //  Avoid division by zero\n        lr = (lr === 0) ? lr : 1 / lr;\n        bt = (bt === 0) ? bt : 1 / bt;\n        nf = (nf === 0) ? nf : 1 / nf;\n\n        out[0] = -2 * lr;\n        out[1] = 0;\n        out[2] = 0;\n        out[3] = 0;\n\n        out[4] = 0;\n        out[5] = -2 * bt;\n        out[6] = 0;\n        out[7] = 0;\n\n        out[8] = 0;\n        out[9] = 0;\n        out[10] = 2 * nf;\n        out[11] = 0;\n\n        out[12] = (left + right) * lr;\n        out[13] = (top + bottom) * bt;\n        out[14] = (far + near) * nf;\n        out[15] = 1;\n\n        return this;\n    },\n\n    /**\n     * Generate a look-at matrix with the given eye position, focal point, and up axis.\n     *\n     * @method Phaser.Math.Matrix4#lookAt\n     * @since 3.0.0\n     *\n     * @param {Phaser.Math.Vector3} eye - Position of the viewer\n     * @param {Phaser.Math.Vector3} center - Point the viewer is looking at\n     * @param {Phaser.Math.Vector3} up - vec3 pointing up.\n     *\n     * @return {Phaser.Math.Matrix4} This Matrix4.\n     */\n    lookAt: function (eye, center, up)\n    {\n        var out = this.val;\n\n        var eyex = eye.x;\n        var eyey = eye.y;\n        var eyez = eye.z;\n\n        var upx = up.x;\n        var upy = up.y;\n        var upz = up.z;\n\n        var centerx = center.x;\n        var centery = center.y;\n        var centerz = center.z;\n\n        if (Math.abs(eyex - centerx) < EPSILON &&\n            Math.abs(eyey - centery) < EPSILON &&\n            Math.abs(eyez - centerz) < EPSILON)\n        {\n            return this.identity();\n        }\n\n        var z0 = eyex - centerx;\n        var z1 = eyey - centery;\n        var z2 = eyez - centerz;\n\n        var len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);\n\n        z0 *= len;\n        z1 *= len;\n        z2 *= len;\n\n        var x0 = upy * z2 - upz * z1;\n        var x1 = upz * z0 - upx * z2;\n        var x2 = upx * z1 - upy * z0;\n\n        len = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);\n\n        if (!len)\n        {\n            x0 = 0;\n            x1 = 0;\n            x2 = 0;\n        }\n        else\n        {\n            len = 1 / len;\n            x0 *= len;\n            x1 *= len;\n            x2 *= len;\n        }\n\n        var y0 = z1 * x2 - z2 * x1;\n        var y1 = z2 * x0 - z0 * x2;\n        var y2 = z0 * x1 - z1 * x0;\n\n        len = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);\n\n        if (!len)\n        {\n            y0 = 0;\n            y1 = 0;\n            y2 = 0;\n        }\n        else\n        {\n            len = 1 / len;\n            y0 *= len;\n            y1 *= len;\n            y2 *= len;\n        }\n\n        out[0] = x0;\n        out[1] = y0;\n        out[2] = z0;\n        out[3] = 0;\n\n        out[4] = x1;\n        out[5] = y1;\n        out[6] = z1;\n        out[7] = 0;\n\n        out[8] = x2;\n        out[9] = y2;\n        out[10] = z2;\n        out[11] = 0;\n\n        out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);\n        out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);\n        out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);\n        out[15] = 1;\n\n        return this;\n    },\n\n    /**\n     * Set the values of this matrix from the given `yaw`, `pitch` and `roll` values.\n     *\n     * @method Phaser.Math.Matrix4#yawPitchRoll\n     * @since 3.0.0\n     *\n     * @param {number} yaw - [description]\n     * @param {number} pitch - [description]\n     * @param {number} roll - [description]\n     *\n     * @return {Phaser.Math.Matrix4} This Matrix4.\n     */\n    yawPitchRoll: function (yaw, pitch, roll)\n    {\n        this.zero();\n        _tempMat1.zero();\n        _tempMat2.zero();\n\n        var m0 = this.val;\n        var m1 = _tempMat1.val;\n        var m2 = _tempMat2.val;\n\n        //  Rotate Z\n        var s = Math.sin(roll);\n        var c = Math.cos(roll);\n\n        m0[10] = 1;\n        m0[15] = 1;\n        m0[0] = c;\n        m0[1] = s;\n        m0[4] = -s;\n        m0[5] = c;\n\n        //  Rotate X\n        s = Math.sin(pitch);\n        c = Math.cos(pitch);\n\n        m1[0] = 1;\n        m1[15] = 1;\n        m1[5] = c;\n        m1[10] = c;\n        m1[9] = -s;\n        m1[6] = s;\n\n        //  Rotate Y\n        s = Math.sin(yaw);\n        c = Math.cos(yaw);\n\n        m2[5] = 1;\n        m2[15] = 1;\n        m2[0] = c;\n        m2[2] = -s;\n        m2[8] = s;\n        m2[10] = c;\n\n        this.multiplyLocal(_tempMat1);\n        this.multiplyLocal(_tempMat2);\n\n        return this;\n    },\n\n    /**\n     * Generate a world matrix from the given rotation, position, scale, view matrix and projection matrix.\n     *\n     * @method Phaser.Math.Matrix4#setWorldMatrix\n     * @since 3.0.0\n     *\n     * @param {Phaser.Math.Vector3} rotation - The rotation of the world matrix.\n     * @param {Phaser.Math.Vector3} position - The position of the world matrix.\n     * @param {Phaser.Math.Vector3} scale - The scale of the world matrix.\n     * @param {Phaser.Math.Matrix4} [viewMatrix] - The view matrix.\n     * @param {Phaser.Math.Matrix4} [projectionMatrix] - The projection matrix.\n     *\n     * @return {Phaser.Math.Matrix4} This Matrix4.\n     */\n    setWorldMatrix: function (rotation, position, scale, viewMatrix, projectionMatrix)\n    {\n        this.yawPitchRoll(rotation.y, rotation.x, rotation.z);\n\n        _tempMat1.scaling(scale.x, scale.y, scale.z);\n        _tempMat2.xyz(position.x, position.y, position.z);\n\n        this.multiplyLocal(_tempMat1);\n        this.multiplyLocal(_tempMat2);\n\n        if (viewMatrix !== undefined)\n        {\n            this.multiplyLocal(viewMatrix);\n        }\n\n        if (projectionMatrix !== undefined)\n        {\n            this.multiplyLocal(projectionMatrix);\n        }\n\n        return this;\n    }\n\n});\n\nvar _tempMat1 = new Matrix4();\nvar _tempMat2 = new Matrix4();\n\nmodule.exports = Matrix4;\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * Add an `amount` to a `value`, limiting the maximum result to `max`.\n *\n * @function Phaser.Math.MaxAdd\n * @since 3.0.0\n *\n * @param {number} value - The value to add to.\n * @param {number} amount - The amount to add.\n * @param {number} max - The maximum value to return.\n *\n * @return {number} The resulting value.\n */\nvar MaxAdd = function (value, amount, max)\n{\n    return Math.min(value + amount, max);\n};\n\nmodule.exports = MaxAdd;\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * Subtract an `amount` from `value`, limiting the minimum result to `min`.\n *\n * @function Phaser.Math.MinSub\n * @since 3.0.0\n *\n * @param {number} value - The value to subtract from.\n * @param {number} amount - The amount to subtract.\n * @param {number} min - The minimum value to return.\n *\n * @return {number} The resulting value.\n */\nvar MinSub = function (value, amount, min)\n{\n    return Math.max(value - amount, min);\n};\n\nmodule.exports = MinSub;\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * Work out what percentage `value` is of the range between `min` and `max`.\n * If `max` isn't given then it will return the percentage of `value` to `min`.\n *\n * You can optionally specify an `upperMax` value, which is a mid-way point in the range that represents 100%, after which the % starts to go down to zero again.\n *\n * @function Phaser.Math.Percent\n * @since 3.0.0\n *\n * @param {number} value - The value to determine the percentage of.\n * @param {number} min - The minimum value.\n * @param {number} [max] - The maximum value.\n * @param {number} [upperMax] - The mid-way point in the range that represents 100%.\n *\n * @return {number} A value between 0 and 1 representing the percentage.\n */\nvar Percent = function (value, min, max, upperMax)\n{\n    if (max === undefined) { max = min + 1; }\n\n    var percentage = (value - min) / (max - min);\n\n    if (percentage > 1)\n    {\n        if (upperMax !== undefined)\n        {\n            percentage = ((upperMax - value)) / (upperMax - max);\n\n            if (percentage < 0)\n            {\n                percentage = 0;\n            }\n        }\n        else\n        {\n            percentage = 1;\n        }\n    }\n    else if (percentage < 0)\n    {\n        percentage = 0;\n    }\n\n    return percentage;\n};\n\nmodule.exports = Percent;\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n//  Adapted from [gl-matrix](https://github.com/toji/gl-matrix) by toji\n//  and [vecmath](https://github.com/mattdesl/vecmath) by mattdesl\n\nvar Class = require('../utils/Class');\nvar Vector3 = require('./Vector3');\nvar Matrix3 = require('./Matrix3');\n\nvar EPSILON = 0.000001;\n\n//  Some shared 'private' arrays\nvar siNext = new Int8Array([ 1, 2, 0 ]);\nvar tmp = new Float32Array([ 0, 0, 0 ]);\n\nvar xUnitVec3 = new Vector3(1, 0, 0);\nvar yUnitVec3 = new Vector3(0, 1, 0);\n\nvar tmpvec = new Vector3();\nvar tmpMat3 = new Matrix3();\n\n/**\n * @classdesc\n * A quaternion.\n *\n * @class Quaternion\n * @memberof Phaser.Math\n * @constructor\n * @since 3.0.0\n *\n * @param {number} [x] - The x component.\n * @param {number} [y] - The y component.\n * @param {number} [z] - The z component.\n * @param {number} [w] - The w component.\n */\nvar Quaternion = new Class({\n\n    initialize:\n\n    function Quaternion (x, y, z, w)\n    {\n        /**\n         * The x component of this Quaternion.\n         *\n         * @name Phaser.Math.Quaternion#x\n         * @type {number}\n         * @default 0\n         * @since 3.0.0\n         */\n\n        /**\n         * The y component of this Quaternion.\n         *\n         * @name Phaser.Math.Quaternion#y\n         * @type {number}\n         * @default 0\n         * @since 3.0.0\n         */\n\n        /**\n         * The z component of this Quaternion.\n         *\n         * @name Phaser.Math.Quaternion#z\n         * @type {number}\n         * @default 0\n         * @since 3.0.0\n         */\n\n        /**\n         * The w component of this Quaternion.\n         *\n         * @name Phaser.Math.Quaternion#w\n         * @type {number}\n         * @default 0\n         * @since 3.0.0\n         */\n\n        if (typeof x === 'object')\n        {\n            this.x = x.x || 0;\n            this.y = x.y || 0;\n            this.z = x.z || 0;\n            this.w = x.w || 0;\n        }\n        else\n        {\n            this.x = x || 0;\n            this.y = y || 0;\n            this.z = z || 0;\n            this.w = w || 0;\n        }\n    },\n\n    /**\n     * Copy the components of a given Quaternion or Vector into this Quaternion.\n     *\n     * @method Phaser.Math.Quaternion#copy\n     * @since 3.0.0\n     *\n     * @param {(Phaser.Math.Quaternion|Phaser.Math.Vector4)} src - The Quaternion or Vector to copy the components from.\n     *\n     * @return {Phaser.Math.Quaternion} This Quaternion.\n     */\n    copy: function (src)\n    {\n        this.x = src.x;\n        this.y = src.y;\n        this.z = src.z;\n        this.w = src.w;\n\n        return this;\n    },\n\n    /**\n     * Set the components of this Quaternion.\n     *\n     * @method Phaser.Math.Quaternion#set\n     * @since 3.0.0\n     *\n     * @param {(number|object)} [x=0] - The x component, or an object containing x, y, z, and w components.\n     * @param {number} [y=0] - The y component.\n     * @param {number} [z=0] - The z component.\n     * @param {number} [w=0] - The w component.\n     *\n     * @return {Phaser.Math.Quaternion} This Quaternion.\n     */\n    set: function (x, y, z, w)\n    {\n        if (typeof x === 'object')\n        {\n            this.x = x.x || 0;\n            this.y = x.y || 0;\n            this.z = x.z || 0;\n            this.w = x.w || 0;\n        }\n        else\n        {\n            this.x = x || 0;\n            this.y = y || 0;\n            this.z = z || 0;\n            this.w = w || 0;\n        }\n\n        return this;\n    },\n\n    /**\n     * Add a given Quaternion or Vector to this Quaternion. Addition is component-wise.\n     *\n     * @method Phaser.Math.Quaternion#add\n     * @since 3.0.0\n     *\n     * @param {(Phaser.Math.Quaternion|Phaser.Math.Vector4)} v - The Quaternion or Vector to add to this Quaternion.\n     *\n     * @return {Phaser.Math.Quaternion} This Quaternion.\n     */\n    add: function (v)\n    {\n        this.x += v.x;\n        this.y += v.y;\n        this.z += v.z;\n        this.w += v.w;\n\n        return this;\n    },\n\n    /**\n     * Subtract a given Quaternion or Vector from this Quaternion. Subtraction is component-wise.\n     *\n     * @method Phaser.Math.Quaternion#subtract\n     * @since 3.0.0\n     *\n     * @param {(Phaser.Math.Quaternion|Phaser.Math.Vector4)} v - The Quaternion or Vector to subtract from this Quaternion.\n     *\n     * @return {Phaser.Math.Quaternion} This Quaternion.\n     */\n    subtract: function (v)\n    {\n        this.x -= v.x;\n        this.y -= v.y;\n        this.z -= v.z;\n        this.w -= v.w;\n\n        return this;\n    },\n\n    /**\n     * Scale this Quaternion by the given value.\n     *\n     * @method Phaser.Math.Quaternion#scale\n     * @since 3.0.0\n     *\n     * @param {number} scale - The value to scale this Quaternion by.\n     *\n     * @return {Phaser.Math.Quaternion} This Quaternion.\n     */\n    scale: function (scale)\n    {\n        this.x *= scale;\n        this.y *= scale;\n        this.z *= scale;\n        this.w *= scale;\n\n        return this;\n    },\n\n    /**\n     * Calculate the length of this Quaternion.\n     *\n     * @method Phaser.Math.Quaternion#length\n     * @since 3.0.0\n     *\n     * @return {number} The length of this Quaternion.\n     */\n    length: function ()\n    {\n        var x = this.x;\n        var y = this.y;\n        var z = this.z;\n        var w = this.w;\n\n        return Math.sqrt(x * x + y * y + z * z + w * w);\n    },\n\n    /**\n     * Calculate the length of this Quaternion squared.\n     *\n     * @method Phaser.Math.Quaternion#lengthSq\n     * @since 3.0.0\n     *\n     * @return {number} The length of this Quaternion, squared.\n     */\n    lengthSq: function ()\n    {\n        var x = this.x;\n        var y = this.y;\n        var z = this.z;\n        var w = this.w;\n\n        return x * x + y * y + z * z + w * w;\n    },\n\n    /**\n     * Normalize this Quaternion.\n     *\n     * @method Phaser.Math.Quaternion#normalize\n     * @since 3.0.0\n     *\n     * @return {Phaser.Math.Quaternion} This Quaternion.\n     */\n    normalize: function ()\n    {\n        var x = this.x;\n        var y = this.y;\n        var z = this.z;\n        var w = this.w;\n        var len = x * x + y * y + z * z + w * w;\n\n        if (len > 0)\n        {\n            len = 1 / Math.sqrt(len);\n\n            this.x = x * len;\n            this.y = y * len;\n            this.z = z * len;\n            this.w = w * len;\n        }\n\n        return this;\n    },\n\n    /**\n     * Calculate the dot product of this Quaternion and the given Quaternion or Vector.\n     *\n     * @method Phaser.Math.Quaternion#dot\n     * @since 3.0.0\n     *\n     * @param {(Phaser.Math.Quaternion|Phaser.Math.Vector4)} v - The Quaternion or Vector to dot product with this Quaternion.\n     *\n     * @return {number} The dot product of this Quaternion and the given Quaternion or Vector.\n     */\n    dot: function (v)\n    {\n        return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;\n    },\n\n    /**\n     * Linearly interpolate this Quaternion towards the given Quaternion or Vector.\n     *\n     * @method Phaser.Math.Quaternion#lerp\n     * @since 3.0.0\n     *\n     * @param {(Phaser.Math.Quaternion|Phaser.Math.Vector4)} v - The Quaternion or Vector to interpolate towards.\n     * @param {number} [t=0] - The percentage of interpolation.\n     *\n     * @return {Phaser.Math.Quaternion} This Quaternion.\n     */\n    lerp: function (v, t)\n    {\n        if (t === undefined) { t = 0; }\n\n        var ax = this.x;\n        var ay = this.y;\n        var az = this.z;\n        var aw = this.w;\n\n        this.x = ax + t * (v.x - ax);\n        this.y = ay + t * (v.y - ay);\n        this.z = az + t * (v.z - az);\n        this.w = aw + t * (v.w - aw);\n\n        return this;\n    },\n\n    /**\n     * [description]\n     *\n     * @method Phaser.Math.Quaternion#rotationTo\n     * @since 3.0.0\n     *\n     * @param {Phaser.Math.Vector3} a - [description]\n     * @param {Phaser.Math.Vector3} b - [description]\n     *\n     * @return {Phaser.Math.Quaternion} This Quaternion.\n     */\n    rotationTo: function (a, b)\n    {\n        var dot = a.x * b.x + a.y * b.y + a.z * b.z;\n\n        if (dot < -0.999999)\n        {\n            if (tmpvec.copy(xUnitVec3).cross(a).length() < EPSILON)\n            {\n                tmpvec.copy(yUnitVec3).cross(a);\n            }\n\n            tmpvec.normalize();\n\n            return this.setAxisAngle(tmpvec, Math.PI);\n\n        }\n        else if (dot > 0.999999)\n        {\n            this.x = 0;\n            this.y = 0;\n            this.z = 0;\n            this.w = 1;\n\n            return this;\n        }\n        else\n        {\n            tmpvec.copy(a).cross(b);\n\n            this.x = tmpvec.x;\n            this.y = tmpvec.y;\n            this.z = tmpvec.z;\n            this.w = 1 + dot;\n\n            return this.normalize();\n        }\n    },\n\n    /**\n     * Set the axes of this Quaternion.\n     *\n     * @method Phaser.Math.Quaternion#setAxes\n     * @since 3.0.0\n     *\n     * @param {Phaser.Math.Vector3} view - The view axis.\n     * @param {Phaser.Math.Vector3} right - The right axis.\n     * @param {Phaser.Math.Vector3} up - The upwards axis.\n     *\n     * @return {Phaser.Math.Quaternion} This Quaternion.\n     */\n    setAxes: function (view, right, up)\n    {\n        var m = tmpMat3.val;\n\n        m[0] = right.x;\n        m[3] = right.y;\n        m[6] = right.z;\n\n        m[1] = up.x;\n        m[4] = up.y;\n        m[7] = up.z;\n\n        m[2] = -view.x;\n        m[5] = -view.y;\n        m[8] = -view.z;\n\n        return this.fromMat3(tmpMat3).normalize();\n    },\n\n    /**\n     * Reset this Matrix to an identity (default) Quaternion.\n     *\n     * @method Phaser.Math.Quaternion#identity\n     * @since 3.0.0\n     *\n     * @return {Phaser.Math.Quaternion} This Quaternion.\n     */\n    identity: function ()\n    {\n        this.x = 0;\n        this.y = 0;\n        this.z = 0;\n        this.w = 1;\n\n        return this;\n    },\n\n    /**\n     * Set the axis angle of this Quaternion.\n     *\n     * @method Phaser.Math.Quaternion#setAxisAngle\n     * @since 3.0.0\n     *\n     * @param {Phaser.Math.Vector3} axis - The axis.\n     * @param {number} rad - The angle in radians.\n     *\n     * @return {Phaser.Math.Quaternion} This Quaternion.\n     */\n    setAxisAngle: function (axis, rad)\n    {\n        rad = rad * 0.5;\n\n        var s = Math.sin(rad);\n\n        this.x = s * axis.x;\n        this.y = s * axis.y;\n        this.z = s * axis.z;\n        this.w = Math.cos(rad);\n\n        return this;\n    },\n\n    /**\n     * Multiply this Quaternion by the given Quaternion or Vector.\n     *\n     * @method Phaser.Math.Quaternion#multiply\n     * @since 3.0.0\n     *\n     * @param {(Phaser.Math.Quaternion|Phaser.Math.Vector4)} b - The Quaternion or Vector to multiply this Quaternion by.\n     *\n     * @return {Phaser.Math.Quaternion} This Quaternion.\n     */\n    multiply: function (b)\n    {\n        var ax = this.x;\n        var ay = this.y;\n        var az = this.z;\n        var aw = this.w;\n\n        var bx = b.x;\n        var by = b.y;\n        var bz = b.z;\n        var bw = b.w;\n\n        this.x = ax * bw + aw * bx + ay * bz - az * by;\n        this.y = ay * bw + aw * by + az * bx - ax * bz;\n        this.z = az * bw + aw * bz + ax * by - ay * bx;\n        this.w = aw * bw - ax * bx - ay * by - az * bz;\n\n        return this;\n    },\n\n    /**\n     * Smoothly linearly interpolate this Quaternion towards the given Quaternion or Vector.\n     *\n     * @method Phaser.Math.Quaternion#slerp\n     * @since 3.0.0\n     *\n     * @param {(Phaser.Math.Quaternion|Phaser.Math.Vector4)} b - The Quaternion or Vector to interpolate towards.\n     * @param {number} t - The percentage of interpolation.\n     *\n     * @return {Phaser.Math.Quaternion} This Quaternion.\n     */\n    slerp: function (b, t)\n    {\n        // benchmarks: http://jsperf.com/quaternion-slerp-implementations\n\n        var ax = this.x;\n        var ay = this.y;\n        var az = this.z;\n        var aw = this.w;\n\n        var bx = b.x;\n        var by = b.y;\n        var bz = b.z;\n        var bw = b.w;\n\n        // calc cosine\n        var cosom = ax * bx + ay * by + az * bz + aw * bw;\n\n        // adjust signs (if necessary)\n        if (cosom < 0)\n        {\n            cosom = -cosom;\n            bx = - bx;\n            by = - by;\n            bz = - bz;\n            bw = - bw;\n        }\n\n        // \"from\" and \"to\" quaternions are very close\n        //  ... so we can do a linear interpolation\n        var scale0 = 1 - t;\n        var scale1 = t;\n\n        // calculate coefficients\n        if ((1 - cosom) > EPSILON)\n        {\n            // standard case (slerp)\n            var omega = Math.acos(cosom);\n            var sinom = Math.sin(omega);\n\n            scale0 = Math.sin((1.0 - t) * omega) / sinom;\n            scale1 = Math.sin(t * omega) / sinom;\n        }\n\n        // calculate final values\n        this.x = scale0 * ax + scale1 * bx;\n        this.y = scale0 * ay + scale1 * by;\n        this.z = scale0 * az + scale1 * bz;\n        this.w = scale0 * aw + scale1 * bw;\n\n        return this;\n    },\n\n    /**\n     * Invert this Quaternion.\n     *\n     * @method Phaser.Math.Quaternion#invert\n     * @since 3.0.0\n     *\n     * @return {Phaser.Math.Quaternion} This Quaternion.\n     */\n    invert: function ()\n    {\n        var a0 = this.x;\n        var a1 = this.y;\n        var a2 = this.z;\n        var a3 = this.w;\n\n        var dot = a0 * a0 + a1 * a1 + a2 * a2 + a3 * a3;\n        var invDot = (dot) ? 1 / dot : 0;\n\n        // TODO: Would be faster to return [0,0,0,0] immediately if dot == 0\n\n        this.x = -a0 * invDot;\n        this.y = -a1 * invDot;\n        this.z = -a2 * invDot;\n        this.w = a3 * invDot;\n\n        return this;\n    },\n\n    /**\n     * Convert this Quaternion into its conjugate.\n     *\n     * Sets the x, y and z components.\n     *\n     * @method Phaser.Math.Quaternion#conjugate\n     * @since 3.0.0\n     *\n     * @return {Phaser.Math.Quaternion} This Quaternion.\n     */\n    conjugate: function ()\n    {\n        this.x = -this.x;\n        this.y = -this.y;\n        this.z = -this.z;\n\n        return this;\n    },\n\n    /**\n     * Rotate this Quaternion on the X axis.\n     *\n     * @method Phaser.Math.Quaternion#rotateX\n     * @since 3.0.0\n     *\n     * @param {number} rad - The rotation angle in radians.\n     *\n     * @return {Phaser.Math.Quaternion} This Quaternion.\n     */\n    rotateX: function (rad)\n    {\n        rad *= 0.5;\n\n        var ax = this.x;\n        var ay = this.y;\n        var az = this.z;\n        var aw = this.w;\n\n        var bx = Math.sin(rad);\n        var bw = Math.cos(rad);\n\n        this.x = ax * bw + aw * bx;\n        this.y = ay * bw + az * bx;\n        this.z = az * bw - ay * bx;\n        this.w = aw * bw - ax * bx;\n\n        return this;\n    },\n\n    /**\n     * Rotate this Quaternion on the Y axis.\n     *\n     * @method Phaser.Math.Quaternion#rotateY\n     * @since 3.0.0\n     *\n     * @param {number} rad - The rotation angle in radians.\n     *\n     * @return {Phaser.Math.Quaternion} This Quaternion.\n     */\n    rotateY: function (rad)\n    {\n        rad *= 0.5;\n\n        var ax = this.x;\n        var ay = this.y;\n        var az = this.z;\n        var aw = this.w;\n\n        var by = Math.sin(rad);\n        var bw = Math.cos(rad);\n\n        this.x = ax * bw - az * by;\n        this.y = ay * bw + aw * by;\n        this.z = az * bw + ax * by;\n        this.w = aw * bw - ay * by;\n\n        return this;\n    },\n\n    /**\n     * Rotate this Quaternion on the Z axis.\n     *\n     * @method Phaser.Math.Quaternion#rotateZ\n     * @since 3.0.0\n     *\n     * @param {number} rad - The rotation angle in radians.\n     *\n     * @return {Phaser.Math.Quaternion} This Quaternion.\n     */\n    rotateZ: function (rad)\n    {\n        rad *= 0.5;\n\n        var ax = this.x;\n        var ay = this.y;\n        var az = this.z;\n        var aw = this.w;\n\n        var bz = Math.sin(rad);\n        var bw = Math.cos(rad);\n\n        this.x = ax * bw + ay * bz;\n        this.y = ay * bw - ax * bz;\n        this.z = az * bw + aw * bz;\n        this.w = aw * bw - az * bz;\n\n        return this;\n    },\n\n    /**\n     * Create a unit (or rotation) Quaternion from its x, y, and z components.\n     *\n     * Sets the w component.\n     *\n     * @method Phaser.Math.Quaternion#calculateW\n     * @since 3.0.0\n     *\n     * @return {Phaser.Math.Quaternion} This Quaternion.\n     */\n    calculateW: function ()\n    {\n        var x = this.x;\n        var y = this.y;\n        var z = this.z;\n\n        this.w = -Math.sqrt(1.0 - x * x - y * y - z * z);\n\n        return this;\n    },\n\n    /**\n     * Convert the given Matrix into this Quaternion.\n     *\n     * @method Phaser.Math.Quaternion#fromMat3\n     * @since 3.0.0\n     *\n     * @param {Phaser.Math.Matrix3} mat - The Matrix to convert from.\n     *\n     * @return {Phaser.Math.Quaternion} This Quaternion.\n     */\n    fromMat3: function (mat)\n    {\n        // benchmarks:\n        //    http://jsperf.com/typed-array-access-speed\n        //    http://jsperf.com/conversion-of-3x3-matrix-to-quaternion\n\n        // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes\n        // article \"Quaternion Calculus and Fast Animation\".\n        var m = mat.val;\n        var fTrace = m[0] + m[4] + m[8];\n        var fRoot;\n\n        if (fTrace > 0)\n        {\n            // |w| > 1/2, may as well choose w > 1/2\n            fRoot = Math.sqrt(fTrace + 1.0); // 2w\n\n            this.w = 0.5 * fRoot;\n\n            fRoot = 0.5 / fRoot; // 1/(4w)\n\n            this.x = (m[7] - m[5]) * fRoot;\n            this.y = (m[2] - m[6]) * fRoot;\n            this.z = (m[3] - m[1]) * fRoot;\n        }\n        else\n        {\n            // |w| <= 1/2\n            var i = 0;\n\n            if (m[4] > m[0])\n            {\n                i = 1;\n            }\n\n            if (m[8] > m[i * 3 + i])\n            {\n                i = 2;\n            }\n\n            var j = siNext[i];\n            var k = siNext[j];\n\n            //  This isn't quite as clean without array access\n            fRoot = Math.sqrt(m[i * 3 + i] - m[j * 3 + j] - m[k * 3 + k] + 1);\n            tmp[i] = 0.5 * fRoot;\n\n            fRoot = 0.5 / fRoot;\n\n            tmp[j] = (m[j * 3 + i] + m[i * 3 + j]) * fRoot;\n            tmp[k] = (m[k * 3 + i] + m[i * 3 + k]) * fRoot;\n\n            this.x = tmp[0];\n            this.y = tmp[1];\n            this.z = tmp[2];\n            this.w = (m[k * 3 + j] - m[j * 3 + k]) * fRoot;\n        }\n\n        return this;\n    }\n\n});\n\nmodule.exports = Quaternion;\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\nvar CONST = require('./const');\n\n/**\n * Convert the given angle in radians, to the equivalent angle in degrees.\n *\n * @function Phaser.Math.RadToDeg\n * @since 3.0.0\n *\n * @param {number} radians - The angle in radians to convert ot degrees.\n *\n * @return {integer} The given angle converted to degrees.\n */\nvar RadToDeg = function (radians)\n{\n    return radians * CONST.RAD_TO_DEG;\n};\n\nmodule.exports = RadToDeg;\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * Compute a random unit vector.\n *\n * Computes random values for the given vector between -1 and 1 that can be used to represent a direction.\n *\n * Optionally accepts a scale value to scale the resulting vector by.\n *\n * @function Phaser.Math.RandomXY\n * @since 3.0.0\n *\n * @param {Phaser.Math.Vector2} vector - The Vector to compute random values for.\n * @param {number} [scale=1] - The scale of the random values.\n *\n * @return {Phaser.Math.Vector2} The given Vector.\n */\nvar RandomXY = function (vector, scale)\n{\n    if (scale === undefined) { scale = 1; }\n\n    var r = Math.random() * 2 * Math.PI;\n\n    vector.x = Math.cos(r) * scale;\n    vector.y = Math.sin(r) * scale;\n\n    return vector;\n};\n\nmodule.exports = RandomXY;\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * Compute a random position vector in a spherical area, optionally defined by the given radius.\n *\n * @function Phaser.Math.RandomXYZ\n * @since 3.0.0\n *\n * @param {Phaser.Math.Vector3} vec3 - The Vector to compute random values for.\n * @param {number} [radius=1] - The radius.\n *\n * @return {Phaser.Math.Vector3} The given Vector.\n */\nvar RandomXYZ = function (vec3, radius)\n{\n    if (radius === undefined) { radius = 1; }\n\n    var r = Math.random() * 2 * Math.PI;\n    var z = (Math.random() * 2) - 1;\n    var zScale = Math.sqrt(1 - z * z) * radius;\n\n    vec3.x = Math.cos(r) * zScale;\n    vec3.y = Math.sin(r) * zScale;\n    vec3.z = z * radius;\n\n    return vec3;\n};\n\nmodule.exports = RandomXYZ;\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * Compute a random four-dimensional vector.\n *\n * @function Phaser.Math.RandomXYZW\n * @since 3.0.0\n *\n * @param {Phaser.Math.Vector4} vec4 - The Vector to compute random values for.\n * @param {number} [scale=1] - The scale of the random values.\n *\n * @return {Phaser.Math.Vector4} The given Vector.\n */\nvar RandomXYZW = function (vec4, scale)\n{\n    if (scale === undefined) { scale = 1; }\n\n    // TODO: Not spherical; should fix this for more uniform distribution\n    vec4.x = (Math.random() * 2 - 1) * scale;\n    vec4.y = (Math.random() * 2 - 1) * scale;\n    vec4.z = (Math.random() * 2 - 1) * scale;\n    vec4.w = (Math.random() * 2 - 1) * scale;\n\n    return vec4;\n};\n\nmodule.exports = RandomXYZW;\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * Rotate a given point by a given angle around the origin (0, 0), in an anti-clockwise direction.\n *\n * @function Phaser.Math.Rotate\n * @since 3.0.0\n *\n * @param {(Phaser.Geom.Point|object)} point - The point to be rotated.\n * @param {number} angle - The angle to be rotated by in an anticlockwise direction.\n *\n * @return {Phaser.Geom.Point} The given point, rotated by the given angle in an anticlockwise direction.\n */\nvar Rotate = function (point, angle)\n{\n    var x = point.x;\n    var y = point.y;\n\n    point.x = (x * Math.cos(angle)) - (y * Math.sin(angle));\n    point.y = (x * Math.sin(angle)) + (y * Math.cos(angle));\n\n    return point;\n};\n\nmodule.exports = Rotate;\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * Rotate a `point` around `x` and `y` by the given `angle`.\n *\n * @function Phaser.Math.RotateAround\n * @since 3.0.0\n *\n * @param {(Phaser.Geom.Point|object)} point - The point to be rotated.\n * @param {number} x - The horizontal coordinate to rotate around.\n * @param {number} y - The vertical coordinate to rotate around.\n * @param {number} angle - The angle of rotation in radians.\n *\n * @return {Phaser.Geom.Point} The given point, rotated by the given angle around the given coordinates.\n */\nvar RotateAround = function (point, x, y, angle)\n{\n    var c = Math.cos(angle);\n    var s = Math.sin(angle);\n\n    var tx = point.x - x;\n    var ty = point.y - y;\n\n    point.x = tx * c - ty * s + x;\n    point.y = tx * s + ty * c + y;\n\n    return point;\n};\n\nmodule.exports = RotateAround;\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * Rotate a `point` around `x` and `y` by the given `angle` and `distance`.\n *\n * @function Phaser.Math.RotateAroundDistance\n * @since 3.0.0\n *\n * @param {(Phaser.Geom.Point|object)} point - The point to be rotated.\n * @param {number} x - The horizontal coordinate to rotate around.\n * @param {number} y - The vertical coordinate to rotate around.\n * @param {number} angle - The angle of rotation in radians.\n * @param {number} distance - The distance from (x, y) to place the point at.\n *\n * @return {Phaser.Geom.Point} The given point.\n */\nvar RotateAroundDistance = function (point, x, y, angle, distance)\n{\n    var t = angle + Math.atan2(point.y - y, point.x - x);\n\n    point.x = x + (distance * Math.cos(t));\n    point.y = y + (distance * Math.sin(t));\n\n    return point;\n};\n\nmodule.exports = RotateAroundDistance;\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\nvar Vector3 = require('../math/Vector3');\nvar Matrix4 = require('../math/Matrix4');\nvar Quaternion = require('../math/Quaternion');\n\nvar tmpMat4 = new Matrix4();\nvar tmpQuat = new Quaternion();\nvar tmpVec3 = new Vector3();\n\n/**\n * Rotates a vector in place by axis angle.\n *\n * This is the same as transforming a point by an\n * axis-angle quaternion, but it has higher precision.\n *\n * @function Phaser.Math.RotateVec3\n * @since 3.0.0\n *\n * @param {Phaser.Math.Vector3} vec - The vector to be rotated.\n * @param {Phaser.Math.Vector3} axis - The axis to rotate around.\n * @param {number} radians - The angle of rotation in radians.\n *\n * @return {Phaser.Math.Vector3} The given vector.\n */\nvar RotateVec3 = function (vec, axis, radians)\n{\n    //  Set the quaternion to our axis angle\n    tmpQuat.setAxisAngle(axis, radians);\n\n    //  Create a rotation matrix from the axis angle\n    tmpMat4.fromRotationTranslation(tmpQuat, tmpVec3.set(0, 0, 0));\n\n    //  Multiply our vector by the rotation matrix\n    return vec.transformMat4(tmpMat4);\n};\n\nmodule.exports = RotateVec3;\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * Round a given number so it is further away from zero. That is, positive numbers are rounded up, and negative numbers are rounded down.\n *\n * @function Phaser.Math.RoundAwayFromZero\n * @since 3.0.0\n *\n * @param {number} value - The number to round.\n *\n * @return {number} The rounded number, rounded away from zero.\n */\nvar RoundAwayFromZero = function (value)\n{\n    // \"Opposite\" of truncate.\n    return (value > 0) ? Math.ceil(value) : Math.floor(value);\n};\n\nmodule.exports = RoundAwayFromZero;\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * Round a value to the given precision.\n * \n * For example:\n * \n * ```javascript\n * RoundTo(123.456, 0) = 123\n * RoundTo(123.456, 1) = 120\n * RoundTo(123.456, 2) = 100\n * ```\n * \n * To round the decimal, i.e. to round to precision, pass in a negative `place`:\n * \n * ```javascript\n * RoundTo(123.456789, 0) = 123\n * RoundTo(123.456789, -1) = 123.5\n * RoundTo(123.456789, -2) = 123.46\n * RoundTo(123.456789, -3) = 123.457\n * ```\n *\n * @function Phaser.Math.RoundTo\n * @since 3.0.0\n *\n * @param {number} value - The value to round.\n * @param {integer} [place=0] - The place to round to. Positive to round the units, negative to round the decimal.\n * @param {integer} [base=10] - The base to round in. Default is 10 for decimal.\n *\n * @return {number} The rounded value.\n */\nvar RoundTo = function (value, place, base)\n{\n    if (place === undefined) { place = 0; }\n    if (base === undefined) { base = 10; }\n\n    var p = Math.pow(base, -place);\n\n    return Math.round(value * p) / p;\n};\n\nmodule.exports = RoundTo;\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * Generate a series of sine and cosine values.\n *\n * @function Phaser.Math.SinCosTableGenerator\n * @since 3.0.0\n *\n * @param {number} length - The number of values to generate.\n * @param {number} [sinAmp=1] - The sine value amplitude.\n * @param {number} [cosAmp=1] - The cosine value amplitude.\n * @param {number} [frequency=1] - The frequency of the values.\n *\n * @return {Phaser.Types.Math.SinCosTable} The generated values.\n */\nvar SinCosTableGenerator = function (length, sinAmp, cosAmp, frequency)\n{\n    if (sinAmp === undefined) { sinAmp = 1; }\n    if (cosAmp === undefined) { cosAmp = 1; }\n    if (frequency === undefined) { frequency = 1; }\n\n    frequency *= Math.PI / length;\n\n    var cos = [];\n    var sin = [];\n\n    for (var c = 0; c < length; c++)\n    {\n        cosAmp -= sinAmp * frequency;\n        sinAmp += cosAmp * frequency;\n\n        cos[c] = cosAmp;\n        sin[c] = sinAmp;\n    }\n\n    return {\n        sin: sin,\n        cos: cos,\n        length: length\n    };\n};\n\nmodule.exports = SinCosTableGenerator;\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * Calculate a smooth interpolation percentage of `x` between `min` and `max`.\n *\n * The function receives the number `x` as an argument and returns 0 if `x` is less than or equal to the left edge,\n * 1 if `x` is greater than or equal to the right edge, and smoothly interpolates, using a Hermite polynomial,\n * between 0 and 1 otherwise.\n *\n * @function Phaser.Math.SmoothStep\n * @since 3.0.0\n * @see {@link https://en.wikipedia.org/wiki/Smoothstep}\n *\n * @param {number} x - The input value.\n * @param {number} min - The minimum value, also known as the 'left edge', assumed smaller than the 'right edge'.\n * @param {number} max - The maximum value, also known as the 'right edge', assumed greater than the 'left edge'.\n *\n * @return {number} The percentage of interpolation, between 0 and 1.\n */\nvar SmoothStep = function (x, min, max)\n{\n    if (x <= min)\n    {\n        return 0;\n    }\n\n    if (x >= max)\n    {\n        return 1;\n    }\n\n    x = (x - min) / (max - min);\n\n    return x * x * (3 - 2 * x);\n};\n\nmodule.exports = SmoothStep;\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * Calculate a smoother interpolation percentage of `x` between `min` and `max`.\n *\n * The function receives the number `x` as an argument and returns 0 if `x` is less than or equal to the left edge,\n * 1 if `x` is greater than or equal to the right edge, and smoothly interpolates, using a Hermite polynomial,\n * between 0 and 1 otherwise.\n *\n * Produces an even smoother interpolation than {@link Phaser.Math.SmoothStep}.\n *\n * @function Phaser.Math.SmootherStep\n * @since 3.0.0\n * @see {@link https://en.wikipedia.org/wiki/Smoothstep#Variations}\n *\n * @param {number} x - The input value.\n * @param {number} min - The minimum value, also known as the 'left edge', assumed smaller than the 'right edge'.\n * @param {number} max - The maximum value, also known as the 'right edge', assumed greater than the 'left edge'.\n *\n * @return {number} The percentage of interpolation, between 0 and 1.\n */\nvar SmootherStep = function (x, min, max)\n{\n    x = Math.max(0, Math.min(1, (x - min) / (max - min)));\n\n    return x * x * x * (x * (x * 6 - 15) + 10);\n};\n\nmodule.exports = SmootherStep;\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\nvar Vector2 = require('./Vector2');\n\n/**\n * Returns a Vec2 containing the x and y position of the given index in a `width` x `height` sized grid.\n * \n * For example, in a 6 x 4 grid, index 16 would equal x: 4 y: 2.\n * \n * If the given index is out of range an empty Vec2 is returned.\n *\n * @function Phaser.Math.ToXY\n * @since 3.19.0\n *\n * @param {integer} index - The position within the grid to get the x/y value for.\n * @param {integer} width - The width of the grid.\n * @param {integer} height - The height of the grid.\n * @param {Phaser.Math.Vector2} [out] - An optional Vector2 to store the result in. If not given, a new Vector2 instance will be created.\n *\n * @return {Phaser.Math.Vector2} A Vector2 where the x and y properties contain the given grid index.\n */\nvar ToXY = function (index, width, height, out)\n{\n    if (out === undefined) { out = new Vector2(); }\n\n    var x = 0;\n    var y = 0;\n    var total = width * height;\n\n    if (index > 0 && index <= total)\n    {\n        if (index > width - 1)\n        {\n            y = Math.floor(index / width);\n            x = index - (y * width);\n        }\n        else\n        {\n            x = index;\n        }\n\n        out.set(x, y);\n    }\n\n    return out;\n};\n\nmodule.exports = ToXY;\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\nvar Vector2 = require('./Vector2');\n\n/**\n * Takes the `x` and `y` coordinates and transforms them into the same space as\n * defined by the position, rotation and scale values.\n *\n * @function Phaser.Math.TransformXY\n * @since 3.0.0\n *\n * @param {number} x - The x coordinate to be transformed.\n * @param {number} y - The y coordinate to be transformed.\n * @param {number} positionX - Horizontal position of the transform point.\n * @param {number} positionY - Vertical position of the transform point.\n * @param {number} rotation - Rotation of the transform point, in radians.\n * @param {number} scaleX - Horizontal scale of the transform point.\n * @param {number} scaleY - Vertical scale of the transform point.\n * @param {(Phaser.Math.Vector2|Phaser.Geom.Point|object)} [output] - The output vector, point or object for the translated coordinates.\n *\n * @return {(Phaser.Math.Vector2|Phaser.Geom.Point|object)} The translated point.\n */\nvar TransformXY = function (x, y, positionX, positionY, rotation, scaleX, scaleY, output)\n{\n    if (output === undefined) { output = new Vector2(); }\n\n    var radianSin = Math.sin(rotation);\n    var radianCos = Math.cos(rotation);\n\n    // Rotate and Scale\n    var a = radianCos * scaleX;\n    var b = radianSin * scaleX;\n    var c = -radianSin * scaleY;\n    var d = radianCos * scaleY;\n\n    //  Invert\n    var id = 1 / ((a * d) + (c * -b));\n\n    output.x = (d * id * x) + (-c * id * y) + (((positionY * c) - (positionX * d)) * id);\n    output.y = (a * id * y) + (-b * id * x) + (((-positionY * a) + (positionX * b)) * id);\n\n    return output;\n};\n\nmodule.exports = TransformXY;\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n//  Adapted from [gl-matrix](https://github.com/toji/gl-matrix) by toji\n//  and [vecmath](https://github.com/mattdesl/vecmath) by mattdesl\n\nvar Class = require('../utils/Class');\n\n/**\n * @classdesc\n * A representation of a vector in 2D space.\n *\n * A two-component vector.\n *\n * @class Vector2\n * @memberof Phaser.Math\n * @constructor\n * @since 3.0.0\n *\n * @param {number|Phaser.Types.Math.Vector2Like} [x] - The x component, or an object with `x` and `y` properties.\n * @param {number} [y] - The y component.\n */\nvar Vector2 = new Class({\n\n    initialize:\n\n    function Vector2 (x, y)\n    {\n        /**\n         * The x component of this Vector.\n         *\n         * @name Phaser.Math.Vector2#x\n         * @type {number}\n         * @default 0\n         * @since 3.0.0\n         */\n        this.x = 0;\n\n        /**\n         * The y component of this Vector.\n         *\n         * @name Phaser.Math.Vector2#y\n         * @type {number}\n         * @default 0\n         * @since 3.0.0\n         */\n        this.y = 0;\n\n        if (typeof x === 'object')\n        {\n            this.x = x.x || 0;\n            this.y = x.y || 0;\n        }\n        else\n        {\n            if (y === undefined) { y = x; }\n\n            this.x = x || 0;\n            this.y = y || 0;\n        }\n    },\n\n    /**\n     * Make a clone of this Vector2.\n     *\n     * @method Phaser.Math.Vector2#clone\n     * @since 3.0.0\n     *\n     * @return {Phaser.Math.Vector2} A clone of this Vector2.\n     */\n    clone: function ()\n    {\n        return new Vector2(this.x, this.y);\n    },\n\n    /**\n     * Copy the components of a given Vector into this Vector.\n     *\n     * @method Phaser.Math.Vector2#copy\n     * @since 3.0.0\n     *\n     * @param {Phaser.Math.Vector2} src - The Vector to copy the components from.\n     *\n     * @return {Phaser.Math.Vector2} This Vector2.\n     */\n    copy: function (src)\n    {\n        this.x = src.x || 0;\n        this.y = src.y || 0;\n\n        return this;\n    },\n\n    /**\n     * Set the component values of this Vector from a given Vector2Like object.\n     *\n     * @method Phaser.Math.Vector2#setFromObject\n     * @since 3.0.0\n     *\n     * @param {Phaser.Types.Math.Vector2Like} obj - The object containing the component values to set for this Vector.\n     *\n     * @return {Phaser.Math.Vector2} This Vector2.\n     */\n    setFromObject: function (obj)\n    {\n        this.x = obj.x || 0;\n        this.y = obj.y || 0;\n\n        return this;\n    },\n\n    /**\n     * Set the `x` and `y` components of the this Vector to the given `x` and `y` values.\n     *\n     * @method Phaser.Math.Vector2#set\n     * @since 3.0.0\n     *\n     * @param {number} x - The x value to set for this Vector.\n     * @param {number} [y=x] - The y value to set for this Vector.\n     *\n     * @return {Phaser.Math.Vector2} This Vector2.\n     */\n    set: function (x, y)\n    {\n        if (y === undefined) { y = x; }\n\n        this.x = x;\n        this.y = y;\n\n        return this;\n    },\n\n    /**\n     * This method is an alias for `Vector2.set`.\n     *\n     * @method Phaser.Math.Vector2#setTo\n     * @since 3.4.0\n     *\n     * @param {number} x - The x value to set for this Vector.\n     * @param {number} [y=x] - The y value to set for this Vector.\n     *\n     * @return {Phaser.Math.Vector2} This Vector2.\n     */\n    setTo: function (x, y)\n    {\n        return this.set(x, y);\n    },\n\n    /**\n     * Sets the `x` and `y` values of this object from a given polar coordinate.\n     *\n     * @method Phaser.Math.Vector2#setToPolar\n     * @since 3.0.0\n     *\n     * @param {number} azimuth - The angular coordinate, in radians.\n     * @param {number} [radius=1] - The radial coordinate (length).\n     *\n     * @return {Phaser.Math.Vector2} This Vector2.\n     */\n    setToPolar: function (azimuth, radius)\n    {\n        if (radius == null) { radius = 1; }\n\n        this.x = Math.cos(azimuth) * radius;\n        this.y = Math.sin(azimuth) * radius;\n\n        return this;\n    },\n\n    /**\n     * Check whether this Vector is equal to a given Vector.\n     *\n     * Performs a strict equality check against each Vector's components.\n     *\n     * @method Phaser.Math.Vector2#equals\n     * @since 3.0.0\n     *\n     * @param {Phaser.Math.Vector2} v - The vector to compare with this Vector.\n     *\n     * @return {boolean} Whether the given Vector is equal to this Vector.\n     */\n    equals: function (v)\n    {\n        return ((this.x === v.x) && (this.y === v.y));\n    },\n\n    /**\n     * Calculate the angle between this Vector and the positive x-axis, in radians.\n     *\n     * @method Phaser.Math.Vector2#angle\n     * @since 3.0.0\n     *\n     * @return {number} The angle between this Vector, and the positive x-axis, given in radians.\n     */\n    angle: function ()\n    {\n        // computes the angle in radians with respect to the positive x-axis\n\n        var angle = Math.atan2(this.y, this.x);\n\n        if (angle < 0)\n        {\n            angle += 2 * Math.PI;\n        }\n\n        return angle;\n    },\n\n    /**\n     * Add a given Vector to this Vector. Addition is component-wise.\n     *\n     * @method Phaser.Math.Vector2#add\n     * @since 3.0.0\n     *\n     * @param {Phaser.Math.Vector2} src - The Vector to add to this Vector.\n     *\n     * @return {Phaser.Math.Vector2} This Vector2.\n     */\n    add: function (src)\n    {\n        this.x += src.x;\n        this.y += src.y;\n\n        return this;\n    },\n\n    /**\n     * Subtract the given Vector from this Vector. Subtraction is component-wise.\n     *\n     * @method Phaser.Math.Vector2#subtract\n     * @since 3.0.0\n     *\n     * @param {Phaser.Math.Vector2} src - The Vector to subtract from this Vector.\n     *\n     * @return {Phaser.Math.Vector2} This Vector2.\n     */\n    subtract: function (src)\n    {\n        this.x -= src.x;\n        this.y -= src.y;\n\n        return this;\n    },\n\n    /**\n     * Perform a component-wise multiplication between this Vector and the given Vector.\n     *\n     * Multiplies this Vector by the given Vector.\n     *\n     * @method Phaser.Math.Vector2#multiply\n     * @since 3.0.0\n     *\n     * @param {Phaser.Math.Vector2} src - The Vector to multiply this Vector by.\n     *\n     * @return {Phaser.Math.Vector2} This Vector2.\n     */\n    multiply: function (src)\n    {\n        this.x *= src.x;\n        this.y *= src.y;\n\n        return this;\n    },\n\n    /**\n     * Scale this Vector by the given value.\n     *\n     * @method Phaser.Math.Vector2#scale\n     * @since 3.0.0\n     *\n     * @param {number} value - The value to scale this Vector by.\n     *\n     * @return {Phaser.Math.Vector2} This Vector2.\n     */\n    scale: function (value)\n    {\n        if (isFinite(value))\n        {\n            this.x *= value;\n            this.y *= value;\n        }\n        else\n        {\n            this.x = 0;\n            this.y = 0;\n        }\n\n        return this;\n    },\n\n    /**\n     * Perform a component-wise division between this Vector and the given Vector.\n     *\n     * Divides this Vector by the given Vector.\n     *\n     * @method Phaser.Math.Vector2#divide\n     * @since 3.0.0\n     *\n     * @param {Phaser.Math.Vector2} src - The Vector to divide this Vector by.\n     *\n     * @return {Phaser.Math.Vector2} This Vector2.\n     */\n    divide: function (src)\n    {\n        this.x /= src.x;\n        this.y /= src.y;\n\n        return this;\n    },\n\n    /**\n     * Negate the `x` and `y` components of this Vector.\n     *\n     * @method Phaser.Math.Vector2#negate\n     * @since 3.0.0\n     *\n     * @return {Phaser.Math.Vector2} This Vector2.\n     */\n    negate: function ()\n    {\n        this.x = -this.x;\n        this.y = -this.y;\n\n        return this;\n    },\n\n    /**\n     * Calculate the distance between this Vector and the given Vector.\n     *\n     * @method Phaser.Math.Vector2#distance\n     * @since 3.0.0\n     *\n     * @param {Phaser.Math.Vector2} src - The Vector to calculate the distance to.\n     *\n     * @return {number} The distance from this Vector to the given Vector.\n     */\n    distance: function (src)\n    {\n        var dx = src.x - this.x;\n        var dy = src.y - this.y;\n\n        return Math.sqrt(dx * dx + dy * dy);\n    },\n\n    /**\n     * Calculate the distance between this Vector and the given Vector, squared.\n     *\n     * @method Phaser.Math.Vector2#distanceSq\n     * @since 3.0.0\n     *\n     * @param {Phaser.Math.Vector2} src - The Vector to calculate the distance to.\n     *\n     * @return {number} The distance from this Vector to the given Vector, squared.\n     */\n    distanceSq: function (src)\n    {\n        var dx = src.x - this.x;\n        var dy = src.y - this.y;\n\n        return dx * dx + dy * dy;\n    },\n\n    /**\n     * Calculate the length (or magnitude) of this Vector.\n     *\n     * @method Phaser.Math.Vector2#length\n     * @since 3.0.0\n     *\n     * @return {number} The length of this Vector.\n     */\n    length: function ()\n    {\n        var x = this.x;\n        var y = this.y;\n\n        return Math.sqrt(x * x + y * y);\n    },\n\n    /**\n     * Calculate the length of this Vector squared.\n     *\n     * @method Phaser.Math.Vector2#lengthSq\n     * @since 3.0.0\n     *\n     * @return {number} The length of this Vector, squared.\n     */\n    lengthSq: function ()\n    {\n        var x = this.x;\n        var y = this.y;\n\n        return x * x + y * y;\n    },\n\n    /**\n     * Normalize this Vector.\n     *\n     * Makes the vector a unit length vector (magnitude of 1) in the same direction.\n     *\n     * @method Phaser.Math.Vector2#normalize\n     * @since 3.0.0\n     *\n     * @return {Phaser.Math.Vector2} This Vector2.\n     */\n    normalize: function ()\n    {\n        var x = this.x;\n        var y = this.y;\n        var len = x * x + y * y;\n\n        if (len > 0)\n        {\n            len = 1 / Math.sqrt(len);\n\n            this.x = x * len;\n            this.y = y * len;\n        }\n\n        return this;\n    },\n\n    /**\n     * Right-hand normalize (make unit length) this Vector.\n     *\n     * @method Phaser.Math.Vector2#normalizeRightHand\n     * @since 3.0.0\n     *\n     * @return {Phaser.Math.Vector2} This Vector2.\n     */\n    normalizeRightHand: function ()\n    {\n        var x = this.x;\n\n        this.x = this.y * -1;\n        this.y = x;\n\n        return this;\n    },\n\n    /**\n     * Calculate the dot product of this Vector and the given Vector.\n     *\n     * @method Phaser.Math.Vector2#dot\n     * @since 3.0.0\n     *\n     * @param {Phaser.Math.Vector2} src - The Vector2 to dot product with this Vector2.\n     *\n     * @return {number} The dot product of this Vector and the given Vector.\n     */\n    dot: function (src)\n    {\n        return this.x * src.x + this.y * src.y;\n    },\n\n    /**\n     * Calculate the cross product of this Vector and the given Vector.\n     *\n     * @method Phaser.Math.Vector2#cross\n     * @since 3.0.0\n     *\n     * @param {Phaser.Math.Vector2} src - The Vector2 to cross with this Vector2.\n     *\n     * @return {number} The cross product of this Vector and the given Vector.\n     */\n    cross: function (src)\n    {\n        return this.x * src.y - this.y * src.x;\n    },\n\n    /**\n     * Linearly interpolate between this Vector and the given Vector.\n     *\n     * Interpolates this Vector towards the given Vector.\n     *\n     * @method Phaser.Math.Vector2#lerp\n     * @since 3.0.0\n     *\n     * @param {Phaser.Math.Vector2} src - The Vector2 to interpolate towards.\n     * @param {number} [t=0] - The interpolation percentage, between 0 and 1.\n     *\n     * @return {Phaser.Math.Vector2} This Vector2.\n     */\n    lerp: function (src, t)\n    {\n        if (t === undefined) { t = 0; }\n\n        var ax = this.x;\n        var ay = this.y;\n\n        this.x = ax + t * (src.x - ax);\n        this.y = ay + t * (src.y - ay);\n\n        return this;\n    },\n\n    /**\n     * Transform this Vector with the given Matrix.\n     *\n     * @method Phaser.Math.Vector2#transformMat3\n     * @since 3.0.0\n     *\n     * @param {Phaser.Math.Matrix3} mat - The Matrix3 to transform this Vector2 with.\n     *\n     * @return {Phaser.Math.Vector2} This Vector2.\n     */\n    transformMat3: function (mat)\n    {\n        var x = this.x;\n        var y = this.y;\n        var m = mat.val;\n\n        this.x = m[0] * x + m[3] * y + m[6];\n        this.y = m[1] * x + m[4] * y + m[7];\n\n        return this;\n    },\n\n    /**\n     * Transform this Vector with the given Matrix.\n     *\n     * @method Phaser.Math.Vector2#transformMat4\n     * @since 3.0.0\n     *\n     * @param {Phaser.Math.Matrix4} mat - The Matrix4 to transform this Vector2 with.\n     *\n     * @return {Phaser.Math.Vector2} This Vector2.\n     */\n    transformMat4: function (mat)\n    {\n        var x = this.x;\n        var y = this.y;\n        var m = mat.val;\n\n        this.x = m[0] * x + m[4] * y + m[12];\n        this.y = m[1] * x + m[5] * y + m[13];\n\n        return this;\n    },\n\n    /**\n     * Make this Vector the zero vector (0, 0).\n     *\n     * @method Phaser.Math.Vector2#reset\n     * @since 3.0.0\n     *\n     * @return {Phaser.Math.Vector2} This Vector2.\n     */\n    reset: function ()\n    {\n        this.x = 0;\n        this.y = 0;\n\n        return this;\n    }\n\n});\n\n/**\n * A static zero Vector2 for use by reference.\n * \n * This constant is meant for comparison operations and should not be modified directly.\n *\n * @constant\n * @name Phaser.Math.Vector2.ZERO\n * @type {Phaser.Math.Vector2}\n * @since 3.1.0\n */\nVector2.ZERO = new Vector2();\n\n/**\n * A static right Vector2 for use by reference.\n * \n * This constant is meant for comparison operations and should not be modified directly.\n *\n * @constant\n * @name Phaser.Math.Vector2.RIGHT\n * @type {Phaser.Math.Vector2}\n * @since 3.16.0\n */\nVector2.RIGHT = new Vector2(1, 0);\n\n/**\n * A static left Vector2 for use by reference.\n * \n * This constant is meant for comparison operations and should not be modified directly.\n *\n * @constant\n * @name Phaser.Math.Vector2.LEFT\n * @type {Phaser.Math.Vector2}\n * @since 3.16.0\n */\nVector2.LEFT = new Vector2(-1, 0);\n\n/**\n * A static up Vector2 for use by reference.\n * \n * This constant is meant for comparison operations and should not be modified directly.\n *\n * @constant\n * @name Phaser.Math.Vector2.UP\n * @type {Phaser.Math.Vector2}\n * @since 3.16.0\n */\nVector2.UP = new Vector2(0, -1);\n\n/**\n * A static down Vector2 for use by reference.\n * \n * This constant is meant for comparison operations and should not be modified directly.\n *\n * @constant\n * @name Phaser.Math.Vector2.DOWN\n * @type {Phaser.Math.Vector2}\n * @since 3.16.0\n */\nVector2.DOWN = new Vector2(0, 1);\n\n/**\n * A static one Vector2 for use by reference.\n * \n * This constant is meant for comparison operations and should not be modified directly.\n *\n * @constant\n * @name Phaser.Math.Vector2.ONE\n * @type {Phaser.Math.Vector2}\n * @since 3.16.0\n */\nVector2.ONE = new Vector2(1, 1);\n\nmodule.exports = Vector2;\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n//  Adapted from [gl-matrix](https://github.com/toji/gl-matrix) by toji\n//  and [vecmath](https://github.com/mattdesl/vecmath) by mattdesl\n\nvar Class = require('../utils/Class');\n\n/**\n * @classdesc\n * A representation of a vector in 3D space.\n *\n * A three-component vector.\n *\n * @class Vector3\n * @memberof Phaser.Math\n * @constructor\n * @since 3.0.0\n *\n * @param {number} [x] - The x component.\n * @param {number} [y] - The y component.\n * @param {number} [z] - The z component.\n */\nvar Vector3 = new Class({\n\n    initialize:\n\n    function Vector3 (x, y, z)\n    {\n        /**\n         * The x component of this Vector.\n         *\n         * @name Phaser.Math.Vector3#x\n         * @type {number}\n         * @default 0\n         * @since 3.0.0\n         */\n        this.x = 0;\n\n        /**\n         * The y component of this Vector.\n         *\n         * @name Phaser.Math.Vector3#y\n         * @type {number}\n         * @default 0\n         * @since 3.0.0\n         */\n        this.y = 0;\n\n        /**\n         * The z component of this Vector.\n         *\n         * @name Phaser.Math.Vector3#z\n         * @type {number}\n         * @default 0\n         * @since 3.0.0\n         */\n        this.z = 0;\n\n        if (typeof x === 'object')\n        {\n            this.x = x.x || 0;\n            this.y = x.y || 0;\n            this.z = x.z || 0;\n        }\n        else\n        {\n            this.x = x || 0;\n            this.y = y || 0;\n            this.z = z || 0;\n        }\n    },\n\n    /**\n     * Set this Vector to point up.\n     *\n     * Sets the y component of the vector to 1, and the others to 0.\n     *\n     * @method Phaser.Math.Vector3#up\n     * @since 3.0.0\n     *\n     * @return {Phaser.Math.Vector3} This Vector3.\n     */\n    up: function ()\n    {\n        this.x = 0;\n        this.y = 1;\n        this.z = 0;\n\n        return this;\n    },\n\n    /**\n     * Make a clone of this Vector3.\n     *\n     * @method Phaser.Math.Vector3#clone\n     * @since 3.0.0\n     *\n     * @return {Phaser.Math.Vector3} A new Vector3 object containing this Vectors values.\n     */\n    clone: function ()\n    {\n        return new Vector3(this.x, this.y, this.z);\n    },\n\n    /**\n     * Calculate the cross (vector) product of two given Vectors.\n     *\n     * @method Phaser.Math.Vector3#crossVectors\n     * @since 3.0.0\n     *\n     * @param {Phaser.Math.Vector3} a - The first Vector to multiply.\n     * @param {Phaser.Math.Vector3} b - The second Vector to multiply.\n     *\n     * @return {Phaser.Math.Vector3} This Vector3.\n     */\n    crossVectors: function (a, b)\n    {\n        var ax = a.x;\n        var ay = a.y;\n        var az = a.z;\n        var bx = b.x;\n        var by = b.y;\n        var bz = b.z;\n\n        this.x = ay * bz - az * by;\n        this.y = az * bx - ax * bz;\n        this.z = ax * by - ay * bx;\n\n        return this;\n    },\n\n    /**\n     * Check whether this Vector is equal to a given Vector.\n     *\n     * Performs a strict equality check against each Vector's components.\n     *\n     * @method Phaser.Math.Vector3#equals\n     * @since 3.0.0\n     *\n     * @param {Phaser.Math.Vector3} v - The Vector3 to compare against.\n     *\n     * @return {boolean} True if the two vectors strictly match, otherwise false.\n     */\n    equals: function (v)\n    {\n        return ((this.x === v.x) && (this.y === v.y) && (this.z === v.z));\n    },\n\n    /**\n     * Copy the components of a given Vector into this Vector.\n     *\n     * @method Phaser.Math.Vector3#copy\n     * @since 3.0.0\n     *\n     * @param {(Phaser.Math.Vector2|Phaser.Math.Vector3)} src - The Vector to copy the components from.\n     *\n     * @return {Phaser.Math.Vector3} This Vector3.\n     */\n    copy: function (src)\n    {\n        this.x = src.x;\n        this.y = src.y;\n        this.z = src.z || 0;\n\n        return this;\n    },\n\n    /**\n     * Set the `x`, `y`, and `z` components of this Vector to the given `x`, `y`, and `z` values.\n     *\n     * @method Phaser.Math.Vector3#set\n     * @since 3.0.0\n     *\n     * @param {(number|object)} x - The x value to set for this Vector, or an object containing x, y and z components.\n     * @param {number} [y] - The y value to set for this Vector.\n     * @param {number} [z] - The z value to set for this Vector.\n     *\n     * @return {Phaser.Math.Vector3} This Vector3.\n     */\n    set: function (x, y, z)\n    {\n        if (typeof x === 'object')\n        {\n            this.x = x.x || 0;\n            this.y = x.y || 0;\n            this.z = x.z || 0;\n        }\n        else\n        {\n            this.x = x || 0;\n            this.y = y || 0;\n            this.z = z || 0;\n        }\n\n        return this;\n    },\n\n    /**\n     * Add a given Vector to this Vector. Addition is component-wise.\n     *\n     * @method Phaser.Math.Vector3#add\n     * @since 3.0.0\n     *\n     * @param {(Phaser.Math.Vector2|Phaser.Math.Vector3)} v - The Vector to add to this Vector.\n     *\n     * @return {Phaser.Math.Vector3} This Vector3.\n     */\n    add: function (v)\n    {\n        this.x += v.x;\n        this.y += v.y;\n        this.z += v.z || 0;\n\n        return this;\n    },\n\n    /**\n     * Subtract the given Vector from this Vector. Subtraction is component-wise.\n     *\n     * @method Phaser.Math.Vector3#subtract\n     * @since 3.0.0\n     *\n     * @param {(Phaser.Math.Vector2|Phaser.Math.Vector3)} v - The Vector to subtract from this Vector.\n     *\n     * @return {Phaser.Math.Vector3} This Vector3.\n     */\n    subtract: function (v)\n    {\n        this.x -= v.x;\n        this.y -= v.y;\n        this.z -= v.z || 0;\n\n        return this;\n    },\n\n    /**\n     * Perform a component-wise multiplication between this Vector and the given Vector.\n     *\n     * Multiplies this Vector by the given Vector.\n     *\n     * @method Phaser.Math.Vector3#multiply\n     * @since 3.0.0\n     *\n     * @param {(Phaser.Math.Vector2|Phaser.Math.Vector3)} v - The Vector to multiply this Vector by.\n     *\n     * @return {Phaser.Math.Vector3} This Vector3.\n     */\n    multiply: function (v)\n    {\n        this.x *= v.x;\n        this.y *= v.y;\n        this.z *= v.z || 1;\n\n        return this;\n    },\n\n    /**\n     * Scale this Vector by the given value.\n     *\n     * @method Phaser.Math.Vector3#scale\n     * @since 3.0.0\n     *\n     * @param {number} scale - The value to scale this Vector by.\n     *\n     * @return {Phaser.Math.Vector3} This Vector3.\n     */\n    scale: function (scale)\n    {\n        if (isFinite(scale))\n        {\n            this.x *= scale;\n            this.y *= scale;\n            this.z *= scale;\n        }\n        else\n        {\n            this.x = 0;\n            this.y = 0;\n            this.z = 0;\n        }\n\n        return this;\n    },\n\n    /**\n     * Perform a component-wise division between this Vector and the given Vector.\n     *\n     * Divides this Vector by the given Vector.\n     *\n     * @method Phaser.Math.Vector3#divide\n     * @since 3.0.0\n     *\n     * @param {(Phaser.Math.Vector2|Phaser.Math.Vector3)} v - The Vector to divide this Vector by.\n     *\n     * @return {Phaser.Math.Vector3} This Vector3.\n     */\n    divide: function (v)\n    {\n        this.x /= v.x;\n        this.y /= v.y;\n        this.z /= v.z || 1;\n\n        return this;\n    },\n\n    /**\n     * Negate the `x`, `y` and `z` components of this Vector.\n     *\n     * @method Phaser.Math.Vector3#negate\n     * @since 3.0.0\n     *\n     * @return {Phaser.Math.Vector3} This Vector3.\n     */\n    negate: function ()\n    {\n        this.x = -this.x;\n        this.y = -this.y;\n        this.z = -this.z;\n\n        return this;\n    },\n\n    /**\n     * Calculate the distance between this Vector and the given Vector.\n     *\n     * @method Phaser.Math.Vector3#distance\n     * @since 3.0.0\n     *\n     * @param {(Phaser.Math.Vector2|Phaser.Math.Vector3)} v - The Vector to calculate the distance to.\n     *\n     * @return {number} The distance from this Vector to the given Vector.\n     */\n    distance: function (v)\n    {\n        var dx = v.x - this.x;\n        var dy = v.y - this.y;\n        var dz = v.z - this.z || 0;\n\n        return Math.sqrt(dx * dx + dy * dy + dz * dz);\n    },\n\n    /**\n     * Calculate the distance between this Vector and the given Vector, squared.\n     *\n     * @method Phaser.Math.Vector3#distanceSq\n     * @since 3.0.0\n     *\n     * @param {(Phaser.Math.Vector2|Phaser.Math.Vector3)} v - The Vector to calculate the distance to.\n     *\n     * @return {number} The distance from this Vector to the given Vector, squared.\n     */\n    distanceSq: function (v)\n    {\n        var dx = v.x - this.x;\n        var dy = v.y - this.y;\n        var dz = v.z - this.z || 0;\n\n        return dx * dx + dy * dy + dz * dz;\n    },\n\n    /**\n     * Calculate the length (or magnitude) of this Vector.\n     *\n     * @method Phaser.Math.Vector3#length\n     * @since 3.0.0\n     *\n     * @return {number} The length of this Vector.\n     */\n    length: function ()\n    {\n        var x = this.x;\n        var y = this.y;\n        var z = this.z;\n\n        return Math.sqrt(x * x + y * y + z * z);\n    },\n\n    /**\n     * Calculate the length of this Vector squared.\n     *\n     * @method Phaser.Math.Vector3#lengthSq\n     * @since 3.0.0\n     *\n     * @return {number} The length of this Vector, squared.\n     */\n    lengthSq: function ()\n    {\n        var x = this.x;\n        var y = this.y;\n        var z = this.z;\n\n        return x * x + y * y + z * z;\n    },\n\n    /**\n     * Normalize this Vector.\n     *\n     * Makes the vector a unit length vector (magnitude of 1) in the same direction.\n     *\n     * @method Phaser.Math.Vector3#normalize\n     * @since 3.0.0\n     *\n     * @return {Phaser.Math.Vector3} This Vector3.\n     */\n    normalize: function ()\n    {\n        var x = this.x;\n        var y = this.y;\n        var z = this.z;\n        var len = x * x + y * y + z * z;\n\n        if (len > 0)\n        {\n            len = 1 / Math.sqrt(len);\n\n            this.x = x * len;\n            this.y = y * len;\n            this.z = z * len;\n        }\n\n        return this;\n    },\n\n    /**\n     * Calculate the dot product of this Vector and the given Vector.\n     *\n     * @method Phaser.Math.Vector3#dot\n     * @since 3.0.0\n     *\n     * @param {Phaser.Math.Vector3} v - The Vector3 to dot product with this Vector3.\n     *\n     * @return {number} The dot product of this Vector and `v`.\n     */\n    dot: function (v)\n    {\n        return this.x * v.x + this.y * v.y + this.z * v.z;\n    },\n\n    /**\n     * Calculate the cross (vector) product of this Vector (which will be modified) and the given Vector.\n     *\n     * @method Phaser.Math.Vector3#cross\n     * @since 3.0.0\n     *\n     * @param {Phaser.Math.Vector3} v - The Vector to cross product with.\n     *\n     * @return {Phaser.Math.Vector3} This Vector3.\n     */\n    cross: function (v)\n    {\n        var ax = this.x;\n        var ay = this.y;\n        var az = this.z;\n        var bx = v.x;\n        var by = v.y;\n        var bz = v.z;\n\n        this.x = ay * bz - az * by;\n        this.y = az * bx - ax * bz;\n        this.z = ax * by - ay * bx;\n\n        return this;\n    },\n\n    /**\n     * Linearly interpolate between this Vector and the given Vector.\n     *\n     * Interpolates this Vector towards the given Vector.\n     *\n     * @method Phaser.Math.Vector3#lerp\n     * @since 3.0.0\n     *\n     * @param {Phaser.Math.Vector3} v - The Vector3 to interpolate towards.\n     * @param {number} [t=0] - The interpolation percentage, between 0 and 1.\n     *\n     * @return {Phaser.Math.Vector3} This Vector3.\n     */\n    lerp: function (v, t)\n    {\n        if (t === undefined) { t = 0; }\n\n        var ax = this.x;\n        var ay = this.y;\n        var az = this.z;\n\n        this.x = ax + t * (v.x - ax);\n        this.y = ay + t * (v.y - ay);\n        this.z = az + t * (v.z - az);\n\n        return this;\n    },\n\n    /**\n     * Transform this Vector with the given Matrix.\n     *\n     * @method Phaser.Math.Vector3#transformMat3\n     * @since 3.0.0\n     *\n     * @param {Phaser.Math.Matrix3} mat - The Matrix3 to transform this Vector3 with.\n     *\n     * @return {Phaser.Math.Vector3} This Vector3.\n     */\n    transformMat3: function (mat)\n    {\n        var x = this.x;\n        var y = this.y;\n        var z = this.z;\n        var m = mat.val;\n\n        this.x = x * m[0] + y * m[3] + z * m[6];\n        this.y = x * m[1] + y * m[4] + z * m[7];\n        this.z = x * m[2] + y * m[5] + z * m[8];\n\n        return this;\n    },\n\n    /**\n     * Transform this Vector with the given Matrix.\n     *\n     * @method Phaser.Math.Vector3#transformMat4\n     * @since 3.0.0\n     *\n     * @param {Phaser.Math.Matrix4} mat - The Matrix4 to transform this Vector3 with.\n     *\n     * @return {Phaser.Math.Vector3} This Vector3.\n     */\n    transformMat4: function (mat)\n    {\n        var x = this.x;\n        var y = this.y;\n        var z = this.z;\n        var m = mat.val;\n\n        this.x = m[0] * x + m[4] * y + m[8] * z + m[12];\n        this.y = m[1] * x + m[5] * y + m[9] * z + m[13];\n        this.z = m[2] * x + m[6] * y + m[10] * z + m[14];\n\n        return this;\n    },\n\n    /**\n     * Transforms the coordinates of this Vector3 with the given Matrix4.\n     *\n     * @method Phaser.Math.Vector3#transformCoordinates\n     * @since 3.0.0\n     *\n     * @param {Phaser.Math.Matrix4} mat - The Matrix4 to transform this Vector3 with.\n     *\n     * @return {Phaser.Math.Vector3} This Vector3.\n     */\n    transformCoordinates: function (mat)\n    {\n        var x = this.x;\n        var y = this.y;\n        var z = this.z;\n        var m = mat.val;\n\n        var tx = (x * m[0]) + (y * m[4]) + (z * m[8]) + m[12];\n        var ty = (x * m[1]) + (y * m[5]) + (z * m[9]) + m[13];\n        var tz = (x * m[2]) + (y * m[6]) + (z * m[10]) + m[14];\n        var tw = (x * m[3]) + (y * m[7]) + (z * m[11]) + m[15];\n\n        this.x = tx / tw;\n        this.y = ty / tw;\n        this.z = tz / tw;\n\n        return this;\n    },\n\n    /**\n     * Transform this Vector with the given Quaternion.\n     *\n     * @method Phaser.Math.Vector3#transformQuat\n     * @since 3.0.0\n     *\n     * @param {Phaser.Math.Quaternion} q - The Quaternion to transform this Vector with.\n     *\n     * @return {Phaser.Math.Vector3} This Vector3.\n     */\n    transformQuat: function (q)\n    {\n        // benchmarks: http://jsperf.com/quaternion-transform-vec3-implementations\n        var x = this.x;\n        var y = this.y;\n        var z = this.z;\n        var qx = q.x;\n        var qy = q.y;\n        var qz = q.z;\n        var qw = q.w;\n\n        // calculate quat * vec\n        var ix = qw * x + qy * z - qz * y;\n        var iy = qw * y + qz * x - qx * z;\n        var iz = qw * z + qx * y - qy * x;\n        var iw = -qx * x - qy * y - qz * z;\n\n        // calculate result * inverse quat\n        this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;\n        this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;\n        this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;\n\n        return this;\n    },\n\n    /**\n     * Multiplies this Vector3 by the specified matrix, applying a W divide. This is useful for projection,\n     * e.g. unprojecting a 2D point into 3D space.\n     *\n     * @method Phaser.Math.Vector3#project\n     * @since 3.0.0\n     *\n     * @param {Phaser.Math.Matrix4} mat - The Matrix4 to multiply this Vector3 with.\n     *\n     * @return {Phaser.Math.Vector3} This Vector3.\n     */\n    project: function (mat)\n    {\n        var x = this.x;\n        var y = this.y;\n        var z = this.z;\n        var m = mat.val;\n\n        var a00 = m[0];\n        var a01 = m[1];\n        var a02 = m[2];\n        var a03 = m[3];\n        var a10 = m[4];\n        var a11 = m[5];\n        var a12 = m[6];\n        var a13 = m[7];\n        var a20 = m[8];\n        var a21 = m[9];\n        var a22 = m[10];\n        var a23 = m[11];\n        var a30 = m[12];\n        var a31 = m[13];\n        var a32 = m[14];\n        var a33 = m[15];\n\n        var lw = 1 / (x * a03 + y * a13 + z * a23 + a33);\n\n        this.x = (x * a00 + y * a10 + z * a20 + a30) * lw;\n        this.y = (x * a01 + y * a11 + z * a21 + a31) * lw;\n        this.z = (x * a02 + y * a12 + z * a22 + a32) * lw;\n\n        return this;\n    },\n\n    /**\n     * Unproject this point from 2D space to 3D space.\n     * The point should have its x and y properties set to\n     * 2D screen space, and the z either at 0 (near plane)\n     * or 1 (far plane). The provided matrix is assumed to already\n     * be combined, i.e. projection * view * model.\n     *\n     * After this operation, this vector's (x, y, z) components will\n     * represent the unprojected 3D coordinate.\n     *\n     * @method Phaser.Math.Vector3#unproject\n     * @since 3.0.0\n     *\n     * @param {Phaser.Math.Vector4} viewport - Screen x, y, width and height in pixels.\n     * @param {Phaser.Math.Matrix4} invProjectionView - Combined projection and view matrix.\n     *\n     * @return {Phaser.Math.Vector3} This Vector3.\n     */\n    unproject: function (viewport, invProjectionView)\n    {\n        var viewX = viewport.x;\n        var viewY = viewport.y;\n        var viewWidth = viewport.z;\n        var viewHeight = viewport.w;\n\n        var x = this.x - viewX;\n        var y = (viewHeight - this.y - 1) - viewY;\n        var z = this.z;\n\n        this.x = (2 * x) / viewWidth - 1;\n        this.y = (2 * y) / viewHeight - 1;\n        this.z = 2 * z - 1;\n\n        return this.project(invProjectionView);\n    },\n\n    /**\n     * Make this Vector the zero vector (0, 0, 0).\n     *\n     * @method Phaser.Math.Vector3#reset\n     * @since 3.0.0\n     *\n     * @return {Phaser.Math.Vector3} This Vector3.\n     */\n    reset: function ()\n    {\n        this.x = 0;\n        this.y = 0;\n        this.z = 0;\n\n        return this;\n    }\n\n});\n\n/**\n * A static zero Vector3 for use by reference.\n * \n * This constant is meant for comparison operations and should not be modified directly.\n *\n * @constant\n * @name Phaser.Math.Vector3.ZERO\n * @type {Phaser.Math.Vector3}\n * @since 3.16.0\n */\nVector3.ZERO = new Vector3();\n\n/**\n * A static right Vector3 for use by reference.\n * \n * This constant is meant for comparison operations and should not be modified directly.\n *\n * @constant\n * @name Phaser.Math.Vector3.RIGHT\n * @type {Phaser.Math.Vector3}\n * @since 3.16.0\n */\nVector3.RIGHT = new Vector3(1, 0, 0);\n\n/**\n * A static left Vector3 for use by reference.\n * \n * This constant is meant for comparison operations and should not be modified directly.\n *\n * @constant\n * @name Phaser.Math.Vector3.LEFT\n * @type {Phaser.Math.Vector3}\n * @since 3.16.0\n */\nVector3.LEFT = new Vector3(-1, 0, 0);\n\n/**\n * A static up Vector3 for use by reference.\n * \n * This constant is meant for comparison operations and should not be modified directly.\n *\n * @constant\n * @name Phaser.Math.Vector3.UP\n * @type {Phaser.Math.Vector3}\n * @since 3.16.0\n */\nVector3.UP = new Vector3(0, -1, 0);\n\n/**\n * A static down Vector3 for use by reference.\n * \n * This constant is meant for comparison operations and should not be modified directly.\n *\n * @constant\n * @name Phaser.Math.Vector3.DOWN\n * @type {Phaser.Math.Vector3}\n * @since 3.16.0\n */\nVector3.DOWN = new Vector3(0, 1, 0);\n\n/**\n * A static forward Vector3 for use by reference.\n * \n * This constant is meant for comparison operations and should not be modified directly.\n *\n * @constant\n * @name Phaser.Math.Vector3.FORWARD\n * @type {Phaser.Math.Vector3}\n * @since 3.16.0\n */\nVector3.FORWARD = new Vector3(0, 0, 1);\n\n/**\n * A static back Vector3 for use by reference.\n * \n * This constant is meant for comparison operations and should not be modified directly.\n *\n * @constant\n * @name Phaser.Math.Vector3.BACK\n * @type {Phaser.Math.Vector3}\n * @since 3.16.0\n */\nVector3.BACK = new Vector3(0, 0, -1);\n\n/**\n * A static one Vector3 for use by reference.\n * \n * This constant is meant for comparison operations and should not be modified directly.\n *\n * @constant\n * @name Phaser.Math.Vector3.ONE\n * @type {Phaser.Math.Vector3}\n * @since 3.16.0\n */\nVector3.ONE = new Vector3(1, 1, 1);\n\nmodule.exports = Vector3;\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n//  Adapted from [gl-matrix](https://github.com/toji/gl-matrix) by toji\n//  and [vecmath](https://github.com/mattdesl/vecmath) by mattdesl\n\nvar Class = require('../utils/Class');\n\n/**\n * @classdesc\n * A representation of a vector in 4D space.\n *\n * A four-component vector.\n *\n * @class Vector4\n * @memberof Phaser.Math\n * @constructor\n * @since 3.0.0\n *\n * @param {number} [x] - The x component.\n * @param {number} [y] - The y component.\n * @param {number} [z] - The z component.\n * @param {number} [w] - The w component.\n */\nvar Vector4 = new Class({\n\n    initialize:\n\n    function Vector4 (x, y, z, w)\n    {\n        /**\n         * The x component of this Vector.\n         *\n         * @name Phaser.Math.Vector4#x\n         * @type {number}\n         * @default 0\n         * @since 3.0.0\n         */\n        this.x = 0;\n\n        /**\n         * The y component of this Vector.\n         *\n         * @name Phaser.Math.Vector4#y\n         * @type {number}\n         * @default 0\n         * @since 3.0.0\n         */\n        this.y = 0;\n\n        /**\n         * The z component of this Vector.\n         *\n         * @name Phaser.Math.Vector4#z\n         * @type {number}\n         * @default 0\n         * @since 3.0.0\n         */\n        this.z = 0;\n\n        /**\n         * The w component of this Vector.\n         *\n         * @name Phaser.Math.Vector4#w\n         * @type {number}\n         * @default 0\n         * @since 3.0.0\n         */\n        this.w = 0;\n\n        if (typeof x === 'object')\n        {\n            this.x = x.x || 0;\n            this.y = x.y || 0;\n            this.z = x.z || 0;\n            this.w = x.w || 0;\n        }\n        else\n        {\n            this.x = x || 0;\n            this.y = y || 0;\n            this.z = z || 0;\n            this.w = w || 0;\n        }\n    },\n\n    /**\n     * Make a clone of this Vector4.\n     *\n     * @method Phaser.Math.Vector4#clone\n     * @since 3.0.0\n     *\n     * @return {Phaser.Math.Vector4} A clone of this Vector4.\n     */\n    clone: function ()\n    {\n        return new Vector4(this.x, this.y, this.z, this.w);\n    },\n\n    /**\n     * Copy the components of a given Vector into this Vector.\n     *\n     * @method Phaser.Math.Vector4#copy\n     * @since 3.0.0\n     *\n     * @param {Phaser.Math.Vector4} src - The Vector to copy the components from.\n     *\n     * @return {Phaser.Math.Vector4} This Vector4.\n     */\n    copy: function (src)\n    {\n        this.x = src.x;\n        this.y = src.y;\n        this.z = src.z || 0;\n        this.w = src.w || 0;\n\n        return this;\n    },\n\n    /**\n     * Check whether this Vector is equal to a given Vector.\n     *\n     * Performs a strict quality check against each Vector's components.\n     *\n     * @method Phaser.Math.Vector4#equals\n     * @since 3.0.0\n     *\n     * @param {Phaser.Math.Vector4} v - The vector to check equality with.\n     *\n     * @return {boolean} A boolean indicating whether the two Vectors are equal or not.\n     */\n    equals: function (v)\n    {\n        return ((this.x === v.x) && (this.y === v.y) && (this.z === v.z) && (this.w === v.w));\n    },\n\n    /**\n     * Set the `x`, `y`, `z` and `w` components of the this Vector to the given `x`, `y`, `z` and `w` values.\n     *\n     * @method Phaser.Math.Vector4#set\n     * @since 3.0.0\n     *\n     * @param {(number|object)} x - The x value to set for this Vector, or an object containing x, y, z and w components.\n     * @param {number} y - The y value to set for this Vector.\n     * @param {number} z - The z value to set for this Vector.\n     * @param {number} w - The z value to set for this Vector.\n     *\n     * @return {Phaser.Math.Vector4} This Vector4.\n     */\n    set: function (x, y, z, w)\n    {\n        if (typeof x === 'object')\n        {\n            this.x = x.x || 0;\n            this.y = x.y || 0;\n            this.z = x.z || 0;\n            this.w = x.w || 0;\n        }\n        else\n        {\n            this.x = x || 0;\n            this.y = y || 0;\n            this.z = z || 0;\n            this.w = w || 0;\n        }\n\n        return this;\n    },\n\n    /**\n     * Add a given Vector to this Vector. Addition is component-wise.\n     *\n     * @method Phaser.Math.Vector4#add\n     * @since 3.0.0\n     *\n     * @param {(Phaser.Math.Vector2|Phaser.Math.Vector3|Phaser.Math.Vector4)} v - The Vector to add to this Vector.\n     *\n     * @return {Phaser.Math.Vector4} This Vector4.\n     */\n    add: function (v)\n    {\n        this.x += v.x;\n        this.y += v.y;\n        this.z += v.z || 0;\n        this.w += v.w || 0;\n\n        return this;\n    },\n\n    /**\n     * Subtract the given Vector from this Vector. Subtraction is component-wise.\n     *\n     * @method Phaser.Math.Vector4#subtract\n     * @since 3.0.0\n     *\n     * @param {(Phaser.Math.Vector2|Phaser.Math.Vector3|Phaser.Math.Vector4)} v - The Vector to subtract from this Vector.\n     *\n     * @return {Phaser.Math.Vector4} This Vector4.\n     */\n    subtract: function (v)\n    {\n        this.x -= v.x;\n        this.y -= v.y;\n        this.z -= v.z || 0;\n        this.w -= v.w || 0;\n\n        return this;\n    },\n\n    /**\n     * Scale this Vector by the given value.\n     *\n     * @method Phaser.Math.Vector4#scale\n     * @since 3.0.0\n     *\n     * @param {number} scale - The value to scale this Vector by.\n     *\n     * @return {Phaser.Math.Vector4} This Vector4.\n     */\n    scale: function (scale)\n    {\n        this.x *= scale;\n        this.y *= scale;\n        this.z *= scale;\n        this.w *= scale;\n\n        return this;\n    },\n\n    /**\n     * Calculate the length (or magnitude) of this Vector.\n     *\n     * @method Phaser.Math.Vector4#length\n     * @since 3.0.0\n     *\n     * @return {number} The length of this Vector.\n     */\n    length: function ()\n    {\n        var x = this.x;\n        var y = this.y;\n        var z = this.z;\n        var w = this.w;\n\n        return Math.sqrt(x * x + y * y + z * z + w * w);\n    },\n\n    /**\n     * Calculate the length of this Vector squared.\n     *\n     * @method Phaser.Math.Vector4#lengthSq\n     * @since 3.0.0\n     *\n     * @return {number} The length of this Vector, squared.\n     */\n    lengthSq: function ()\n    {\n        var x = this.x;\n        var y = this.y;\n        var z = this.z;\n        var w = this.w;\n\n        return x * x + y * y + z * z + w * w;\n    },\n\n    /**\n     * Normalize this Vector.\n     *\n     * Makes the vector a unit length vector (magnitude of 1) in the same direction.\n     *\n     * @method Phaser.Math.Vector4#normalize\n     * @since 3.0.0\n     *\n     * @return {Phaser.Math.Vector4} This Vector4.\n     */\n    normalize: function ()\n    {\n        var x = this.x;\n        var y = this.y;\n        var z = this.z;\n        var w = this.w;\n        var len = x * x + y * y + z * z + w * w;\n\n        if (len > 0)\n        {\n            len = 1 / Math.sqrt(len);\n\n            this.x = x * len;\n            this.y = y * len;\n            this.z = z * len;\n            this.w = w * len;\n        }\n\n        return this;\n    },\n\n    /**\n     * Calculate the dot product of this Vector and the given Vector.\n     *\n     * @method Phaser.Math.Vector4#dot\n     * @since 3.0.0\n     *\n     * @param {Phaser.Math.Vector4} v - The Vector4 to dot product with this Vector4.\n     *\n     * @return {number} The dot product of this Vector and the given Vector.\n     */\n    dot: function (v)\n    {\n        return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;\n    },\n\n    /**\n     * Linearly interpolate between this Vector and the given Vector.\n     *\n     * Interpolates this Vector towards the given Vector.\n     *\n     * @method Phaser.Math.Vector4#lerp\n     * @since 3.0.0\n     *\n     * @param {Phaser.Math.Vector4} v - The Vector4 to interpolate towards.\n     * @param {number} [t=0] - The interpolation percentage, between 0 and 1.\n     *\n     * @return {Phaser.Math.Vector4} This Vector4.\n     */\n    lerp: function (v, t)\n    {\n        if (t === undefined) { t = 0; }\n\n        var ax = this.x;\n        var ay = this.y;\n        var az = this.z;\n        var aw = this.w;\n\n        this.x = ax + t * (v.x - ax);\n        this.y = ay + t * (v.y - ay);\n        this.z = az + t * (v.z - az);\n        this.w = aw + t * (v.w - aw);\n\n        return this;\n    },\n\n    /**\n     * Perform a component-wise multiplication between this Vector and the given Vector.\n     *\n     * Multiplies this Vector by the given Vector.\n     *\n     * @method Phaser.Math.Vector4#multiply\n     * @since 3.0.0\n     *\n     * @param {(Phaser.Math.Vector2|Phaser.Math.Vector3|Phaser.Math.Vector4)} v - The Vector to multiply this Vector by.\n     *\n     * @return {Phaser.Math.Vector4} This Vector4.\n     */\n    multiply: function (v)\n    {\n        this.x *= v.x;\n        this.y *= v.y;\n        this.z *= v.z || 1;\n        this.w *= v.w || 1;\n\n        return this;\n    },\n\n    /**\n     * Perform a component-wise division between this Vector and the given Vector.\n     *\n     * Divides this Vector by the given Vector.\n     *\n     * @method Phaser.Math.Vector4#divide\n     * @since 3.0.0\n     *\n     * @param {(Phaser.Math.Vector2|Phaser.Math.Vector3|Phaser.Math.Vector4)} v - The Vector to divide this Vector by.\n     *\n     * @return {Phaser.Math.Vector4} This Vector4.\n     */\n    divide: function (v)\n    {\n        this.x /= v.x;\n        this.y /= v.y;\n        this.z /= v.z || 1;\n        this.w /= v.w || 1;\n\n        return this;\n    },\n\n    /**\n     * Calculate the distance between this Vector and the given Vector.\n     *\n     * @method Phaser.Math.Vector4#distance\n     * @since 3.0.0\n     *\n     * @param {(Phaser.Math.Vector2|Phaser.Math.Vector3|Phaser.Math.Vector4)} v - The Vector to calculate the distance to.\n     *\n     * @return {number} The distance from this Vector to the given Vector.\n     */\n    distance: function (v)\n    {\n        var dx = v.x - this.x;\n        var dy = v.y - this.y;\n        var dz = v.z - this.z || 0;\n        var dw = v.w - this.w || 0;\n\n        return Math.sqrt(dx * dx + dy * dy + dz * dz + dw * dw);\n    },\n\n    /**\n     * Calculate the distance between this Vector and the given Vector, squared.\n     *\n     * @method Phaser.Math.Vector4#distanceSq\n     * @since 3.0.0\n     *\n     * @param {(Phaser.Math.Vector2|Phaser.Math.Vector3|Phaser.Math.Vector4)} v - The Vector to calculate the distance to.\n     *\n     * @return {number} The distance from this Vector to the given Vector, squared.\n     */\n    distanceSq: function (v)\n    {\n        var dx = v.x - this.x;\n        var dy = v.y - this.y;\n        var dz = v.z - this.z || 0;\n        var dw = v.w - this.w || 0;\n\n        return dx * dx + dy * dy + dz * dz + dw * dw;\n    },\n\n    /**\n     * Negate the `x`, `y`, `z` and `w` components of this Vector.\n     *\n     * @method Phaser.Math.Vector4#negate\n     * @since 3.0.0\n     *\n     * @return {Phaser.Math.Vector4} This Vector4.\n     */\n    negate: function ()\n    {\n        this.x = -this.x;\n        this.y = -this.y;\n        this.z = -this.z;\n        this.w = -this.w;\n\n        return this;\n    },\n\n    /**\n     * Transform this Vector with the given Matrix.\n     *\n     * @method Phaser.Math.Vector4#transformMat4\n     * @since 3.0.0\n     *\n     * @param {Phaser.Math.Matrix4} mat - The Matrix4 to transform this Vector4 with.\n     *\n     * @return {Phaser.Math.Vector4} This Vector4.\n     */\n    transformMat4: function (mat)\n    {\n        var x = this.x;\n        var y = this.y;\n        var z = this.z;\n        var w = this.w;\n        var m = mat.val;\n\n        this.x = m[0] * x + m[4] * y + m[8] * z + m[12] * w;\n        this.y = m[1] * x + m[5] * y + m[9] * z + m[13] * w;\n        this.z = m[2] * x + m[6] * y + m[10] * z + m[14] * w;\n        this.w = m[3] * x + m[7] * y + m[11] * z + m[15] * w;\n\n        return this;\n    },\n\n    /**\n     * Transform this Vector with the given Quaternion.\n     *\n     * @method Phaser.Math.Vector4#transformQuat\n     * @since 3.0.0\n     *\n     * @param {Phaser.Math.Quaternion} q - The Quaternion to transform this Vector with.\n     *\n     * @return {Phaser.Math.Vector4} This Vector4.\n     */\n    transformQuat: function (q)\n    {\n        // TODO: is this really the same as Vector3?\n        // Also, what about this: http://molecularmusings.wordpress.com/2013/05/24/a-faster-quaternion-vector-multiplication/\n        // benchmarks: http://jsperf.com/quaternion-transform-vec3-implementations\n        var x = this.x;\n        var y = this.y;\n        var z = this.z;\n        var qx = q.x;\n        var qy = q.y;\n        var qz = q.z;\n        var qw = q.w;\n\n        // calculate quat * vec\n        var ix = qw * x + qy * z - qz * y;\n        var iy = qw * y + qz * x - qx * z;\n        var iz = qw * z + qx * y - qy * x;\n        var iw = -qx * x - qy * y - qz * z;\n\n        // calculate result * inverse quat\n        this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;\n        this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;\n        this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;\n\n        return this;\n    },\n\n    /**\n     * Make this Vector the zero vector (0, 0, 0, 0).\n     *\n     * @method Phaser.Math.Vector4#reset\n     * @since 3.0.0\n     *\n     * @return {Phaser.Math.Vector4} This Vector4.\n     */\n    reset: function ()\n    {\n        this.x = 0;\n        this.y = 0;\n        this.z = 0;\n        this.w = 0;\n\n        return this;\n    }\n\n});\n\n//  TODO: Check if these are required internally, if not, remove.\nVector4.prototype.sub = Vector4.prototype.subtract;\nVector4.prototype.mul = Vector4.prototype.multiply;\nVector4.prototype.div = Vector4.prototype.divide;\nVector4.prototype.dist = Vector4.prototype.distance;\nVector4.prototype.distSq = Vector4.prototype.distanceSq;\nVector4.prototype.len = Vector4.prototype.length;\nVector4.prototype.lenSq = Vector4.prototype.lengthSq;\n\nmodule.exports = Vector4;\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * Checks if the two values are within the given `tolerance` of each other.\n *\n * @function Phaser.Math.Within\n * @since 3.0.0\n *\n * @param {number} a - The first value to use in the calculation.\n * @param {number} b - The second value to use in the calculation.\n * @param {number} tolerance - The tolerance. Anything equal to or less than this value is considered as being within range.\n *\n * @return {boolean} Returns `true` if `a` is less than or equal to the tolerance of `b`.\n */\nvar Within = function (a, b, tolerance)\n{\n    return (Math.abs(a - b) <= tolerance);\n};\n\nmodule.exports = Within;\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * Wrap the given `value` between `min` and `max.\n *\n * @function Phaser.Math.Wrap\n * @since 3.0.0\n *\n * @param {number} value - The value to wrap.\n * @param {number} min - The minimum value.\n * @param {number} max - The maximum value.\n *\n * @return {number} The wrapped value.\n */\nvar Wrap = function (value, min, max)\n{\n    var range = max - min;\n\n    return (min + ((((value - min) % range) + range) % range));\n};\n\nmodule.exports = Wrap;\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * Find the angle of a segment from (x1, y1) -> (x2, y2).\n *\n * @function Phaser.Math.Angle.Between\n * @since 3.0.0\n *\n * @param {number} x1 - The x coordinate of the first point.\n * @param {number} y1 - The y coordinate of the first point.\n * @param {number} x2 - The x coordinate of the second point.\n * @param {number} y2 - The y coordinate of the second point.\n *\n * @return {number} The angle in radians.\n */\nvar Between = function (x1, y1, x2, y2)\n{\n    return Math.atan2(y2 - y1, x2 - x1);\n};\n\nmodule.exports = Between;\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * Find the angle of a segment from (point1.x, point1.y) -> (point2.x, point2.y).\n *\n * Calculates the angle of the vector from the first point to the second point.\n *\n * @function Phaser.Math.Angle.BetweenPoints\n * @since 3.0.0\n *\n * @param {(Phaser.Geom.Point|object)} point1 - The first point.\n * @param {(Phaser.Geom.Point|object)} point2 - The second point.\n *\n * @return {number} The angle in radians.\n */\nvar BetweenPoints = function (point1, point2)\n{\n    return Math.atan2(point2.y - point1.y, point2.x - point1.x);\n};\n\nmodule.exports = BetweenPoints;\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * Find the angle of a segment from (point1.x, point1.y) -> (point2.x, point2.y).\n *\n * The difference between this method and {@link Phaser.Math.Angle.BetweenPoints} is that this assumes the y coordinate\n * travels down the screen.\n *\n * @function Phaser.Math.Angle.BetweenPointsY\n * @since 3.0.0\n *\n * @param {(Phaser.Geom.Point|object)} point1 - The first point.\n * @param {(Phaser.Geom.Point|object)} point2 - The second point.\n *\n * @return {number} The angle in radians.\n */\nvar BetweenPointsY = function (point1, point2)\n{\n    return Math.atan2(point2.x - point1.x, point2.y - point1.y);\n};\n\nmodule.exports = BetweenPointsY;\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * Find the angle of a segment from (x1, y1) -> (x2, y2).\n *\n * The difference between this method and {@link Phaser.Math.Angle.Between} is that this assumes the y coordinate\n * travels down the screen.\n *\n * @function Phaser.Math.Angle.BetweenY\n * @since 3.0.0\n *\n * @param {number} x1 - The x coordinate of the first point.\n * @param {number} y1 - The y coordinate of the first point.\n * @param {number} x2 - The x coordinate of the second point.\n * @param {number} y2 - The y coordinate of the second point.\n *\n * @return {number} The angle in radians.\n */\nvar BetweenY = function (x1, y1, x2, y2)\n{\n    return Math.atan2(x2 - x1, y2 - y1);\n};\n\nmodule.exports = BetweenY;\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\nvar CONST = require('../const');\n\n/**\n * Takes an angle in Phasers default clockwise format and converts it so that\n * 0 is North, 90 is West, 180 is South and 270 is East,\n * therefore running counter-clockwise instead of clockwise.\n * \n * You can pass in the angle from a Game Object using:\n * \n * ```javascript\n * var converted = CounterClockwise(gameobject.rotation);\n * ```\n * \n * All values for this function are in radians.\n *\n * @function Phaser.Math.Angle.CounterClockwise\n * @since 3.16.0\n *\n * @param {number} angle - The angle to convert, in radians.\n *\n * @return {number} The converted angle, in radians.\n */\nvar CounterClockwise = function (angle)\n{\n    if (angle > Math.PI)\n    {\n        angle -= CONST.PI2;\n    }\n\n    return Math.abs((((angle + CONST.TAU) % CONST.PI2) - CONST.PI2) % CONST.PI2);\n};\n\nmodule.exports = CounterClockwise;\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * Normalize an angle to the [0, 2pi] range.\n *\n * @function Phaser.Math.Angle.Normalize\n * @since 3.0.0\n *\n * @param {number} angle - The angle to normalize, in radians.\n *\n * @return {number} The normalized angle, in radians.\n */\nvar Normalize = function (angle)\n{\n    angle = angle % (2 * Math.PI);\n\n    if (angle >= 0)\n    {\n        return angle;\n    }\n    else\n    {\n        return angle + 2 * Math.PI;\n    }\n};\n\nmodule.exports = Normalize;\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\nvar Normalize = require('./Normalize');\n\n/**\n * Reverse the given angle.\n *\n * @function Phaser.Math.Angle.Reverse\n * @since 3.0.0\n *\n * @param {number} angle - The angle to reverse, in radians.\n *\n * @return {number} The reversed angle, in radians.\n */\nvar Reverse = function (angle)\n{\n    return Normalize(angle + Math.PI);\n};\n\nmodule.exports = Reverse;\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\nvar MATH_CONST = require('../const');\n\n/**\n * Rotates `currentAngle` towards `targetAngle`, taking the shortest rotation distance. The `lerp` argument is the amount to rotate by in this call.\n *\n * @function Phaser.Math.Angle.RotateTo\n * @since 3.0.0\n *\n * @param {number} currentAngle - The current angle, in radians.\n * @param {number} targetAngle - The target angle to rotate to, in radians.\n * @param {number} [lerp=0.05] - The lerp value to add to the current angle.\n *\n * @return {number} The adjusted angle.\n */\nvar RotateTo = function (currentAngle, targetAngle, lerp)\n{\n    if (lerp === undefined) { lerp = 0.05; }\n\n    if (currentAngle === targetAngle)\n    {\n        return currentAngle;\n    }\n\n    if (Math.abs(targetAngle - currentAngle) <= lerp || Math.abs(targetAngle - currentAngle) >= (MATH_CONST.PI2 - lerp))\n    {\n        currentAngle = targetAngle;\n    }\n    else\n    {\n        if (Math.abs(targetAngle - currentAngle) > Math.PI)\n        {\n            if (targetAngle < currentAngle)\n            {\n                targetAngle += MATH_CONST.PI2;\n            }\n            else\n            {\n                targetAngle -= MATH_CONST.PI2;\n            }\n        }\n\n        if (targetAngle > currentAngle)\n        {\n            currentAngle += lerp;\n        }\n        else if (targetAngle < currentAngle)\n        {\n            currentAngle -= lerp;\n        }\n    }\n\n    return currentAngle;\n};\n\nmodule.exports = RotateTo;\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * Gets the shortest angle between `angle1` and `angle2`.\n *\n * Both angles must be in the range -180 to 180, which is the same clamped\n * range that `sprite.angle` uses, so you can pass in two sprite angles to\n * this method and get the shortest angle back between the two of them.\n *\n * The angle returned will be in the same range. If the returned angle is\n * greater than 0 then it's a counter-clockwise rotation, if < 0 then it's\n * a clockwise rotation.\n *\n * TODO: Wrap the angles in this function?\n *\n * @function Phaser.Math.Angle.ShortestBetween\n * @since 3.0.0\n *\n * @param {number} angle1 - The first angle in the range -180 to 180.\n * @param {number} angle2 - The second angle in the range -180 to 180.\n *\n * @return {number} The shortest angle, in degrees. If greater than zero it's a counter-clockwise rotation.\n */\nvar ShortestBetween = function (angle1, angle2)\n{\n    var difference = angle2 - angle1;\n\n    if (difference === 0)\n    {\n        return 0;\n    }\n\n    var times = Math.floor((difference - (-180)) / 360);\n\n    return difference - (times * 360);\n\n};\n\nmodule.exports = ShortestBetween;\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\nvar MathWrap = require('../Wrap');\n\n/**\n * Wrap an angle.\n *\n * Wraps the angle to a value in the range of -PI to PI.\n *\n * @function Phaser.Math.Angle.Wrap\n * @since 3.0.0\n *\n * @param {number} angle - The angle to wrap, in radians.\n *\n * @return {number} The wrapped angle, in radians.\n */\nvar Wrap = function (angle)\n{\n    return MathWrap(angle, -Math.PI, Math.PI);\n};\n\nmodule.exports = Wrap;\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\nvar Wrap = require('../Wrap');\n\n/**\n * Wrap an angle in degrees.\n *\n * Wraps the angle to a value in the range of -180 to 180.\n *\n * @function Phaser.Math.Angle.WrapDegrees\n * @since 3.0.0\n *\n * @param {number} angle - The angle to wrap, in degrees.\n *\n * @return {number} The wrapped angle, in degrees.\n */\nvar WrapDegrees = function (angle)\n{\n    return Wrap(angle, -180, 180);\n};\n\nmodule.exports = WrapDegrees;\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * @namespace Phaser.Math.Angle\n */\n\nmodule.exports = {\n\n    Between: require('./Between'),\n    BetweenPoints: require('./BetweenPoints'),\n    BetweenPointsY: require('./BetweenPointsY'),\n    BetweenY: require('./BetweenY'),\n    CounterClockwise: require('./CounterClockwise'),\n    Normalize: require('./Normalize'),\n    Reverse: require('./Reverse'),\n    RotateTo: require('./RotateTo'),\n    ShortestBetween: require('./ShortestBetween'),\n    Wrap: require('./Wrap'),\n    WrapDegrees: require('./WrapDegrees')\n\n};\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\nvar MATH_CONST = {\n\n    /**\n     * The value of PI * 2.\n     * \n     * @name Phaser.Math.PI2\n     * @type {number}\n     * @since 3.0.0\n     */\n    PI2: Math.PI * 2,\n\n    /**\n     * The value of PI * 0.5.\n     * \n     * @name Phaser.Math.TAU\n     * @type {number}\n     * @since 3.0.0\n     */\n    TAU: Math.PI * 0.5,\n\n    /**\n     * An epsilon value (1.0e-6)\n     * \n     * @name Phaser.Math.EPSILON\n     * @type {number}\n     * @since 3.0.0\n     */\n    EPSILON: 1.0e-6,\n\n    /**\n     * For converting degrees to radians (PI / 180)\n     * \n     * @name Phaser.Math.DEG_TO_RAD\n     * @type {number}\n     * @since 3.0.0\n     */\n    DEG_TO_RAD: Math.PI / 180,\n\n    /**\n     * For converting radians to degrees (180 / PI)\n     * \n     * @name Phaser.Math.RAD_TO_DEG\n     * @type {number}\n     * @since 3.0.0\n     */\n    RAD_TO_DEG: 180 / Math.PI,\n\n    /**\n     * An instance of the Random Number Generator.\n     * This is not set until the Game boots.\n     * \n     * @name Phaser.Math.RND\n     * @type {Phaser.Math.RandomDataGenerator}\n     * @since 3.0.0\n     */\n    RND: null\n\n};\n\nmodule.exports = MATH_CONST;\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * Calculate the distance between two sets of coordinates (points).\n *\n * @function Phaser.Math.Distance.Between\n * @since 3.0.0\n *\n * @param {number} x1 - The x coordinate of the first point.\n * @param {number} y1 - The y coordinate of the first point.\n * @param {number} x2 - The x coordinate of the second point.\n * @param {number} y2 - The y coordinate of the second point.\n *\n * @return {number} The distance between each point.\n */\nvar DistanceBetween = function (x1, y1, x2, y2)\n{\n    var dx = x1 - x2;\n    var dy = y1 - y2;\n\n    return Math.sqrt(dx * dx + dy * dy);\n};\n\nmodule.exports = DistanceBetween;\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * Calculate the distance between two sets of coordinates (points) to the power of `pow`.\n *\n * @function Phaser.Math.Distance.Power\n * @since 3.0.0\n *\n * @param {number} x1 - The x coordinate of the first point.\n * @param {number} y1 - The y coordinate of the first point.\n * @param {number} x2 - The x coordinate of the second point.\n * @param {number} y2 - The y coordinate of the second point.\n * @param {number} pow - The exponent.\n *\n * @return {number} The distance between each point.\n */\nvar DistancePower = function (x1, y1, x2, y2, pow)\n{\n    if (pow === undefined) { pow = 2; }\n\n    return Math.sqrt(Math.pow(x2 - x1, pow) + Math.pow(y2 - y1, pow));\n};\n\nmodule.exports = DistancePower;\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * Calculate the distance between two sets of coordinates (points), squared.\n *\n * @function Phaser.Math.Distance.Squared\n * @since 3.0.0\n *\n * @param {number} x1 - The x coordinate of the first point.\n * @param {number} y1 - The y coordinate of the first point.\n * @param {number} x2 - The x coordinate of the second point.\n * @param {number} y2 - The y coordinate of the second point.\n *\n * @return {number} The distance between each point, squared.\n */\nvar DistanceSquared = function (x1, y1, x2, y2)\n{\n    var dx = x1 - x2;\n    var dy = y1 - y2;\n\n    return dx * dx + dy * dy;\n};\n\nmodule.exports = DistanceSquared;\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * @namespace Phaser.Math.Distance\n */\n\nmodule.exports = {\n\n    Between: require('./DistanceBetween'),\n    Power: require('./DistancePower'),\n    Squared: require('./DistanceSquared')\n\n};\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * Back ease-in.\n *\n * @function Phaser.Math.Easing.Back.In\n * @since 3.0.0\n *\n * @param {number} v - The value to be tweened.\n * @param {number} [overshoot=1.70158] - The overshoot amount.\n *\n * @return {number} The tweened value.\n */\nvar In = function (v, overshoot)\n{\n    if (overshoot === undefined) { overshoot = 1.70158; }\n\n    return v * v * ((overshoot + 1) * v - overshoot);\n};\n\nmodule.exports = In;\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * Back ease-in/out.\n *\n * @function Phaser.Math.Easing.Back.InOut\n * @since 3.0.0\n *\n * @param {number} v - The value to be tweened.\n * @param {number} [overshoot=1.70158] - The overshoot amount.\n *\n * @return {number} The tweened value.\n */\nvar InOut = function (v, overshoot)\n{\n    if (overshoot === undefined) { overshoot = 1.70158; }\n\n    var s = overshoot * 1.525;\n\n    if ((v *= 2) < 1)\n    {\n        return 0.5 * (v * v * ((s + 1) * v - s));\n    }\n    else\n    {\n        return 0.5 * ((v -= 2) * v * ((s + 1) * v + s) + 2);\n    }\n};\n\nmodule.exports = InOut;\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * Back ease-out.\n *\n * @function Phaser.Math.Easing.Back.Out\n * @since 3.0.0\n *\n * @param {number} v - The value to be tweened.\n * @param {number} [overshoot=1.70158] - The overshoot amount.\n *\n * @return {number} The tweened value.\n */\nvar Out = function (v, overshoot)\n{\n    if (overshoot === undefined) { overshoot = 1.70158; }\n\n    return --v * v * ((overshoot + 1) * v + overshoot) + 1;\n};\n\nmodule.exports = Out;\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * @namespace Phaser.Math.Easing.Back\n */\n\nmodule.exports = {\n\n    In: require('./In'),\n    Out: require('./Out'),\n    InOut: require('./InOut')\n\n};\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * Bounce ease-in.\n *\n * @function Phaser.Math.Easing.Bounce.In\n * @since 3.0.0\n *\n * @param {number} v - The value to be tweened.\n *\n * @return {number} The tweened value.\n */\nvar In = function (v)\n{\n    v = 1 - v;\n\n    if (v < 1 / 2.75)\n    {\n        return 1 - (7.5625 * v * v);\n    }\n    else if (v < 2 / 2.75)\n    {\n        return 1 - (7.5625 * (v -= 1.5 / 2.75) * v + 0.75);\n    }\n    else if (v < 2.5 / 2.75)\n    {\n        return 1 - (7.5625 * (v -= 2.25 / 2.75) * v + 0.9375);\n    }\n    else\n    {\n        return 1 - (7.5625 * (v -= 2.625 / 2.75) * v + 0.984375);\n    }\n};\n\nmodule.exports = In;\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * Bounce ease-in/out.\n *\n * @function Phaser.Math.Easing.Bounce.InOut\n * @since 3.0.0\n *\n * @param {number} v - The value to be tweened.\n *\n * @return {number} The tweened value.\n */\nvar InOut = function (v)\n{\n    var reverse = false;\n\n    if (v < 0.5)\n    {\n        v = 1 - (v * 2);\n        reverse = true;\n    }\n    else\n    {\n        v = (v * 2) - 1;\n    }\n\n    if (v < 1 / 2.75)\n    {\n        v = 7.5625 * v * v;\n    }\n    else if (v < 2 / 2.75)\n    {\n        v = 7.5625 * (v -= 1.5 / 2.75) * v + 0.75;\n    }\n    else if (v < 2.5 / 2.75)\n    {\n        v = 7.5625 * (v -= 2.25 / 2.75) * v + 0.9375;\n    }\n    else\n    {\n        v = 7.5625 * (v -= 2.625 / 2.75) * v + 0.984375;\n    }\n\n    if (reverse)\n    {\n        return (1 - v) * 0.5;\n    }\n    else\n    {\n        return v * 0.5 + 0.5;\n    }\n};\n\nmodule.exports = InOut;\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * Bounce ease-out.\n *\n * @function Phaser.Math.Easing.Bounce.Out\n * @since 3.0.0\n *\n * @param {number} v - The value to be tweened.\n *\n * @return {number} The tweened value.\n */\nvar Out = function (v)\n{\n    if (v < 1 / 2.75)\n    {\n        return 7.5625 * v * v;\n    }\n    else if (v < 2 / 2.75)\n    {\n        return 7.5625 * (v -= 1.5 / 2.75) * v + 0.75;\n    }\n    else if (v < 2.5 / 2.75)\n    {\n        return 7.5625 * (v -= 2.25 / 2.75) * v + 0.9375;\n    }\n    else\n    {\n        return 7.5625 * (v -= 2.625 / 2.75) * v + 0.984375;\n    }\n};\n\nmodule.exports = Out;\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * @namespace Phaser.Math.Easing.Bounce\n */\n\nmodule.exports = {\n\n    In: require('./In'),\n    Out: require('./Out'),\n    InOut: require('./InOut')\n\n};\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * Circular ease-in.\n *\n * @function Phaser.Math.Easing.Circular.In\n * @since 3.0.0\n *\n * @param {number} v - The value to be tweened.\n *\n * @return {number} The tweened value.\n */\nvar In = function (v)\n{\n    return 1 - Math.sqrt(1 - v * v);\n};\n\nmodule.exports = In;\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * Circular ease-in/out.\n *\n * @function Phaser.Math.Easing.Circular.InOut\n * @since 3.0.0\n *\n * @param {number} v - The value to be tweened.\n *\n * @return {number} The tweened value.\n */\nvar InOut = function (v)\n{\n    if ((v *= 2) < 1)\n    {\n        return -0.5 * (Math.sqrt(1 - v * v) - 1);\n    }\n    else\n    {\n        return 0.5 * (Math.sqrt(1 - (v -= 2) * v) + 1);\n    }\n};\n\nmodule.exports = InOut;\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * Circular ease-out.\n *\n * @function Phaser.Math.Easing.Circular.Out\n * @since 3.0.0\n *\n * @param {number} v - The value to be tweened.\n *\n * @return {number} The tweened value.\n */\nvar Out = function (v)\n{\n    return Math.sqrt(1 - (--v * v));\n};\n\nmodule.exports = Out;\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * @namespace Phaser.Math.Easing.Circular\n */\n\nmodule.exports = {\n\n    In: require('./In'),\n    Out: require('./Out'),\n    InOut: require('./InOut')\n\n};\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * Cubic ease-in.\n *\n * @function Phaser.Math.Easing.Cubic.In\n * @since 3.0.0\n *\n * @param {number} v - The value to be tweened.\n *\n * @return {number} The tweened value.\n */\nvar In = function (v)\n{\n    return v * v * v;\n};\n\nmodule.exports = In;\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * Cubic ease-in/out.\n *\n * @function Phaser.Math.Easing.Cubic.InOut\n * @since 3.0.0\n *\n * @param {number} v - The value to be tweened.\n *\n * @return {number} The tweened value.\n */\nvar InOut = function (v)\n{\n    if ((v *= 2) < 1)\n    {\n        return 0.5 * v * v * v;\n    }\n    else\n    {\n        return 0.5 * ((v -= 2) * v * v + 2);\n    }\n};\n\nmodule.exports = InOut;\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * Cubic ease-out.\n *\n * @function Phaser.Math.Easing.Cubic.Out\n * @since 3.0.0\n *\n * @param {number} v - The value to be tweened.\n *\n * @return {number} The tweened value.\n */\nvar Out = function (v)\n{\n    return --v * v * v + 1;\n};\n\nmodule.exports = Out;\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * @namespace Phaser.Math.Easing.Cubic\n */\n\nmodule.exports = {\n\n    In: require('./In'),\n    Out: require('./Out'),\n    InOut: require('./InOut')\n\n};\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * Elastic ease-in.\n *\n * @function Phaser.Math.Easing.Elastic.In\n * @since 3.0.0\n *\n * @param {number} v - The value to be tweened.\n * @param {number} [amplitude=0.1] - The amplitude of the elastic ease.\n * @param {number} [period=0.1] - Sets how tight the sine-wave is, where smaller values are tighter waves, which result in more cycles.\n *\n * @return {number} The tweened value.\n */\nvar In = function (v, amplitude, period)\n{\n    if (amplitude === undefined) { amplitude = 0.1; }\n    if (period === undefined) { period = 0.1; }\n\n    if (v === 0)\n    {\n        return 0;\n    }\n    else if (v === 1)\n    {\n        return 1;\n    }\n    else\n    {\n        var s = period / 4;\n\n        if (amplitude < 1)\n        {\n            amplitude = 1;\n        }\n        else\n        {\n            s = period * Math.asin(1 / amplitude) / (2 * Math.PI);\n        }\n\n        return -(amplitude * Math.pow(2, 10 * (v -= 1)) * Math.sin((v - s) * (2 * Math.PI) / period));\n    }\n};\n\nmodule.exports = In;\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * Elastic ease-in/out.\n *\n * @function Phaser.Math.Easing.Elastic.InOut\n * @since 3.0.0\n *\n * @param {number} v - The value to be tweened.\n * @param {number} [amplitude=0.1] - The amplitude of the elastic ease.\n * @param {number} [period=0.1] - Sets how tight the sine-wave is, where smaller values are tighter waves, which result in more cycles.\n *\n * @return {number} The tweened value.\n */\nvar InOut = function (v, amplitude, period)\n{\n    if (amplitude === undefined) { amplitude = 0.1; }\n    if (period === undefined) { period = 0.1; }\n\n    if (v === 0)\n    {\n        return 0;\n    }\n    else if (v === 1)\n    {\n        return 1;\n    }\n    else\n    {\n        var s = period / 4;\n\n        if (amplitude < 1)\n        {\n            amplitude = 1;\n        }\n        else\n        {\n            s = period * Math.asin(1 / amplitude) / (2 * Math.PI);\n        }\n\n        if ((v *= 2) < 1)\n        {\n            return -0.5 * (amplitude * Math.pow(2, 10 * (v -= 1)) * Math.sin((v - s) * (2 * Math.PI) / period));\n        }\n        else\n        {\n            return amplitude * Math.pow(2, -10 * (v -= 1)) * Math.sin((v - s) * (2 * Math.PI) / period) * 0.5 + 1;\n        }\n    }\n};\n\nmodule.exports = InOut;\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * Elastic ease-out.\n *\n * @function Phaser.Math.Easing.Elastic.Out\n * @since 3.0.0\n *\n * @param {number} v - The value to be tweened.\n * @param {number} [amplitude=0.1] - The amplitude of the elastic ease.\n * @param {number} [period=0.1] - Sets how tight the sine-wave is, where smaller values are tighter waves, which result in more cycles.\n *\n * @return {number} The tweened value.\n */\nvar Out = function (v, amplitude, period)\n{\n    if (amplitude === undefined) { amplitude = 0.1; }\n    if (period === undefined) { period = 0.1; }\n\n    if (v === 0)\n    {\n        return 0;\n    }\n    else if (v === 1)\n    {\n        return 1;\n    }\n    else\n    {\n        var s = period / 4;\n\n        if (amplitude < 1)\n        {\n            amplitude = 1;\n        }\n        else\n        {\n            s = period * Math.asin(1 / amplitude) / (2 * Math.PI);\n        }\n\n        return (amplitude * Math.pow(2, -10 * v) * Math.sin((v - s) * (2 * Math.PI) / period) + 1);\n    }\n};\n\nmodule.exports = Out;\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * @namespace Phaser.Math.Easing.Elastic\n */\n\nmodule.exports = {\n\n    In: require('./In'),\n    Out: require('./Out'),\n    InOut: require('./InOut')\n\n};\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * Exponential ease-in.\n *\n * @function Phaser.Math.Easing.Expo.In\n * @since 3.0.0\n *\n * @param {number} v - The value to be tweened.\n *\n * @return {number} The tweened value.\n */\nvar In = function (v)\n{\n    return Math.pow(2, 10 * (v - 1)) - 0.001;\n};\n\nmodule.exports = In;\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * Exponential ease-in/out.\n *\n * @function Phaser.Math.Easing.Expo.InOut\n * @since 3.0.0\n *\n * @param {number} v - The value to be tweened.\n *\n * @return {number} The tweened value.\n */\nvar InOut = function (v)\n{\n    if ((v *= 2) < 1)\n    {\n        return 0.5 * Math.pow(2, 10 * (v - 1));\n    }\n    else\n    {\n        return 0.5 * (2 - Math.pow(2, -10 * (v - 1)));\n    }\n};\n\nmodule.exports = InOut;\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * Exponential ease-out.\n *\n * @function Phaser.Math.Easing.Expo.Out\n * @since 3.0.0\n *\n * @param {number} v - The value to be tweened.\n *\n * @return {number} The tweened value.\n */\nvar Out = function (v)\n{\n    return 1 - Math.pow(2, -10 * v);\n};\n\nmodule.exports = Out;\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * @namespace Phaser.Math.Easing.Expo\n */\n\nmodule.exports = {\n\n    In: require('./In'),\n    Out: require('./Out'),\n    InOut: require('./InOut')\n\n};\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * @namespace Phaser.Math.Easing\n */\n\nmodule.exports = {\n\n    Back: require('./back'),\n    Bounce: require('./bounce'),\n    Circular: require('./circular'),\n    Cubic: require('./cubic'),\n    Elastic: require('./elastic'),\n    Expo: require('./expo'),\n    Linear: require('./linear'),\n    Quadratic: require('./quadratic'),\n    Quartic: require('./quartic'),\n    Quintic: require('./quintic'),\n    Sine: require('./sine'),\n    Stepped: require('./stepped')\n\n};\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * Linear easing (no variation).\n *\n * @function Phaser.Math.Easing.Linear.Linear\n * @since 3.0.0\n *\n * @param {number} v - The value to be tweened.\n *\n * @return {number} The tweened value.\n */\nvar Linear = function (v)\n{\n    return v;\n};\n\nmodule.exports = Linear;\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * @namespace Phaser.Math.Easing.Linear\n */\n\nmodule.exports = require('./Linear');\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * Quadratic ease-in.\n *\n * @function Phaser.Math.Easing.Quadratic.In\n * @since 3.0.0\n *\n * @param {number} v - The value to be tweened.\n *\n * @return {number} The tweened value.\n */\nvar In = function (v)\n{\n    return v * v;\n};\n\nmodule.exports = In;\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * Quadratic ease-in/out.\n *\n * @function Phaser.Math.Easing.Quadratic.InOut\n * @since 3.0.0\n *\n * @param {number} v - The value to be tweened.\n *\n * @return {number} The tweened value.\n */\nvar InOut = function (v)\n{\n    if ((v *= 2) < 1)\n    {\n        return 0.5 * v * v;\n    }\n    else\n    {\n        return -0.5 * (--v * (v - 2) - 1);\n    }\n};\n\nmodule.exports = InOut;\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * Quadratic ease-out.\n *\n * @function Phaser.Math.Easing.Quadratic.Out\n * @since 3.0.0\n *\n * @param {number} v - The value to be tweened.\n *\n * @return {number} The tweened value.\n */\nvar Out = function (v)\n{\n    return v * (2 - v);\n};\n\nmodule.exports = Out;\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * @namespace Phaser.Math.Easing.Quadratic\n */\n\nmodule.exports = {\n\n    In: require('./In'),\n    Out: require('./Out'),\n    InOut: require('./InOut')\n\n};\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * Quartic ease-in.\n *\n * @function Phaser.Math.Easing.Quartic.In\n * @since 3.0.0\n *\n * @param {number} v - The value to be tweened.\n *\n * @return {number} The tweened value.\n */\nvar In = function (v)\n{\n    return v * v * v * v;\n};\n\nmodule.exports = In;\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * Quartic ease-in/out.\n *\n * @function Phaser.Math.Easing.Quartic.InOut\n * @since 3.0.0\n *\n * @param {number} v - The value to be tweened.\n *\n * @return {number} The tweened value.\n */\nvar InOut = function (v)\n{\n    if ((v *= 2) < 1)\n    {\n        return 0.5 * v * v * v * v;\n    }\n    else\n    {\n        return -0.5 * ((v -= 2) * v * v * v - 2);\n    }\n};\n\nmodule.exports = InOut;\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * Quartic ease-out.\n *\n * @function Phaser.Math.Easing.Quartic.Out\n * @since 3.0.0\n *\n * @param {number} v - The value to be tweened.\n *\n * @return {number} The tweened value.\n */\nvar Out = function (v)\n{\n    return 1 - (--v * v * v * v);\n};\n\nmodule.exports = Out;\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * @namespace Phaser.Math.Easing.Quartic\n */\n\nmodule.exports = {\n\n    In: require('./In'),\n    Out: require('./Out'),\n    InOut: require('./InOut')\n\n};\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * Quintic ease-in.\n *\n * @function Phaser.Math.Easing.Quintic.In\n * @since 3.0.0\n *\n * @param {number} v - The value to be tweened.\n *\n * @return {number} The tweened value.\n */\nvar In = function (v)\n{\n    return v * v * v * v * v;\n};\n\nmodule.exports = In;\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * Quintic ease-in/out.\n *\n * @function Phaser.Math.Easing.Quintic.InOut\n * @since 3.0.0\n *\n * @param {number} v - The value to be tweened.\n *\n * @return {number} The tweened value.\n */\nvar InOut = function (v)\n{\n    if ((v *= 2) < 1)\n    {\n        return 0.5 * v * v * v * v * v;\n    }\n    else\n    {\n        return 0.5 * ((v -= 2) * v * v * v * v + 2);\n    }\n};\n\nmodule.exports = InOut;\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * Quintic ease-out.\n *\n * @function Phaser.Math.Easing.Quintic.Out\n * @since 3.0.0\n *\n * @param {number} v - The value to be tweened.\n *\n * @return {number} The tweened value.\n */\nvar Out = function (v)\n{\n    return --v * v * v * v * v + 1;\n};\n\nmodule.exports = Out;\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * @namespace Phaser.Math.Easing.Quintic\n */\n\nmodule.exports = {\n\n    In: require('./In'),\n    Out: require('./Out'),\n    InOut: require('./InOut')\n\n};\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * Sinusoidal ease-in.\n *\n * @function Phaser.Math.Easing.Sine.In\n * @since 3.0.0\n *\n * @param {number} v - The value to be tweened.\n *\n * @return {number} The tweened value.\n */\nvar In = function (v)\n{\n    if (v === 0)\n    {\n        return 0;\n    }\n    else if (v === 1)\n    {\n        return 1;\n    }\n    else\n    {\n        return 1 - Math.cos(v * Math.PI / 2);\n    }\n};\n\nmodule.exports = In;\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * Sinusoidal ease-in/out.\n *\n * @function Phaser.Math.Easing.Sine.InOut\n * @since 3.0.0\n *\n * @param {number} v - The value to be tweened.\n *\n * @return {number} The tweened value.\n */\nvar InOut = function (v)\n{\n    if (v === 0)\n    {\n        return 0;\n    }\n    else if (v === 1)\n    {\n        return 1;\n    }\n    else\n    {\n        return 0.5 * (1 - Math.cos(Math.PI * v));\n    }\n};\n\nmodule.exports = InOut;\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * Sinusoidal ease-out.\n *\n * @function Phaser.Math.Easing.Sine.Out\n * @since 3.0.0\n *\n * @param {number} v - The value to be tweened.\n *\n * @return {number} The tweened value.\n */\nvar Out = function (v)\n{\n    if (v === 0)\n    {\n        return 0;\n    }\n    else if (v === 1)\n    {\n        return 1;\n    }\n    else\n    {\n        return Math.sin(v * Math.PI / 2);\n    }\n};\n\nmodule.exports = Out;\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * @namespace Phaser.Math.Easing.Sine\n */\n\nmodule.exports = {\n\n    In: require('./In'),\n    Out: require('./Out'),\n    InOut: require('./InOut')\n\n};\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * Stepped easing.\n *\n * @function Phaser.Math.Easing.Stepped.Stepped\n * @since 3.0.0\n *\n * @param {number} v - The value to be tweened.\n * @param {number} [steps=1] - The number of steps in the ease.\n *\n * @return {number} The tweened value.\n */\nvar Stepped = function (v, steps)\n{\n    if (steps === undefined) { steps = 1; }\n\n    if (v <= 0)\n    {\n        return 0;\n    }\n    else if (v >= 1)\n    {\n        return 1;\n    }\n    else\n    {\n        return (((steps * v) | 0) + 1) * (1 / steps);\n    }\n};\n\nmodule.exports = Stepped;\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * @namespace Phaser.Math.Easing.Stepped\n */\n\nmodule.exports = require('./Stepped');\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * Calculate the fuzzy ceiling of the given value.\n *\n * @function Phaser.Math.Fuzzy.Ceil\n * @since 3.0.0\n *\n * @param {number} value - The value.\n * @param {number} [epsilon=0.0001] - The epsilon.\n *\n * @return {number} The fuzzy ceiling of the value.\n */\nvar Ceil = function (value, epsilon)\n{\n    if (epsilon === undefined) { epsilon = 0.0001; }\n\n    return Math.ceil(value - epsilon);\n};\n\nmodule.exports = Ceil;\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * Check whether the given values are fuzzily equal.\n *\n * Two numbers are fuzzily equal if their difference is less than `epsilon`.\n *\n * @function Phaser.Math.Fuzzy.Equal\n * @since 3.0.0\n *\n * @param {number} a - The first value.\n * @param {number} b - The second value.\n * @param {number} [epsilon=0.0001] - The epsilon.\n *\n * @return {boolean} `true` if the values are fuzzily equal, otherwise `false`.\n */\nvar Equal = function (a, b, epsilon)\n{\n    if (epsilon === undefined) { epsilon = 0.0001; }\n\n    return Math.abs(a - b) < epsilon;\n};\n\nmodule.exports = Equal;\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * Calculate the fuzzy floor of the given value.\n *\n * @function Phaser.Math.Fuzzy.Floor\n * @since 3.0.0\n *\n * @param {number} value - The value.\n * @param {number} [epsilon=0.0001] - The epsilon.\n *\n * @return {number} The floor of the value.\n */\nvar Floor = function (value, epsilon)\n{\n    if (epsilon === undefined) { epsilon = 0.0001; }\n\n    return Math.floor(value + epsilon);\n};\n\nmodule.exports = Floor;\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * Check whether `a` is fuzzily greater than `b`.\n *\n * `a` is fuzzily greater than `b` if it is more than `b - epsilon`.\n *\n * @function Phaser.Math.Fuzzy.GreaterThan\n * @since 3.0.0\n *\n * @param {number} a - The first value.\n * @param {number} b - The second value.\n * @param {number} [epsilon=0.0001] - The epsilon.\n *\n * @return {boolean} `true` if `a` is fuzzily greater than than `b`, otherwise `false`.\n */\nvar GreaterThan = function (a, b, epsilon)\n{\n    if (epsilon === undefined) { epsilon = 0.0001; }\n\n    return a > b - epsilon;\n};\n\nmodule.exports = GreaterThan;\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * Check whether `a` is fuzzily less than `b`.\n *\n * `a` is fuzzily less than `b` if it is less than `b + epsilon`.\n *\n * @function Phaser.Math.Fuzzy.LessThan\n * @since 3.0.0\n *\n * @param {number} a - The first value.\n * @param {number} b - The second value.\n * @param {number} [epsilon=0.0001] - The epsilon.\n *\n * @return {boolean} `true` if `a` is fuzzily less than `b`, otherwise `false`.\n */\nvar LessThan = function (a, b, epsilon)\n{\n    if (epsilon === undefined) { epsilon = 0.0001; }\n\n    return a < b + epsilon;\n};\n\nmodule.exports = LessThan;\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * @namespace Phaser.Math.Fuzzy\n */\n\nmodule.exports = {\n\n    Ceil: require('./Ceil'),\n    Equal: require('./Equal'),\n    Floor: require('./Floor'),\n    GreaterThan: require('./GreaterThan'),\n    LessThan: require('./LessThan')\n\n};\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\nvar CONST = require('./const');\nvar Extend = require('../utils/object/Extend');\n\n/**\n * @namespace Phaser.Math\n */\n\nvar PhaserMath = {\n\n    //  Collections of functions\n    Angle: require('./angle/'),\n    Distance: require('./distance/'),\n    Easing: require('./easing/'),\n    Fuzzy: require('./fuzzy/'),\n    Interpolation: require('./interpolation/'),\n    Pow2: require('./pow2/'),\n    Snap: require('./snap/'),\n\n    //  Expose the RNG Class\n    RandomDataGenerator: require('./random-data-generator/RandomDataGenerator'),\n\n    //  Single functions\n    Average: require('./Average'),\n    Bernstein: require('./Bernstein'),\n    Between: require('./Between'),\n    CatmullRom: require('./CatmullRom'),\n    CeilTo: require('./CeilTo'),\n    Clamp: require('./Clamp'),\n    DegToRad: require('./DegToRad'),\n    Difference: require('./Difference'),\n    Factorial: require('./Factorial'),\n    FloatBetween: require('./FloatBetween'),\n    FloorTo: require('./FloorTo'),\n    FromPercent: require('./FromPercent'),\n    GetSpeed: require('./GetSpeed'),\n    IsEven: require('./IsEven'),\n    IsEvenStrict: require('./IsEvenStrict'),\n    Linear: require('./Linear'),\n    MaxAdd: require('./MaxAdd'),\n    MinSub: require('./MinSub'),\n    Percent: require('./Percent'),\n    RadToDeg: require('./RadToDeg'),\n    RandomXY: require('./RandomXY'),\n    RandomXYZ: require('./RandomXYZ'),\n    RandomXYZW: require('./RandomXYZW'),\n    Rotate: require('./Rotate'),\n    RotateAround: require('./RotateAround'),\n    RotateAroundDistance: require('./RotateAroundDistance'),\n    RoundAwayFromZero: require('./RoundAwayFromZero'),\n    RoundTo: require('./RoundTo'),\n    SinCosTableGenerator: require('./SinCosTableGenerator'),\n    SmootherStep: require('./SmootherStep'),\n    SmoothStep: require('./SmoothStep'),\n    ToXY: require('./ToXY'),\n    TransformXY: require('./TransformXY'),\n    Within: require('./Within'),\n    Wrap: require('./Wrap'),\n\n    //  Vector classes\n    Vector2: require('./Vector2'),\n    Vector3: require('./Vector3'),\n    Vector4: require('./Vector4'),\n    Matrix3: require('./Matrix3'),\n    Matrix4: require('./Matrix4'),\n    Quaternion: require('./Quaternion'),\n    RotateVec3: require('./RotateVec3')\n\n};\n\n//   Merge in the consts\n\nPhaserMath = Extend(false, PhaserMath, CONST);\n\n//  Export it\n\nmodule.exports = PhaserMath;\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\nvar Bernstein = require('../Bernstein');\n\n/**\n * A bezier interpolation method.\n *\n * @function Phaser.Math.Interpolation.Bezier\n * @since 3.0.0\n *\n * @param {number[]} v - The input array of values to interpolate between.\n * @param {number} k - The percentage of interpolation, between 0 and 1.\n *\n * @return {number} The interpolated value.\n */\nvar BezierInterpolation = function (v, k)\n{\n    var b = 0;\n    var n = v.length - 1;\n\n    for (var i = 0; i <= n; i++)\n    {\n        b += Math.pow(1 - k, n - i) * Math.pow(k, i) * v[i] * Bernstein(n, i);\n    }\n\n    return b;\n};\n\nmodule.exports = BezierInterpolation;\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\nvar CatmullRom = require('../CatmullRom');\n\n/**\n * A Catmull-Rom interpolation method.\n *\n * @function Phaser.Math.Interpolation.CatmullRom\n * @since 3.0.0\n *\n * @param {number[]} v - The input array of values to interpolate between.\n * @param {number} k - The percentage of interpolation, between 0 and 1.\n *\n * @return {number} The interpolated value.\n */\nvar CatmullRomInterpolation = function (v, k)\n{\n    var m = v.length - 1;\n    var f = m * k;\n    var i = Math.floor(f);\n\n    if (v[0] === v[m])\n    {\n        if (k < 0)\n        {\n            i = Math.floor(f = m * (1 + k));\n        }\n\n        return CatmullRom(f - i, v[(i - 1 + m) % m], v[i], v[(i + 1) % m], v[(i + 2) % m]);\n    }\n    else\n    {\n        if (k < 0)\n        {\n            return v[0] - (CatmullRom(-f, v[0], v[0], v[1], v[1]) - v[0]);\n        }\n\n        if (k > 1)\n        {\n            return v[m] - (CatmullRom(f - m, v[m], v[m], v[m - 1], v[m - 1]) - v[m]);\n        }\n\n        return CatmullRom(f - i, v[i ? i - 1 : 0], v[i], v[m < i + 1 ? m : i + 1], v[m < i + 2 ? m : i + 2]);\n    }\n};\n\nmodule.exports = CatmullRomInterpolation;\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * @ignore\n */\nfunction P0 (t, p)\n{\n    var k = 1 - t;\n\n    return k * k * k * p;\n}\n\n/**\n * @ignore\n */\nfunction P1 (t, p)\n{\n    var k = 1 - t;\n\n    return 3 * k * k * t * p;\n}\n\n/**\n * @ignore\n */\nfunction P2 (t, p)\n{\n    return 3 * (1 - t) * t * t * p;\n}\n\n/**\n * @ignore\n */\nfunction P3 (t, p)\n{\n    return t * t * t * p;\n}\n\n/**\n * A cubic bezier interpolation method.\n *\n * https://medium.com/@adrian_cooney/bezier-interpolation-13b68563313a\n *\n * @function Phaser.Math.Interpolation.CubicBezier\n * @since 3.0.0\n *\n * @param {number} t - The percentage of interpolation, between 0 and 1.\n * @param {number} p0 - The start point.\n * @param {number} p1 - The first control point.\n * @param {number} p2 - The second control point.\n * @param {number} p3 - The end point.\n *\n * @return {number} The interpolated value.\n */\nvar CubicBezierInterpolation = function (t, p0, p1, p2, p3)\n{\n    return P0(t, p0) + P1(t, p1) + P2(t, p2) + P3(t, p3);\n};\n\nmodule.exports = CubicBezierInterpolation;\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\nvar Linear = require('../Linear');\n\n/**\n * A linear interpolation method.\n *\n * @function Phaser.Math.Interpolation.Linear\n * @since 3.0.0\n * @see {@link https://en.wikipedia.org/wiki/Linear_interpolation}\n *\n * @param {number[]} v - The input array of values to interpolate between.\n * @param {!number} k - The percentage of interpolation, between 0 and 1.\n *\n * @return {!number} The interpolated value.\n */\nvar LinearInterpolation = function (v, k)\n{\n    var m = v.length - 1;\n    var f = m * k;\n    var i = Math.floor(f);\n\n    if (k < 0)\n    {\n        return Linear(v[0], v[1], f);\n    }\n    else if (k > 1)\n    {\n        return Linear(v[m], v[m - 1], m - f);\n    }\n    else\n    {\n        return Linear(v[i], v[(i + 1 > m) ? m : i + 1], f - i);\n    }\n};\n\nmodule.exports = LinearInterpolation;\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * @ignore\n */\nfunction P0 (t, p)\n{\n    var k = 1 - t;\n\n    return k * k * p;\n}\n\n/**\n * @ignore\n */\nfunction P1 (t, p)\n{\n    return 2 * (1 - t) * t * p;\n}\n\n/**\n * @ignore\n */\nfunction P2 (t, p)\n{\n    return t * t * p;\n}\n\n// https://github.com/mrdoob/three.js/blob/master/src/extras/core/Interpolations.js\n\n/**\n * A quadratic bezier interpolation method.\n *\n * @function Phaser.Math.Interpolation.QuadraticBezier\n * @since 3.2.0\n *\n * @param {number} t - The percentage of interpolation, between 0 and 1.\n * @param {number} p0 - The start point.\n * @param {number} p1 - The control point.\n * @param {number} p2 - The end point.\n *\n * @return {number} The interpolated value.\n */\nvar QuadraticBezierInterpolation = function (t, p0, p1, p2)\n{\n    return P0(t, p0) + P1(t, p1) + P2(t, p2);\n};\n\nmodule.exports = QuadraticBezierInterpolation;\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\nvar SmoothStep = require('../SmoothStep');\n\n/**\n * A Smooth Step interpolation method.\n *\n * @function Phaser.Math.Interpolation.SmoothStep\n * @since 3.9.0\n * @see {@link https://en.wikipedia.org/wiki/Smoothstep}\n *\n * @param {number} t - The percentage of interpolation, between 0 and 1.\n * @param {number} min - The minimum value, also known as the 'left edge', assumed smaller than the 'right edge'.\n * @param {number} max - The maximum value, also known as the 'right edge', assumed greater than the 'left edge'.\n *\n * @return {number} The interpolated value.\n */\nvar SmoothStepInterpolation = function (t, min, max)\n{\n    return min + (max - min) * SmoothStep(t, 0, 1);\n};\n\nmodule.exports = SmoothStepInterpolation;\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\nvar SmootherStep = require('../SmootherStep');\n\n/**\n * A Smoother Step interpolation method.\n *\n * @function Phaser.Math.Interpolation.SmootherStep\n * @since 3.9.0\n * @see {@link https://en.wikipedia.org/wiki/Smoothstep#Variations}\n *\n * @param {number} t - The percentage of interpolation, between 0 and 1.\n * @param {number} min - The minimum value, also known as the 'left edge', assumed smaller than the 'right edge'.\n * @param {number} max - The maximum value, also known as the 'right edge', assumed greater than the 'left edge'.\n *\n * @return {number} The interpolated value.\n */\nvar SmootherStepInterpolation = function (t, min, max)\n{\n    return min + (max - min) * SmootherStep(t, 0, 1);\n};\n\nmodule.exports = SmootherStepInterpolation;\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * @namespace Phaser.Math.Interpolation\n */\n\nmodule.exports = {\n\n    Bezier: require('./BezierInterpolation'),\n    CatmullRom: require('./CatmullRomInterpolation'),\n    CubicBezier: require('./CubicBezierInterpolation'),\n    Linear: require('./LinearInterpolation'),\n    QuadraticBezier: require('./QuadraticBezierInterpolation'),\n    SmoothStep: require('./SmoothStepInterpolation'),\n    SmootherStep: require('./SmootherStepInterpolation')\n\n};\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * Returns the nearest power of 2 to the given `value`.\n *\n * @function Phaser.Math.Pow2.GetPowerOfTwo\n * @since 3.0.0\n *\n * @param {number} value - The value.\n *\n * @return {integer} The nearest power of 2 to `value`.\n */\nvar GetPowerOfTwo = function (value)\n{\n    var index = Math.log(value) / 0.6931471805599453;\n\n    return (1 << Math.ceil(index));\n};\n\nmodule.exports = GetPowerOfTwo;\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * Checks if the given `width` and `height` are a power of two.\n * Useful for checking texture dimensions.\n *\n * @function Phaser.Math.Pow2.IsSizePowerOfTwo\n * @since 3.0.0\n *\n * @param {number} width - The width.\n * @param {number} height - The height.\n *\n * @return {boolean} `true` if `width` and `height` are a power of two, otherwise `false`.\n */\nvar IsSizePowerOfTwo = function (width, height)\n{\n    return (width > 0 && (width & (width - 1)) === 0 && height > 0 && (height & (height - 1)) === 0);\n};\n\nmodule.exports = IsSizePowerOfTwo;\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * Tests the value and returns `true` if it is a power of two.\n *\n * @function Phaser.Math.Pow2.IsValuePowerOfTwo\n * @since 3.0.0\n *\n * @param {number} value - The value to check if it's a power of two.\n *\n * @return {boolean} Returns `true` if `value` is a power of two, otherwise `false`.\n */\nvar IsValuePowerOfTwo = function (value)\n{\n    return (value > 0 && (value & (value - 1)) === 0);\n};\n\nmodule.exports = IsValuePowerOfTwo;\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * @namespace Phaser.Math.Pow2\n */\n\nmodule.exports = {\n\n    GetNext: require('./GetPowerOfTwo'),\n    IsSize: require('./IsSizePowerOfTwo'),\n    IsValue: require('./IsValuePowerOfTwo')\n\n};\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\nvar Class = require('../../utils/Class');\n\n/**\n * @classdesc\n * A seeded Random Data Generator.\n * \n * Access via `Phaser.Math.RND` which is an instance of this class pre-defined\n * by Phaser. Or, create your own instance to use as you require.\n * \n * The `Math.RND` generator is seeded by the Game Config property value `seed`.\n * If no such config property exists, a random number is used.\n * \n * If you create your own instance of this class you should provide a seed for it.\n * If no seed is given it will use a 'random' one based on Date.now.\n *\n * @class RandomDataGenerator\n * @memberof Phaser.Math\n * @constructor\n * @since 3.0.0\n *\n * @param {(string|string[])} [seeds] - The seeds to use for the random number generator.\n */\nvar RandomDataGenerator = new Class({\n\n    initialize:\n\n    function RandomDataGenerator (seeds)\n    {\n        if (seeds === undefined) { seeds = [ (Date.now() * Math.random()).toString() ]; }\n\n        /**\n         * Internal var.\n         *\n         * @name Phaser.Math.RandomDataGenerator#c\n         * @type {number}\n         * @default 1\n         * @private\n         * @since 3.0.0\n         */\n        this.c = 1;\n\n        /**\n         * Internal var.\n         *\n         * @name Phaser.Math.RandomDataGenerator#s0\n         * @type {number}\n         * @default 0\n         * @private\n         * @since 3.0.0\n         */\n        this.s0 = 0;\n\n        /**\n         * Internal var.\n         *\n         * @name Phaser.Math.RandomDataGenerator#s1\n         * @type {number}\n         * @default 0\n         * @private\n         * @since 3.0.0\n         */\n        this.s1 = 0;\n\n        /**\n         * Internal var.\n         *\n         * @name Phaser.Math.RandomDataGenerator#s2\n         * @type {number}\n         * @default 0\n         * @private\n         * @since 3.0.0\n         */\n        this.s2 = 0;\n\n        /**\n         * Internal var.\n         *\n         * @name Phaser.Math.RandomDataGenerator#n\n         * @type {number}\n         * @default 0\n         * @private\n         * @since 3.2.0\n         */\n        this.n = 0;\n\n        /**\n         * Signs to choose from.\n         *\n         * @name Phaser.Math.RandomDataGenerator#signs\n         * @type {number[]}\n         * @since 3.0.0\n         */\n        this.signs = [ -1, 1 ];\n\n        if (seeds)\n        {\n            this.init(seeds);\n        }\n    },\n\n    /**\n     * Private random helper.\n     *\n     * @method Phaser.Math.RandomDataGenerator#rnd\n     * @since 3.0.0\n     * @private\n     *\n     * @return {number} A random number.\n     */\n    rnd: function ()\n    {\n        var t = 2091639 * this.s0 + this.c * 2.3283064365386963e-10; // 2^-32\n\n        this.c = t | 0;\n        this.s0 = this.s1;\n        this.s1 = this.s2;\n        this.s2 = t - this.c;\n\n        return this.s2;\n    },\n\n    /**\n     * Internal method that creates a seed hash.\n     *\n     * @method Phaser.Math.RandomDataGenerator#hash\n     * @since 3.0.0\n     * @private\n     *\n     * @param {string} data - The value to hash.\n     *\n     * @return {number} The hashed value.\n     */\n    hash: function (data)\n    {\n        var h;\n        var n = this.n;\n\n        data = data.toString();\n\n        for (var i = 0; i < data.length; i++)\n        {\n            n += data.charCodeAt(i);\n            h = 0.02519603282416938 * n;\n            n = h >>> 0;\n            h -= n;\n            h *= n;\n            n = h >>> 0;\n            h -= n;\n            n += h * 0x100000000;// 2^32\n        }\n\n        this.n = n;\n\n        return (n >>> 0) * 2.3283064365386963e-10;// 2^-32\n    },\n\n    /**\n     * Initialize the state of the random data generator.\n     *\n     * @method Phaser.Math.RandomDataGenerator#init\n     * @since 3.0.0\n     *\n     * @param {(string|string[])} seeds - The seeds to initialize the random data generator with.\n     */\n    init: function (seeds)\n    {\n        if (typeof seeds === 'string')\n        {\n            this.state(seeds);\n        }\n        else\n        {\n            this.sow(seeds);\n        }\n    },\n\n    /**\n     * Reset the seed of the random data generator.\n     *\n     * _Note_: the seed array is only processed up to the first `undefined` (or `null`) value, should such be present.\n     *\n     * @method Phaser.Math.RandomDataGenerator#sow\n     * @since 3.0.0\n     *\n     * @param {string[]} seeds - The array of seeds: the `toString()` of each value is used.\n     */\n    sow: function (seeds)\n    {\n        // Always reset to default seed\n        this.n = 0xefc8249d;\n        this.s0 = this.hash(' ');\n        this.s1 = this.hash(' ');\n        this.s2 = this.hash(' ');\n        this.c = 1;\n\n        if (!seeds)\n        {\n            return;\n        }\n\n        // Apply any seeds\n        for (var i = 0; i < seeds.length && (seeds[i] != null); i++)\n        {\n            var seed = seeds[i];\n\n            this.s0 -= this.hash(seed);\n            this.s0 += ~~(this.s0 < 0);\n            this.s1 -= this.hash(seed);\n            this.s1 += ~~(this.s1 < 0);\n            this.s2 -= this.hash(seed);\n            this.s2 += ~~(this.s2 < 0);\n        }\n    },\n\n    /**\n     * Returns a random integer between 0 and 2^32.\n     *\n     * @method Phaser.Math.RandomDataGenerator#integer\n     * @since 3.0.0\n     *\n     * @return {number} A random integer between 0 and 2^32.\n     */\n    integer: function ()\n    {\n        // 2^32\n        return this.rnd() * 0x100000000;\n    },\n\n    /**\n     * Returns a random real number between 0 and 1.\n     *\n     * @method Phaser.Math.RandomDataGenerator#frac\n     * @since 3.0.0\n     *\n     * @return {number} A random real number between 0 and 1.\n     */\n    frac: function ()\n    {\n        // 2^-53\n        return this.rnd() + (this.rnd() * 0x200000 | 0) * 1.1102230246251565e-16;\n    },\n\n    /**\n     * Returns a random real number between 0 and 2^32.\n     *\n     * @method Phaser.Math.RandomDataGenerator#real\n     * @since 3.0.0\n     *\n     * @return {number} A random real number between 0 and 2^32.\n     */\n    real: function ()\n    {\n        return this.integer() + this.frac();\n    },\n\n    /**\n     * Returns a random integer between and including min and max.\n     *\n     * @method Phaser.Math.RandomDataGenerator#integerInRange\n     * @since 3.0.0\n     *\n     * @param {number} min - The minimum value in the range.\n     * @param {number} max - The maximum value in the range.\n     *\n     * @return {number} A random number between min and max.\n     */\n    integerInRange: function (min, max)\n    {\n        return Math.floor(this.realInRange(0, max - min + 1) + min);\n    },\n\n    /**\n     * Returns a random integer between and including min and max.\n     * This method is an alias for RandomDataGenerator.integerInRange.\n     *\n     * @method Phaser.Math.RandomDataGenerator#between\n     * @since 3.0.0\n     *\n     * @param {number} min - The minimum value in the range.\n     * @param {number} max - The maximum value in the range.\n     *\n     * @return {number} A random number between min and max.\n     */\n    between: function (min, max)\n    {\n        return Math.floor(this.realInRange(0, max - min + 1) + min);\n    },\n\n    /**\n     * Returns a random real number between min and max.\n     *\n     * @method Phaser.Math.RandomDataGenerator#realInRange\n     * @since 3.0.0\n     *\n     * @param {number} min - The minimum value in the range.\n     * @param {number} max - The maximum value in the range.\n     *\n     * @return {number} A random number between min and max.\n     */\n    realInRange: function (min, max)\n    {\n        return this.frac() * (max - min) + min;\n    },\n\n    /**\n     * Returns a random real number between -1 and 1.\n     *\n     * @method Phaser.Math.RandomDataGenerator#normal\n     * @since 3.0.0\n     *\n     * @return {number} A random real number between -1 and 1.\n     */\n    normal: function ()\n    {\n        return 1 - (2 * this.frac());\n    },\n\n    /**\n     * Returns a valid RFC4122 version4 ID hex string from https://gist.github.com/1308368\n     *\n     * @method Phaser.Math.RandomDataGenerator#uuid\n     * @since 3.0.0\n     *\n     * @return {string} A valid RFC4122 version4 ID hex string\n     */\n    uuid: function ()\n    {\n        var a = '';\n        var b = '';\n\n        for (b = a = ''; a++ < 36; b += ~a % 5 | a * 3 & 4 ? (a ^ 15 ? 8 ^ this.frac() * (a ^ 20 ? 16 : 4) : 4).toString(16) : '-')\n        {\n            // eslint-disable-next-line no-empty\n        }\n\n        return b;\n    },\n\n    /**\n     * Returns a random element from within the given array.\n     *\n     * @method Phaser.Math.RandomDataGenerator#pick\n     * @since 3.0.0\n     *\n     * @param {array} array - The array to pick a random element from.\n     *\n     * @return {*} A random member of the array.\n     */\n    pick: function (array)\n    {\n        return array[this.integerInRange(0, array.length - 1)];\n    },\n\n    /**\n     * Returns a sign to be used with multiplication operator.\n     *\n     * @method Phaser.Math.RandomDataGenerator#sign\n     * @since 3.0.0\n     *\n     * @return {number} -1 or +1.\n     */\n    sign: function ()\n    {\n        return this.pick(this.signs);\n    },\n\n    /**\n     * Returns a random element from within the given array, favoring the earlier entries.\n     *\n     * @method Phaser.Math.RandomDataGenerator#weightedPick\n     * @since 3.0.0\n     *\n     * @param {array} array - The array to pick a random element from.\n     *\n     * @return {*} A random member of the array.\n     */\n    weightedPick: function (array)\n    {\n        return array[~~(Math.pow(this.frac(), 2) * (array.length - 1) + 0.5)];\n    },\n\n    /**\n     * Returns a random timestamp between min and max, or between the beginning of 2000 and the end of 2020 if min and max aren't specified.\n     *\n     * @method Phaser.Math.RandomDataGenerator#timestamp\n     * @since 3.0.0\n     *\n     * @param {number} min - The minimum value in the range.\n     * @param {number} max - The maximum value in the range.\n     *\n     * @return {number} A random timestamp between min and max.\n     */\n    timestamp: function (min, max)\n    {\n        return this.realInRange(min || 946684800000, max || 1577862000000);\n    },\n\n    /**\n     * Returns a random angle between -180 and 180.\n     *\n     * @method Phaser.Math.RandomDataGenerator#angle\n     * @since 3.0.0\n     *\n     * @return {number} A random number between -180 and 180.\n     */\n    angle: function ()\n    {\n        return this.integerInRange(-180, 180);\n    },\n\n    /**\n     * Returns a random rotation in radians, between -3.141 and 3.141\n     *\n     * @method Phaser.Math.RandomDataGenerator#rotation\n     * @since 3.0.0\n     *\n     * @return {number} A random number between -3.141 and 3.141\n     */\n    rotation: function ()\n    {\n        return this.realInRange(-3.1415926, 3.1415926);\n    },\n\n    /**\n     * Gets or Sets the state of the generator. This allows you to retain the values\n     * that the generator is using between games, i.e. in a game save file.\n     *\n     * To seed this generator with a previously saved state you can pass it as the\n     * `seed` value in your game config, or call this method directly after Phaser has booted.\n     *\n     * Call this method with no parameters to return the current state.\n     *\n     * If providing a state it should match the same format that this method\n     * returns, which is a string with a header `!rnd` followed by the `c`,\n     * `s0`, `s1` and `s2` values respectively, each comma-delimited.\n     *\n     * @method Phaser.Math.RandomDataGenerator#state\n     * @since 3.0.0\n     *\n     * @param {string} [state] - Generator state to be set.\n     *\n     * @return {string} The current state of the generator.\n     */\n    state: function (state)\n    {\n        if (typeof state === 'string' && state.match(/^!rnd/))\n        {\n            state = state.split(',');\n\n            this.c = parseFloat(state[1]);\n            this.s0 = parseFloat(state[2]);\n            this.s1 = parseFloat(state[3]);\n            this.s2 = parseFloat(state[4]);\n        }\n\n        return [ '!rnd', this.c, this.s0, this.s1, this.s2 ].join(',');\n    },\n\n    /**\n     * Shuffles the given array, using the current seed.\n     *\n     * @method Phaser.Math.RandomDataGenerator#shuffle\n     * @since 3.7.0\n     *\n     * @param {array} [array] - The array to be shuffled.\n     *\n     * @return {array} The shuffled array.\n     */\n    shuffle: function (array)\n    {\n        var len = array.length - 1;\n\n        for (var i = len; i > 0; i--)\n        {\n            var randomIndex = Math.floor(this.frac() * (i + 1));\n            var itemAtIndex = array[randomIndex];\n\n            array[randomIndex] = array[i];\n            array[i] = itemAtIndex;\n        }\n\n        return array;\n    }\n\n});\n\nmodule.exports = RandomDataGenerator;\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * Snap a value to nearest grid slice, using ceil.\n *\n * Example: if you have an interval gap of `5` and a position of `12`... you will snap to `15`.\n * As will `14` snap to `15`... but `16` will snap to `20`.\n *\n * @function Phaser.Math.Snap.Ceil\n * @since 3.0.0\n *\n * @param {number} value - The value to snap.\n * @param {number} gap - The interval gap of the grid.\n * @param {number} [start=0] - Optional starting offset for gap.\n * @param {boolean} [divide=false] - If `true` it will divide the snapped value by the gap before returning.\n *\n * @return {number} The snapped value.\n */\nvar SnapCeil = function (value, gap, start, divide)\n{\n    if (start === undefined) { start = 0; }\n\n    if (gap === 0)\n    {\n        return value;\n    }\n\n    value -= start;\n    value = gap * Math.ceil(value / gap);\n\n    return (divide) ? (start + value) / gap : start + value;\n};\n\nmodule.exports = SnapCeil;\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * Snap a value to nearest grid slice, using floor.\n *\n * Example: if you have an interval gap of `5` and a position of `12`... you will snap to `10`.\n * As will `14` snap to `10`... but `16` will snap to `15`.\n *\n * @function Phaser.Math.Snap.Floor\n * @since 3.0.0\n *\n * @param {number} value - The value to snap.\n * @param {number} gap - The interval gap of the grid.\n * @param {number} [start=0] - Optional starting offset for gap.\n * @param {boolean} [divide=false] - If `true` it will divide the snapped value by the gap before returning.\n *\n * @return {number} The snapped value.\n */\nvar SnapFloor = function (value, gap, start, divide)\n{\n    if (start === undefined) { start = 0; }\n\n    if (gap === 0)\n    {\n        return value;\n    }\n\n    value -= start;\n    value = gap * Math.floor(value / gap);\n\n    return (divide) ? (start + value) / gap : start + value;\n};\n\nmodule.exports = SnapFloor;\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * Snap a value to nearest grid slice, using rounding.\n *\n * Example: if you have an interval gap of `5` and a position of `12`... you will snap to `10` whereas `14` will snap to `15`.\n *\n * @function Phaser.Math.Snap.To\n * @since 3.0.0\n *\n * @param {number} value - The value to snap.\n * @param {number} gap - The interval gap of the grid.\n * @param {number} [start=0] - Optional starting offset for gap.\n * @param {boolean} [divide=false] - If `true` it will divide the snapped value by the gap before returning.\n *\n * @return {number} The snapped value.\n */\nvar SnapTo = function (value, gap, start, divide)\n{\n    if (start === undefined) { start = 0; }\n\n    if (gap === 0)\n    {\n        return value;\n    }\n\n    value -= start;\n    value = gap * Math.round(value / gap);\n\n    return (divide) ? (start + value) / gap : start + value;\n};\n\nmodule.exports = SnapTo;\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * @namespace Phaser.Math.Snap\n */\n\nmodule.exports = {\n\n    Ceil: require('./SnapCeil'),\n    Floor: require('./SnapFloor'),\n    To: require('./SnapTo')\n\n};\n","/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2019 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser3-plugin-template/blob/master/LICENSE|MIT License}\n*/\n\nvar Class = require('../utils/Class');\n\n/**\n * @classdesc\n * A Global Plugin is installed just once into the Game owned Plugin Manager.\n * It can listen for Game events and respond to them.\n *\n * @class BasePlugin\n * @memberof Phaser.Plugins\n * @constructor\n * @since 3.8.0\n *\n * @param {Phaser.Plugins.PluginManager} pluginManager - A reference to the Plugin Manager.\n */\nvar BasePlugin = new Class({\n\n    initialize:\n\n    function BasePlugin (pluginManager)\n    {\n        /**\n         * A handy reference to the Plugin Manager that is responsible for this plugin.\n         * Can be used as a route to gain access to game systems and  events.\n         *\n         * @name Phaser.Plugins.BasePlugin#pluginManager\n         * @type {Phaser.Plugins.PluginManager}\n         * @protected\n         * @since 3.8.0\n         */\n        this.pluginManager = pluginManager;\n\n        /**\n         * A reference to the Game instance this plugin is running under.\n         *\n         * @name Phaser.Plugins.BasePlugin#game\n         * @type {Phaser.Game}\n         * @protected\n         * @since 3.8.0\n         */\n        this.game = pluginManager.game;\n\n        /**\n         * A reference to the Scene that has installed this plugin.\n         * Only set if it's a Scene Plugin, otherwise `null`.\n         * This property is only set when the plugin is instantiated and added to the Scene, not before.\n         * You cannot use it during the `init` method, but you can during the `boot` method.\n         *\n         * @name Phaser.Plugins.BasePlugin#scene\n         * @type {?Phaser.Scene}\n         * @protected\n         * @since 3.8.0\n         */\n        this.scene;\n\n        /**\n         * A reference to the Scene Systems of the Scene that has installed this plugin.\n         * Only set if it's a Scene Plugin, otherwise `null`.\n         * This property is only set when the plugin is instantiated and added to the Scene, not before.\n         * You cannot use it during the `init` method, but you can during the `boot` method.\n         *\n         * @name Phaser.Plugins.BasePlugin#systems\n         * @type {?Phaser.Scenes.Systems}\n         * @protected\n         * @since 3.8.0\n         */\n        this.systems;\n    },\n\n    /**\n     * Called by the PluginManager when this plugin is first instantiated.\n     * It will never be called again on this instance.\n     * In here you can set-up whatever you need for this plugin to run.\n     * If a plugin is set to automatically start then `BasePlugin.start` will be called immediately after this.\n     *\n     * @method Phaser.Plugins.BasePlugin#init\n     * @since 3.8.0\n     *\n     * @param {?any} [data] - A value specified by the user, if any, from the `data` property of the plugin's configuration object (if started at game boot) or passed in the PluginManager's `install` method (if started manually).\n     */\n    init: function ()\n    {\n    },\n\n    /**\n     * Called by the PluginManager when this plugin is started.\n     * If a plugin is stopped, and then started again, this will get called again.\n     * Typically called immediately after `BasePlugin.init`.\n     *\n     * @method Phaser.Plugins.BasePlugin#start\n     * @since 3.8.0\n     */\n    start: function ()\n    {\n        //  Here are the game-level events you can listen to.\n        //  At the very least you should offer a destroy handler for when the game closes down.\n\n        // var eventEmitter = this.game.events;\n\n        // eventEmitter.once('destroy', this.gameDestroy, this);\n        // eventEmitter.on('pause', this.gamePause, this);\n        // eventEmitter.on('resume', this.gameResume, this);\n        // eventEmitter.on('resize', this.gameResize, this);\n        // eventEmitter.on('prestep', this.gamePreStep, this);\n        // eventEmitter.on('step', this.gameStep, this);\n        // eventEmitter.on('poststep', this.gamePostStep, this);\n        // eventEmitter.on('prerender', this.gamePreRender, this);\n        // eventEmitter.on('postrender', this.gamePostRender, this);\n    },\n\n    /**\n     * Called by the PluginManager when this plugin is stopped.\n     * The game code has requested that your plugin stop doing whatever it does.\n     * It is now considered as 'inactive' by the PluginManager.\n     * Handle that process here (i.e. stop listening for events, etc)\n     * If the plugin is started again then `BasePlugin.start` will be called again.\n     *\n     * @method Phaser.Plugins.BasePlugin#stop\n     * @since 3.8.0\n     */\n    stop: function ()\n    {\n    },\n\n    /**\n     * If this is a Scene Plugin (i.e. installed into a Scene) then this method is called when the Scene boots.\n     * By this point the plugin properties `scene` and `systems` will have already been set.\n     * In here you can listen for Scene events and set-up whatever you need for this plugin to run.\n     *\n     * @method Phaser.Plugins.BasePlugin#boot\n     * @since 3.8.0\n     */\n    boot: function ()\n    {\n        //  Here are the Scene events you can listen to.\n        //  At the very least you should offer a destroy handler for when the Scene closes down.\n\n        // var eventEmitter = this.systems.events;\n\n        // eventEmitter.once('destroy', this.sceneDestroy, this);\n        // eventEmitter.on('start', this.sceneStart, this);\n        // eventEmitter.on('preupdate', this.scenePreUpdate, this);\n        // eventEmitter.on('update', this.sceneUpdate, this);\n        // eventEmitter.on('postupdate', this.scenePostUpdate, this);\n        // eventEmitter.on('pause', this.scenePause, this);\n        // eventEmitter.on('resume', this.sceneResume, this);\n        // eventEmitter.on('sleep', this.sceneSleep, this);\n        // eventEmitter.on('wake', this.sceneWake, this);\n        // eventEmitter.on('shutdown', this.sceneShutdown, this);\n        // eventEmitter.on('destroy', this.sceneDestroy, this);\n    },\n\n    /**\n     * Game instance has been destroyed.\n     * You must release everything in here, all references, all objects, free it all up.\n     *\n     * @method Phaser.Plugins.BasePlugin#destroy\n     * @since 3.8.0\n     */\n    destroy: function ()\n    {\n        this.pluginManager = null;\n        this.game = null;\n        this.scene = null;\n        this.systems = null;\n    }\n\n});\n\nmodule.exports = BasePlugin;\n","/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2019 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser3-plugin-template/blob/master/LICENSE|MIT License}\n*/\n\nvar BasePlugin = require('./BasePlugin');\nvar Class = require('../utils/Class');\nvar SceneEvents = require('../scene/events');\n\n/**\n * @classdesc\n * A Scene Level Plugin is installed into every Scene and belongs to that Scene.\n * It can listen for Scene events and respond to them.\n * It can map itself to a Scene property, or into the Scene Systems, or both.\n *\n * @class ScenePlugin\n * @memberof Phaser.Plugins\n * @extends Phaser.Plugins.BasePlugin\n * @constructor\n * @since 3.8.0\n *\n * @param {Phaser.Scene} scene - A reference to the Scene that has installed this plugin.\n * @param {Phaser.Plugins.PluginManager} pluginManager - A reference to the Plugin Manager.\n */\nvar ScenePlugin = new Class({\n\n    Extends: BasePlugin,\n\n    initialize:\n\n    function ScenePlugin (scene, pluginManager)\n    {\n        BasePlugin.call(this, pluginManager);\n\n        this.scene = scene;\n        this.systems = scene.sys;\n\n        scene.sys.events.once(SceneEvents.BOOT, this.boot, this);\n    },\n\n    /**\n     * This method is called when the Scene boots. It is only ever called once.\n     * \n     * By this point the plugin properties `scene` and `systems` will have already been set.\n     * \n     * In here you can listen for Scene events and set-up whatever you need for this plugin to run.\n     * Here are the Scene events you can listen to:\n     * \n     * start\n     * ready\n     * preupdate\n     * update\n     * postupdate\n     * resize\n     * pause\n     * resume\n     * sleep\n     * wake\n     * transitioninit\n     * transitionstart\n     * transitioncomplete\n     * transitionout\n     * shutdown\n     * destroy\n     * \n     * At the very least you should offer a destroy handler for when the Scene closes down, i.e:\n     *\n     * ```javascript\n     * var eventEmitter = this.systems.events;\n     * eventEmitter.once('destroy', this.sceneDestroy, this);\n     * ```\n     *\n     * @method Phaser.Plugins.ScenePlugin#boot\n     * @since 3.8.0\n     */\n    boot: function ()\n    {\n    }\n\n});\n\nmodule.exports = ScenePlugin;\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * Phaser Blend Modes.\n * \n * @namespace Phaser.BlendModes\n * @since 3.0.0\n */\n\nmodule.exports = {\n\n    /**\n     * Skips the Blend Mode check in the renderer.\n     * \n     * @name Phaser.BlendModes.SKIP_CHECK\n     * @type {integer}\n     * @const\n     * @since 3.0.0\n     */\n    SKIP_CHECK: -1,\n\n    /**\n     * Normal blend mode. For Canvas and WebGL.\n     * This is the default setting and draws new shapes on top of the existing canvas content.\n     * \n     * @name Phaser.BlendModes.NORMAL\n     * @type {integer}\n     * @const\n     * @since 3.0.0\n     */\n    NORMAL: 0,\n\n    /**\n     * Add blend mode. For Canvas and WebGL.\n     * Where both shapes overlap the color is determined by adding color values.\n     * \n     * @name Phaser.BlendModes.ADD\n     * @type {integer}\n     * @const\n     * @since 3.0.0\n     */\n    ADD: 1,\n\n    /**\n     * Multiply blend mode. For Canvas and WebGL.\n     * The pixels are of the top layer are multiplied with the corresponding pixel of the bottom layer. A darker picture is the result.\n     * \n     * @name Phaser.BlendModes.MULTIPLY\n     * @type {integer}\n     * @const\n     * @since 3.0.0\n     */\n    MULTIPLY: 2,\n\n    /**\n     * Screen blend mode. For Canvas and WebGL.\n     * The pixels are inverted, multiplied, and inverted again. A lighter picture is the result (opposite of multiply)\n     * \n     * @name Phaser.BlendModes.SCREEN\n     * @type {integer}\n     * @const\n     * @since 3.0.0\n     */\n    SCREEN: 3,\n\n    /**\n     * Overlay blend mode. For Canvas only.\n     * A combination of multiply and screen. Dark parts on the base layer become darker, and light parts become lighter.\n     * \n     * @name Phaser.BlendModes.OVERLAY\n     * @type {integer}\n     * @const\n     * @since 3.0.0\n     */\n    OVERLAY: 4,\n\n    /**\n     * Darken blend mode. For Canvas only.\n     * Retains the darkest pixels of both layers.\n     * \n     * @name Phaser.BlendModes.DARKEN\n     * @type {integer}\n     * @const\n     * @since 3.0.0\n     */\n    DARKEN: 5,\n\n    /**\n     * Lighten blend mode. For Canvas only.\n     * Retains the lightest pixels of both layers.\n     * \n     * @name Phaser.BlendModes.LIGHTEN\n     * @type {integer}\n     * @const\n     * @since 3.0.0\n     */\n    LIGHTEN: 6,\n\n    /**\n     * Color Dodge blend mode. For Canvas only.\n     * Divides the bottom layer by the inverted top layer.\n     * \n     * @name Phaser.BlendModes.COLOR_DODGE\n     * @type {integer}\n     * @const\n     * @since 3.0.0\n     */\n    COLOR_DODGE: 7,\n\n    /**\n     * Color Burn blend mode. For Canvas only.\n     * Divides the inverted bottom layer by the top layer, and then inverts the result.\n     * \n     * @name Phaser.BlendModes.COLOR_BURN\n     * @type {integer}\n     * @const\n     * @since 3.0.0\n     */\n    COLOR_BURN: 8,\n\n    /**\n     * Hard Light blend mode. For Canvas only.\n     * A combination of multiply and screen like overlay, but with top and bottom layer swapped.\n     * \n     * @name Phaser.BlendModes.HARD_LIGHT\n     * @type {integer}\n     * @const\n     * @since 3.0.0\n     */\n    HARD_LIGHT: 9,\n\n    /**\n     * Soft Light blend mode. For Canvas only.\n     * A softer version of hard-light. Pure black or white does not result in pure black or white.\n     * \n     * @name Phaser.BlendModes.SOFT_LIGHT\n     * @type {integer}\n     * @const\n     * @since 3.0.0\n     */\n    SOFT_LIGHT: 10,\n\n    /**\n     * Difference blend mode. For Canvas only.\n     * Subtracts the bottom layer from the top layer or the other way round to always get a positive value.\n     * \n     * @name Phaser.BlendModes.DIFFERENCE\n     * @type {integer}\n     * @const\n     * @since 3.0.0\n     */\n    DIFFERENCE: 11,\n\n    /**\n     * Exclusion blend mode. For Canvas only.\n     * Like difference, but with lower contrast.\n     * \n     * @name Phaser.BlendModes.EXCLUSION\n     * @type {integer}\n     * @const\n     * @since 3.0.0\n     */\n    EXCLUSION: 12,\n\n    /**\n     * Hue blend mode. For Canvas only.\n     * Preserves the luma and chroma of the bottom layer, while adopting the hue of the top layer.\n     * \n     * @name Phaser.BlendModes.HUE\n     * @type {integer}\n     * @const\n     * @since 3.0.0\n     */\n    HUE: 13,\n\n    /**\n     * Saturation blend mode. For Canvas only.\n     * Preserves the luma and hue of the bottom layer, while adopting the chroma of the top layer.\n     * \n     * @name Phaser.BlendModes.SATURATION\n     * @type {integer}\n     * @const\n     * @since 3.0.0\n     */\n    SATURATION: 14,\n\n    /**\n     * Color blend mode. For Canvas only.\n     * Preserves the luma of the bottom layer, while adopting the hue and chroma of the top layer.\n     * \n     * @name Phaser.BlendModes.COLOR\n     * @type {integer}\n     * @const\n     * @since 3.0.0\n     */\n    COLOR: 15,\n\n    /**\n     * Luminosity blend mode. For Canvas only.\n     * Preserves the hue and chroma of the bottom layer, while adopting the luma of the top layer.\n     * \n     * @name Phaser.BlendModes.LUMINOSITY\n     * @type {integer}\n     * @const\n     * @since 3.0.0\n     */\n    LUMINOSITY: 16,\n\n    /**\n     * Alpha erase blend mode. For Canvas and WebGL.\n     * \n     * @name Phaser.BlendModes.ERASE\n     * @type {integer}\n     * @const\n     * @since 3.0.0\n     */\n    ERASE: 17,\n\n    /**\n     * Source-in blend mode. For Canvas only.\n     * The new shape is drawn only where both the new shape and the destination canvas overlap. Everything else is made transparent.\n     * \n     * @name Phaser.BlendModes.SOURCE_IN\n     * @type {integer}\n     * @const\n     * @since 3.0.0\n     */\n    SOURCE_IN: 18,\n\n    /**\n     * Source-out blend mode. For Canvas only.\n     * The new shape is drawn where it doesn't overlap the existing canvas content.\n     * \n     * @name Phaser.BlendModes.SOURCE_OUT\n     * @type {integer}\n     * @const\n     * @since 3.0.0\n     */\n    SOURCE_OUT: 19,\n\n    /**\n     * Source-out blend mode. For Canvas only.\n     * The new shape is only drawn where it overlaps the existing canvas content.\n     * \n     * @name Phaser.BlendModes.SOURCE_ATOP\n     * @type {integer}\n     * @const\n     * @since 3.0.0\n     */\n    SOURCE_ATOP: 20,\n\n    /**\n     * Destination-over blend mode. For Canvas only.\n     * New shapes are drawn behind the existing canvas content.\n     * \n     * @name Phaser.BlendModes.DESTINATION_OVER\n     * @type {integer}\n     * @const\n     * @since 3.0.0\n     */\n    DESTINATION_OVER: 21,\n\n    /**\n     * Destination-in blend mode. For Canvas only.\n     * The existing canvas content is kept where both the new shape and existing canvas content overlap. Everything else is made transparent.\n     * \n     * @name Phaser.BlendModes.DESTINATION_IN\n     * @type {integer}\n     * @const\n     * @since 3.0.0\n     */\n    DESTINATION_IN: 22,\n\n    /**\n     * Destination-out blend mode. For Canvas only.\n     * The existing content is kept where it doesn't overlap the new shape.\n     * \n     * @name Phaser.BlendModes.DESTINATION_OUT\n     * @type {integer}\n     * @const\n     * @since 3.0.0\n     */\n    DESTINATION_OUT: 23,\n\n    /**\n     * Destination-out blend mode. For Canvas only.\n     * The existing canvas is only kept where it overlaps the new shape. The new shape is drawn behind the canvas content.\n     * \n     * @name Phaser.BlendModes.DESTINATION_ATOP\n     * @type {integer}\n     * @const\n     * @since 3.0.0\n     */\n    DESTINATION_ATOP: 24,\n\n    /**\n     * Lighten blend mode. For Canvas only.\n     * Where both shapes overlap the color is determined by adding color values.\n     * \n     * @name Phaser.BlendModes.LIGHTER\n     * @type {integer}\n     * @const\n     * @since 3.0.0\n     */\n    LIGHTER: 25,\n\n    /**\n     * Copy blend mode. For Canvas only.\n     * Only the new shape is shown.\n     * \n     * @name Phaser.BlendModes.COPY\n     * @type {integer}\n     * @const\n     * @since 3.0.0\n     */\n    COPY: 26,\n\n    /**\n     * Xor blend mode. For Canvas only.\n     * Shapes are made transparent where both overlap and drawn normal everywhere else.\n     * \n     * @name Phaser.BlendModes.XOR\n     * @type {integer}\n     * @const\n     * @since 3.0.0\n     */\n    XOR: 27\n\n};\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * Phaser Scale Modes.\n * \n * @namespace Phaser.ScaleModes\n * @since 3.0.0\n */\n\nvar ScaleModes = {\n\n    /**\n     * Default Scale Mode (Linear).\n     * \n     * @name Phaser.ScaleModes.DEFAULT\n     * @type {integer}\n     * @readonly\n     * @since 3.0.0\n     */\n    DEFAULT: 0,\n\n    /**\n     * Linear Scale Mode.\n     * \n     * @name Phaser.ScaleModes.LINEAR\n     * @type {integer}\n     * @readonly\n     * @since 3.0.0\n     */\n    LINEAR: 0,\n\n    /**\n     * Nearest Scale Mode.\n     * \n     * @name Phaser.ScaleModes.NEAREST\n     * @type {integer}\n     * @readonly\n     * @since 3.0.0\n     */\n    NEAREST: 1\n\n};\n\nmodule.exports = ScaleModes;\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * Takes a reference to the Canvas Renderer, a Canvas Rendering Context, a Game Object, a Camera and a parent matrix\n * and then performs the following steps:\n * \n * 1. Checks the alpha of the source combined with the Camera alpha. If 0 or less it aborts.\n * 2. Takes the Camera and Game Object matrix and multiplies them, combined with the parent matrix if given.\n * 3. Sets the blend mode of the context to be that used by the Game Object.\n * 4. Sets the alpha value of the context to be that used by the Game Object combined with the Camera.\n * 5. Saves the context state.\n * 6. Sets the final matrix values into the context via setTransform.\n * \n * This function is only meant to be used internally. Most of the Canvas Renderer classes use it.\n *\n * @function Phaser.Renderer.Canvas.SetTransform\n * @since 3.12.0\n *\n * @param {Phaser.Renderer.Canvas.CanvasRenderer} renderer - A reference to the current active Canvas renderer.\n * @param {CanvasRenderingContext2D} ctx - The canvas context to set the transform on.\n * @param {Phaser.GameObjects.GameObject} src - The Game Object being rendered. Can be any type that extends the base class.\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\n * @param {Phaser.GameObjects.Components.TransformMatrix} [parentMatrix] - A parent transform matrix to apply to the Game Object before rendering.\n * \n * @return {boolean} `true` if the Game Object context was set, otherwise `false`.\n */\nvar SetTransform = function (renderer, ctx, src, camera, parentMatrix)\n{\n    var alpha = camera.alpha * src.alpha;\n\n    if (alpha <= 0)\n    {\n        //  Nothing to see, so don't waste time calculating stuff\n        return false;\n    }\n\n    var camMatrix = renderer._tempMatrix1.copyFromArray(camera.matrix.matrix);\n    var gameObjectMatrix = renderer._tempMatrix2.applyITRS(src.x, src.y, src.rotation, src.scaleX, src.scaleY);\n    var calcMatrix = renderer._tempMatrix3;\n\n    if (parentMatrix)\n    {\n        //  Multiply the camera by the parent matrix\n        camMatrix.multiplyWithOffset(parentMatrix, -camera.scrollX * src.scrollFactorX, -camera.scrollY * src.scrollFactorY);\n\n        //  Undo the camera scroll\n        gameObjectMatrix.e = src.x;\n        gameObjectMatrix.f = src.y;\n\n        //  Multiply by the Sprite matrix, store result in calcMatrix\n        camMatrix.multiply(gameObjectMatrix, calcMatrix);\n    }\n    else\n    {\n        gameObjectMatrix.e -= camera.scrollX * src.scrollFactorX;\n        gameObjectMatrix.f -= camera.scrollY * src.scrollFactorY;\n\n        //  Multiply by the Sprite matrix, store result in calcMatrix\n        camMatrix.multiply(gameObjectMatrix, calcMatrix);\n    }\n\n    //  Blend Mode\n    ctx.globalCompositeOperation = renderer.blendModes[src.blendMode];\n\n    //  Alpha\n    ctx.globalAlpha = alpha;\n\n    ctx.save();\n\n    calcMatrix.setToContext(ctx);\n\n    return true;\n};\n\nmodule.exports = SetTransform;\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * The Scale Manager Resize Event.\n * \n * This event is dispatched whenever the Scale Manager detects a resize event from the browser.\n * It sends three parameters to the callback, each of them being Size components. You can read\n * the `width`, `height`, `aspectRatio` and other properties of these components to help with\n * scaling your own game content.\n *\n * @event Phaser.Scale.Events#RESIZE\n * @since 3.16.1\n * \n * @param {Phaser.Structs.Size} gameSize - A reference to the Game Size component. This is the un-scaled size of your game canvas.\n * @param {Phaser.Structs.Size} baseSize - A reference to the Base Size component. This is the game size multiplied by resolution.\n * @param {Phaser.Structs.Size} displaySize - A reference to the Display Size component. This is the scaled canvas size, after applying zoom and scale mode.\n * @param {number} resolution - The current resolution. Defaults to 1 at the moment.\n * @param {number} previousWidth - If the `gameSize` has changed, this value contains its previous width, otherwise it contains the current width.\n * @param {number} previousHeight - If the `gameSize` has changed, this value contains its previous height, otherwise it contains the current height.\n */\nmodule.exports = 'resize';\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * The Scene Systems Boot Event.\n * \n * This event is dispatched by a Scene during the Scene Systems boot process. Primarily used by Scene Plugins.\n * \n * Listen to it from a Scene using `this.scene.events.on('boot', listener)`.\n * \n * @event Phaser.Scenes.Events#BOOT\n * @since 3.0.0\n * \n * @param {Phaser.Scenes.Systems} sys - A reference to the Scene Systems class of the Scene that emitted this event.\n */\nmodule.exports = 'boot';\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * The Scene Create Event.\n * \n * This event is dispatched by a Scene after it has been created by the Scene Manager.\n * \n * If a Scene has a `create` method then this event is emitted _after_ that has run.\n * \n * If there is a transition, this event will be fired after the `TRANSITION_START` event.\n * \n * Listen to it from a Scene using `this.scene.events.on('create', listener)`.\n * \n * @event Phaser.Scenes.Events#CREATE\n * @since 3.17.0\n * \n * @param {Phaser.Scene} scene - A reference to the Scene that emitted this event.\n */\nmodule.exports = 'create';\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * The Scene Systems Destroy Event.\n * \n * This event is dispatched by a Scene during the Scene Systems destroy process.\n * \n * Listen to it from a Scene using `this.scene.events.on('destroy', listener)`.\n * \n * You should destroy any resources that may be in use by your Scene in this event handler.\n * \n * @event Phaser.Scenes.Events#DESTROY\n * @since 3.0.0\n * \n * @param {Phaser.Scenes.Systems} sys - A reference to the Scene Systems class of the Scene that emitted this event.\n */\nmodule.exports = 'destroy';\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * The Scene Systems Pause Event.\n * \n * This event is dispatched by a Scene when it is paused, either directly via the `pause` method, or as an\n * action from another Scene.\n * \n * Listen to it from a Scene using `this.scene.events.on('pause', listener)`.\n * \n * @event Phaser.Scenes.Events#PAUSE\n * @since 3.0.0\n * \n * @param {Phaser.Scenes.Systems} sys - A reference to the Scene Systems class of the Scene that emitted this event.\n * @param {any} [data] - An optional data object that was passed to this Scene when it was paused.\n */\nmodule.exports = 'pause';\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * The Scene Systems Post Update Event.\n * \n * This event is dispatched by a Scene during the main game loop step.\n * \n * The event flow for a single step of a Scene is as follows:\n * \n * 1. [PRE_UPDATE]{@linkcode Phaser.Scenes.Events#event:PRE_UPDATE}\n * 2. [UPDATE]{@linkcode Phaser.Scenes.Events#event:UPDATE}\n * 3. The `Scene.update` method is called, if it exists\n * 4. [POST_UPDATE]{@linkcode Phaser.Scenes.Events#event:POST_UPDATE}\n * 5. [RENDER]{@linkcode Phaser.Scenes.Events#event:RENDER}\n * \n * Listen to it from a Scene using `this.scene.events.on('postupdate', listener)`.\n * \n * A Scene will only run its step if it is active.\n * \n * @event Phaser.Scenes.Events#POST_UPDATE\n * @since 3.0.0\n * \n * @param {Phaser.Scenes.Systems} sys - A reference to the Scene Systems class of the Scene that emitted this event.\n * @param {number} time - The current time. Either a High Resolution Timer value if it comes from Request Animation Frame, or Date.now if using SetTimeout.\n * @param {number} delta - The delta time in ms since the last frame. This is a smoothed and capped value based on the FPS rate.\n */\nmodule.exports = 'postupdate';\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * The Scene Systems Pre Update Event.\n * \n * This event is dispatched by a Scene during the main game loop step.\n * \n * The event flow for a single step of a Scene is as follows:\n * \n * 1. [PRE_UPDATE]{@linkcode Phaser.Scenes.Events#event:PRE_UPDATE}\n * 2. [UPDATE]{@linkcode Phaser.Scenes.Events#event:UPDATE}\n * 3. The `Scene.update` method is called, if it exists\n * 4. [POST_UPDATE]{@linkcode Phaser.Scenes.Events#event:POST_UPDATE}\n * 5. [RENDER]{@linkcode Phaser.Scenes.Events#event:RENDER}\n * \n * Listen to it from a Scene using `this.scene.events.on('preupdate', listener)`.\n * \n * A Scene will only run its step if it is active.\n * \n * @event Phaser.Scenes.Events#PRE_UPDATE\n * @since 3.0.0\n * \n * @param {Phaser.Scenes.Systems} sys - A reference to the Scene Systems class of the Scene that emitted this event.\n * @param {number} time - The current time. Either a High Resolution Timer value if it comes from Request Animation Frame, or Date.now if using SetTimeout.\n * @param {number} delta - The delta time in ms since the last frame. This is a smoothed and capped value based on the FPS rate.\n */\nmodule.exports = 'preupdate';\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * The Scene Systems Ready Event.\n * \n * This event is dispatched by a Scene during the Scene Systems start process.\n * By this point in the process the Scene is now fully active and rendering.\n * This event is meant for your game code to use, as all plugins have responded to the earlier 'start' event.\n * \n * Listen to it from a Scene using `this.scene.events.on('ready', listener)`.\n * \n * @event Phaser.Scenes.Events#READY\n * @since 3.0.0\n * \n * @param {Phaser.Scenes.Systems} sys - A reference to the Scene Systems class of the Scene that emitted this event.\n * @param {any} [data] - An optional data object that was passed to this Scene when it was started.\n */\nmodule.exports = 'ready';\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * The Scene Systems Render Event.\n * \n * This event is dispatched by a Scene during the main game loop step.\n * \n * The event flow for a single step of a Scene is as follows:\n * \n * 1. [PRE_UPDATE]{@linkcode Phaser.Scenes.Events#event:PRE_UPDATE}\n * 2. [UPDATE]{@linkcode Phaser.Scenes.Events#event:UPDATE}\n * 3. The `Scene.update` method is called, if it exists\n * 4. [POST_UPDATE]{@linkcode Phaser.Scenes.Events#event:POST_UPDATE}\n * 5. [RENDER]{@linkcode Phaser.Scenes.Events#event:RENDER}\n * \n * Listen to it from a Scene using `this.scene.events.on('render', listener)`.\n * \n * A Scene will only render if it is visible and active.\n * By the time this event is dispatched, the Scene will have already been rendered.\n * \n * @event Phaser.Scenes.Events#RENDER\n * @since 3.0.0\n * \n * @param {(Phaser.Renderer.Canvas.CanvasRenderer|Phaser.Renderer.WebGL.WebGLRenderer)} renderer - The renderer that rendered the Scene.\n */\nmodule.exports = 'render';\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * The Scene Systems Resume Event.\n * \n * This event is dispatched by a Scene when it is resumed from a paused state, either directly via the `resume` method,\n * or as an action from another Scene.\n * \n * Listen to it from a Scene using `this.scene.events.on('resume', listener)`.\n * \n * @event Phaser.Scenes.Events#RESUME\n * @since 3.0.0\n * \n * @param {Phaser.Scenes.Systems} sys - A reference to the Scene Systems class of the Scene that emitted this event.\n * @param {any} [data] - An optional data object that was passed to this Scene when it was resumed.\n */\nmodule.exports = 'resume';\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * The Scene Systems Shutdown Event.\n * \n * This event is dispatched by a Scene during the Scene Systems shutdown process.\n * \n * Listen to it from a Scene using `this.scene.events.on('shutdown', listener)`.\n * \n * You should free-up any resources that may be in use by your Scene in this event handler, on the understanding\n * that the Scene may, at any time, become active again. A shutdown Scene is not 'destroyed', it's simply not\n * currently active. Use the [DESTROY]{@linkcode Phaser.Scenes.Events#event:DESTROY} event to completely clear resources.\n * \n * @event Phaser.Scenes.Events#SHUTDOWN\n * @since 3.0.0\n * \n * @param {Phaser.Scenes.Systems} sys - A reference to the Scene Systems class of the Scene that emitted this event.\n * @param {any} [data] - An optional data object that was passed to this Scene when it was shutdown.\n */\nmodule.exports = 'shutdown';\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * The Scene Systems Sleep Event.\n * \n * This event is dispatched by a Scene when it is sent to sleep, either directly via the `sleep` method,\n * or as an action from another Scene.\n * \n * Listen to it from a Scene using `this.scene.events.on('sleep', listener)`.\n * \n * @event Phaser.Scenes.Events#SLEEP\n * @since 3.0.0\n * \n * @param {Phaser.Scenes.Systems} sys - A reference to the Scene Systems class of the Scene that emitted this event.\n * @param {any} [data] - An optional data object that was passed to this Scene when it was sent to sleep.\n */\nmodule.exports = 'sleep';\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * The Scene Systems Start Event.\n * \n * This event is dispatched by a Scene during the Scene Systems start process. Primarily used by Scene Plugins.\n * \n * Listen to it from a Scene using `this.scene.events.on('start', listener)`.\n * \n * @event Phaser.Scenes.Events#START\n * @since 3.0.0\n * \n * @param {Phaser.Scenes.Systems} sys - A reference to the Scene Systems class of the Scene that emitted this event.\n */\nmodule.exports = 'start';\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * The Scene Transition Complete Event.\n * \n * This event is dispatched by the Target Scene of a transition.\n * \n * It happens when the transition process has completed. This occurs when the duration timer equals or exceeds the duration\n * of the transition.\n * \n * Listen to it from a Scene using `this.scene.events.on('transitioncomplete', listener)`.\n * \n * The Scene Transition event flow is as follows:\n * \n * 1. [TRANSITION_OUT]{@linkcode Phaser.Scenes.Events#event:TRANSITION_OUT} - the Scene that started the transition will emit this event.\n * 2. [TRANSITION_INIT]{@linkcode Phaser.Scenes.Events#event:TRANSITION_INIT} - the Target Scene will emit this event if it has an `init` method.\n * 3. [TRANSITION_START]{@linkcode Phaser.Scenes.Events#event:TRANSITION_START} - the Target Scene will emit this event after its `create` method is called, OR ...\n * 4. [TRANSITION_WAKE]{@linkcode Phaser.Scenes.Events#event:TRANSITION_WAKE} - the Target Scene will emit this event if it was asleep and has been woken-up to be transitioned to.\n * 5. [TRANSITION_COMPLETE]{@linkcode Phaser.Scenes.Events#event:TRANSITION_COMPLETE} - the Target Scene will emit this event when the transition finishes.\n * \n * @event Phaser.Scenes.Events#TRANSITION_COMPLETE\n * @since 3.5.0\n * \n * @param {Phaser.Scene} scene -The Scene on which the transitioned completed.\n */\nmodule.exports = 'transitioncomplete';\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * The Scene Transition Init Event.\n * \n * This event is dispatched by the Target Scene of a transition.\n * \n * It happens immediately after the `Scene.init` method is called. If the Scene does not have an `init` method,\n * this event is not dispatched.\n * \n * Listen to it from a Scene using `this.scene.events.on('transitioninit', listener)`.\n * \n * The Scene Transition event flow is as follows:\n * \n * 1. [TRANSITION_OUT]{@linkcode Phaser.Scenes.Events#event:TRANSITION_OUT} - the Scene that started the transition will emit this event.\n * 2. [TRANSITION_INIT]{@linkcode Phaser.Scenes.Events#event:TRANSITION_INIT} - the Target Scene will emit this event if it has an `init` method.\n * 3. [TRANSITION_START]{@linkcode Phaser.Scenes.Events#event:TRANSITION_START} - the Target Scene will emit this event after its `create` method is called, OR ...\n * 4. [TRANSITION_WAKE]{@linkcode Phaser.Scenes.Events#event:TRANSITION_WAKE} - the Target Scene will emit this event if it was asleep and has been woken-up to be transitioned to.\n * 5. [TRANSITION_COMPLETE]{@linkcode Phaser.Scenes.Events#event:TRANSITION_COMPLETE} - the Target Scene will emit this event when the transition finishes.\n * \n * @event Phaser.Scenes.Events#TRANSITION_INIT\n * @since 3.5.0\n * \n * @param {Phaser.Scene} from - A reference to the Scene that is being transitioned from.\n * @param {number} duration - The duration of the transition in ms.\n */\nmodule.exports = 'transitioninit';\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * The Scene Transition Out Event.\n * \n * This event is dispatched by a Scene when it initiates a transition to another Scene.\n * \n * Listen to it from a Scene using `this.scene.events.on('transitionout', listener)`.\n * \n * The Scene Transition event flow is as follows:\n * \n * 1. [TRANSITION_OUT]{@linkcode Phaser.Scenes.Events#event:TRANSITION_OUT} - the Scene that started the transition will emit this event.\n * 2. [TRANSITION_INIT]{@linkcode Phaser.Scenes.Events#event:TRANSITION_INIT} - the Target Scene will emit this event if it has an `init` method.\n * 3. [TRANSITION_START]{@linkcode Phaser.Scenes.Events#event:TRANSITION_START} - the Target Scene will emit this event after its `create` method is called, OR ...\n * 4. [TRANSITION_WAKE]{@linkcode Phaser.Scenes.Events#event:TRANSITION_WAKE} - the Target Scene will emit this event if it was asleep and has been woken-up to be transitioned to.\n * 5. [TRANSITION_COMPLETE]{@linkcode Phaser.Scenes.Events#event:TRANSITION_COMPLETE} - the Target Scene will emit this event when the transition finishes.\n * \n * @event Phaser.Scenes.Events#TRANSITION_OUT\n * @since 3.5.0\n * \n * @param {Phaser.Scene} target - A reference to the Scene that is being transitioned to.\n * @param {number} duration - The duration of the transition in ms.\n */\nmodule.exports = 'transitionout';\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * The Scene Transition Start Event.\n * \n * This event is dispatched by the Target Scene of a transition, only if that Scene was not asleep.\n * \n * It happens immediately after the `Scene.create` method is called. If the Scene does not have a `create` method,\n * this event is dispatched anyway.\n * \n * If the Target Scene was sleeping then the [TRANSITION_WAKE]{@linkcode Phaser.Scenes.Events#event:TRANSITION_WAKE} event is\n * dispatched instead of this event.\n * \n * Listen to it from a Scene using `this.scene.events.on('transitionstart', listener)`.\n * \n * The Scene Transition event flow is as follows:\n * \n * 1. [TRANSITION_OUT]{@linkcode Phaser.Scenes.Events#event:TRANSITION_OUT} - the Scene that started the transition will emit this event.\n * 2. [TRANSITION_INIT]{@linkcode Phaser.Scenes.Events#event:TRANSITION_INIT} - the Target Scene will emit this event if it has an `init` method.\n * 3. [TRANSITION_START]{@linkcode Phaser.Scenes.Events#event:TRANSITION_START} - the Target Scene will emit this event after its `create` method is called, OR ...\n * 4. [TRANSITION_WAKE]{@linkcode Phaser.Scenes.Events#event:TRANSITION_WAKE} - the Target Scene will emit this event if it was asleep and has been woken-up to be transitioned to.\n * 5. [TRANSITION_COMPLETE]{@linkcode Phaser.Scenes.Events#event:TRANSITION_COMPLETE} - the Target Scene will emit this event when the transition finishes.\n * \n * @event Phaser.Scenes.Events#TRANSITION_START\n * @since 3.5.0\n * \n * @param {Phaser.Scene} from - A reference to the Scene that is being transitioned from.\n * @param {number} duration - The duration of the transition in ms.\n */\nmodule.exports = 'transitionstart';\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * The Scene Transition Wake Event.\n * \n * This event is dispatched by the Target Scene of a transition, only if that Scene was asleep before\n * the transition began. If the Scene was not asleep the [TRANSITION_START]{@linkcode Phaser.Scenes.Events#event:TRANSITION_START} event is dispatched instead.\n * \n * Listen to it from a Scene using `this.scene.events.on('transitionwake', listener)`.\n * \n * The Scene Transition event flow is as follows:\n * \n * 1. [TRANSITION_OUT]{@linkcode Phaser.Scenes.Events#event:TRANSITION_OUT} - the Scene that started the transition will emit this event.\n * 2. [TRANSITION_INIT]{@linkcode Phaser.Scenes.Events#event:TRANSITION_INIT} - the Target Scene will emit this event if it has an `init` method.\n * 3. [TRANSITION_START]{@linkcode Phaser.Scenes.Events#event:TRANSITION_START} - the Target Scene will emit this event after its `create` method is called, OR ...\n * 4. [TRANSITION_WAKE]{@linkcode Phaser.Scenes.Events#event:TRANSITION_WAKE} - the Target Scene will emit this event if it was asleep and has been woken-up to be transitioned to.\n * 5. [TRANSITION_COMPLETE]{@linkcode Phaser.Scenes.Events#event:TRANSITION_COMPLETE} - the Target Scene will emit this event when the transition finishes.\n * \n * @event Phaser.Scenes.Events#TRANSITION_WAKE\n * @since 3.5.0\n * \n * @param {Phaser.Scene} from - A reference to the Scene that is being transitioned from.\n * @param {number} duration - The duration of the transition in ms.\n */\nmodule.exports = 'transitionwake';\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * The Scene Systems Update Event.\n * \n * This event is dispatched by a Scene during the main game loop step.\n * \n * The event flow for a single step of a Scene is as follows:\n * \n * 1. [PRE_UPDATE]{@linkcode Phaser.Scenes.Events#event:PRE_UPDATE}\n * 2. [UPDATE]{@linkcode Phaser.Scenes.Events#event:UPDATE}\n * 3. The `Scene.update` method is called, if it exists\n * 4. [POST_UPDATE]{@linkcode Phaser.Scenes.Events#event:POST_UPDATE}\n * 5. [RENDER]{@linkcode Phaser.Scenes.Events#event:RENDER}\n * \n * Listen to it from a Scene using `this.scene.events.on('update', listener)`.\n * \n * A Scene will only run its step if it is active.\n * \n * @event Phaser.Scenes.Events#UPDATE\n * @since 3.0.0\n * \n * @param {Phaser.Scenes.Systems} sys - A reference to the Scene Systems class of the Scene that emitted this event.\n * @param {number} time - The current time. Either a High Resolution Timer value if it comes from Request Animation Frame, or Date.now if using SetTimeout.\n * @param {number} delta - The delta time in ms since the last frame. This is a smoothed and capped value based on the FPS rate.\n */\nmodule.exports = 'update';\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * The Scene Systems Wake Event.\n * \n * This event is dispatched by a Scene when it is woken from sleep, either directly via the `wake` method,\n * or as an action from another Scene.\n * \n * Listen to it from a Scene using `this.scene.events.on('wake', listener)`.\n * \n * @event Phaser.Scenes.Events#WAKE\n * @since 3.0.0\n * \n * @param {Phaser.Scenes.Systems} sys - A reference to the Scene Systems class of the Scene that emitted this event.\n * @param {any} [data] - An optional data object that was passed to this Scene when it was woken up.\n */\nmodule.exports = 'wake';\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * @namespace Phaser.Scenes.Events\n */\n\nmodule.exports = {\n\n    BOOT: require('./BOOT_EVENT'),\n    CREATE: require('./CREATE_EVENT'),\n    DESTROY: require('./DESTROY_EVENT'),\n    PAUSE: require('./PAUSE_EVENT'),\n    POST_UPDATE: require('./POST_UPDATE_EVENT'),\n    PRE_UPDATE: require('./PRE_UPDATE_EVENT'),\n    READY: require('./READY_EVENT'),\n    RENDER: require('./RENDER_EVENT'),\n    RESUME: require('./RESUME_EVENT'),\n    SHUTDOWN: require('./SHUTDOWN_EVENT'),\n    SLEEP: require('./SLEEP_EVENT'),\n    START: require('./START_EVENT'),\n    TRANSITION_COMPLETE: require('./TRANSITION_COMPLETE_EVENT'),\n    TRANSITION_INIT: require('./TRANSITION_INIT_EVENT'),\n    TRANSITION_OUT: require('./TRANSITION_OUT_EVENT'),\n    TRANSITION_START: require('./TRANSITION_START_EVENT'),\n    TRANSITION_WAKE: require('./TRANSITION_WAKE_EVENT'),\n    UPDATE: require('./UPDATE_EVENT'),\n    WAKE: require('./WAKE_EVENT')\n\n};\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n//  Taken from klasse by mattdesl https://github.com/mattdesl/klasse\n\nfunction hasGetterOrSetter (def)\n{\n    return (!!def.get && typeof def.get === 'function') || (!!def.set && typeof def.set === 'function');\n}\n\nfunction getProperty (definition, k, isClassDescriptor)\n{\n    //  This may be a lightweight object, OR it might be a property that was defined previously.\n\n    //  For simple class descriptors we can just assume its NOT previously defined.\n    var def = (isClassDescriptor) ? definition[k] : Object.getOwnPropertyDescriptor(definition, k);\n\n    if (!isClassDescriptor && def.value && typeof def.value === 'object')\n    {\n        def = def.value;\n    }\n\n    //  This might be a regular property, or it may be a getter/setter the user defined in a class.\n    if (def && hasGetterOrSetter(def))\n    {\n        if (typeof def.enumerable === 'undefined')\n        {\n            def.enumerable = true;\n        }\n\n        if (typeof def.configurable === 'undefined')\n        {\n            def.configurable = true;\n        }\n\n        return def;\n    }\n    else\n    {\n        return false;\n    }\n}\n\nfunction hasNonConfigurable (obj, k)\n{\n    var prop = Object.getOwnPropertyDescriptor(obj, k);\n\n    if (!prop)\n    {\n        return false;\n    }\n\n    if (prop.value && typeof prop.value === 'object')\n    {\n        prop = prop.value;\n    }\n\n    if (prop.configurable === false)\n    {\n        return true;\n    }\n\n    return false;\n}\n\n/**\n * Extends the given `myClass` object's prototype with the properties of `definition`.\n *\n * @function extend\n * @param {Object} ctor The constructor object to mix into.\n * @param {Object} definition A dictionary of functions for the class.\n * @param {boolean} isClassDescriptor Is the definition a class descriptor?\n * @param {Object} [extend] The parent constructor object.\n */\nfunction extend (ctor, definition, isClassDescriptor, extend)\n{\n    for (var k in definition)\n    {\n        if (!definition.hasOwnProperty(k))\n        {\n            continue;\n        }\n\n        var def = getProperty(definition, k, isClassDescriptor);\n\n        if (def !== false)\n        {\n            //  If Extends is used, we will check its prototype to see if the final variable exists.\n\n            var parent = extend || ctor;\n\n            if (hasNonConfigurable(parent.prototype, k))\n            {\n                //  Just skip the final property\n                if (Class.ignoreFinals)\n                {\n                    continue;\n                }\n\n                //  We cannot re-define a property that is configurable=false.\n                //  So we will consider them final and throw an error. This is by\n                //  default so it is clear to the developer what is happening.\n                //  You can set ignoreFinals to true if you need to extend a class\n                //  which has configurable=false; it will simply not re-define final properties.\n                throw new Error('cannot override final property \\'' + k + '\\', set Class.ignoreFinals = true to skip');\n            }\n\n            Object.defineProperty(ctor.prototype, k, def);\n        }\n        else\n        {\n            ctor.prototype[k] = definition[k];\n        }\n    }\n}\n\n/**\n * Applies the given `mixins` to the prototype of `myClass`.\n *\n * @function mixin\n * @param {Object} myClass The constructor object to mix into.\n * @param {Object|Array<Object>} mixins The mixins to apply to the constructor.\n */\nfunction mixin (myClass, mixins)\n{\n    if (!mixins)\n    {\n        return;\n    }\n\n    if (!Array.isArray(mixins))\n    {\n        mixins = [ mixins ];\n    }\n\n    for (var i = 0; i < mixins.length; i++)\n    {\n        extend(myClass, mixins[i].prototype || mixins[i]);\n    }\n}\n\n/**\n * Creates a new class with the given descriptor.\n * The constructor, defined by the name `initialize`,\n * is an optional function. If unspecified, an anonymous\n * function will be used which calls the parent class (if\n * one exists).\n *\n * You can also use `Extends` and `Mixins` to provide subclassing\n * and inheritance.\n *\n * @class Phaser.Class\n * @constructor\n * @param {Object} definition a dictionary of functions for the class\n * @example\n *\n *      var MyClass = new Phaser.Class({\n *\n *          initialize: function() {\n *              this.foo = 2.0;\n *          },\n *\n *          bar: function() {\n *              return this.foo + 5;\n *          }\n *      });\n */\nfunction Class (definition)\n{\n    if (!definition)\n    {\n        definition = {};\n    }\n\n    //  The variable name here dictates what we see in Chrome debugger\n    var initialize;\n    var Extends;\n\n    if (definition.initialize)\n    {\n        if (typeof definition.initialize !== 'function')\n        {\n            throw new Error('initialize must be a function');\n        }\n\n        initialize = definition.initialize;\n\n        //  Usually we should avoid 'delete' in V8 at all costs.\n        //  However, its unlikely to make any performance difference\n        //  here since we only call this on class creation (i.e. not object creation).\n        delete definition.initialize;\n    }\n    else if (definition.Extends)\n    {\n        var base = definition.Extends;\n\n        initialize = function ()\n        {\n            base.apply(this, arguments);\n        };\n    }\n    else\n    {\n        initialize = function () {};\n    }\n\n    if (definition.Extends)\n    {\n        initialize.prototype = Object.create(definition.Extends.prototype);\n        initialize.prototype.constructor = initialize;\n\n        //  For getOwnPropertyDescriptor to work, we need to act directly on the Extends (or Mixin)\n\n        Extends = definition.Extends;\n\n        delete definition.Extends;\n    }\n    else\n    {\n        initialize.prototype.constructor = initialize;\n    }\n\n    //  Grab the mixins, if they are specified...\n    var mixins = null;\n\n    if (definition.Mixins)\n    {\n        mixins = definition.Mixins;\n        delete definition.Mixins;\n    }\n\n    //  First, mixin if we can.\n    mixin(initialize, mixins);\n\n    //  Now we grab the actual definition which defines the overrides.\n    extend(initialize, definition, true, Extends);\n\n    return initialize;\n}\n\nClass.extend = extend;\nClass.mixin = mixin;\nClass.ignoreFinals = false;\n\nmodule.exports = Class;\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * A NOOP (No Operation) callback function.\n *\n * Used internally by Phaser when it's more expensive to determine if a callback exists\n * than it is to just invoke an empty function.\n *\n * @function Phaser.Utils.NOOP\n * @since 3.0.0\n */\nvar NOOP = function ()\n{\n    //  NOOP\n};\n\nmodule.exports = NOOP;\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\nvar IsPlainObject = require('./IsPlainObject');\n\n// @param {boolean} deep - Perform a deep copy?\n// @param {object} target - The target object to copy to.\n// @return {object} The extended object.\n\n/**\n * This is a slightly modified version of http://api.jquery.com/jQuery.extend/\n *\n * @function Phaser.Utils.Objects.Extend\n * @since 3.0.0\n *\n * @return {object} The extended object.\n */\nvar Extend = function ()\n{\n    var options, name, src, copy, copyIsArray, clone,\n        target = arguments[0] || {},\n        i = 1,\n        length = arguments.length,\n        deep = false;\n\n    // Handle a deep copy situation\n    if (typeof target === 'boolean')\n    {\n        deep = target;\n        target = arguments[1] || {};\n\n        // skip the boolean and the target\n        i = 2;\n    }\n\n    // extend Phaser if only one argument is passed\n    if (length === i)\n    {\n        target = this;\n        --i;\n    }\n\n    for (; i < length; i++)\n    {\n        // Only deal with non-null/undefined values\n        if ((options = arguments[i]) != null)\n        {\n            // Extend the base object\n            for (name in options)\n            {\n                src = target[name];\n                copy = options[name];\n\n                // Prevent never-ending loop\n                if (target === copy)\n                {\n                    continue;\n                }\n\n                // Recurse if we're merging plain objects or arrays\n                if (deep && copy && (IsPlainObject(copy) || (copyIsArray = Array.isArray(copy))))\n                {\n                    if (copyIsArray)\n                    {\n                        copyIsArray = false;\n                        clone = src && Array.isArray(src) ? src : [];\n                    }\n                    else\n                    {\n                        clone = src && IsPlainObject(src) ? src : {};\n                    }\n\n                    // Never move original objects, clone them\n                    target[name] = Extend(deep, clone, copy);\n\n                // Don't bring in undefined values\n                }\n                else if (copy !== undefined)\n                {\n                    target[name] = copy;\n                }\n            }\n        }\n    }\n\n    // Return the modified object\n    return target;\n};\n\nmodule.exports = Extend;\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\nvar MATH = require('../../math');\nvar GetValue = require('./GetValue');\n\n/**\n * Retrieves a value from an object. Allows for more advanced selection options, including:\n *\n * Allowed types:\n * \n * Implicit\n * {\n *     x: 4\n * }\n *\n * From function\n * {\n *     x: function ()\n * }\n *\n * Randomly pick one element from the array\n * {\n *     x: [a, b, c, d, e, f]\n * }\n *\n * Random integer between min and max:\n * {\n *     x: { randInt: [min, max] }\n * }\n *\n * Random float between min and max:\n * {\n *     x: { randFloat: [min, max] }\n * }\n * \n *\n * @function Phaser.Utils.Objects.GetAdvancedValue\n * @since 3.0.0\n *\n * @param {object} source - The object to retrieve the value from.\n * @param {string} key - The name of the property to retrieve from the object. If a property is nested, the names of its preceding properties should be separated by a dot (`.`) - `banner.hideBanner` would return the value of the `hideBanner` property from the object stored in the `banner` property of the `source` object.\n * @param {*} defaultValue - The value to return if the `key` isn't found in the `source` object.\n *\n * @return {*} The value of the requested key.\n */\nvar GetAdvancedValue = function (source, key, defaultValue)\n{\n    var value = GetValue(source, key, null);\n\n    if (value === null)\n    {\n        return defaultValue;\n    }\n    else if (Array.isArray(value))\n    {\n        return MATH.RND.pick(value);\n    }\n    else if (typeof value === 'object')\n    {\n        if (value.hasOwnProperty('randInt'))\n        {\n            return MATH.RND.integerInRange(value.randInt[0], value.randInt[1]);\n        }\n        else if (value.hasOwnProperty('randFloat'))\n        {\n            return MATH.RND.realInRange(value.randFloat[0], value.randFloat[1]);\n        }\n    }\n    else if (typeof value === 'function')\n    {\n        return value(key);\n    }\n\n    return value;\n};\n\nmodule.exports = GetAdvancedValue;\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * Finds the key within the top level of the {@link source} object, or returns {@link defaultValue}\n *\n * @function Phaser.Utils.Objects.GetFastValue\n * @since 3.0.0\n *\n * @param {object} source - The object to search\n * @param {string} key - The key for the property on source. Must exist at the top level of the source object (no periods)\n * @param {*} [defaultValue] - The default value to use if the key does not exist.\n *\n * @return {*} The value if found; otherwise, defaultValue (null if none provided)\n */\nvar GetFastValue = function (source, key, defaultValue)\n{\n    var t = typeof(source);\n\n    if (!source || t === 'number' || t === 'string')\n    {\n        return defaultValue;\n    }\n    else if (source.hasOwnProperty(key) && source[key] !== undefined)\n    {\n        return source[key];\n    }\n    else\n    {\n        return defaultValue;\n    }\n};\n\nmodule.exports = GetFastValue;\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n//  Source object\n//  The key as a string, or an array of keys, i.e. 'banner', or 'banner.hideBanner'\n//  The default value to use if the key doesn't exist\n\n/**\n * Retrieves a value from an object.\n *\n * @function Phaser.Utils.Objects.GetValue\n * @since 3.0.0\n *\n * @param {object} source - The object to retrieve the value from.\n * @param {string} key - The name of the property to retrieve from the object. If a property is nested, the names of its preceding properties should be separated by a dot (`.`) - `banner.hideBanner` would return the value of the `hideBanner` property from the object stored in the `banner` property of the `source` object.\n * @param {*} defaultValue - The value to return if the `key` isn't found in the `source` object.\n *\n * @return {*} The value of the requested key.\n */\nvar GetValue = function (source, key, defaultValue)\n{\n    if (!source || typeof source === 'number')\n    {\n        return defaultValue;\n    }\n    else if (source.hasOwnProperty(key))\n    {\n        return source[key];\n    }\n    else if (key.indexOf('.') !== -1)\n    {\n        var keys = key.split('.');\n        var parent = source;\n        var value = defaultValue;\n\n        //  Use for loop here so we can break early\n        for (var i = 0; i < keys.length; i++)\n        {\n            if (parent.hasOwnProperty(keys[i]))\n            {\n                //  Yes it has a key property, let's carry on down\n                value = parent[keys[i]];\n\n                parent = parent[keys[i]];\n            }\n            else\n            {\n                //  Can't go any further, so reset to default\n                value = defaultValue;\n                break;\n            }\n        }\n\n        return value;\n    }\n    else\n    {\n        return defaultValue;\n    }\n};\n\nmodule.exports = GetValue;\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * This is a slightly modified version of jQuery.isPlainObject.\n * A plain object is an object whose internal class property is [object Object].\n *\n * @function Phaser.Utils.Objects.IsPlainObject\n * @since 3.0.0\n *\n * @param {object} obj - The object to inspect.\n *\n * @return {boolean} `true` if the object is plain, otherwise `false`.\n */\nvar IsPlainObject = function (obj)\n{\n    // Not plain objects:\n    // - Any object or value whose internal [[Class]] property is not \"[object Object]\"\n    // - DOM nodes\n    // - window\n    if (typeof(obj) !== 'object' || obj.nodeType || obj === obj.window)\n    {\n        return false;\n    }\n\n    // Support: Firefox <20\n    // The try/catch suppresses exceptions thrown when attempting to access\n    // the \"constructor\" property of certain host objects, ie. |window.location|\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=814622\n    try\n    {\n        if (obj.constructor && !({}).hasOwnProperty.call(obj.constructor.prototype, 'isPrototypeOf'))\n        {\n            return false;\n        }\n    }\n    catch (e)\n    {\n        return false;\n    }\n\n    // If the function hasn't returned already, we're confident that\n    // |obj| is a plain object, created by {} or constructed with new Object\n    return true;\n};\n\nmodule.exports = IsPlainObject;\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2018 Photon Storm Ltd.\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n */\n\nvar Class = require('../../../src/utils/Class');\nvar GetFastValue = require('../../../src/utils/object/GetFastValue');\nvar ImageFile = require('../../../src/loader/filetypes/ImageFile.js');\nvar IsPlainObject = require('../../../src/utils/object/IsPlainObject');\nvar JSONFile = require('../../../src/loader/filetypes/JSONFile.js');\nvar MultiFile = require('../../../src/loader/MultiFile.js');\nvar TextFile = require('../../../src/loader/filetypes/TextFile.js');\n\n/**\n * @typedef {object} Phaser.Loader.FileTypes.SpineFileConfig\n *\n * @property {string} key - The key of the file. Must be unique within both the Loader and the Texture Manager.\n * @property {string} [textureURL] - The absolute or relative URL to load the texture image file from.\n * @property {string} [textureExtension='png'] - The default file extension to use for the image texture if no url is provided.\n * @property {XHRSettingsObject} [textureXhrSettings] - Extra XHR Settings specifically for the texture image file.\n * @property {string} [normalMap] - The filename of an associated normal map. It uses the same path and url to load as the texture image.\n * @property {string} [atlasURL] - The absolute or relative URL to load the atlas data file from.\n * @property {string} [atlasExtension='txt'] - The default file extension to use for the atlas data if no url is provided.\n * @property {XHRSettingsObject} [atlasXhrSettings] - Extra XHR Settings specifically for the atlas data file.\n */\n\n/**\n * @classdesc\n * A Spine File suitable for loading by the Loader.\n *\n * These are created when you use the Phaser.Loader.LoaderPlugin#spine method and are not typically created directly.\n * \n * For documentation about what all the arguments and configuration options mean please see Phaser.Loader.LoaderPlugin#spine.\n *\n * @class SpineFile\n * @extends Phaser.Loader.MultiFile\n * @memberof Phaser.Loader.FileTypes\n * @constructor\n *\n * @param {Phaser.Loader.LoaderPlugin} loader - A reference to the Loader that is responsible for this file.\n * @param {(string|Phaser.Loader.FileTypes.UnityAtlasFileConfig)} key - The key to use for this file, or a file configuration object.\n * @param {string|string[]} [textureURL] - The absolute or relative URL to load the texture image file from. If undefined or `null` it will be set to `<key>.png`, i.e. if `key` was \"alien\" then the URL will be \"alien.png\".\n * @param {string} [atlasURL] - The absolute or relative URL to load the texture atlas data file from. If undefined or `null` it will be set to `<key>.txt`, i.e. if `key` was \"alien\" then the URL will be \"alien.txt\".\n * @param {boolean} [preMultipliedAlpha=false] - \n * @param {XHRSettingsObject} [textureXhrSettings] - An XHR Settings configuration object for the atlas image file. Used in replacement of the Loaders default XHR Settings.\n * @param {XHRSettingsObject} [atlasXhrSettings] - An XHR Settings configuration object for the atlas data file. Used in replacement of the Loaders default XHR Settings.\n */\nvar SpineFile = new Class({\n\n    Extends: MultiFile,\n\n    initialize:\n\n    function SpineFile (loader, key, jsonURL, atlasURL, preMultipliedAlpha, jsonXhrSettings, atlasXhrSettings)\n    {\n        var i;\n        var json;\n        var atlas;\n        var files = [];\n        var cache = loader.cacheManager.custom.spine;\n\n        //  atlas can be an array of atlas files, not just a single one\n\n        if (IsPlainObject(key))\n        {\n            var config = key;\n\n            key = GetFastValue(config, 'key');\n\n            json = new JSONFile(loader, {\n                key: key,\n                url: GetFastValue(config, 'jsonURL'),\n                extension: GetFastValue(config, 'jsonExtension', 'json'),\n                xhrSettings: GetFastValue(config, 'jsonXhrSettings')\n            });\n\n            atlasURL = GetFastValue(config, 'atlasURL');\n            preMultipliedAlpha = GetFastValue(config, 'preMultipliedAlpha');\n\n            if (!Array.isArray(atlasURL))\n            {\n                atlasURL = [ atlasURL ];\n            }\n\n            for (i = 0; i < atlasURL.length; i++)\n            {\n                atlas = new TextFile(loader, {\n                    key: key,\n                    url: atlasURL[i],\n                    extension: GetFastValue(config, 'atlasExtension', 'atlas'),\n                    xhrSettings: GetFastValue(config, 'atlasXhrSettings'),\n                });\n\n                atlas.cache = cache;\n                // atlas.config.preMultipliedAlpha = preMultipliedAlpha;\n\n                files.push(atlas);\n            }\n        }\n        else\n        {\n            json = new JSONFile(loader, key, jsonURL, jsonXhrSettings);\n\n            if (!Array.isArray(atlasURL))\n            {\n                atlasURL = [ atlasURL ];\n            }\n\n            for (i = 0; i < atlasURL.length; i++)\n            {\n                atlas = new TextFile(loader, key + '_' + i, atlasURL[i], atlasXhrSettings);\n                atlas.cache = cache;\n                // atlas.config.preMultipliedAlpha = preMultipliedAlpha;\n\n                files.push(atlas);\n            }\n        }\n\n        files.unshift(json);\n\n        MultiFile.call(this, loader, 'spine', key, files);\n\n        this.config.preMultipliedAlpha = preMultipliedAlpha;\n    },\n\n    /**\n     * Called by each File when it finishes loading.\n     *\n     * @method Phaser.Loader.MultiFile#onFileComplete\n     * @since 3.7.0\n     *\n     * @param {Phaser.Loader.File} file - The File that has completed processing.\n     */\n    onFileComplete: function (file)\n    {\n        var index = this.files.indexOf(file);\n\n        if (index !== -1)\n        {\n            this.pending--;\n\n            if (file.type === 'text')\n            {\n                //  Inspect the data for the files to now load\n                var content = file.data.split('\\n');\n\n                //  Extract the textures\n                var textures = [];\n\n                for (var t = 0; t < content.length; t++)\n                {\n                    var line = content[t];\n\n                    if (line.trim() === '' && t < content.length - 1)\n                    {\n                        line = content[t + 1];\n\n                        textures.push(line);\n                    }\n                }\n\n                var config = this.config;\n                var loader = this.loader;\n\n                var currentBaseURL = loader.baseURL;\n                var currentPath = loader.path;\n                var currentPrefix = loader.prefix;\n\n                var baseURL = GetFastValue(config, 'baseURL', currentBaseURL);\n                var path = GetFastValue(config, 'path', currentPath);\n                var prefix = GetFastValue(config, 'prefix', currentPrefix);\n                var textureXhrSettings = GetFastValue(config, 'textureXhrSettings');\n\n                loader.setBaseURL(baseURL);\n                loader.setPath(path);\n                loader.setPrefix(prefix);\n\n                for (var i = 0; i < textures.length; i++)\n                {\n                    var textureURL = textures[i];\n\n                    var key = '_SP_' + textureURL;\n\n                    var image = new ImageFile(loader, key, textureURL, textureXhrSettings);\n\n                    this.addToMultiFile(image);\n\n                    loader.addFile(image);\n                }\n\n                //  Reset the loader settings\n                loader.setBaseURL(currentBaseURL);\n                loader.setPath(currentPath);\n                loader.setPrefix(currentPrefix);\n            }\n        }\n    },\n\n    /**\n     * Adds this file to its target cache upon successful loading and processing.\n     *\n     * @method Phaser.Loader.FileTypes.SpineFile#addToCache\n     * @since 3.16.0\n     */\n    addToCache: function ()\n    {\n        if (this.isReadyToProcess())\n        {\n            var fileJSON = this.files[0];\n\n            fileJSON.addToCache();\n\n            var atlasCache;\n            var atlasKey = '';\n            var combinedAtlastData = '';\n            var preMultipliedAlpha = (this.config.preMultipliedAlpha) ? true : false;\n\n            for (var i = 1; i < this.files.length; i++)\n            {\n                var file = this.files[i];\n\n                if (file.type === 'text')\n                {\n                    atlasKey = file.key.substr(0, file.key.length - 2);\n\n                    atlasCache = file.cache;\n\n                    combinedAtlastData = combinedAtlastData.concat(file.data);\n                }\n                else\n                {\n                    var key = file.key.substr(4).trim();\n   \n                    this.loader.textureManager.addImage(key, file.data);\n                }\n\n                file.pendingDestroy();\n            }\n\n            atlasCache.add(atlasKey, { preMultipliedAlpha: preMultipliedAlpha, data: combinedAtlastData });\n\n            this.complete = true;\n        }\n    }\n\n});\n\nmodule.exports = SpineFile;\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2018 Photon Storm Ltd.\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n */\n\nvar BuildGameObject = require('../../../src/gameobjects/BuildGameObject');\nvar Class = require('../../../src/utils/Class');\nvar GetValue = require('../../../src/utils/object/GetValue');\nvar ScenePlugin = require('../../../src/plugins/ScenePlugin');\nvar SpineFile = require('./SpineFile');\nvar Spine = require('Spine');\nvar SpineGameObject = require('./gameobject/SpineGameObject');\nvar ResizeEvent = require('../../../src/scale/events/RESIZE_EVENT');\n\n/**\n * @classdesc\n * TODO\n *\n * @class SpinePlugin\n * @extends Phaser.Plugins.ScenePlugin\n * @constructor\n * @since 3.19.0\n *\n * @param {Phaser.Scene} scene - A reference to the Scene that has installed this plugin.\n * @param {Phaser.Plugins.PluginManager} pluginManager - A reference to the Phaser Plugin Manager.\n */\nvar SpinePlugin = new Class({\n\n    Extends: ScenePlugin,\n\n    initialize:\n\n    function SpinePlugin (scene, pluginManager)\n    {\n        ScenePlugin.call(this, scene, pluginManager);\n\n        var game = pluginManager.game;\n\n        this.isWebGL = (game.config.renderType === 2);\n\n        //  Create a custom cache to store the spine data (.atlas files)\n        this.cache = game.cache.addCustom('spine');\n\n        this.spineTextures = game.cache.addCustom('spineTextures');\n\n        this.json = game.cache.json;\n\n        this.textures = game.textures;\n\n        this.drawDebug = false;\n\n        this.gl;\n        this.renderer;\n        this.sceneRenderer;\n        this.skeletonDebugRenderer;\n\n        this.plugin = Spine;\n\n        if (this.isWebGL)\n        {\n            this.runtime = Spine.webgl;\n\n            this.renderer = game.renderer;\n            this.gl = game.renderer.gl;\n\n            this.getAtlas = this.getAtlasWebGL;\n        }\n        else\n        {\n            this.runtime = Spine.canvas;\n\n            this.renderer = game.renderer;\n\n            this.getAtlas = this.getAtlasCanvas;\n        }\n\n        this.temp1;\n        this.temp2;\n\n        pluginManager.registerFileType('spine', this.spineFileCallback, scene);\n\n        pluginManager.registerGameObject('spine', this.add.bind(this), this.make.bind(this));\n    },\n\n    boot: function ()\n    {\n        if (this.isWebGL)\n        {\n            this.bootWebGL();\n        }\n        else\n        {\n            this.bootCanvas();\n        }\n\n        this.onResize();\n\n        this.game.scale.on(ResizeEvent, this.onResize, this);\n\n        var eventEmitter = this.systems.events;\n\n        eventEmitter.once('shutdown', this.shutdown, this);\n        eventEmitter.once('destroy', this.destroy, this);\n    },\n\n    bootCanvas: function ()\n    {\n        this.skeletonRenderer = new this.runtime.SkeletonRenderer(this.scene.sys.context);\n    },\n\n    getAtlasCanvas: function (key)\n    {\n        var atlasData = this.cache.get(key);\n\n        if (!atlasData)\n        {\n            console.warn('No atlas data for: ' + key);\n            return;\n        }\n\n        var atlas;\n        var spineTextures = this.spineTextures;\n\n        if (spineTextures.has(key))\n        {\n            atlas = new Spine.TextureAtlas(atlasData, function ()\n            {\n                return spineTextures.get(key);\n            });\n        }\n        else\n        {\n            var textures = this.textures;\n\n            atlas = new Spine.TextureAtlas(atlasData, function (path)\n            {\n                var canvasTexture = new Spine.canvas.CanvasTexture(textures.get(path).getSourceImage());\n\n                spineTextures.add(key, canvasTexture);\n\n                return canvasTexture;\n            });\n        }\n\n        return atlas;\n    },\n\n    bootWebGL: function ()\n    {\n        this.sceneRenderer = new Spine.webgl.SceneRenderer(this.renderer.canvas, this.gl, true);\n\n        //  Monkeypatch the Spine setBlendMode functions, or batching is destroyed\n\n        var setBlendMode = function (srcBlend, dstBlend)\n        {\n            if (srcBlend !== this.srcBlend || dstBlend !== this.dstBlend)\n            {\n                var gl = this.context.gl;\n\n                this.srcBlend = srcBlend;\n                this.dstBlend = dstBlend;\n\n                if (this.isDrawing)\n                {\n                    this.flush();\n                    gl.blendFunc(this.srcBlend, this.dstBlend);\n                }\n            }\n        };\n\n        this.sceneRenderer.batcher.setBlendMode = setBlendMode;\n        this.sceneRenderer.shapes.setBlendMode = setBlendMode;\n\n        this.skeletonDebugRenderer = this.sceneRenderer.skeletonDebugRenderer;\n\n        this.temp1 = new Spine.webgl.Vector3(0, 0, 0);\n        this.temp2 = new Spine.webgl.Vector3(0, 0, 0);\n    },\n\n    worldToLocal: function (x, y, skeleton, bone)\n    {\n        var temp1 = this.temp1;\n        var temp2 = this.temp2;\n        var camera = this.sceneRenderer.camera;\n\n        temp1.set(x + skeleton.x, y - skeleton.y, 0);\n\n        var width = camera.viewportWidth;\n        var height = camera.viewportHeight;\n\n        camera.screenToWorld(temp1, width, height);\n\n        if (bone && bone.parent !== null)\n        {\n            bone.parent.worldToLocal(temp2.set(temp1.x - skeleton.x, temp1.y - skeleton.y, 0));\n\n            return new Spine.Vector2(temp2.x, temp2.y);\n        }\n        else if (bone)\n        {\n            return new Spine.Vector2(temp1.x - skeleton.x, temp1.y - skeleton.y);\n        }\n        else\n        {\n            return new Spine.Vector2(temp1.x, temp1.y);\n        }\n    },\n\n    getAtlasWebGL: function (key)\n    {\n        var atlasEntry = this.cache.get(key);\n\n        if (!atlasEntry)\n        {\n            console.warn('No atlas data for: ' + key);\n            return;\n        }\n\n        var atlas;\n        var spineTextures = this.spineTextures;\n\n        if (spineTextures.has(key))\n        {\n            atlas = new Spine.TextureAtlas(atlasEntry.data, function ()\n            {\n                return spineTextures.get(key);\n            });\n        }\n        else\n        {\n            var textures = this.textures;\n\n            var gl = this.sceneRenderer.context.gl;\n\n            gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);\n\n            atlas = new Spine.TextureAtlas(atlasEntry.data, function (path)\n            {\n                var glTexture = new Spine.webgl.GLTexture(gl, textures.get(path).getSourceImage(), false);\n\n                spineTextures.add(key, glTexture);\n\n                return glTexture;\n            });\n        }\n\n        return atlas;\n    },\n\n    getVector2: function (x, y)\n    {\n        return new Spine.Vector2(x, y);\n    },\n\n    getVector3: function (x, y, z)\n    {\n        return new Spine.webgl.Vector3(x, y, z);\n    },\n\n    setDebugBones: function (value)\n    {\n        if (value === undefined) { value = true; }\n\n        this.skeletonDebugRenderer.drawBones = value;\n\n        return this;\n    },\n\n    setDebugRegionAttachments: function (value)\n    {\n        if (value === undefined) { value = true; }\n\n        this.skeletonDebugRenderer.drawRegionAttachments = value;\n\n        return this;\n    },\n\n    setDebugBoundingBoxes: function (value)\n    {\n        if (value === undefined) { value = true; }\n\n        this.skeletonDebugRenderer.drawBoundingBoxes = value;\n\n        return this;\n    },\n\n    setDebugMeshHull: function (value)\n    {\n        if (value === undefined) { value = true; }\n\n        this.skeletonDebugRenderer.drawMeshHull = value;\n\n        return this;\n    },\n\n    setDebugMeshTriangles: function (value)\n    {\n        if (value === undefined) { value = true; }\n\n        this.skeletonDebugRenderer.drawMeshTriangles = value;\n\n        return this;\n    },\n\n    setDebugPaths: function (value)\n    {\n        if (value === undefined) { value = true; }\n\n        this.skeletonDebugRenderer.drawPaths = value;\n\n        return this;\n    },\n\n    setDebugSkeletonXY: function (value)\n    {\n        if (value === undefined) { value = true; }\n\n        this.skeletonDebugRenderer.drawSkeletonXY = value;\n\n        return this;\n    },\n\n    setDebugClipping: function (value)\n    {\n        if (value === undefined) { value = true; }\n\n        this.skeletonDebugRenderer.drawClipping = value;\n\n        return this;\n    },\n\n    setEffect: function (effect)\n    {\n        this.sceneRenderer.skeletonRenderer.vertexEffect = effect;\n\n        return this;\n    },\n\n    spineFileCallback: function (key, jsonURL, atlasURL, preMultipliedAlpha, jsonXhrSettings, atlasXhrSettings)\n    {\n        var multifile;\n   \n        if (Array.isArray(key))\n        {\n            for (var i = 0; i < key.length; i++)\n            {\n                multifile = new SpineFile(this, key[i]);\n    \n                this.addFile(multifile.files);\n            }\n        }\n        else\n        {\n            multifile = new SpineFile(this, key, jsonURL, atlasURL, preMultipliedAlpha, jsonXhrSettings, atlasXhrSettings);\n\n            this.addFile(multifile.files);\n        }\n        \n        return this;\n    },\n\n    /**\n     * Creates a new Spine Game Object and adds it to the Scene.\n     *\n     * @method Phaser.GameObjects.GameObjectFactory#add\n     * @since 3.19.0\n     * \n     * @param {number} x - The horizontal position of this Game Object.\n     * @param {number} y - The vertical position of this Game Object.\n     * @param {string} texture - The key of the Texture this Game Object will use to render with, as stored in the Texture Manager.\n     * @param {(string|integer)} [frame] - An optional frame from the Texture this Game Object is rendering with.\n     *\n     * @return {Phaser.GameObjects.Spine} The Game Object that was created.\n     */\n    add: function (x, y, key, animationName, loop)\n    {\n        var spineGO = new SpineGameObject(this.scene, this, x, y, key, animationName, loop);\n\n        this.scene.sys.displayList.add(spineGO);\n        this.scene.sys.updateList.add(spineGO);\n    \n        return spineGO;\n    },\n\n    /**\n     * Creates a new Image Game Object and returns it.\n     *\n     * Note: This method will only be available if the Image Game Object has been built into Phaser.\n     *\n     * @method Phaser.GameObjects.GameObjectCreator#image\n     * @since 3.0.0\n     *\n     * @param {object} config - The configuration object this Game Object will use to create itself.\n     * @param {boolean} [addToScene] - Add this Game Object to the Scene after creating it? If set this argument overrides the `add` property in the config object.\n     *\n     * @return {Phaser.GameObjects.Image} The Game Object that was created.\n     */\n    make: function (config, addToScene)\n    {\n        if (config === undefined) { config = {}; }\n\n        var key = GetValue(config, 'key', null);\n        var animationName = GetValue(config, 'animationName', null);\n        var loop = GetValue(config, 'loop', false);\n\n        var spineGO = new SpineGameObject(this.scene, this, 0, 0, key, animationName, loop);\n\n        if (addToScene !== undefined)\n        {\n            config.add = addToScene;\n        }\n\n        BuildGameObject(this.scene, spineGO, config);\n\n        //  Spine specific\n        var skinName = GetValue(config, 'skinName', false);\n\n        if (skinName)\n        {\n            spineGO.setSkinByName(skinName);\n        }\n\n        var slotName = GetValue(config, 'slotName', false);\n        var attachmentName = GetValue(config, 'attachmentName', null);\n\n        if (slotName)\n        {\n            spineGO.setAttachment(slotName, attachmentName);\n        }\n\n        return spineGO.refresh();\n    },\n\n    getRuntime: function ()\n    {\n        return this.runtime;\n    },\n\n    createSkeleton: function (key, skeletonJSON)\n    {\n        var atlasKey = key;\n        var jsonKey = key;\n        var split = (key.indexOf('.') !== -1);\n\n        if (split)\n        {\n            var parts = key.split('.');\n\n            atlasKey = parts.shift();\n            jsonKey = parts.join('.');\n        }\n\n        var atlasData = this.cache.get(atlasKey);\n        var atlas = this.getAtlas(atlasKey);\n\n        if (!atlas)\n        {\n            return null;\n        }\n\n        var preMultipliedAlpha = atlasData.preMultipliedAlpha;\n\n        var atlasLoader = new Spine.AtlasAttachmentLoader(atlas);\n        \n        var skeletonJson = new Spine.SkeletonJson(atlasLoader);\n\n        var data;\n\n        if (skeletonJSON)\n        {\n            data = skeletonJSON;\n        }\n        else\n        {\n            var json = this.json.get(atlasKey);\n\n            data = (split) ? GetValue(json, jsonKey) : json;\n        }\n\n        if (data)\n        {\n            var skeletonData = skeletonJson.readSkeletonData(data);\n\n            var skeleton = new Spine.Skeleton(skeletonData);\n        \n            return { skeletonData: skeletonData, skeleton: skeleton, preMultipliedAlpha: preMultipliedAlpha };\n        }\n        else\n        {\n            return null;\n        }\n    },\n\n    getBounds: function (skeleton)\n    {\n        var offset = new Spine.Vector2();\n        var size = new Spine.Vector2();\n\n        skeleton.getBounds(offset, size, []);\n\n        return { offset: offset, size: size };\n    },\n\n    createAnimationState: function (skeleton)\n    {\n        var stateData = new Spine.AnimationStateData(skeleton.data);\n\n        var state = new Spine.AnimationState(stateData);\n\n        return { stateData: stateData, state: state };\n    },\n\n    onResize: function ()\n    {\n        var renderer = this.renderer;\n        var sceneRenderer = this.sceneRenderer;\n\n        var viewportWidth = renderer.width;\n        var viewportHeight = renderer.height;\n\n        sceneRenderer.camera.position.x = viewportWidth / 2;\n        sceneRenderer.camera.position.y = viewportHeight / 2;\n    \n        sceneRenderer.camera.viewportWidth = viewportWidth;\n        sceneRenderer.camera.viewportHeight = viewportHeight;\n    },\n\n    /**\n     * The Scene that owns this plugin is shutting down.\n     * We need to kill and reset all internal properties as well as stop listening to Scene events.\n     *\n     * @method Camera3DPlugin#shutdown\n     * @private\n     * @since 3.0.0\n     */\n    shutdown: function ()\n    {\n        var eventEmitter = this.systems.events;\n\n        eventEmitter.off('shutdown', this.shutdown, this);\n\n        this.sceneRenderer.dispose();\n    },\n\n    /**\n     * The Scene that owns this plugin is being destroyed.\n     * We need to shutdown and then kill off all external references.\n     *\n     * @method Camera3DPlugin#destroy\n     * @private\n     * @since 3.0.0\n     */\n    destroy: function ()\n    {\n        this.shutdown();\n\n        this.pluginManager.removeGameObject('spine', true, true);\n\n        this.pluginManager = null;\n        this.game = null;\n        this.scene = null;\n        this.systems = null;\n\n        this.cache = null;\n        this.spineTextures = null;\n        this.json = null;\n        this.textures = null;\n        this.sceneRenderer = null;\n        this.gl = null;\n    }\n\n});\n\nmodule.exports = SpinePlugin;\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * The Complete Event.\n *\n * @event SpinePluginEvents#COMPLETE\n * @since 3.19.0\n */\nmodule.exports = 'complete';\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * The Complete Event.\n *\n * @event SpinePluginEvents#DISPOSE\n * @since 3.19.0\n */\nmodule.exports = 'dispose';\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * The Complete Event.\n *\n * @event SpinePluginEvents#END\n * @since 3.19.0\n */\nmodule.exports = 'end';\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * The Complete Event.\n *\n * @event SpinePluginEvents#EVENT\n * @since 3.19.0\n */\nmodule.exports = 'event';\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * The Complete Event.\n *\n * @event SpinePluginEvents#INTERRUPTED\n * @since 3.19.0\n */\nmodule.exports = 'interrupted';\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * The Complete Event.\n *\n * @event SpinePluginEvents#START\n * @since 3.19.0\n */\nmodule.exports = 'start';\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * @namespace SpinePluginEvents\n */\n\nmodule.exports = {\n\n    COMPLETE: require('./COMPLETE_EVENT'),\n    DISPOSE: require('./DISPOSE_EVENT'),\n    END: require('./END_EVENT'),\n    EVENT: require('./EVENT_EVENT'),\n    INTERRUPTED: require('./INTERRUPTED_EVENT'),\n    START: require('./START_EVENT')\n\n};\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2018 Photon Storm Ltd.\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n */\n\nvar Class = require('../../../../src/utils/Class');\nvar Clamp = require('../../../../src/math/Clamp');\nvar ComponentsComputedSize = require('../../../../src/gameobjects/components/ComputedSize');\nvar ComponentsDepth = require('../../../../src/gameobjects/components/Depth');\nvar ComponentsFlip = require('../../../../src/gameobjects/components/Flip');\nvar ComponentsScrollFactor = require('../../../../src/gameobjects/components/ScrollFactor');\nvar ComponentsTransform = require('../../../../src/gameobjects/components/Transform');\nvar ComponentsVisible = require('../../../../src/gameobjects/components/Visible');\nvar SpineEvents = require('../events/');\nvar GameObject = require('../../../../src/gameobjects/GameObject');\nvar SpineGameObjectRender = require('./SpineGameObjectRender');\nvar AngleBetween = require('../../../../src/math/angle/Between');\nvar CounterClockwise = require('../../../../src/math/angle/CounterClockwise');\nvar DegToRad = require('../../../../src/math/DegToRad');\nvar RadToDeg = require('../../../../src/math/RadToDeg');\n\n/**\n * @classdesc\n * TODO\n *\n * @class SpineGameObject\n * @constructor\n * @since 3.16.0\n *\n * @param {Phaser.Scene} scene - A reference to the Scene that has installed this plugin.\n * @param {Phaser.Plugins.PluginManager} pluginManager - A reference to the Phaser Plugin Manager.\n */\nvar SpineGameObject = new Class({\n\n    Extends: GameObject,\n\n    Mixins: [\n        ComponentsComputedSize,\n        ComponentsDepth,\n        ComponentsFlip,\n        ComponentsScrollFactor,\n        ComponentsTransform,\n        ComponentsVisible,\n        SpineGameObjectRender\n    ],\n\n    initialize:\n\n    function SpineGameObject (scene, plugin, x, y, key, animationName, loop)\n    {\n        GameObject.call(this, scene, 'Spine');\n\n        this.plugin = plugin;\n\n        this.root = null;\n        this.skeleton = null;\n        this.skeletonData = null;\n\n        this.state = null;\n        this.stateData = null;\n\n        this.bounds = null;\n        \n        this.drawDebug = false;\n\n        this.timeScale = 1;\n\n        this.displayOriginX = 0;\n        this.displayOriginY = 0;\n\n        this.preMultipliedAlpha = false;\n\n        //  BlendMode Normal\n        this.blendMode = 0;\n\n        this.setPosition(x, y);\n\n        if (key)\n        {\n            this.setSkeleton(key, animationName, loop);\n        }\n    },\n\n    willRender: function ()\n    {\n        return true;\n    },\n\n    /**\n     * Set the Alpha level of this Game Object. The alpha controls the opacity of the Game Object as it renders.\n     * Alpha values are provided as a float between 0, fully transparent, and 1, fully opaque.\n     *\n     * If your game is running under WebGL you can optionally specify four different alpha values, each of which\n     * correspond to the four corners of the Game Object. Under Canvas only the `topLeft` value given is used.\n     *\n     * @method SpineGameObject#setAlpha\n     * @since 3.19.0\n     *\n     * @param {number} [value=1] - The alpha value used for the whole Skeleton.\n     *\n     * @return {this} This Game Object instance.\n     */\n    setAlpha: function (value, slotName)\n    {\n        if (value === undefined) { value = 1; }\n\n        if (slotName)\n        {\n            var slot = this.findSlot(slotName);\n\n            if (slot)\n            {\n                slot.color.a = Clamp(value, 0, 1);\n            }\n        }\n        else\n        {\n            this.alpha = value;\n        }\n\n        return this;\n    },\n\n    /**\n     * The alpha value of the Skeleton.\n     * \n     * A value between 0 and 1.\n     *\n     * This is a global value, impacting the entire Skeleton, not just a region of it.\n     *\n     * @name SpineGameObject#alpha\n     * @type {number}\n     * @since 3.0.0\n     */\n    alpha: {\n\n        get: function ()\n        {\n            return this.skeleton.color.a;\n        },\n\n        set: function (value)\n        {\n            var v = Clamp(value, 0, 1);\n\n            if (this.skeleton)\n            {\n                this.skeleton.color.a = v;\n            }\n\n            if (v === 0)\n            {\n                this.renderFlags &= ~2;\n            }\n            else\n            {\n                this.renderFlags |= 2;\n            }\n        }\n\n    },\n\n    /**\n     * The amount of red used when rendering the Skeletons.\n     * \n     * A value between 0 and 1.\n     *\n     * This is a global value, impacting the entire Skeleton, not just a region of it.\n     *\n     * @name SpineGameObject#red\n     * @type {number}\n     * @since 3.0.0\n     */\n    red: {\n\n        get: function ()\n        {\n            return this.skeleton.color.r;\n        },\n\n        set: function (value)\n        {\n            var v = Clamp(value, 0, 1);\n\n            if (this.skeleton)\n            {\n                this.skeleton.color.r = v;\n            }\n        }\n\n    },\n\n    /**\n     * The amount of green used when rendering the Skeletons.\n     * \n     * A value between 0 and 1.\n     *\n     * This is a global value, impacting the entire Skeleton, not just a region of it.\n     *\n     * @name SpineGameObject#green\n     * @type {number}\n     * @since 3.0.0\n     */\n    green: {\n\n        get: function ()\n        {\n            return this.skeleton.color.g;\n        },\n\n        set: function (value)\n        {\n            var v = Clamp(value, 0, 1);\n\n            if (this.skeleton)\n            {\n                this.skeleton.color.g = v;\n            }\n        }\n\n    },\n\n    /**\n     * The amount of blue used when rendering the Skeletons.\n     * \n     * A value between 0 and 1.\n     *\n     * This is a global value, impacting the entire Skeleton, not just a region of it.\n     *\n     * @name SpineGameObject#blue\n     * @type {number}\n     * @since 3.0.0\n     */\n    blue: {\n\n        get: function ()\n        {\n            return this.skeleton.color.b;\n        },\n\n        set: function (value)\n        {\n            var v = Clamp(value, 0, 1);\n\n            if (this.skeleton)\n            {\n                this.skeleton.color.b = v;\n            }\n        }\n\n    },\n\n    /**\n     * Sets an additive tint on this Game Object.\n     *\n     * @method Phaser.GameObjects.Components.Tint#setColor\n     * @webglOnly\n     * @since 3.19.0\n     *\n     * @param {integer} [color=0xffffff] - The tint being applied to the top-left of the Game Object. If no other values are given this value is applied evenly, tinting the whole Game Object.\n     * \n     * @return {this} This Game Object instance.\n     */\n    setColor: function (color, slotName)\n    {\n        if (color === undefined) { color = 0xffffff; }\n\n        var red = (color >> 16 & 0xFF) / 255;\n        var green = (color >> 8 & 0xFF) / 255;\n        var blue = (color & 0xFF) / 255;\n        var alpha = (color > 16777215) ? (color >>> 24) / 255 : null;\n\n        var target = this.skeleton;\n\n        if (slotName)\n        {\n            var slot = this.findSlot(slotName);\n\n            if (slot)\n            {\n                target = slot;\n            }\n        }\n\n        target.color.r = red;\n        target.color.g = green;\n        target.color.b = blue;\n\n        if (alpha !== null)\n        {\n            target.color.a = alpha;\n        }\n\n        return this;\n    },\n\n    setSkeletonFromJSON: function (atlasDataKey, skeletonJSON, animationName, loop)\n    {\n        return this.setSkeleton(atlasDataKey, skeletonJSON, animationName, loop);\n    },\n\n    setSkeleton: function (atlasDataKey, animationName, loop, skeletonJSON)\n    {\n        if (this.state)\n        {\n            this.state.clearListeners();\n            this.state.clearListenerNotifications();\n        }\n\n        var data = this.plugin.createSkeleton(atlasDataKey, skeletonJSON);\n\n        this.skeletonData = data.skeletonData;\n\n        this.preMultipliedAlpha = data.preMultipliedAlpha;\n\n        var skeleton = data.skeleton;\n\n        skeleton.setSkinByName('default');\n        skeleton.setToSetupPose();\n\n        this.skeleton = skeleton;\n\n        //  AnimationState\n        data = this.plugin.createAnimationState(skeleton);\n\n        if (this.state)\n        {\n            this.state.clearListeners();\n            this.state.clearListenerNotifications();\n        }\n\n        this.state = data.state;\n        this.stateData = data.stateData;\n\n        this.state.addListener({\n            event: this.onEvent.bind(this),\n            complete: this.onComplete.bind(this),\n            start: this.onStart.bind(this),\n            end: this.onEnd.bind(this),\n            dispose: this.onDispose.bind(this),\n            interrupted: this.onInterrupted.bind(this)\n        });\n\n        if (animationName)\n        {\n            this.setAnimation(0, animationName, loop);\n        }\n\n        this.root = this.getRootBone();\n\n        if (this.root)\n        {\n            //  +90 degrees to account for the difference in Spine vs. Phaser rotation\n            this.root.rotation = RadToDeg(CounterClockwise(this.rotation)) + 90;\n        }\n\n        this.state.apply(skeleton);\n\n        skeleton.updateCache();\n\n        return this.updateSize();\n    },\n\n    onComplete: function (entry)\n    {\n        this.emit(SpineEvents.COMPLETE, entry);\n    },\n\n    onDispose: function (entry)\n    {\n        this.emit(SpineEvents.DISPOSE, entry);\n    },\n\n    onEnd: function (entry)\n    {\n        this.emit(SpineEvents.END, entry);\n    },\n\n    onEvent: function (entry, event)\n    {\n        this.emit(SpineEvents.EVENT, entry, event);\n    },\n\n    onInterrupted: function (entry)\n    {\n        this.emit(SpineEvents.INTERRUPTED, entry);\n    },\n\n    onStart: function (entry)\n    {\n        this.emit(SpineEvents.START, entry);\n    },\n\n    refresh: function ()\n    {\n        if (this.root)\n        {\n            //  +90 degrees to account for the difference in Spine vs. Phaser rotation\n            this.root.rotation = RadToDeg(CounterClockwise(this.rotation)) + 90;\n        }\n\n        this.updateSize();\n\n        this.skeleton.updateCache();\n\n        return this;\n    },\n\n    setSize: function (width, height, offsetX, offsetY)\n    {\n        var skeleton = this.skeleton;\n\n        if (width === undefined) { width = skeleton.data.width; }\n        if (height === undefined) { height = skeleton.data.height; }\n        if (offsetX === undefined) { offsetX = 0; }\n        if (offsetY === undefined) { offsetY = 0; }\n\n        this.width = width;\n        this.height = height;\n\n        this.displayOriginX = skeleton.x - offsetX;\n        this.displayOriginY = skeleton.y - offsetY;\n\n        return this;\n    },\n\n    setOffset: function (offsetX, offsetY)\n    {\n        var skeleton = this.skeleton;\n\n        if (offsetX === undefined) { offsetX = 0; }\n        if (offsetY === undefined) { offsetY = 0; }\n\n        this.displayOriginX = skeleton.x - offsetX;\n        this.displayOriginY = skeleton.y - offsetY;\n\n        return this;\n    },\n\n    updateSize: function ()\n    {\n        var skeleton = this.skeleton;\n        var renderer = this.scene.sys.renderer;\n\n        var height = renderer.height;\n\n        var oldScaleX = this.scaleX;\n        var oldScaleY = this.scaleY;\n\n        skeleton.x = this.x;\n        skeleton.y = height - this.y;\n        skeleton.scaleX = 1;\n        skeleton.scaleY = 1;\n\n        skeleton.updateWorldTransform();\n\n        var bounds = this.getBounds();\n\n        this.width = bounds.size.x;\n        this.height = bounds.size.y;\n\n        this.displayOriginX = this.x - bounds.offset.x;\n        this.displayOriginY = this.y - (height - (this.height + bounds.offset.y));\n\n        skeleton.scaleX = oldScaleX;\n        skeleton.scaleY = oldScaleY;\n\n        skeleton.updateWorldTransform();\n\n        return this;\n    },\n\n    /**\n     * The horizontal scale of this Game Object.\n     * Override Transform component.\n     *\n     * @name Phaser.GameObjects.Components.Transform#scaleX\n     * @type {number}\n     * @default 1\n     * @since 3.0.0\n     */\n    scaleX: {\n\n        get: function ()\n        {\n            return this._scaleX;\n        },\n\n        set: function (value)\n        {\n            this._scaleX = value;\n\n            this.refresh();\n        }\n\n    },\n\n    /**\n     * The vertical scale of this Game Object.\n     *\n     * @name Phaser.GameObjects.Components.Transform#scaleY\n     * @type {number}\n     * @default 1\n     * @since 3.0.0\n     */\n    scaleY: {\n\n        get: function ()\n        {\n            return this._scaleY;\n        },\n\n        set: function (value)\n        {\n            this._scaleY = value;\n\n            this.refresh();\n        }\n\n    },\n\n    getBoneList: function ()\n    {\n        var output = [];\n\n        var skeletonData = this.skeletonData;\n\n        if (skeletonData)\n        {\n            for (var i = 0; i < skeletonData.bones.length; i++)\n            {\n                output.push(skeletonData.bones[i].name);\n            }\n        }\n\n        return output;\n    },\n\n    getSkinList: function ()\n    {\n        var output = [];\n\n        var skeletonData = this.skeletonData;\n\n        if (skeletonData)\n        {\n            for (var i = 0; i < skeletonData.skins.length; i++)\n            {\n                output.push(skeletonData.skins[i].name);\n            }\n        }\n\n        return output;\n    },\n\n    getSlotList: function ()\n    {\n        var output = [];\n\n        var skeleton = this.skeleton;\n\n        for (var i = 0; i < skeleton.slots.length; i++)\n        {\n            output.push(skeleton.slots[i].data.name);\n        }\n\n        return output;\n    },\n\n    getAnimationList: function ()\n    {\n        var output = [];\n\n        var skeletonData = this.skeletonData;\n\n        if (skeletonData)\n        {\n            for (var i = 0; i < skeletonData.animations.length; i++)\n            {\n                output.push(skeletonData.animations[i].name);\n            }\n        }\n\n        return output;\n    },\n\n    getCurrentAnimation: function (trackIndex)\n    {\n        if (trackIndex === undefined) { trackIndex = 0; }\n\n        var current = this.state.getCurrent(trackIndex);\n\n        if (current)\n        {\n            return current.animation;\n        }\n    },\n\n    /**\n     * Plays an Animation on a Game Object that has the Animation component, such as a Sprite.\n     * \n     * Animations are stored in the global Animation Manager and are referenced by a unique string-based key.\n     *\n     * @method Phaser.GameObjects.Components.Animation#play\n     * @fires Phaser.GameObjects.Components.Animation#onStartEvent\n     * @since 3.0.0\n     *\n     * @param {(string|Phaser.Animations.Animation)} key - The string-based key of the animation to play, as defined previously in the Animation Manager. Or an Animation instance.\n     * @param {boolean} [ignoreIfPlaying=false] - If this animation is already playing then ignore this call.\n     * @param {integer} [startFrame=0] - Optionally start the animation playing from this frame index.\n     *\n     * @return {Phaser.GameObjects.GameObject} The Game Object that owns this Animation Component.\n     */\n    play: function (animationName, loop, ignoreIfPlaying)\n    {\n        return this.setAnimation(0, animationName, loop, ignoreIfPlaying);\n    },\n\n    setAnimation: function (trackIndex, animationName, loop, ignoreIfPlaying)\n    {\n        if (loop === undefined) { loop = false; }\n        if (ignoreIfPlaying === undefined) { ignoreIfPlaying = false; }\n\n        if (ignoreIfPlaying && this.state)\n        {\n            var currentTrack = this.state.getCurrent(0);\n \n            if (currentTrack && currentTrack.animation.name === animationName && !currentTrack.isComplete())\n            {\n                return this;\n            }\n        }\n\n        if (this.findAnimation(animationName))\n        {\n            this.state.setAnimation(trackIndex, animationName, loop);\n        }\n\n        return this;\n    },\n\n    addAnimation: function (trackIndex, animationName, loop, delay)\n    {\n        this.state.addAnimation(trackIndex, animationName, loop, delay);\n\n        return this;\n    },\n\n    setEmptyAnimation: function (trackIndex, mixDuration)\n    {\n        this.state.setEmptyAnimation(trackIndex, mixDuration);\n\n        return this;\n    },\n\n    clearTrack: function (trackIndex)\n    {\n        this.state.clearTrack(trackIndex);\n\n        return this;\n    },\n     \n    clearTracks: function ()\n    {\n        this.state.clearTracks();\n\n        return this;\n    },\n\n    setSkinByName: function (skinName)\n    {\n        var skeleton = this.skeleton;\n\n        skeleton.setSkinByName(skinName);\n\n        skeleton.setSlotsToSetupPose();\n\n        this.state.apply(skeleton);\n\n        return this;\n    },\n\n    setSkin: function (newSkin)\n    {\n        var skeleton = this.skeleton;\n\n        skeleton.setSkin(newSkin);\n\n        skeleton.setSlotsToSetupPose();\n\n        this.state.apply(skeleton);\n\n        return this;\n    },\n\n    setMix: function (fromName, toName, duration)\n    {\n        this.stateData.setMix(fromName, toName, duration);\n\n        return this;\n    },\n\n    getAttachment: function (slotIndex, attachmentName)\n    {\n        return this.skeleton.getAttachment(slotIndex, attachmentName);\n    },\n\n    getAttachmentByName: function (slotName, attachmentName)\n    {\n        return this.skeleton.getAttachmentByName(slotName, attachmentName);\n    },\n\n    setAttachment: function (slotName, attachmentName)\n    {\n        if (Array.isArray(slotName) && Array.isArray(attachmentName) && slotName.length === attachmentName.length)\n        {\n            for (var i = 0; i < slotName.length; i++)\n            {\n                this.skeleton.setAttachment(slotName[i], attachmentName[i]);\n            }\n        }\n        else\n        {\n            this.skeleton.setAttachment(slotName, attachmentName);\n        }\n\n        return this;\n    },\n\n    setToSetupPose: function ()\n    {\n        this.skeleton.setToSetupPose();\n\n        return this;\n    },\n\n    setSlotsToSetupPose: function ()\n    {\n        this.skeleton.setSlotsToSetupPose();\n\n        return this;\n    },\n\n    setBonesToSetupPose: function ()\n    {\n        this.skeleton.setBonesToSetupPose();\n\n        return this;\n    },\n\n    getRootBone: function ()\n    {\n        return this.skeleton.getRootBone();\n    },\n\n    angleBoneToXY: function (bone, worldX, worldY, offset, minAngle, maxAngle)\n    {\n        if (offset === undefined) { offset = 0; }\n        if (minAngle === undefined) { minAngle = 0; }\n        if (maxAngle === undefined) { maxAngle = 360; }\n\n        var renderer = this.scene.sys.renderer;\n        var height = renderer.height;\n\n        var angle = CounterClockwise(AngleBetween(bone.worldX, height - bone.worldY, worldX, worldY) + DegToRad(offset));\n\n        bone.rotation = Clamp(RadToDeg(angle), minAngle, maxAngle);\n\n        return this;\n    },\n\n    findBone: function (boneName)\n    {\n        return this.skeleton.findBone(boneName);\n    },\n\n    findBoneIndex: function (boneName)\n    {\n        return this.skeleton.findBoneIndex(boneName);\n    },\n\n    findSlot: function (slotName)\n    {\n        return this.skeleton.findSlot(slotName);\n    },\n\n    findSlotIndex: function (slotName)\n    {\n        return this.skeleton.findSlotIndex(slotName);\n    },\n\n    findSkin: function (skinName)\n    {\n        return this.skeletonData.findSkin(skinName);\n    },\n\n    findEvent: function (eventDataName)\n    {\n        return this.skeletonData.findEvent(eventDataName);\n    },\n\n    findAnimation: function (animationName)\n    {\n        return this.skeletonData.findAnimation(animationName);\n    },\n\n    findIkConstraint: function (constraintName)\n    {\n        return this.skeletonData.findIkConstraint(constraintName);\n    },\n\n    findTransformConstraint: function (constraintName)\n    {\n        return this.skeletonData.findTransformConstraint(constraintName);\n    },\n\n    findPathConstraint: function (constraintName)\n    {\n        return this.skeletonData.findPathConstraint(constraintName);\n    },\n\n    findPathConstraintIndex: function (pathConstraintName)\n    {\n        return this.skeletonData.findPathConstraintIndex(pathConstraintName);\n    },\n\n    // getBounds (\t2-tuple offset, 2-tuple size, float[] temp): void\n    // Returns the axis aligned bounding box (AABB) of the region and mesh attachments for the current pose.\n    // offset An output value, the distance from the skeleton origin to the bottom left corner of the AABB.\n    // size An output value, the width and height of the AABB.\n\n    getBounds: function ()\n    {\n        return this.plugin.getBounds(this.skeleton);\n    },\n\n    preUpdate: function (time, delta)\n    {\n        var skeleton = this.skeleton;\n\n        this.state.update((delta / 1000) * this.timeScale);\n\n        this.state.apply(skeleton);\n\n        this.emit('spine.update', skeleton);\n    },\n\n    /**\n     * Internal destroy handler, called as part of the destroy process.\n     *\n     * @method Phaser.GameObjects.RenderTexture#preDestroy\n     * @protected\n     * @since 3.16.0\n     */\n    preDestroy: function ()\n    {\n        if (this.state)\n        {\n            this.state.clearListeners();\n            this.state.clearListenerNotifications();\n        }\n\n        this.plugin = null;\n\n        this.skeleton = null;\n        this.skeletonData = null;\n\n        this.state = null;\n        this.stateData = null;\n    }\n\n});\n\nmodule.exports = SpineGameObject;\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2018 Photon Storm Ltd.\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n */\n\nvar SetTransform = require('../../../../src/renderer/canvas/utils/SetTransform');\n\n/**\n * Renders this Game Object with the Canvas Renderer to the given Camera.\n * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.\n * This method should not be called directly. It is a utility function of the Render module.\n *\n * @method Phaser.GameObjects.SpineGameObject#renderCanvas\n * @since 3.16.0\n * @private\n *\n * @param {Phaser.Renderer.Canvas.CanvasRenderer} renderer - A reference to the current active Canvas renderer.\n * @param {Phaser.GameObjects.SpineGameObject} src - The Game Object being rendered in this call.\n * @param {number} interpolationPercentage - Reserved for future use and custom pipelines.\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\n * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - This transform matrix is defined if the game object is nested\n */\nvar SpineGameObjectCanvasRenderer = function (renderer, src, interpolationPercentage, camera, parentMatrix)\n{\n    var context = renderer.currentContext;\n\n    var plugin = src.plugin;\n    var skeleton = src.skeleton;\n    var skeletonRenderer = plugin.skeletonRenderer;\n\n    if (!skeleton || !SetTransform(renderer, context, src, camera, parentMatrix))\n    {\n        return;\n    }\n\n    skeletonRenderer.ctx = context;\n\n    context.save();\n\n    skeletonRenderer.draw(skeleton);\n\n    if (plugin.drawDebug || src.drawDebug)\n    {\n        context.strokeStyle = '#00ff00';\n        context.beginPath();\n        context.moveTo(-1000, 0);\n        context.lineTo(1000, 0);\n        context.moveTo(0, -1000);\n        context.lineTo(0, 1000);\n        context.stroke();\n    }\n\n    context.restore();\n};\n\nmodule.exports = SpineGameObjectCanvasRenderer;\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2018 Photon Storm Ltd.\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n */\n\nvar renderWebGL = require('../../../../src/utils/NOOP');\nvar renderCanvas = require('../../../../src/utils/NOOP');\n\nif (typeof WEBGL_RENDERER)\n{\n    renderWebGL = require('./SpineGameObjectWebGLRenderer');\n}\n\nif (typeof CANVAS_RENDERER)\n{\n    renderCanvas = require('./SpineGameObjectCanvasRenderer');\n}\n\nmodule.exports = {\n\n    renderWebGL: renderWebGL,\n    renderCanvas: renderCanvas\n\n};\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2018 Photon Storm Ltd.\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n */\n\nvar CounterClockwise = require('../../../../src/math/angle/CounterClockwise');\nvar RadToDeg = require('../../../../src/math/RadToDeg');\nvar Wrap = require('../../../../src/math/Wrap');\n\n/**\n * Renders this Game Object with the WebGL Renderer to the given Camera.\n * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.\n * This method should not be called directly. It is a utility function of the Render module.\n *\n * @method Phaser.GameObjects.SpineGameObject#renderWebGL\n * @since 3.19.0\n * @private\n *\n * @param {Phaser.Renderer.WebGL.WebGLRenderer} renderer - A reference to the current active WebGL renderer.\n * @param {SpineGameObject} src - The Game Object being rendered in this call.\n * @param {number} interpolationPercentage - Reserved for future use and custom pipelines.\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\n * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - This transform matrix is defined if the game object is nested\n */\nvar SpineGameObjectWebGLRenderer = function (renderer, src, interpolationPercentage, camera, parentMatrix)\n{\n    var plugin = src.plugin;\n    var skeleton = src.skeleton;\n    var sceneRenderer = plugin.sceneRenderer;\n\n    var GameObjectRenderMask = 15;\n\n    var willRender = !(GameObjectRenderMask !== src.renderFlags || (src.cameraFilter !== 0 && (src.cameraFilter & camera.id)));\n\n    if (!skeleton || !willRender)\n    {\n        //  Reset the current type\n        renderer.currentType = '';\n\n        //  If there is already a batch running, we need to close it\n        if (!renderer.nextTypeMatch)\n        {\n            //  The next object in the display list is not a Spine object, so we end the batch\n            sceneRenderer.end();\n    \n            renderer.rebindPipeline(renderer.pipelines.TextureTintPipeline);\n        }\n    \n        return;\n    }\n\n    if (renderer.newType)\n    {\n        renderer.clearPipeline();\n    }\n\n    var camMatrix = renderer._tempMatrix1;\n    var spriteMatrix = renderer._tempMatrix2;\n    var calcMatrix = renderer._tempMatrix3;\n\n    spriteMatrix.applyITRS(src.x, src.y, src.rotation, Math.abs(src.scaleX), Math.abs(src.scaleY));\n\n    camMatrix.copyFrom(camera.matrix);\n\n    if (parentMatrix)\n    {\n        //  Multiply the camera by the parent matrix\n        camMatrix.multiplyWithOffset(parentMatrix, -camera.scrollX * src.scrollFactorX, -camera.scrollY * src.scrollFactorY);\n\n        //  Undo the camera scroll\n        spriteMatrix.e = src.x;\n        spriteMatrix.f = src.y;\n\n        //  Multiply by the Sprite matrix, store result in calcMatrix\n        camMatrix.multiply(spriteMatrix, calcMatrix);\n    }\n    else\n    {\n        spriteMatrix.e -= camera.scrollX * src.scrollFactorX;\n        spriteMatrix.f -= camera.scrollY * src.scrollFactorY;\n\n        //  Multiply by the Sprite matrix, store result in calcMatrix\n        camMatrix.multiply(spriteMatrix, calcMatrix);\n    }\n\n    var viewportHeight = renderer.height;\n\n    skeleton.x = calcMatrix.tx;\n    skeleton.y = viewportHeight - calcMatrix.ty;\n\n    skeleton.scaleX = calcMatrix.scaleX;\n    skeleton.scaleY = calcMatrix.scaleY;\n\n    if (src.scaleX < 0)\n    {\n        skeleton.scaleX *= -1;\n\n        src.root.rotation = RadToDeg(calcMatrix.rotationNormalized);\n    }\n    else\n    {\n        //  +90 degrees to account for the difference in Spine vs. Phaser rotation\n        src.root.rotation = Wrap(RadToDeg(CounterClockwise(calcMatrix.rotationNormalized)) + 90, 0, 360);\n    }\n\n    if (src.scaleY < 0)\n    {\n        skeleton.scaleY *= -1;\n\n        if (src.scaleX < 0)\n        {\n            src.root.rotation -= (RadToDeg(calcMatrix.rotationNormalized) * 2);\n        }\n        else\n        {\n            src.root.rotation += (RadToDeg(calcMatrix.rotationNormalized) * 2);\n        }\n    }\n\n    if (camera.renderToTexture)\n    {\n        skeleton.y = calcMatrix.ty;\n        skeleton.scaleY *= -1;\n    }\n\n    //  Add autoUpdate option\n    skeleton.updateWorldTransform();\n\n    if (renderer.newType)\n    {\n        sceneRenderer.begin();\n    }\n\n    //  Draw the current skeleton\n    sceneRenderer.drawSkeleton(skeleton, src.preMultipliedAlpha);\n\n    if (plugin.drawDebug || src.drawDebug)\n    {\n        //  Because if we don't, the bones render positions are completely wrong (*sigh*)\n        var oldX = skeleton.x;\n        var oldY = skeleton.y;\n\n        skeleton.x = 0;\n        skeleton.y = 0;\n\n        sceneRenderer.drawSkeletonDebug(skeleton, src.preMultipliedAlpha);\n\n        skeleton.x = oldX;\n        skeleton.y = oldY;\n    }\n\n    if (!renderer.nextTypeMatch)\n    {\n        //  The next object in the display list is not a Spine object, so we end the batch\n        sceneRenderer.end();\n\n        renderer.rebindPipeline(renderer.pipelines.TextureTintPipeline);\n    }\n};\n\nmodule.exports = SpineGameObjectWebGLRenderer;\n","/*** IMPORTS FROM imports-loader ***/\n(function() {\n\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar spine;\n(function (spine) {\n    var Animation = (function () {\n        function Animation(name, timelines, duration) {\n            if (name == null)\n                throw new Error(\"name cannot be null.\");\n            if (timelines == null)\n                throw new Error(\"timelines cannot be null.\");\n            this.name = name;\n            this.timelines = timelines;\n            this.duration = duration;\n        }\n        Animation.prototype.apply = function (skeleton, lastTime, time, loop, events, alpha, blend, direction) {\n            if (skeleton == null)\n                throw new Error(\"skeleton cannot be null.\");\n            if (loop && this.duration != 0) {\n                time %= this.duration;\n                if (lastTime > 0)\n                    lastTime %= this.duration;\n            }\n            var timelines = this.timelines;\n            for (var i = 0, n = timelines.length; i < n; i++)\n                timelines[i].apply(skeleton, lastTime, time, events, alpha, blend, direction);\n        };\n        Animation.binarySearch = function (values, target, step) {\n            if (step === void 0) { step = 1; }\n            var low = 0;\n            var high = values.length / step - 2;\n            if (high == 0)\n                return step;\n            var current = high >>> 1;\n            while (true) {\n                if (values[(current + 1) * step] <= target)\n                    low = current + 1;\n                else\n                    high = current;\n                if (low == high)\n                    return (low + 1) * step;\n                current = (low + high) >>> 1;\n            }\n        };\n        Animation.linearSearch = function (values, target, step) {\n            for (var i = 0, last = values.length - step; i <= last; i += step)\n                if (values[i] > target)\n                    return i;\n            return -1;\n        };\n        return Animation;\n    }());\n    spine.Animation = Animation;\n    var MixBlend;\n    (function (MixBlend) {\n        MixBlend[MixBlend[\"setup\"] = 0] = \"setup\";\n        MixBlend[MixBlend[\"first\"] = 1] = \"first\";\n        MixBlend[MixBlend[\"replace\"] = 2] = \"replace\";\n        MixBlend[MixBlend[\"add\"] = 3] = \"add\";\n    })(MixBlend = spine.MixBlend || (spine.MixBlend = {}));\n    var MixDirection;\n    (function (MixDirection) {\n        MixDirection[MixDirection[\"in\"] = 0] = \"in\";\n        MixDirection[MixDirection[\"out\"] = 1] = \"out\";\n    })(MixDirection = spine.MixDirection || (spine.MixDirection = {}));\n    var TimelineType;\n    (function (TimelineType) {\n        TimelineType[TimelineType[\"rotate\"] = 0] = \"rotate\";\n        TimelineType[TimelineType[\"translate\"] = 1] = \"translate\";\n        TimelineType[TimelineType[\"scale\"] = 2] = \"scale\";\n        TimelineType[TimelineType[\"shear\"] = 3] = \"shear\";\n        TimelineType[TimelineType[\"attachment\"] = 4] = \"attachment\";\n        TimelineType[TimelineType[\"color\"] = 5] = \"color\";\n        TimelineType[TimelineType[\"deform\"] = 6] = \"deform\";\n        TimelineType[TimelineType[\"event\"] = 7] = \"event\";\n        TimelineType[TimelineType[\"drawOrder\"] = 8] = \"drawOrder\";\n        TimelineType[TimelineType[\"ikConstraint\"] = 9] = \"ikConstraint\";\n        TimelineType[TimelineType[\"transformConstraint\"] = 10] = \"transformConstraint\";\n        TimelineType[TimelineType[\"pathConstraintPosition\"] = 11] = \"pathConstraintPosition\";\n        TimelineType[TimelineType[\"pathConstraintSpacing\"] = 12] = \"pathConstraintSpacing\";\n        TimelineType[TimelineType[\"pathConstraintMix\"] = 13] = \"pathConstraintMix\";\n        TimelineType[TimelineType[\"twoColor\"] = 14] = \"twoColor\";\n    })(TimelineType = spine.TimelineType || (spine.TimelineType = {}));\n    var CurveTimeline = (function () {\n        function CurveTimeline(frameCount) {\n            if (frameCount <= 0)\n                throw new Error(\"frameCount must be > 0: \" + frameCount);\n            this.curves = spine.Utils.newFloatArray((frameCount - 1) * CurveTimeline.BEZIER_SIZE);\n        }\n        CurveTimeline.prototype.getFrameCount = function () {\n            return this.curves.length / CurveTimeline.BEZIER_SIZE + 1;\n        };\n        CurveTimeline.prototype.setLinear = function (frameIndex) {\n            this.curves[frameIndex * CurveTimeline.BEZIER_SIZE] = CurveTimeline.LINEAR;\n        };\n        CurveTimeline.prototype.setStepped = function (frameIndex) {\n            this.curves[frameIndex * CurveTimeline.BEZIER_SIZE] = CurveTimeline.STEPPED;\n        };\n        CurveTimeline.prototype.getCurveType = function (frameIndex) {\n            var index = frameIndex * CurveTimeline.BEZIER_SIZE;\n            if (index == this.curves.length)\n                return CurveTimeline.LINEAR;\n            var type = this.curves[index];\n            if (type == CurveTimeline.LINEAR)\n                return CurveTimeline.LINEAR;\n            if (type == CurveTimeline.STEPPED)\n                return CurveTimeline.STEPPED;\n            return CurveTimeline.BEZIER;\n        };\n        CurveTimeline.prototype.setCurve = function (frameIndex, cx1, cy1, cx2, cy2) {\n            var tmpx = (-cx1 * 2 + cx2) * 0.03, tmpy = (-cy1 * 2 + cy2) * 0.03;\n            var dddfx = ((cx1 - cx2) * 3 + 1) * 0.006, dddfy = ((cy1 - cy2) * 3 + 1) * 0.006;\n            var ddfx = tmpx * 2 + dddfx, ddfy = tmpy * 2 + dddfy;\n            var dfx = cx1 * 0.3 + tmpx + dddfx * 0.16666667, dfy = cy1 * 0.3 + tmpy + dddfy * 0.16666667;\n            var i = frameIndex * CurveTimeline.BEZIER_SIZE;\n            var curves = this.curves;\n            curves[i++] = CurveTimeline.BEZIER;\n            var x = dfx, y = dfy;\n            for (var n = i + CurveTimeline.BEZIER_SIZE - 1; i < n; i += 2) {\n                curves[i] = x;\n                curves[i + 1] = y;\n                dfx += ddfx;\n                dfy += ddfy;\n                ddfx += dddfx;\n                ddfy += dddfy;\n                x += dfx;\n                y += dfy;\n            }\n        };\n        CurveTimeline.prototype.getCurvePercent = function (frameIndex, percent) {\n            percent = spine.MathUtils.clamp(percent, 0, 1);\n            var curves = this.curves;\n            var i = frameIndex * CurveTimeline.BEZIER_SIZE;\n            var type = curves[i];\n            if (type == CurveTimeline.LINEAR)\n                return percent;\n            if (type == CurveTimeline.STEPPED)\n                return 0;\n            i++;\n            var x = 0;\n            for (var start = i, n = i + CurveTimeline.BEZIER_SIZE - 1; i < n; i += 2) {\n                x = curves[i];\n                if (x >= percent) {\n                    var prevX = void 0, prevY = void 0;\n                    if (i == start) {\n                        prevX = 0;\n                        prevY = 0;\n                    }\n                    else {\n                        prevX = curves[i - 2];\n                        prevY = curves[i - 1];\n                    }\n                    return prevY + (curves[i + 1] - prevY) * (percent - prevX) / (x - prevX);\n                }\n            }\n            var y = curves[i - 1];\n            return y + (1 - y) * (percent - x) / (1 - x);\n        };\n        CurveTimeline.LINEAR = 0;\n        CurveTimeline.STEPPED = 1;\n        CurveTimeline.BEZIER = 2;\n        CurveTimeline.BEZIER_SIZE = 10 * 2 - 1;\n        return CurveTimeline;\n    }());\n    spine.CurveTimeline = CurveTimeline;\n    var RotateTimeline = (function (_super) {\n        __extends(RotateTimeline, _super);\n        function RotateTimeline(frameCount) {\n            var _this = _super.call(this, frameCount) || this;\n            _this.frames = spine.Utils.newFloatArray(frameCount << 1);\n            return _this;\n        }\n        RotateTimeline.prototype.getPropertyId = function () {\n            return (TimelineType.rotate << 24) + this.boneIndex;\n        };\n        RotateTimeline.prototype.setFrame = function (frameIndex, time, degrees) {\n            frameIndex <<= 1;\n            this.frames[frameIndex] = time;\n            this.frames[frameIndex + RotateTimeline.ROTATION] = degrees;\n        };\n        RotateTimeline.prototype.apply = function (skeleton, lastTime, time, events, alpha, blend, direction) {\n            var frames = this.frames;\n            var bone = skeleton.bones[this.boneIndex];\n            if (time < frames[0]) {\n                switch (blend) {\n                    case MixBlend.setup:\n                        bone.rotation = bone.data.rotation;\n                        return;\n                    case MixBlend.first:\n                        var r_1 = bone.data.rotation - bone.rotation;\n                        bone.rotation += (r_1 - (16384 - ((16384.499999999996 - r_1 / 360) | 0)) * 360) * alpha;\n                }\n                return;\n            }\n            if (time >= frames[frames.length - RotateTimeline.ENTRIES]) {\n                var r_2 = frames[frames.length + RotateTimeline.PREV_ROTATION];\n                switch (blend) {\n                    case MixBlend.setup:\n                        bone.rotation = bone.data.rotation + r_2 * alpha;\n                        break;\n                    case MixBlend.first:\n                    case MixBlend.replace:\n                        r_2 += bone.data.rotation - bone.rotation;\n                        r_2 -= (16384 - ((16384.499999999996 - r_2 / 360) | 0)) * 360;\n                    case MixBlend.add:\n                        bone.rotation += r_2 * alpha;\n                }\n                return;\n            }\n            var frame = Animation.binarySearch(frames, time, RotateTimeline.ENTRIES);\n            var prevRotation = frames[frame + RotateTimeline.PREV_ROTATION];\n            var frameTime = frames[frame];\n            var percent = this.getCurvePercent((frame >> 1) - 1, 1 - (time - frameTime) / (frames[frame + RotateTimeline.PREV_TIME] - frameTime));\n            var r = frames[frame + RotateTimeline.ROTATION] - prevRotation;\n            r = prevRotation + (r - (16384 - ((16384.499999999996 - r / 360) | 0)) * 360) * percent;\n            switch (blend) {\n                case MixBlend.setup:\n                    bone.rotation = bone.data.rotation + (r - (16384 - ((16384.499999999996 - r / 360) | 0)) * 360) * alpha;\n                    break;\n                case MixBlend.first:\n                case MixBlend.replace:\n                    r += bone.data.rotation - bone.rotation;\n                case MixBlend.add:\n                    bone.rotation += (r - (16384 - ((16384.499999999996 - r / 360) | 0)) * 360) * alpha;\n            }\n        };\n        RotateTimeline.ENTRIES = 2;\n        RotateTimeline.PREV_TIME = -2;\n        RotateTimeline.PREV_ROTATION = -1;\n        RotateTimeline.ROTATION = 1;\n        return RotateTimeline;\n    }(CurveTimeline));\n    spine.RotateTimeline = RotateTimeline;\n    var TranslateTimeline = (function (_super) {\n        __extends(TranslateTimeline, _super);\n        function TranslateTimeline(frameCount) {\n            var _this = _super.call(this, frameCount) || this;\n            _this.frames = spine.Utils.newFloatArray(frameCount * TranslateTimeline.ENTRIES);\n            return _this;\n        }\n        TranslateTimeline.prototype.getPropertyId = function () {\n            return (TimelineType.translate << 24) + this.boneIndex;\n        };\n        TranslateTimeline.prototype.setFrame = function (frameIndex, time, x, y) {\n            frameIndex *= TranslateTimeline.ENTRIES;\n            this.frames[frameIndex] = time;\n            this.frames[frameIndex + TranslateTimeline.X] = x;\n            this.frames[frameIndex + TranslateTimeline.Y] = y;\n        };\n        TranslateTimeline.prototype.apply = function (skeleton, lastTime, time, events, alpha, blend, direction) {\n            var frames = this.frames;\n            var bone = skeleton.bones[this.boneIndex];\n            if (time < frames[0]) {\n                switch (blend) {\n                    case MixBlend.setup:\n                        bone.x = bone.data.x;\n                        bone.y = bone.data.y;\n                        return;\n                    case MixBlend.first:\n                        bone.x += (bone.data.x - bone.x) * alpha;\n                        bone.y += (bone.data.y - bone.y) * alpha;\n                }\n                return;\n            }\n            var x = 0, y = 0;\n            if (time >= frames[frames.length - TranslateTimeline.ENTRIES]) {\n                x = frames[frames.length + TranslateTimeline.PREV_X];\n                y = frames[frames.length + TranslateTimeline.PREV_Y];\n            }\n            else {\n                var frame = Animation.binarySearch(frames, time, TranslateTimeline.ENTRIES);\n                x = frames[frame + TranslateTimeline.PREV_X];\n                y = frames[frame + TranslateTimeline.PREV_Y];\n                var frameTime = frames[frame];\n                var percent = this.getCurvePercent(frame / TranslateTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + TranslateTimeline.PREV_TIME] - frameTime));\n                x += (frames[frame + TranslateTimeline.X] - x) * percent;\n                y += (frames[frame + TranslateTimeline.Y] - y) * percent;\n            }\n            switch (blend) {\n                case MixBlend.setup:\n                    bone.x = bone.data.x + x * alpha;\n                    bone.y = bone.data.y + y * alpha;\n                    break;\n                case MixBlend.first:\n                case MixBlend.replace:\n                    bone.x += (bone.data.x + x - bone.x) * alpha;\n                    bone.y += (bone.data.y + y - bone.y) * alpha;\n                    break;\n                case MixBlend.add:\n                    bone.x += x * alpha;\n                    bone.y += y * alpha;\n            }\n        };\n        TranslateTimeline.ENTRIES = 3;\n        TranslateTimeline.PREV_TIME = -3;\n        TranslateTimeline.PREV_X = -2;\n        TranslateTimeline.PREV_Y = -1;\n        TranslateTimeline.X = 1;\n        TranslateTimeline.Y = 2;\n        return TranslateTimeline;\n    }(CurveTimeline));\n    spine.TranslateTimeline = TranslateTimeline;\n    var ScaleTimeline = (function (_super) {\n        __extends(ScaleTimeline, _super);\n        function ScaleTimeline(frameCount) {\n            return _super.call(this, frameCount) || this;\n        }\n        ScaleTimeline.prototype.getPropertyId = function () {\n            return (TimelineType.scale << 24) + this.boneIndex;\n        };\n        ScaleTimeline.prototype.apply = function (skeleton, lastTime, time, events, alpha, blend, direction) {\n            var frames = this.frames;\n            var bone = skeleton.bones[this.boneIndex];\n            if (time < frames[0]) {\n                switch (blend) {\n                    case MixBlend.setup:\n                        bone.scaleX = bone.data.scaleX;\n                        bone.scaleY = bone.data.scaleY;\n                        return;\n                    case MixBlend.first:\n                        bone.scaleX += (bone.data.scaleX - bone.scaleX) * alpha;\n                        bone.scaleY += (bone.data.scaleY - bone.scaleY) * alpha;\n                }\n                return;\n            }\n            var x = 0, y = 0;\n            if (time >= frames[frames.length - ScaleTimeline.ENTRIES]) {\n                x = frames[frames.length + ScaleTimeline.PREV_X] * bone.data.scaleX;\n                y = frames[frames.length + ScaleTimeline.PREV_Y] * bone.data.scaleY;\n            }\n            else {\n                var frame = Animation.binarySearch(frames, time, ScaleTimeline.ENTRIES);\n                x = frames[frame + ScaleTimeline.PREV_X];\n                y = frames[frame + ScaleTimeline.PREV_Y];\n                var frameTime = frames[frame];\n                var percent = this.getCurvePercent(frame / ScaleTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + ScaleTimeline.PREV_TIME] - frameTime));\n                x = (x + (frames[frame + ScaleTimeline.X] - x) * percent) * bone.data.scaleX;\n                y = (y + (frames[frame + ScaleTimeline.Y] - y) * percent) * bone.data.scaleY;\n            }\n            if (alpha == 1) {\n                if (blend == MixBlend.add) {\n                    bone.scaleX += x - bone.data.scaleX;\n                    bone.scaleY += y - bone.data.scaleY;\n                }\n                else {\n                    bone.scaleX = x;\n                    bone.scaleY = y;\n                }\n            }\n            else {\n                var bx = 0, by = 0;\n                if (direction == MixDirection.out) {\n                    switch (blend) {\n                        case MixBlend.setup:\n                            bx = bone.data.scaleX;\n                            by = bone.data.scaleY;\n                            bone.scaleX = bx + (Math.abs(x) * spine.MathUtils.signum(bx) - bx) * alpha;\n                            bone.scaleY = by + (Math.abs(y) * spine.MathUtils.signum(by) - by) * alpha;\n                            break;\n                        case MixBlend.first:\n                        case MixBlend.replace:\n                            bx = bone.scaleX;\n                            by = bone.scaleY;\n                            bone.scaleX = bx + (Math.abs(x) * spine.MathUtils.signum(bx) - bx) * alpha;\n                            bone.scaleY = by + (Math.abs(y) * spine.MathUtils.signum(by) - by) * alpha;\n                            break;\n                        case MixBlend.add:\n                            bx = bone.scaleX;\n                            by = bone.scaleY;\n                            bone.scaleX = bx + (Math.abs(x) * spine.MathUtils.signum(bx) - bone.data.scaleX) * alpha;\n                            bone.scaleY = by + (Math.abs(y) * spine.MathUtils.signum(by) - bone.data.scaleY) * alpha;\n                    }\n                }\n                else {\n                    switch (blend) {\n                        case MixBlend.setup:\n                            bx = Math.abs(bone.data.scaleX) * spine.MathUtils.signum(x);\n                            by = Math.abs(bone.data.scaleY) * spine.MathUtils.signum(y);\n                            bone.scaleX = bx + (x - bx) * alpha;\n                            bone.scaleY = by + (y - by) * alpha;\n                            break;\n                        case MixBlend.first:\n                        case MixBlend.replace:\n                            bx = Math.abs(bone.scaleX) * spine.MathUtils.signum(x);\n                            by = Math.abs(bone.scaleY) * spine.MathUtils.signum(y);\n                            bone.scaleX = bx + (x - bx) * alpha;\n                            bone.scaleY = by + (y - by) * alpha;\n                            break;\n                        case MixBlend.add:\n                            bx = spine.MathUtils.signum(x);\n                            by = spine.MathUtils.signum(y);\n                            bone.scaleX = Math.abs(bone.scaleX) * bx + (x - Math.abs(bone.data.scaleX) * bx) * alpha;\n                            bone.scaleY = Math.abs(bone.scaleY) * by + (y - Math.abs(bone.data.scaleY) * by) * alpha;\n                    }\n                }\n            }\n        };\n        return ScaleTimeline;\n    }(TranslateTimeline));\n    spine.ScaleTimeline = ScaleTimeline;\n    var ShearTimeline = (function (_super) {\n        __extends(ShearTimeline, _super);\n        function ShearTimeline(frameCount) {\n            return _super.call(this, frameCount) || this;\n        }\n        ShearTimeline.prototype.getPropertyId = function () {\n            return (TimelineType.shear << 24) + this.boneIndex;\n        };\n        ShearTimeline.prototype.apply = function (skeleton, lastTime, time, events, alpha, blend, direction) {\n            var frames = this.frames;\n            var bone = skeleton.bones[this.boneIndex];\n            if (time < frames[0]) {\n                switch (blend) {\n                    case MixBlend.setup:\n                        bone.shearX = bone.data.shearX;\n                        bone.shearY = bone.data.shearY;\n                        return;\n                    case MixBlend.first:\n                        bone.shearX += (bone.data.shearX - bone.shearX) * alpha;\n                        bone.shearY += (bone.data.shearY - bone.shearY) * alpha;\n                }\n                return;\n            }\n            var x = 0, y = 0;\n            if (time >= frames[frames.length - ShearTimeline.ENTRIES]) {\n                x = frames[frames.length + ShearTimeline.PREV_X];\n                y = frames[frames.length + ShearTimeline.PREV_Y];\n            }\n            else {\n                var frame = Animation.binarySearch(frames, time, ShearTimeline.ENTRIES);\n                x = frames[frame + ShearTimeline.PREV_X];\n                y = frames[frame + ShearTimeline.PREV_Y];\n                var frameTime = frames[frame];\n                var percent = this.getCurvePercent(frame / ShearTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + ShearTimeline.PREV_TIME] - frameTime));\n                x = x + (frames[frame + ShearTimeline.X] - x) * percent;\n                y = y + (frames[frame + ShearTimeline.Y] - y) * percent;\n            }\n            switch (blend) {\n                case MixBlend.setup:\n                    bone.shearX = bone.data.shearX + x * alpha;\n                    bone.shearY = bone.data.shearY + y * alpha;\n                    break;\n                case MixBlend.first:\n                case MixBlend.replace:\n                    bone.shearX += (bone.data.shearX + x - bone.shearX) * alpha;\n                    bone.shearY += (bone.data.shearY + y - bone.shearY) * alpha;\n                    break;\n                case MixBlend.add:\n                    bone.shearX += x * alpha;\n                    bone.shearY += y * alpha;\n            }\n        };\n        return ShearTimeline;\n    }(TranslateTimeline));\n    spine.ShearTimeline = ShearTimeline;\n    var ColorTimeline = (function (_super) {\n        __extends(ColorTimeline, _super);\n        function ColorTimeline(frameCount) {\n            var _this = _super.call(this, frameCount) || this;\n            _this.frames = spine.Utils.newFloatArray(frameCount * ColorTimeline.ENTRIES);\n            return _this;\n        }\n        ColorTimeline.prototype.getPropertyId = function () {\n            return (TimelineType.color << 24) + this.slotIndex;\n        };\n        ColorTimeline.prototype.setFrame = function (frameIndex, time, r, g, b, a) {\n            frameIndex *= ColorTimeline.ENTRIES;\n            this.frames[frameIndex] = time;\n            this.frames[frameIndex + ColorTimeline.R] = r;\n            this.frames[frameIndex + ColorTimeline.G] = g;\n            this.frames[frameIndex + ColorTimeline.B] = b;\n            this.frames[frameIndex + ColorTimeline.A] = a;\n        };\n        ColorTimeline.prototype.apply = function (skeleton, lastTime, time, events, alpha, blend, direction) {\n            var slot = skeleton.slots[this.slotIndex];\n            var frames = this.frames;\n            if (time < frames[0]) {\n                switch (blend) {\n                    case MixBlend.setup:\n                        slot.color.setFromColor(slot.data.color);\n                        return;\n                    case MixBlend.first:\n                        var color = slot.color, setup = slot.data.color;\n                        color.add((setup.r - color.r) * alpha, (setup.g - color.g) * alpha, (setup.b - color.b) * alpha, (setup.a - color.a) * alpha);\n                }\n                return;\n            }\n            var r = 0, g = 0, b = 0, a = 0;\n            if (time >= frames[frames.length - ColorTimeline.ENTRIES]) {\n                var i = frames.length;\n                r = frames[i + ColorTimeline.PREV_R];\n                g = frames[i + ColorTimeline.PREV_G];\n                b = frames[i + ColorTimeline.PREV_B];\n                a = frames[i + ColorTimeline.PREV_A];\n            }\n            else {\n                var frame = Animation.binarySearch(frames, time, ColorTimeline.ENTRIES);\n                r = frames[frame + ColorTimeline.PREV_R];\n                g = frames[frame + ColorTimeline.PREV_G];\n                b = frames[frame + ColorTimeline.PREV_B];\n                a = frames[frame + ColorTimeline.PREV_A];\n                var frameTime = frames[frame];\n                var percent = this.getCurvePercent(frame / ColorTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + ColorTimeline.PREV_TIME] - frameTime));\n                r += (frames[frame + ColorTimeline.R] - r) * percent;\n                g += (frames[frame + ColorTimeline.G] - g) * percent;\n                b += (frames[frame + ColorTimeline.B] - b) * percent;\n                a += (frames[frame + ColorTimeline.A] - a) * percent;\n            }\n            if (alpha == 1)\n                slot.color.set(r, g, b, a);\n            else {\n                var color = slot.color;\n                if (blend == MixBlend.setup)\n                    color.setFromColor(slot.data.color);\n                color.add((r - color.r) * alpha, (g - color.g) * alpha, (b - color.b) * alpha, (a - color.a) * alpha);\n            }\n        };\n        ColorTimeline.ENTRIES = 5;\n        ColorTimeline.PREV_TIME = -5;\n        ColorTimeline.PREV_R = -4;\n        ColorTimeline.PREV_G = -3;\n        ColorTimeline.PREV_B = -2;\n        ColorTimeline.PREV_A = -1;\n        ColorTimeline.R = 1;\n        ColorTimeline.G = 2;\n        ColorTimeline.B = 3;\n        ColorTimeline.A = 4;\n        return ColorTimeline;\n    }(CurveTimeline));\n    spine.ColorTimeline = ColorTimeline;\n    var TwoColorTimeline = (function (_super) {\n        __extends(TwoColorTimeline, _super);\n        function TwoColorTimeline(frameCount) {\n            var _this = _super.call(this, frameCount) || this;\n            _this.frames = spine.Utils.newFloatArray(frameCount * TwoColorTimeline.ENTRIES);\n            return _this;\n        }\n        TwoColorTimeline.prototype.getPropertyId = function () {\n            return (TimelineType.twoColor << 24) + this.slotIndex;\n        };\n        TwoColorTimeline.prototype.setFrame = function (frameIndex, time, r, g, b, a, r2, g2, b2) {\n            frameIndex *= TwoColorTimeline.ENTRIES;\n            this.frames[frameIndex] = time;\n            this.frames[frameIndex + TwoColorTimeline.R] = r;\n            this.frames[frameIndex + TwoColorTimeline.G] = g;\n            this.frames[frameIndex + TwoColorTimeline.B] = b;\n            this.frames[frameIndex + TwoColorTimeline.A] = a;\n            this.frames[frameIndex + TwoColorTimeline.R2] = r2;\n            this.frames[frameIndex + TwoColorTimeline.G2] = g2;\n            this.frames[frameIndex + TwoColorTimeline.B2] = b2;\n        };\n        TwoColorTimeline.prototype.apply = function (skeleton, lastTime, time, events, alpha, blend, direction) {\n            var slot = skeleton.slots[this.slotIndex];\n            var frames = this.frames;\n            if (time < frames[0]) {\n                switch (blend) {\n                    case MixBlend.setup:\n                        slot.color.setFromColor(slot.data.color);\n                        slot.darkColor.setFromColor(slot.data.darkColor);\n                        return;\n                    case MixBlend.first:\n                        var light = slot.color, dark = slot.darkColor, setupLight = slot.data.color, setupDark = slot.data.darkColor;\n                        light.add((setupLight.r - light.r) * alpha, (setupLight.g - light.g) * alpha, (setupLight.b - light.b) * alpha, (setupLight.a - light.a) * alpha);\n                        dark.add((setupDark.r - dark.r) * alpha, (setupDark.g - dark.g) * alpha, (setupDark.b - dark.b) * alpha, 0);\n                }\n                return;\n            }\n            var r = 0, g = 0, b = 0, a = 0, r2 = 0, g2 = 0, b2 = 0;\n            if (time >= frames[frames.length - TwoColorTimeline.ENTRIES]) {\n                var i = frames.length;\n                r = frames[i + TwoColorTimeline.PREV_R];\n                g = frames[i + TwoColorTimeline.PREV_G];\n                b = frames[i + TwoColorTimeline.PREV_B];\n                a = frames[i + TwoColorTimeline.PREV_A];\n                r2 = frames[i + TwoColorTimeline.PREV_R2];\n                g2 = frames[i + TwoColorTimeline.PREV_G2];\n                b2 = frames[i + TwoColorTimeline.PREV_B2];\n            }\n            else {\n                var frame = Animation.binarySearch(frames, time, TwoColorTimeline.ENTRIES);\n                r = frames[frame + TwoColorTimeline.PREV_R];\n                g = frames[frame + TwoColorTimeline.PREV_G];\n                b = frames[frame + TwoColorTimeline.PREV_B];\n                a = frames[frame + TwoColorTimeline.PREV_A];\n                r2 = frames[frame + TwoColorTimeline.PREV_R2];\n                g2 = frames[frame + TwoColorTimeline.PREV_G2];\n                b2 = frames[frame + TwoColorTimeline.PREV_B2];\n                var frameTime = frames[frame];\n                var percent = this.getCurvePercent(frame / TwoColorTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + TwoColorTimeline.PREV_TIME] - frameTime));\n                r += (frames[frame + TwoColorTimeline.R] - r) * percent;\n                g += (frames[frame + TwoColorTimeline.G] - g) * percent;\n                b += (frames[frame + TwoColorTimeline.B] - b) * percent;\n                a += (frames[frame + TwoColorTimeline.A] - a) * percent;\n                r2 += (frames[frame + TwoColorTimeline.R2] - r2) * percent;\n                g2 += (frames[frame + TwoColorTimeline.G2] - g2) * percent;\n                b2 += (frames[frame + TwoColorTimeline.B2] - b2) * percent;\n            }\n            if (alpha == 1) {\n                slot.color.set(r, g, b, a);\n                slot.darkColor.set(r2, g2, b2, 1);\n            }\n            else {\n                var light = slot.color, dark = slot.darkColor;\n                if (blend == MixBlend.setup) {\n                    light.setFromColor(slot.data.color);\n                    dark.setFromColor(slot.data.darkColor);\n                }\n                light.add((r - light.r) * alpha, (g - light.g) * alpha, (b - light.b) * alpha, (a - light.a) * alpha);\n                dark.add((r2 - dark.r) * alpha, (g2 - dark.g) * alpha, (b2 - dark.b) * alpha, 0);\n            }\n        };\n        TwoColorTimeline.ENTRIES = 8;\n        TwoColorTimeline.PREV_TIME = -8;\n        TwoColorTimeline.PREV_R = -7;\n        TwoColorTimeline.PREV_G = -6;\n        TwoColorTimeline.PREV_B = -5;\n        TwoColorTimeline.PREV_A = -4;\n        TwoColorTimeline.PREV_R2 = -3;\n        TwoColorTimeline.PREV_G2 = -2;\n        TwoColorTimeline.PREV_B2 = -1;\n        TwoColorTimeline.R = 1;\n        TwoColorTimeline.G = 2;\n        TwoColorTimeline.B = 3;\n        TwoColorTimeline.A = 4;\n        TwoColorTimeline.R2 = 5;\n        TwoColorTimeline.G2 = 6;\n        TwoColorTimeline.B2 = 7;\n        return TwoColorTimeline;\n    }(CurveTimeline));\n    spine.TwoColorTimeline = TwoColorTimeline;\n    var AttachmentTimeline = (function () {\n        function AttachmentTimeline(frameCount) {\n            this.frames = spine.Utils.newFloatArray(frameCount);\n            this.attachmentNames = new Array(frameCount);\n        }\n        AttachmentTimeline.prototype.getPropertyId = function () {\n            return (TimelineType.attachment << 24) + this.slotIndex;\n        };\n        AttachmentTimeline.prototype.getFrameCount = function () {\n            return this.frames.length;\n        };\n        AttachmentTimeline.prototype.setFrame = function (frameIndex, time, attachmentName) {\n            this.frames[frameIndex] = time;\n            this.attachmentNames[frameIndex] = attachmentName;\n        };\n        AttachmentTimeline.prototype.apply = function (skeleton, lastTime, time, events, alpha, blend, direction) {\n            var slot = skeleton.slots[this.slotIndex];\n            if (direction == MixDirection.out && blend == MixBlend.setup) {\n                var attachmentName_1 = slot.data.attachmentName;\n                slot.setAttachment(attachmentName_1 == null ? null : skeleton.getAttachment(this.slotIndex, attachmentName_1));\n                return;\n            }\n            var frames = this.frames;\n            if (time < frames[0]) {\n                if (blend == MixBlend.setup || blend == MixBlend.first) {\n                    var attachmentName_2 = slot.data.attachmentName;\n                    slot.setAttachment(attachmentName_2 == null ? null : skeleton.getAttachment(this.slotIndex, attachmentName_2));\n                }\n                return;\n            }\n            var frameIndex = 0;\n            if (time >= frames[frames.length - 1])\n                frameIndex = frames.length - 1;\n            else\n                frameIndex = Animation.binarySearch(frames, time, 1) - 1;\n            var attachmentName = this.attachmentNames[frameIndex];\n            skeleton.slots[this.slotIndex]\n                .setAttachment(attachmentName == null ? null : skeleton.getAttachment(this.slotIndex, attachmentName));\n        };\n        return AttachmentTimeline;\n    }());\n    spine.AttachmentTimeline = AttachmentTimeline;\n    var zeros = null;\n    var DeformTimeline = (function (_super) {\n        __extends(DeformTimeline, _super);\n        function DeformTimeline(frameCount) {\n            var _this = _super.call(this, frameCount) || this;\n            _this.frames = spine.Utils.newFloatArray(frameCount);\n            _this.frameVertices = new Array(frameCount);\n            if (zeros == null)\n                zeros = spine.Utils.newFloatArray(64);\n            return _this;\n        }\n        DeformTimeline.prototype.getPropertyId = function () {\n            return (TimelineType.deform << 27) + +this.attachment.id + this.slotIndex;\n        };\n        DeformTimeline.prototype.setFrame = function (frameIndex, time, vertices) {\n            this.frames[frameIndex] = time;\n            this.frameVertices[frameIndex] = vertices;\n        };\n        DeformTimeline.prototype.apply = function (skeleton, lastTime, time, firedEvents, alpha, blend, direction) {\n            var slot = skeleton.slots[this.slotIndex];\n            var slotAttachment = slot.getAttachment();\n            if (!(slotAttachment instanceof spine.VertexAttachment) || !slotAttachment.applyDeform(this.attachment))\n                return;\n            var verticesArray = slot.attachmentVertices;\n            if (verticesArray.length == 0)\n                blend = MixBlend.setup;\n            var frameVertices = this.frameVertices;\n            var vertexCount = frameVertices[0].length;\n            var frames = this.frames;\n            if (time < frames[0]) {\n                var vertexAttachment = slotAttachment;\n                switch (blend) {\n                    case MixBlend.setup:\n                        verticesArray.length = 0;\n                        return;\n                    case MixBlend.first:\n                        if (alpha == 1) {\n                            verticesArray.length = 0;\n                            break;\n                        }\n                        var vertices_1 = spine.Utils.setArraySize(verticesArray, vertexCount);\n                        if (vertexAttachment.bones == null) {\n                            var setupVertices = vertexAttachment.vertices;\n                            for (var i = 0; i < vertexCount; i++)\n                                vertices_1[i] += (setupVertices[i] - vertices_1[i]) * alpha;\n                        }\n                        else {\n                            alpha = 1 - alpha;\n                            for (var i = 0; i < vertexCount; i++)\n                                vertices_1[i] *= alpha;\n                        }\n                }\n                return;\n            }\n            var vertices = spine.Utils.setArraySize(verticesArray, vertexCount);\n            if (time >= frames[frames.length - 1]) {\n                var lastVertices = frameVertices[frames.length - 1];\n                if (alpha == 1) {\n                    if (blend == MixBlend.add) {\n                        var vertexAttachment = slotAttachment;\n                        if (vertexAttachment.bones == null) {\n                            var setupVertices = vertexAttachment.vertices;\n                            for (var i_1 = 0; i_1 < vertexCount; i_1++) {\n                                vertices[i_1] += lastVertices[i_1] - setupVertices[i_1];\n                            }\n                        }\n                        else {\n                            for (var i_2 = 0; i_2 < vertexCount; i_2++)\n                                vertices[i_2] += lastVertices[i_2];\n                        }\n                    }\n                    else {\n                        spine.Utils.arrayCopy(lastVertices, 0, vertices, 0, vertexCount);\n                    }\n                }\n                else {\n                    switch (blend) {\n                        case MixBlend.setup: {\n                            var vertexAttachment_1 = slotAttachment;\n                            if (vertexAttachment_1.bones == null) {\n                                var setupVertices = vertexAttachment_1.vertices;\n                                for (var i_3 = 0; i_3 < vertexCount; i_3++) {\n                                    var setup = setupVertices[i_3];\n                                    vertices[i_3] = setup + (lastVertices[i_3] - setup) * alpha;\n                                }\n                            }\n                            else {\n                                for (var i_4 = 0; i_4 < vertexCount; i_4++)\n                                    vertices[i_4] = lastVertices[i_4] * alpha;\n                            }\n                            break;\n                        }\n                        case MixBlend.first:\n                        case MixBlend.replace:\n                            for (var i_5 = 0; i_5 < vertexCount; i_5++)\n                                vertices[i_5] += (lastVertices[i_5] - vertices[i_5]) * alpha;\n                        case MixBlend.add:\n                            var vertexAttachment = slotAttachment;\n                            if (vertexAttachment.bones == null) {\n                                var setupVertices = vertexAttachment.vertices;\n                                for (var i_6 = 0; i_6 < vertexCount; i_6++) {\n                                    vertices[i_6] += (lastVertices[i_6] - setupVertices[i_6]) * alpha;\n                                }\n                            }\n                            else {\n                                for (var i_7 = 0; i_7 < vertexCount; i_7++)\n                                    vertices[i_7] += lastVertices[i_7] * alpha;\n                            }\n                    }\n                }\n                return;\n            }\n            var frame = Animation.binarySearch(frames, time);\n            var prevVertices = frameVertices[frame - 1];\n            var nextVertices = frameVertices[frame];\n            var frameTime = frames[frame];\n            var percent = this.getCurvePercent(frame - 1, 1 - (time - frameTime) / (frames[frame - 1] - frameTime));\n            if (alpha == 1) {\n                if (blend == MixBlend.add) {\n                    var vertexAttachment = slotAttachment;\n                    if (vertexAttachment.bones == null) {\n                        var setupVertices = vertexAttachment.vertices;\n                        for (var i_8 = 0; i_8 < vertexCount; i_8++) {\n                            var prev = prevVertices[i_8];\n                            vertices[i_8] += prev + (nextVertices[i_8] - prev) * percent - setupVertices[i_8];\n                        }\n                    }\n                    else {\n                        for (var i_9 = 0; i_9 < vertexCount; i_9++) {\n                            var prev = prevVertices[i_9];\n                            vertices[i_9] += prev + (nextVertices[i_9] - prev) * percent;\n                        }\n                    }\n                }\n                else {\n                    for (var i_10 = 0; i_10 < vertexCount; i_10++) {\n                        var prev = prevVertices[i_10];\n                        vertices[i_10] = prev + (nextVertices[i_10] - prev) * percent;\n                    }\n                }\n            }\n            else {\n                switch (blend) {\n                    case MixBlend.setup: {\n                        var vertexAttachment_2 = slotAttachment;\n                        if (vertexAttachment_2.bones == null) {\n                            var setupVertices = vertexAttachment_2.vertices;\n                            for (var i_11 = 0; i_11 < vertexCount; i_11++) {\n                                var prev = prevVertices[i_11], setup = setupVertices[i_11];\n                                vertices[i_11] = setup + (prev + (nextVertices[i_11] - prev) * percent - setup) * alpha;\n                            }\n                        }\n                        else {\n                            for (var i_12 = 0; i_12 < vertexCount; i_12++) {\n                                var prev = prevVertices[i_12];\n                                vertices[i_12] = (prev + (nextVertices[i_12] - prev) * percent) * alpha;\n                            }\n                        }\n                        break;\n                    }\n                    case MixBlend.first:\n                    case MixBlend.replace:\n                        for (var i_13 = 0; i_13 < vertexCount; i_13++) {\n                            var prev = prevVertices[i_13];\n                            vertices[i_13] += (prev + (nextVertices[i_13] - prev) * percent - vertices[i_13]) * alpha;\n                        }\n                        break;\n                    case MixBlend.add:\n                        var vertexAttachment = slotAttachment;\n                        if (vertexAttachment.bones == null) {\n                            var setupVertices = vertexAttachment.vertices;\n                            for (var i_14 = 0; i_14 < vertexCount; i_14++) {\n                                var prev = prevVertices[i_14];\n                                vertices[i_14] += (prev + (nextVertices[i_14] - prev) * percent - setupVertices[i_14]) * alpha;\n                            }\n                        }\n                        else {\n                            for (var i_15 = 0; i_15 < vertexCount; i_15++) {\n                                var prev = prevVertices[i_15];\n                                vertices[i_15] += (prev + (nextVertices[i_15] - prev) * percent) * alpha;\n                            }\n                        }\n                }\n            }\n        };\n        return DeformTimeline;\n    }(CurveTimeline));\n    spine.DeformTimeline = DeformTimeline;\n    var EventTimeline = (function () {\n        function EventTimeline(frameCount) {\n            this.frames = spine.Utils.newFloatArray(frameCount);\n            this.events = new Array(frameCount);\n        }\n        EventTimeline.prototype.getPropertyId = function () {\n            return TimelineType.event << 24;\n        };\n        EventTimeline.prototype.getFrameCount = function () {\n            return this.frames.length;\n        };\n        EventTimeline.prototype.setFrame = function (frameIndex, event) {\n            this.frames[frameIndex] = event.time;\n            this.events[frameIndex] = event;\n        };\n        EventTimeline.prototype.apply = function (skeleton, lastTime, time, firedEvents, alpha, blend, direction) {\n            if (firedEvents == null)\n                return;\n            var frames = this.frames;\n            var frameCount = this.frames.length;\n            if (lastTime > time) {\n                this.apply(skeleton, lastTime, Number.MAX_VALUE, firedEvents, alpha, blend, direction);\n                lastTime = -1;\n            }\n            else if (lastTime >= frames[frameCount - 1])\n                return;\n            if (time < frames[0])\n                return;\n            var frame = 0;\n            if (lastTime < frames[0])\n                frame = 0;\n            else {\n                frame = Animation.binarySearch(frames, lastTime);\n                var frameTime = frames[frame];\n                while (frame > 0) {\n                    if (frames[frame - 1] != frameTime)\n                        break;\n                    frame--;\n                }\n            }\n            for (; frame < frameCount && time >= frames[frame]; frame++)\n                firedEvents.push(this.events[frame]);\n        };\n        return EventTimeline;\n    }());\n    spine.EventTimeline = EventTimeline;\n    var DrawOrderTimeline = (function () {\n        function DrawOrderTimeline(frameCount) {\n            this.frames = spine.Utils.newFloatArray(frameCount);\n            this.drawOrders = new Array(frameCount);\n        }\n        DrawOrderTimeline.prototype.getPropertyId = function () {\n            return TimelineType.drawOrder << 24;\n        };\n        DrawOrderTimeline.prototype.getFrameCount = function () {\n            return this.frames.length;\n        };\n        DrawOrderTimeline.prototype.setFrame = function (frameIndex, time, drawOrder) {\n            this.frames[frameIndex] = time;\n            this.drawOrders[frameIndex] = drawOrder;\n        };\n        DrawOrderTimeline.prototype.apply = function (skeleton, lastTime, time, firedEvents, alpha, blend, direction) {\n            var drawOrder = skeleton.drawOrder;\n            var slots = skeleton.slots;\n            if (direction == MixDirection.out && blend == MixBlend.setup) {\n                spine.Utils.arrayCopy(skeleton.slots, 0, skeleton.drawOrder, 0, skeleton.slots.length);\n                return;\n            }\n            var frames = this.frames;\n            if (time < frames[0]) {\n                if (blend == MixBlend.setup || blend == MixBlend.first)\n                    spine.Utils.arrayCopy(skeleton.slots, 0, skeleton.drawOrder, 0, skeleton.slots.length);\n                return;\n            }\n            var frame = 0;\n            if (time >= frames[frames.length - 1])\n                frame = frames.length - 1;\n            else\n                frame = Animation.binarySearch(frames, time) - 1;\n            var drawOrderToSetupIndex = this.drawOrders[frame];\n            if (drawOrderToSetupIndex == null)\n                spine.Utils.arrayCopy(slots, 0, drawOrder, 0, slots.length);\n            else {\n                for (var i = 0, n = drawOrderToSetupIndex.length; i < n; i++)\n                    drawOrder[i] = slots[drawOrderToSetupIndex[i]];\n            }\n        };\n        return DrawOrderTimeline;\n    }());\n    spine.DrawOrderTimeline = DrawOrderTimeline;\n    var IkConstraintTimeline = (function (_super) {\n        __extends(IkConstraintTimeline, _super);\n        function IkConstraintTimeline(frameCount) {\n            var _this = _super.call(this, frameCount) || this;\n            _this.frames = spine.Utils.newFloatArray(frameCount * IkConstraintTimeline.ENTRIES);\n            return _this;\n        }\n        IkConstraintTimeline.prototype.getPropertyId = function () {\n            return (TimelineType.ikConstraint << 24) + this.ikConstraintIndex;\n        };\n        IkConstraintTimeline.prototype.setFrame = function (frameIndex, time, mix, bendDirection, compress, stretch) {\n            frameIndex *= IkConstraintTimeline.ENTRIES;\n            this.frames[frameIndex] = time;\n            this.frames[frameIndex + IkConstraintTimeline.MIX] = mix;\n            this.frames[frameIndex + IkConstraintTimeline.BEND_DIRECTION] = bendDirection;\n            this.frames[frameIndex + IkConstraintTimeline.COMPRESS] = compress ? 1 : 0;\n            this.frames[frameIndex + IkConstraintTimeline.STRETCH] = stretch ? 1 : 0;\n        };\n        IkConstraintTimeline.prototype.apply = function (skeleton, lastTime, time, firedEvents, alpha, blend, direction) {\n            var frames = this.frames;\n            var constraint = skeleton.ikConstraints[this.ikConstraintIndex];\n            if (time < frames[0]) {\n                switch (blend) {\n                    case MixBlend.setup:\n                        constraint.mix = constraint.data.mix;\n                        constraint.bendDirection = constraint.data.bendDirection;\n                        constraint.compress = constraint.data.compress;\n                        constraint.stretch = constraint.data.stretch;\n                        return;\n                    case MixBlend.first:\n                        constraint.mix += (constraint.data.mix - constraint.mix) * alpha;\n                        constraint.bendDirection = constraint.data.bendDirection;\n                        constraint.compress = constraint.data.compress;\n                        constraint.stretch = constraint.data.stretch;\n                }\n                return;\n            }\n            if (time >= frames[frames.length - IkConstraintTimeline.ENTRIES]) {\n                if (blend == MixBlend.setup) {\n                    constraint.mix = constraint.data.mix + (frames[frames.length + IkConstraintTimeline.PREV_MIX] - constraint.data.mix) * alpha;\n                    if (direction == MixDirection.out) {\n                        constraint.bendDirection = constraint.data.bendDirection;\n                        constraint.compress = constraint.data.compress;\n                        constraint.stretch = constraint.data.stretch;\n                    }\n                    else {\n                        constraint.bendDirection = frames[frames.length + IkConstraintTimeline.PREV_BEND_DIRECTION];\n                        constraint.compress = frames[frames.length + IkConstraintTimeline.PREV_COMPRESS] != 0;\n                        constraint.stretch = frames[frames.length + IkConstraintTimeline.PREV_STRETCH] != 0;\n                    }\n                }\n                else {\n                    constraint.mix += (frames[frames.length + IkConstraintTimeline.PREV_MIX] - constraint.mix) * alpha;\n                    if (direction == MixDirection[\"in\"]) {\n                        constraint.bendDirection = frames[frames.length + IkConstraintTimeline.PREV_BEND_DIRECTION];\n                        constraint.compress = frames[frames.length + IkConstraintTimeline.PREV_COMPRESS] != 0;\n                        constraint.stretch = frames[frames.length + IkConstraintTimeline.PREV_STRETCH] != 0;\n                    }\n                }\n                return;\n            }\n            var frame = Animation.binarySearch(frames, time, IkConstraintTimeline.ENTRIES);\n            var mix = frames[frame + IkConstraintTimeline.PREV_MIX];\n            var frameTime = frames[frame];\n            var percent = this.getCurvePercent(frame / IkConstraintTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + IkConstraintTimeline.PREV_TIME] - frameTime));\n            if (blend == MixBlend.setup) {\n                constraint.mix = constraint.data.mix + (mix + (frames[frame + IkConstraintTimeline.MIX] - mix) * percent - constraint.data.mix) * alpha;\n                if (direction == MixDirection.out) {\n                    constraint.bendDirection = constraint.data.bendDirection;\n                    constraint.compress = constraint.data.compress;\n                    constraint.stretch = constraint.data.stretch;\n                }\n                else {\n                    constraint.bendDirection = frames[frame + IkConstraintTimeline.PREV_BEND_DIRECTION];\n                    constraint.compress = frames[frame + IkConstraintTimeline.PREV_COMPRESS] != 0;\n                    constraint.stretch = frames[frame + IkConstraintTimeline.PREV_STRETCH] != 0;\n                }\n            }\n            else {\n                constraint.mix += (mix + (frames[frame + IkConstraintTimeline.MIX] - mix) * percent - constraint.mix) * alpha;\n                if (direction == MixDirection[\"in\"]) {\n                    constraint.bendDirection = frames[frame + IkConstraintTimeline.PREV_BEND_DIRECTION];\n                    constraint.compress = frames[frame + IkConstraintTimeline.PREV_COMPRESS] != 0;\n                    constraint.stretch = frames[frame + IkConstraintTimeline.PREV_STRETCH] != 0;\n                }\n            }\n        };\n        IkConstraintTimeline.ENTRIES = 5;\n        IkConstraintTimeline.PREV_TIME = -5;\n        IkConstraintTimeline.PREV_MIX = -4;\n        IkConstraintTimeline.PREV_BEND_DIRECTION = -3;\n        IkConstraintTimeline.PREV_COMPRESS = -2;\n        IkConstraintTimeline.PREV_STRETCH = -1;\n        IkConstraintTimeline.MIX = 1;\n        IkConstraintTimeline.BEND_DIRECTION = 2;\n        IkConstraintTimeline.COMPRESS = 3;\n        IkConstraintTimeline.STRETCH = 4;\n        return IkConstraintTimeline;\n    }(CurveTimeline));\n    spine.IkConstraintTimeline = IkConstraintTimeline;\n    var TransformConstraintTimeline = (function (_super) {\n        __extends(TransformConstraintTimeline, _super);\n        function TransformConstraintTimeline(frameCount) {\n            var _this = _super.call(this, frameCount) || this;\n            _this.frames = spine.Utils.newFloatArray(frameCount * TransformConstraintTimeline.ENTRIES);\n            return _this;\n        }\n        TransformConstraintTimeline.prototype.getPropertyId = function () {\n            return (TimelineType.transformConstraint << 24) + this.transformConstraintIndex;\n        };\n        TransformConstraintTimeline.prototype.setFrame = function (frameIndex, time, rotateMix, translateMix, scaleMix, shearMix) {\n            frameIndex *= TransformConstraintTimeline.ENTRIES;\n            this.frames[frameIndex] = time;\n            this.frames[frameIndex + TransformConstraintTimeline.ROTATE] = rotateMix;\n            this.frames[frameIndex + TransformConstraintTimeline.TRANSLATE] = translateMix;\n            this.frames[frameIndex + TransformConstraintTimeline.SCALE] = scaleMix;\n            this.frames[frameIndex + TransformConstraintTimeline.SHEAR] = shearMix;\n        };\n        TransformConstraintTimeline.prototype.apply = function (skeleton, lastTime, time, firedEvents, alpha, blend, direction) {\n            var frames = this.frames;\n            var constraint = skeleton.transformConstraints[this.transformConstraintIndex];\n            if (time < frames[0]) {\n                var data = constraint.data;\n                switch (blend) {\n                    case MixBlend.setup:\n                        constraint.rotateMix = data.rotateMix;\n                        constraint.translateMix = data.translateMix;\n                        constraint.scaleMix = data.scaleMix;\n                        constraint.shearMix = data.shearMix;\n                        return;\n                    case MixBlend.first:\n                        constraint.rotateMix += (data.rotateMix - constraint.rotateMix) * alpha;\n                        constraint.translateMix += (data.translateMix - constraint.translateMix) * alpha;\n                        constraint.scaleMix += (data.scaleMix - constraint.scaleMix) * alpha;\n                        constraint.shearMix += (data.shearMix - constraint.shearMix) * alpha;\n                }\n                return;\n            }\n            var rotate = 0, translate = 0, scale = 0, shear = 0;\n            if (time >= frames[frames.length - TransformConstraintTimeline.ENTRIES]) {\n                var i = frames.length;\n                rotate = frames[i + TransformConstraintTimeline.PREV_ROTATE];\n                translate = frames[i + TransformConstraintTimeline.PREV_TRANSLATE];\n                scale = frames[i + TransformConstraintTimeline.PREV_SCALE];\n                shear = frames[i + TransformConstraintTimeline.PREV_SHEAR];\n            }\n            else {\n                var frame = Animation.binarySearch(frames, time, TransformConstraintTimeline.ENTRIES);\n                rotate = frames[frame + TransformConstraintTimeline.PREV_ROTATE];\n                translate = frames[frame + TransformConstraintTimeline.PREV_TRANSLATE];\n                scale = frames[frame + TransformConstraintTimeline.PREV_SCALE];\n                shear = frames[frame + TransformConstraintTimeline.PREV_SHEAR];\n                var frameTime = frames[frame];\n                var percent = this.getCurvePercent(frame / TransformConstraintTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + TransformConstraintTimeline.PREV_TIME] - frameTime));\n                rotate += (frames[frame + TransformConstraintTimeline.ROTATE] - rotate) * percent;\n                translate += (frames[frame + TransformConstraintTimeline.TRANSLATE] - translate) * percent;\n                scale += (frames[frame + TransformConstraintTimeline.SCALE] - scale) * percent;\n                shear += (frames[frame + TransformConstraintTimeline.SHEAR] - shear) * percent;\n            }\n            if (blend == MixBlend.setup) {\n                var data = constraint.data;\n                constraint.rotateMix = data.rotateMix + (rotate - data.rotateMix) * alpha;\n                constraint.translateMix = data.translateMix + (translate - data.translateMix) * alpha;\n                constraint.scaleMix = data.scaleMix + (scale - data.scaleMix) * alpha;\n                constraint.shearMix = data.shearMix + (shear - data.shearMix) * alpha;\n            }\n            else {\n                constraint.rotateMix += (rotate - constraint.rotateMix) * alpha;\n                constraint.translateMix += (translate - constraint.translateMix) * alpha;\n                constraint.scaleMix += (scale - constraint.scaleMix) * alpha;\n                constraint.shearMix += (shear - constraint.shearMix) * alpha;\n            }\n        };\n        TransformConstraintTimeline.ENTRIES = 5;\n        TransformConstraintTimeline.PREV_TIME = -5;\n        TransformConstraintTimeline.PREV_ROTATE = -4;\n        TransformConstraintTimeline.PREV_TRANSLATE = -3;\n        TransformConstraintTimeline.PREV_SCALE = -2;\n        TransformConstraintTimeline.PREV_SHEAR = -1;\n        TransformConstraintTimeline.ROTATE = 1;\n        TransformConstraintTimeline.TRANSLATE = 2;\n        TransformConstraintTimeline.SCALE = 3;\n        TransformConstraintTimeline.SHEAR = 4;\n        return TransformConstraintTimeline;\n    }(CurveTimeline));\n    spine.TransformConstraintTimeline = TransformConstraintTimeline;\n    var PathConstraintPositionTimeline = (function (_super) {\n        __extends(PathConstraintPositionTimeline, _super);\n        function PathConstraintPositionTimeline(frameCount) {\n            var _this = _super.call(this, frameCount) || this;\n            _this.frames = spine.Utils.newFloatArray(frameCount * PathConstraintPositionTimeline.ENTRIES);\n            return _this;\n        }\n        PathConstraintPositionTimeline.prototype.getPropertyId = function () {\n            return (TimelineType.pathConstraintPosition << 24) + this.pathConstraintIndex;\n        };\n        PathConstraintPositionTimeline.prototype.setFrame = function (frameIndex, time, value) {\n            frameIndex *= PathConstraintPositionTimeline.ENTRIES;\n            this.frames[frameIndex] = time;\n            this.frames[frameIndex + PathConstraintPositionTimeline.VALUE] = value;\n        };\n        PathConstraintPositionTimeline.prototype.apply = function (skeleton, lastTime, time, firedEvents, alpha, blend, direction) {\n            var frames = this.frames;\n            var constraint = skeleton.pathConstraints[this.pathConstraintIndex];\n            if (time < frames[0]) {\n                switch (blend) {\n                    case MixBlend.setup:\n                        constraint.position = constraint.data.position;\n                        return;\n                    case MixBlend.first:\n                        constraint.position += (constraint.data.position - constraint.position) * alpha;\n                }\n                return;\n            }\n            var position = 0;\n            if (time >= frames[frames.length - PathConstraintPositionTimeline.ENTRIES])\n                position = frames[frames.length + PathConstraintPositionTimeline.PREV_VALUE];\n            else {\n                var frame = Animation.binarySearch(frames, time, PathConstraintPositionTimeline.ENTRIES);\n                position = frames[frame + PathConstraintPositionTimeline.PREV_VALUE];\n                var frameTime = frames[frame];\n                var percent = this.getCurvePercent(frame / PathConstraintPositionTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + PathConstraintPositionTimeline.PREV_TIME] - frameTime));\n                position += (frames[frame + PathConstraintPositionTimeline.VALUE] - position) * percent;\n            }\n            if (blend == MixBlend.setup)\n                constraint.position = constraint.data.position + (position - constraint.data.position) * alpha;\n            else\n                constraint.position += (position - constraint.position) * alpha;\n        };\n        PathConstraintPositionTimeline.ENTRIES = 2;\n        PathConstraintPositionTimeline.PREV_TIME = -2;\n        PathConstraintPositionTimeline.PREV_VALUE = -1;\n        PathConstraintPositionTimeline.VALUE = 1;\n        return PathConstraintPositionTimeline;\n    }(CurveTimeline));\n    spine.PathConstraintPositionTimeline = PathConstraintPositionTimeline;\n    var PathConstraintSpacingTimeline = (function (_super) {\n        __extends(PathConstraintSpacingTimeline, _super);\n        function PathConstraintSpacingTimeline(frameCount) {\n            return _super.call(this, frameCount) || this;\n        }\n        PathConstraintSpacingTimeline.prototype.getPropertyId = function () {\n            return (TimelineType.pathConstraintSpacing << 24) + this.pathConstraintIndex;\n        };\n        PathConstraintSpacingTimeline.prototype.apply = function (skeleton, lastTime, time, firedEvents, alpha, blend, direction) {\n            var frames = this.frames;\n            var constraint = skeleton.pathConstraints[this.pathConstraintIndex];\n            if (time < frames[0]) {\n                switch (blend) {\n                    case MixBlend.setup:\n                        constraint.spacing = constraint.data.spacing;\n                        return;\n                    case MixBlend.first:\n                        constraint.spacing += (constraint.data.spacing - constraint.spacing) * alpha;\n                }\n                return;\n            }\n            var spacing = 0;\n            if (time >= frames[frames.length - PathConstraintSpacingTimeline.ENTRIES])\n                spacing = frames[frames.length + PathConstraintSpacingTimeline.PREV_VALUE];\n            else {\n                var frame = Animation.binarySearch(frames, time, PathConstraintSpacingTimeline.ENTRIES);\n                spacing = frames[frame + PathConstraintSpacingTimeline.PREV_VALUE];\n                var frameTime = frames[frame];\n                var percent = this.getCurvePercent(frame / PathConstraintSpacingTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + PathConstraintSpacingTimeline.PREV_TIME] - frameTime));\n                spacing += (frames[frame + PathConstraintSpacingTimeline.VALUE] - spacing) * percent;\n            }\n            if (blend == MixBlend.setup)\n                constraint.spacing = constraint.data.spacing + (spacing - constraint.data.spacing) * alpha;\n            else\n                constraint.spacing += (spacing - constraint.spacing) * alpha;\n        };\n        return PathConstraintSpacingTimeline;\n    }(PathConstraintPositionTimeline));\n    spine.PathConstraintSpacingTimeline = PathConstraintSpacingTimeline;\n    var PathConstraintMixTimeline = (function (_super) {\n        __extends(PathConstraintMixTimeline, _super);\n        function PathConstraintMixTimeline(frameCount) {\n            var _this = _super.call(this, frameCount) || this;\n            _this.frames = spine.Utils.newFloatArray(frameCount * PathConstraintMixTimeline.ENTRIES);\n            return _this;\n        }\n        PathConstraintMixTimeline.prototype.getPropertyId = function () {\n            return (TimelineType.pathConstraintMix << 24) + this.pathConstraintIndex;\n        };\n        PathConstraintMixTimeline.prototype.setFrame = function (frameIndex, time, rotateMix, translateMix) {\n            frameIndex *= PathConstraintMixTimeline.ENTRIES;\n            this.frames[frameIndex] = time;\n            this.frames[frameIndex + PathConstraintMixTimeline.ROTATE] = rotateMix;\n            this.frames[frameIndex + PathConstraintMixTimeline.TRANSLATE] = translateMix;\n        };\n        PathConstraintMixTimeline.prototype.apply = function (skeleton, lastTime, time, firedEvents, alpha, blend, direction) {\n            var frames = this.frames;\n            var constraint = skeleton.pathConstraints[this.pathConstraintIndex];\n            if (time < frames[0]) {\n                switch (blend) {\n                    case MixBlend.setup:\n                        constraint.rotateMix = constraint.data.rotateMix;\n                        constraint.translateMix = constraint.data.translateMix;\n                        return;\n                    case MixBlend.first:\n                        constraint.rotateMix += (constraint.data.rotateMix - constraint.rotateMix) * alpha;\n                        constraint.translateMix += (constraint.data.translateMix - constraint.translateMix) * alpha;\n                }\n                return;\n            }\n            var rotate = 0, translate = 0;\n            if (time >= frames[frames.length - PathConstraintMixTimeline.ENTRIES]) {\n                rotate = frames[frames.length + PathConstraintMixTimeline.PREV_ROTATE];\n                translate = frames[frames.length + PathConstraintMixTimeline.PREV_TRANSLATE];\n            }\n            else {\n                var frame = Animation.binarySearch(frames, time, PathConstraintMixTimeline.ENTRIES);\n                rotate = frames[frame + PathConstraintMixTimeline.PREV_ROTATE];\n                translate = frames[frame + PathConstraintMixTimeline.PREV_TRANSLATE];\n                var frameTime = frames[frame];\n                var percent = this.getCurvePercent(frame / PathConstraintMixTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + PathConstraintMixTimeline.PREV_TIME] - frameTime));\n                rotate += (frames[frame + PathConstraintMixTimeline.ROTATE] - rotate) * percent;\n                translate += (frames[frame + PathConstraintMixTimeline.TRANSLATE] - translate) * percent;\n            }\n            if (blend == MixBlend.setup) {\n                constraint.rotateMix = constraint.data.rotateMix + (rotate - constraint.data.rotateMix) * alpha;\n                constraint.translateMix = constraint.data.translateMix + (translate - constraint.data.translateMix) * alpha;\n            }\n            else {\n                constraint.rotateMix += (rotate - constraint.rotateMix) * alpha;\n                constraint.translateMix += (translate - constraint.translateMix) * alpha;\n            }\n        };\n        PathConstraintMixTimeline.ENTRIES = 3;\n        PathConstraintMixTimeline.PREV_TIME = -3;\n        PathConstraintMixTimeline.PREV_ROTATE = -2;\n        PathConstraintMixTimeline.PREV_TRANSLATE = -1;\n        PathConstraintMixTimeline.ROTATE = 1;\n        PathConstraintMixTimeline.TRANSLATE = 2;\n        return PathConstraintMixTimeline;\n    }(CurveTimeline));\n    spine.PathConstraintMixTimeline = PathConstraintMixTimeline;\n})(spine || (spine = {}));\nvar spine;\n(function (spine) {\n    var AnimationState = (function () {\n        function AnimationState(data) {\n            this.tracks = new Array();\n            this.events = new Array();\n            this.listeners = new Array();\n            this.queue = new EventQueue(this);\n            this.propertyIDs = new spine.IntSet();\n            this.animationsChanged = false;\n            this.timeScale = 1;\n            this.trackEntryPool = new spine.Pool(function () { return new TrackEntry(); });\n            this.data = data;\n        }\n        AnimationState.prototype.update = function (delta) {\n            delta *= this.timeScale;\n            var tracks = this.tracks;\n            for (var i = 0, n = tracks.length; i < n; i++) {\n                var current = tracks[i];\n                if (current == null)\n                    continue;\n                current.animationLast = current.nextAnimationLast;\n                current.trackLast = current.nextTrackLast;\n                var currentDelta = delta * current.timeScale;\n                if (current.delay > 0) {\n                    current.delay -= currentDelta;\n                    if (current.delay > 0)\n                        continue;\n                    currentDelta = -current.delay;\n                    current.delay = 0;\n                }\n                var next = current.next;\n                if (next != null) {\n                    var nextTime = current.trackLast - next.delay;\n                    if (nextTime >= 0) {\n                        next.delay = 0;\n                        next.trackTime = current.timeScale == 0 ? 0 : (nextTime / current.timeScale + delta) * next.timeScale;\n                        current.trackTime += currentDelta;\n                        this.setCurrent(i, next, true);\n                        while (next.mixingFrom != null) {\n                            next.mixTime += delta;\n                            next = next.mixingFrom;\n                        }\n                        continue;\n                    }\n                }\n                else if (current.trackLast >= current.trackEnd && current.mixingFrom == null) {\n                    tracks[i] = null;\n                    this.queue.end(current);\n                    this.disposeNext(current);\n                    continue;\n                }\n                if (current.mixingFrom != null && this.updateMixingFrom(current, delta)) {\n                    var from = current.mixingFrom;\n                    current.mixingFrom = null;\n                    if (from != null)\n                        from.mixingTo = null;\n                    while (from != null) {\n                        this.queue.end(from);\n                        from = from.mixingFrom;\n                    }\n                }\n                current.trackTime += currentDelta;\n            }\n            this.queue.drain();\n        };\n        AnimationState.prototype.updateMixingFrom = function (to, delta) {\n            var from = to.mixingFrom;\n            if (from == null)\n                return true;\n            var finished = this.updateMixingFrom(from, delta);\n            from.animationLast = from.nextAnimationLast;\n            from.trackLast = from.nextTrackLast;\n            if (to.mixTime > 0 && to.mixTime >= to.mixDuration) {\n                if (from.totalAlpha == 0 || to.mixDuration == 0) {\n                    to.mixingFrom = from.mixingFrom;\n                    if (from.mixingFrom != null)\n                        from.mixingFrom.mixingTo = to;\n                    to.interruptAlpha = from.interruptAlpha;\n                    this.queue.end(from);\n                }\n                return finished;\n            }\n            from.trackTime += delta * from.timeScale;\n            to.mixTime += delta;\n            return false;\n        };\n        AnimationState.prototype.apply = function (skeleton) {\n            if (skeleton == null)\n                throw new Error(\"skeleton cannot be null.\");\n            if (this.animationsChanged)\n                this._animationsChanged();\n            var events = this.events;\n            var tracks = this.tracks;\n            var applied = false;\n            for (var i = 0, n = tracks.length; i < n; i++) {\n                var current = tracks[i];\n                if (current == null || current.delay > 0)\n                    continue;\n                applied = true;\n                var blend = i == 0 ? spine.MixBlend.first : current.mixBlend;\n                var mix = current.alpha;\n                if (current.mixingFrom != null)\n                    mix *= this.applyMixingFrom(current, skeleton, blend);\n                else if (current.trackTime >= current.trackEnd && current.next == null)\n                    mix = 0;\n                var animationLast = current.animationLast, animationTime = current.getAnimationTime();\n                var timelineCount = current.animation.timelines.length;\n                var timelines = current.animation.timelines;\n                if ((i == 0 && mix == 1) || blend == spine.MixBlend.add) {\n                    for (var ii = 0; ii < timelineCount; ii++)\n                        timelines[ii].apply(skeleton, animationLast, animationTime, events, mix, blend, spine.MixDirection[\"in\"]);\n                }\n                else {\n                    var timelineMode = current.timelineMode;\n                    var firstFrame = current.timelinesRotation.length == 0;\n                    if (firstFrame)\n                        spine.Utils.setArraySize(current.timelinesRotation, timelineCount << 1, null);\n                    var timelinesRotation = current.timelinesRotation;\n                    for (var ii = 0; ii < timelineCount; ii++) {\n                        var timeline = timelines[ii];\n                        var timelineBlend = timelineMode[ii] == AnimationState.SUBSEQUENT ? blend : spine.MixBlend.setup;\n                        if (timeline instanceof spine.RotateTimeline) {\n                            this.applyRotateTimeline(timeline, skeleton, animationTime, mix, timelineBlend, timelinesRotation, ii << 1, firstFrame);\n                        }\n                        else {\n                            spine.Utils.webkit602BugfixHelper(mix, blend);\n                            timeline.apply(skeleton, animationLast, animationTime, events, mix, timelineBlend, spine.MixDirection[\"in\"]);\n                        }\n                    }\n                }\n                this.queueEvents(current, animationTime);\n                events.length = 0;\n                current.nextAnimationLast = animationTime;\n                current.nextTrackLast = current.trackTime;\n            }\n            this.queue.drain();\n            return applied;\n        };\n        AnimationState.prototype.applyMixingFrom = function (to, skeleton, blend) {\n            var from = to.mixingFrom;\n            if (from.mixingFrom != null)\n                this.applyMixingFrom(from, skeleton, blend);\n            var mix = 0;\n            if (to.mixDuration == 0) {\n                mix = 1;\n                if (blend == spine.MixBlend.first)\n                    blend = spine.MixBlend.setup;\n            }\n            else {\n                mix = to.mixTime / to.mixDuration;\n                if (mix > 1)\n                    mix = 1;\n                if (blend != spine.MixBlend.first)\n                    blend = from.mixBlend;\n            }\n            var events = mix < from.eventThreshold ? this.events : null;\n            var attachments = mix < from.attachmentThreshold, drawOrder = mix < from.drawOrderThreshold;\n            var animationLast = from.animationLast, animationTime = from.getAnimationTime();\n            var timelineCount = from.animation.timelines.length;\n            var timelines = from.animation.timelines;\n            var alphaHold = from.alpha * to.interruptAlpha, alphaMix = alphaHold * (1 - mix);\n            if (blend == spine.MixBlend.add) {\n                for (var i = 0; i < timelineCount; i++)\n                    timelines[i].apply(skeleton, animationLast, animationTime, events, alphaMix, blend, spine.MixDirection.out);\n            }\n            else {\n                var timelineMode = from.timelineMode;\n                var timelineHoldMix = from.timelineHoldMix;\n                var firstFrame = from.timelinesRotation.length == 0;\n                if (firstFrame)\n                    spine.Utils.setArraySize(from.timelinesRotation, timelineCount << 1, null);\n                var timelinesRotation = from.timelinesRotation;\n                from.totalAlpha = 0;\n                for (var i = 0; i < timelineCount; i++) {\n                    var timeline = timelines[i];\n                    var direction = spine.MixDirection.out;\n                    var timelineBlend = void 0;\n                    var alpha = 0;\n                    switch (timelineMode[i]) {\n                        case AnimationState.SUBSEQUENT:\n                            if (!attachments && timeline instanceof spine.AttachmentTimeline)\n                                continue;\n                            if (!drawOrder && timeline instanceof spine.DrawOrderTimeline)\n                                continue;\n                            timelineBlend = blend;\n                            alpha = alphaMix;\n                            break;\n                        case AnimationState.FIRST:\n                            timelineBlend = spine.MixBlend.setup;\n                            alpha = alphaMix;\n                            break;\n                        case AnimationState.HOLD:\n                            timelineBlend = spine.MixBlend.setup;\n                            alpha = alphaHold;\n                            break;\n                        default:\n                            timelineBlend = spine.MixBlend.setup;\n                            var holdMix = timelineHoldMix[i];\n                            alpha = alphaHold * Math.max(0, 1 - holdMix.mixTime / holdMix.mixDuration);\n                            break;\n                    }\n                    from.totalAlpha += alpha;\n                    if (timeline instanceof spine.RotateTimeline)\n                        this.applyRotateTimeline(timeline, skeleton, animationTime, alpha, timelineBlend, timelinesRotation, i << 1, firstFrame);\n                    else {\n                        spine.Utils.webkit602BugfixHelper(alpha, blend);\n                        if (timelineBlend == spine.MixBlend.setup) {\n                            if (timeline instanceof spine.AttachmentTimeline) {\n                                if (attachments)\n                                    direction = spine.MixDirection.out;\n                            }\n                            else if (timeline instanceof spine.DrawOrderTimeline) {\n                                if (drawOrder)\n                                    direction = spine.MixDirection.out;\n                            }\n                        }\n                        timeline.apply(skeleton, animationLast, animationTime, events, alpha, timelineBlend, direction);\n                    }\n                }\n            }\n            if (to.mixDuration > 0)\n                this.queueEvents(from, animationTime);\n            this.events.length = 0;\n            from.nextAnimationLast = animationTime;\n            from.nextTrackLast = from.trackTime;\n            return mix;\n        };\n        AnimationState.prototype.applyRotateTimeline = function (timeline, skeleton, time, alpha, blend, timelinesRotation, i, firstFrame) {\n            if (firstFrame)\n                timelinesRotation[i] = 0;\n            if (alpha == 1) {\n                timeline.apply(skeleton, 0, time, null, 1, blend, spine.MixDirection[\"in\"]);\n                return;\n            }\n            var rotateTimeline = timeline;\n            var frames = rotateTimeline.frames;\n            var bone = skeleton.bones[rotateTimeline.boneIndex];\n            var r1 = 0, r2 = 0;\n            if (time < frames[0]) {\n                switch (blend) {\n                    case spine.MixBlend.setup:\n                        bone.rotation = bone.data.rotation;\n                    default:\n                        return;\n                    case spine.MixBlend.first:\n                        r1 = bone.rotation;\n                        r2 = bone.data.rotation;\n                }\n            }\n            else {\n                r1 = blend == spine.MixBlend.setup ? bone.data.rotation : bone.rotation;\n                if (time >= frames[frames.length - spine.RotateTimeline.ENTRIES])\n                    r2 = bone.data.rotation + frames[frames.length + spine.RotateTimeline.PREV_ROTATION];\n                else {\n                    var frame = spine.Animation.binarySearch(frames, time, spine.RotateTimeline.ENTRIES);\n                    var prevRotation = frames[frame + spine.RotateTimeline.PREV_ROTATION];\n                    var frameTime = frames[frame];\n                    var percent = rotateTimeline.getCurvePercent((frame >> 1) - 1, 1 - (time - frameTime) / (frames[frame + spine.RotateTimeline.PREV_TIME] - frameTime));\n                    r2 = frames[frame + spine.RotateTimeline.ROTATION] - prevRotation;\n                    r2 -= (16384 - ((16384.499999999996 - r2 / 360) | 0)) * 360;\n                    r2 = prevRotation + r2 * percent + bone.data.rotation;\n                    r2 -= (16384 - ((16384.499999999996 - r2 / 360) | 0)) * 360;\n                }\n            }\n            var total = 0, diff = r2 - r1;\n            diff -= (16384 - ((16384.499999999996 - diff / 360) | 0)) * 360;\n            if (diff == 0) {\n                total = timelinesRotation[i];\n            }\n            else {\n                var lastTotal = 0, lastDiff = 0;\n                if (firstFrame) {\n                    lastTotal = 0;\n                    lastDiff = diff;\n                }\n                else {\n                    lastTotal = timelinesRotation[i];\n                    lastDiff = timelinesRotation[i + 1];\n                }\n                var current = diff > 0, dir = lastTotal >= 0;\n                if (spine.MathUtils.signum(lastDiff) != spine.MathUtils.signum(diff) && Math.abs(lastDiff) <= 90) {\n                    if (Math.abs(lastTotal) > 180)\n                        lastTotal += 360 * spine.MathUtils.signum(lastTotal);\n                    dir = current;\n                }\n                total = diff + lastTotal - lastTotal % 360;\n                if (dir != current)\n                    total += 360 * spine.MathUtils.signum(lastTotal);\n                timelinesRotation[i] = total;\n            }\n            timelinesRotation[i + 1] = diff;\n            r1 += total * alpha;\n            bone.rotation = r1 - (16384 - ((16384.499999999996 - r1 / 360) | 0)) * 360;\n        };\n        AnimationState.prototype.queueEvents = function (entry, animationTime) {\n            var animationStart = entry.animationStart, animationEnd = entry.animationEnd;\n            var duration = animationEnd - animationStart;\n            var trackLastWrapped = entry.trackLast % duration;\n            var events = this.events;\n            var i = 0, n = events.length;\n            for (; i < n; i++) {\n                var event_1 = events[i];\n                if (event_1.time < trackLastWrapped)\n                    break;\n                if (event_1.time > animationEnd)\n                    continue;\n                this.queue.event(entry, event_1);\n            }\n            var complete = false;\n            if (entry.loop)\n                complete = duration == 0 || trackLastWrapped > entry.trackTime % duration;\n            else\n                complete = animationTime >= animationEnd && entry.animationLast < animationEnd;\n            if (complete)\n                this.queue.complete(entry);\n            for (; i < n; i++) {\n                var event_2 = events[i];\n                if (event_2.time < animationStart)\n                    continue;\n                this.queue.event(entry, events[i]);\n            }\n        };\n        AnimationState.prototype.clearTracks = function () {\n            var oldDrainDisabled = this.queue.drainDisabled;\n            this.queue.drainDisabled = true;\n            for (var i = 0, n = this.tracks.length; i < n; i++)\n                this.clearTrack(i);\n            this.tracks.length = 0;\n            this.queue.drainDisabled = oldDrainDisabled;\n            this.queue.drain();\n        };\n        AnimationState.prototype.clearTrack = function (trackIndex) {\n            if (trackIndex >= this.tracks.length)\n                return;\n            var current = this.tracks[trackIndex];\n            if (current == null)\n                return;\n            this.queue.end(current);\n            this.disposeNext(current);\n            var entry = current;\n            while (true) {\n                var from = entry.mixingFrom;\n                if (from == null)\n                    break;\n                this.queue.end(from);\n                entry.mixingFrom = null;\n                entry.mixingTo = null;\n                entry = from;\n            }\n            this.tracks[current.trackIndex] = null;\n            this.queue.drain();\n        };\n        AnimationState.prototype.setCurrent = function (index, current, interrupt) {\n            var from = this.expandToIndex(index);\n            this.tracks[index] = current;\n            if (from != null) {\n                if (interrupt)\n                    this.queue.interrupt(from);\n                current.mixingFrom = from;\n                from.mixingTo = current;\n                current.mixTime = 0;\n                if (from.mixingFrom != null && from.mixDuration > 0)\n                    current.interruptAlpha *= Math.min(1, from.mixTime / from.mixDuration);\n                from.timelinesRotation.length = 0;\n            }\n            this.queue.start(current);\n        };\n        AnimationState.prototype.setAnimation = function (trackIndex, animationName, loop) {\n            var animation = this.data.skeletonData.findAnimation(animationName);\n            if (animation == null)\n                throw new Error(\"Animation not found: \" + animationName);\n            return this.setAnimationWith(trackIndex, animation, loop);\n        };\n        AnimationState.prototype.setAnimationWith = function (trackIndex, animation, loop) {\n            if (animation == null)\n                throw new Error(\"animation cannot be null.\");\n            var interrupt = true;\n            var current = this.expandToIndex(trackIndex);\n            if (current != null) {\n                if (current.nextTrackLast == -1) {\n                    this.tracks[trackIndex] = current.mixingFrom;\n                    this.queue.interrupt(current);\n                    this.queue.end(current);\n                    this.disposeNext(current);\n                    current = current.mixingFrom;\n                    interrupt = false;\n                }\n                else\n                    this.disposeNext(current);\n            }\n            var entry = this.trackEntry(trackIndex, animation, loop, current);\n            this.setCurrent(trackIndex, entry, interrupt);\n            this.queue.drain();\n            return entry;\n        };\n        AnimationState.prototype.addAnimation = function (trackIndex, animationName, loop, delay) {\n            var animation = this.data.skeletonData.findAnimation(animationName);\n            if (animation == null)\n                throw new Error(\"Animation not found: \" + animationName);\n            return this.addAnimationWith(trackIndex, animation, loop, delay);\n        };\n        AnimationState.prototype.addAnimationWith = function (trackIndex, animation, loop, delay) {\n            if (animation == null)\n                throw new Error(\"animation cannot be null.\");\n            var last = this.expandToIndex(trackIndex);\n            if (last != null) {\n                while (last.next != null)\n                    last = last.next;\n            }\n            var entry = this.trackEntry(trackIndex, animation, loop, last);\n            if (last == null) {\n                this.setCurrent(trackIndex, entry, true);\n                this.queue.drain();\n            }\n            else {\n                last.next = entry;\n                if (delay <= 0) {\n                    var duration = last.animationEnd - last.animationStart;\n                    if (duration != 0) {\n                        if (last.loop)\n                            delay += duration * (1 + ((last.trackTime / duration) | 0));\n                        else\n                            delay += Math.max(duration, last.trackTime);\n                        delay -= this.data.getMix(last.animation, animation);\n                    }\n                    else\n                        delay = last.trackTime;\n                }\n            }\n            entry.delay = delay;\n            return entry;\n        };\n        AnimationState.prototype.setEmptyAnimation = function (trackIndex, mixDuration) {\n            var entry = this.setAnimationWith(trackIndex, AnimationState.emptyAnimation, false);\n            entry.mixDuration = mixDuration;\n            entry.trackEnd = mixDuration;\n            return entry;\n        };\n        AnimationState.prototype.addEmptyAnimation = function (trackIndex, mixDuration, delay) {\n            if (delay <= 0)\n                delay -= mixDuration;\n            var entry = this.addAnimationWith(trackIndex, AnimationState.emptyAnimation, false, delay);\n            entry.mixDuration = mixDuration;\n            entry.trackEnd = mixDuration;\n            return entry;\n        };\n        AnimationState.prototype.setEmptyAnimations = function (mixDuration) {\n            var oldDrainDisabled = this.queue.drainDisabled;\n            this.queue.drainDisabled = true;\n            for (var i = 0, n = this.tracks.length; i < n; i++) {\n                var current = this.tracks[i];\n                if (current != null)\n                    this.setEmptyAnimation(current.trackIndex, mixDuration);\n            }\n            this.queue.drainDisabled = oldDrainDisabled;\n            this.queue.drain();\n        };\n        AnimationState.prototype.expandToIndex = function (index) {\n            if (index < this.tracks.length)\n                return this.tracks[index];\n            spine.Utils.ensureArrayCapacity(this.tracks, index + 1, null);\n            this.tracks.length = index + 1;\n            return null;\n        };\n        AnimationState.prototype.trackEntry = function (trackIndex, animation, loop, last) {\n            var entry = this.trackEntryPool.obtain();\n            entry.trackIndex = trackIndex;\n            entry.animation = animation;\n            entry.loop = loop;\n            entry.holdPrevious = false;\n            entry.eventThreshold = 0;\n            entry.attachmentThreshold = 0;\n            entry.drawOrderThreshold = 0;\n            entry.animationStart = 0;\n            entry.animationEnd = animation.duration;\n            entry.animationLast = -1;\n            entry.nextAnimationLast = -1;\n            entry.delay = 0;\n            entry.trackTime = 0;\n            entry.trackLast = -1;\n            entry.nextTrackLast = -1;\n            entry.trackEnd = Number.MAX_VALUE;\n            entry.timeScale = 1;\n            entry.alpha = 1;\n            entry.interruptAlpha = 1;\n            entry.mixTime = 0;\n            entry.mixDuration = last == null ? 0 : this.data.getMix(last.animation, animation);\n            return entry;\n        };\n        AnimationState.prototype.disposeNext = function (entry) {\n            var next = entry.next;\n            while (next != null) {\n                this.queue.dispose(next);\n                next = next.next;\n            }\n            entry.next = null;\n        };\n        AnimationState.prototype._animationsChanged = function () {\n            this.animationsChanged = false;\n            this.propertyIDs.clear();\n            for (var i = 0, n = this.tracks.length; i < n; i++) {\n                var entry = this.tracks[i];\n                if (entry == null)\n                    continue;\n                while (entry.mixingFrom != null)\n                    entry = entry.mixingFrom;\n                do {\n                    if (entry.mixingFrom == null || entry.mixBlend != spine.MixBlend.add)\n                        this.setTimelineModes(entry);\n                    entry = entry.mixingTo;\n                } while (entry != null);\n            }\n        };\n        AnimationState.prototype.setTimelineModes = function (entry) {\n            var to = entry.mixingTo;\n            var timelines = entry.animation.timelines;\n            var timelinesCount = entry.animation.timelines.length;\n            var timelineMode = spine.Utils.setArraySize(entry.timelineMode, timelinesCount);\n            entry.timelineHoldMix.length = 0;\n            var timelineDipMix = spine.Utils.setArraySize(entry.timelineHoldMix, timelinesCount);\n            var propertyIDs = this.propertyIDs;\n            if (to != null && to.holdPrevious) {\n                for (var i = 0; i < timelinesCount; i++) {\n                    propertyIDs.add(timelines[i].getPropertyId());\n                    timelineMode[i] = AnimationState.HOLD;\n                }\n                return;\n            }\n            outer: for (var i = 0; i < timelinesCount; i++) {\n                var id = timelines[i].getPropertyId();\n                if (!propertyIDs.add(id))\n                    timelineMode[i] = AnimationState.SUBSEQUENT;\n                else if (to == null || !this.hasTimeline(to, id))\n                    timelineMode[i] = AnimationState.FIRST;\n                else {\n                    for (var next = to.mixingTo; next != null; next = next.mixingTo) {\n                        if (this.hasTimeline(next, id))\n                            continue;\n                        if (entry.mixDuration > 0) {\n                            timelineMode[i] = AnimationState.HOLD_MIX;\n                            timelineDipMix[i] = next;\n                            continue outer;\n                        }\n                        break;\n                    }\n                    timelineMode[i] = AnimationState.HOLD;\n                }\n            }\n        };\n        AnimationState.prototype.hasTimeline = function (entry, id) {\n            var timelines = entry.animation.timelines;\n            for (var i = 0, n = timelines.length; i < n; i++)\n                if (timelines[i].getPropertyId() == id)\n                    return true;\n            return false;\n        };\n        AnimationState.prototype.getCurrent = function (trackIndex) {\n            if (trackIndex >= this.tracks.length)\n                return null;\n            return this.tracks[trackIndex];\n        };\n        AnimationState.prototype.addListener = function (listener) {\n            if (listener == null)\n                throw new Error(\"listener cannot be null.\");\n            this.listeners.push(listener);\n        };\n        AnimationState.prototype.removeListener = function (listener) {\n            var index = this.listeners.indexOf(listener);\n            if (index >= 0)\n                this.listeners.splice(index, 1);\n        };\n        AnimationState.prototype.clearListeners = function () {\n            this.listeners.length = 0;\n        };\n        AnimationState.prototype.clearListenerNotifications = function () {\n            this.queue.clear();\n        };\n        AnimationState.emptyAnimation = new spine.Animation(\"<empty>\", [], 0);\n        AnimationState.SUBSEQUENT = 0;\n        AnimationState.FIRST = 1;\n        AnimationState.HOLD = 2;\n        AnimationState.HOLD_MIX = 3;\n        return AnimationState;\n    }());\n    spine.AnimationState = AnimationState;\n    var TrackEntry = (function () {\n        function TrackEntry() {\n            this.mixBlend = spine.MixBlend.replace;\n            this.timelineMode = new Array();\n            this.timelineHoldMix = new Array();\n            this.timelinesRotation = new Array();\n        }\n        TrackEntry.prototype.reset = function () {\n            this.next = null;\n            this.mixingFrom = null;\n            this.mixingTo = null;\n            this.animation = null;\n            this.listener = null;\n            this.timelineMode.length = 0;\n            this.timelineHoldMix.length = 0;\n            this.timelinesRotation.length = 0;\n        };\n        TrackEntry.prototype.getAnimationTime = function () {\n            if (this.loop) {\n                var duration = this.animationEnd - this.animationStart;\n                if (duration == 0)\n                    return this.animationStart;\n                return (this.trackTime % duration) + this.animationStart;\n            }\n            return Math.min(this.trackTime + this.animationStart, this.animationEnd);\n        };\n        TrackEntry.prototype.setAnimationLast = function (animationLast) {\n            this.animationLast = animationLast;\n            this.nextAnimationLast = animationLast;\n        };\n        TrackEntry.prototype.isComplete = function () {\n            return this.trackTime >= this.animationEnd - this.animationStart;\n        };\n        TrackEntry.prototype.resetRotationDirections = function () {\n            this.timelinesRotation.length = 0;\n        };\n        return TrackEntry;\n    }());\n    spine.TrackEntry = TrackEntry;\n    var EventQueue = (function () {\n        function EventQueue(animState) {\n            this.objects = [];\n            this.drainDisabled = false;\n            this.animState = animState;\n        }\n        EventQueue.prototype.start = function (entry) {\n            this.objects.push(EventType.start);\n            this.objects.push(entry);\n            this.animState.animationsChanged = true;\n        };\n        EventQueue.prototype.interrupt = function (entry) {\n            this.objects.push(EventType.interrupt);\n            this.objects.push(entry);\n        };\n        EventQueue.prototype.end = function (entry) {\n            this.objects.push(EventType.end);\n            this.objects.push(entry);\n            this.animState.animationsChanged = true;\n        };\n        EventQueue.prototype.dispose = function (entry) {\n            this.objects.push(EventType.dispose);\n            this.objects.push(entry);\n        };\n        EventQueue.prototype.complete = function (entry) {\n            this.objects.push(EventType.complete);\n            this.objects.push(entry);\n        };\n        EventQueue.prototype.event = function (entry, event) {\n            this.objects.push(EventType.event);\n            this.objects.push(entry);\n            this.objects.push(event);\n        };\n        EventQueue.prototype.drain = function () {\n            if (this.drainDisabled)\n                return;\n            this.drainDisabled = true;\n            var objects = this.objects;\n            var listeners = this.animState.listeners;\n            for (var i = 0; i < objects.length; i += 2) {\n                var type = objects[i];\n                var entry = objects[i + 1];\n                switch (type) {\n                    case EventType.start:\n                        if (entry.listener != null && entry.listener.start)\n                            entry.listener.start(entry);\n                        for (var ii = 0; ii < listeners.length; ii++)\n                            if (listeners[ii].start)\n                                listeners[ii].start(entry);\n                        break;\n                    case EventType.interrupt:\n                        if (entry.listener != null && entry.listener.interrupt)\n                            entry.listener.interrupt(entry);\n                        for (var ii = 0; ii < listeners.length; ii++)\n                            if (listeners[ii].interrupt)\n                                listeners[ii].interrupt(entry);\n                        break;\n                    case EventType.end:\n                        if (entry.listener != null && entry.listener.end)\n                            entry.listener.end(entry);\n                        for (var ii = 0; ii < listeners.length; ii++)\n                            if (listeners[ii].end)\n                                listeners[ii].end(entry);\n                    case EventType.dispose:\n                        if (entry.listener != null && entry.listener.dispose)\n                            entry.listener.dispose(entry);\n                        for (var ii = 0; ii < listeners.length; ii++)\n                            if (listeners[ii].dispose)\n                                listeners[ii].dispose(entry);\n                        this.animState.trackEntryPool.free(entry);\n                        break;\n                    case EventType.complete:\n                        if (entry.listener != null && entry.listener.complete)\n                            entry.listener.complete(entry);\n                        for (var ii = 0; ii < listeners.length; ii++)\n                            if (listeners[ii].complete)\n                                listeners[ii].complete(entry);\n                        break;\n                    case EventType.event:\n                        var event_3 = objects[i++ + 2];\n                        if (entry.listener != null && entry.listener.event)\n                            entry.listener.event(entry, event_3);\n                        for (var ii = 0; ii < listeners.length; ii++)\n                            if (listeners[ii].event)\n                                listeners[ii].event(entry, event_3);\n                        break;\n                }\n            }\n            this.clear();\n            this.drainDisabled = false;\n        };\n        EventQueue.prototype.clear = function () {\n            this.objects.length = 0;\n        };\n        return EventQueue;\n    }());\n    spine.EventQueue = EventQueue;\n    var EventType;\n    (function (EventType) {\n        EventType[EventType[\"start\"] = 0] = \"start\";\n        EventType[EventType[\"interrupt\"] = 1] = \"interrupt\";\n        EventType[EventType[\"end\"] = 2] = \"end\";\n        EventType[EventType[\"dispose\"] = 3] = \"dispose\";\n        EventType[EventType[\"complete\"] = 4] = \"complete\";\n        EventType[EventType[\"event\"] = 5] = \"event\";\n    })(EventType = spine.EventType || (spine.EventType = {}));\n    var AnimationStateAdapter2 = (function () {\n        function AnimationStateAdapter2() {\n        }\n        AnimationStateAdapter2.prototype.start = function (entry) {\n        };\n        AnimationStateAdapter2.prototype.interrupt = function (entry) {\n        };\n        AnimationStateAdapter2.prototype.end = function (entry) {\n        };\n        AnimationStateAdapter2.prototype.dispose = function (entry) {\n        };\n        AnimationStateAdapter2.prototype.complete = function (entry) {\n        };\n        AnimationStateAdapter2.prototype.event = function (entry, event) {\n        };\n        return AnimationStateAdapter2;\n    }());\n    spine.AnimationStateAdapter2 = AnimationStateAdapter2;\n})(spine || (spine = {}));\nvar spine;\n(function (spine) {\n    var AnimationStateData = (function () {\n        function AnimationStateData(skeletonData) {\n            this.animationToMixTime = {};\n            this.defaultMix = 0;\n            if (skeletonData == null)\n                throw new Error(\"skeletonData cannot be null.\");\n            this.skeletonData = skeletonData;\n        }\n        AnimationStateData.prototype.setMix = function (fromName, toName, duration) {\n            var from = this.skeletonData.findAnimation(fromName);\n            if (from == null)\n                throw new Error(\"Animation not found: \" + fromName);\n            var to = this.skeletonData.findAnimation(toName);\n            if (to == null)\n                throw new Error(\"Animation not found: \" + toName);\n            this.setMixWith(from, to, duration);\n        };\n        AnimationStateData.prototype.setMixWith = function (from, to, duration) {\n            if (from == null)\n                throw new Error(\"from cannot be null.\");\n            if (to == null)\n                throw new Error(\"to cannot be null.\");\n            var key = from.name + \".\" + to.name;\n            this.animationToMixTime[key] = duration;\n        };\n        AnimationStateData.prototype.getMix = function (from, to) {\n            var key = from.name + \".\" + to.name;\n            var value = this.animationToMixTime[key];\n            return value === undefined ? this.defaultMix : value;\n        };\n        return AnimationStateData;\n    }());\n    spine.AnimationStateData = AnimationStateData;\n})(spine || (spine = {}));\nvar spine;\n(function (spine) {\n    var AssetManager = (function () {\n        function AssetManager(textureLoader, pathPrefix) {\n            if (pathPrefix === void 0) { pathPrefix = \"\"; }\n            this.assets = {};\n            this.errors = {};\n            this.toLoad = 0;\n            this.loaded = 0;\n            this.textureLoader = textureLoader;\n            this.pathPrefix = pathPrefix;\n        }\n        AssetManager.downloadText = function (url, success, error) {\n            var request = new XMLHttpRequest();\n            request.open(\"GET\", url, true);\n            request.onload = function () {\n                if (request.status == 200) {\n                    success(request.responseText);\n                }\n                else {\n                    error(request.status, request.responseText);\n                }\n            };\n            request.onerror = function () {\n                error(request.status, request.responseText);\n            };\n            request.send();\n        };\n        AssetManager.downloadBinary = function (url, success, error) {\n            var request = new XMLHttpRequest();\n            request.open(\"GET\", url, true);\n            request.responseType = \"arraybuffer\";\n            request.onload = function () {\n                if (request.status == 200) {\n                    success(new Uint8Array(request.response));\n                }\n                else {\n                    error(request.status, request.responseText);\n                }\n            };\n            request.onerror = function () {\n                error(request.status, request.responseText);\n            };\n            request.send();\n        };\n        AssetManager.prototype.loadText = function (path, success, error) {\n            var _this = this;\n            if (success === void 0) { success = null; }\n            if (error === void 0) { error = null; }\n            path = this.pathPrefix + path;\n            this.toLoad++;\n            AssetManager.downloadText(path, function (data) {\n                _this.assets[path] = data;\n                if (success)\n                    success(path, data);\n                _this.toLoad--;\n                _this.loaded++;\n            }, function (state, responseText) {\n                _this.errors[path] = \"Couldn't load text \" + path + \": status \" + status + \", \" + responseText;\n                if (error)\n                    error(path, \"Couldn't load text \" + path + \": status \" + status + \", \" + responseText);\n                _this.toLoad--;\n                _this.loaded++;\n            });\n        };\n        AssetManager.prototype.loadTexture = function (path, success, error) {\n            var _this = this;\n            if (success === void 0) { success = null; }\n            if (error === void 0) { error = null; }\n            path = this.pathPrefix + path;\n            this.toLoad++;\n            var img = new Image();\n            img.crossOrigin = \"anonymous\";\n            img.onload = function (ev) {\n                var texture = _this.textureLoader(img);\n                _this.assets[path] = texture;\n                _this.toLoad--;\n                _this.loaded++;\n                if (success)\n                    success(path, img);\n            };\n            img.onerror = function (ev) {\n                _this.errors[path] = \"Couldn't load image \" + path;\n                _this.toLoad--;\n                _this.loaded++;\n                if (error)\n                    error(path, \"Couldn't load image \" + path);\n            };\n            img.src = path;\n        };\n        AssetManager.prototype.loadTextureData = function (path, data, success, error) {\n            var _this = this;\n            if (success === void 0) { success = null; }\n            if (error === void 0) { error = null; }\n            path = this.pathPrefix + path;\n            this.toLoad++;\n            var img = new Image();\n            img.onload = function (ev) {\n                var texture = _this.textureLoader(img);\n                _this.assets[path] = texture;\n                _this.toLoad--;\n                _this.loaded++;\n                if (success)\n                    success(path, img);\n            };\n            img.onerror = function (ev) {\n                _this.errors[path] = \"Couldn't load image \" + path;\n                _this.toLoad--;\n                _this.loaded++;\n                if (error)\n                    error(path, \"Couldn't load image \" + path);\n            };\n            img.src = data;\n        };\n        AssetManager.prototype.loadTextureAtlas = function (path, success, error) {\n            var _this = this;\n            if (success === void 0) { success = null; }\n            if (error === void 0) { error = null; }\n            var parent = path.lastIndexOf(\"/\") >= 0 ? path.substring(0, path.lastIndexOf(\"/\")) : \"\";\n            path = this.pathPrefix + path;\n            this.toLoad++;\n            AssetManager.downloadText(path, function (atlasData) {\n                var pagesLoaded = { count: 0 };\n                var atlasPages = new Array();\n                try {\n                    var atlas = new spine.TextureAtlas(atlasData, function (path) {\n                        atlasPages.push(parent + \"/\" + path);\n                        var image = document.createElement(\"img\");\n                        image.width = 16;\n                        image.height = 16;\n                        return new spine.FakeTexture(image);\n                    });\n                }\n                catch (e) {\n                    var ex = e;\n                    _this.errors[path] = \"Couldn't load texture atlas \" + path + \": \" + ex.message;\n                    if (error)\n                        error(path, \"Couldn't load texture atlas \" + path + \": \" + ex.message);\n                    _this.toLoad--;\n                    _this.loaded++;\n                    return;\n                }\n                var _loop_1 = function (atlasPage) {\n                    var pageLoadError = false;\n                    _this.loadTexture(atlasPage, function (imagePath, image) {\n                        pagesLoaded.count++;\n                        if (pagesLoaded.count == atlasPages.length) {\n                            if (!pageLoadError) {\n                                try {\n                                    var atlas = new spine.TextureAtlas(atlasData, function (path) {\n                                        return _this.get(parent + \"/\" + path);\n                                    });\n                                    _this.assets[path] = atlas;\n                                    if (success)\n                                        success(path, atlas);\n                                    _this.toLoad--;\n                                    _this.loaded++;\n                                }\n                                catch (e) {\n                                    var ex = e;\n                                    _this.errors[path] = \"Couldn't load texture atlas \" + path + \": \" + ex.message;\n                                    if (error)\n                                        error(path, \"Couldn't load texture atlas \" + path + \": \" + ex.message);\n                                    _this.toLoad--;\n                                    _this.loaded++;\n                                }\n                            }\n                            else {\n                                _this.errors[path] = \"Couldn't load texture atlas page \" + imagePath + \"} of atlas \" + path;\n                                if (error)\n                                    error(path, \"Couldn't load texture atlas page \" + imagePath + \" of atlas \" + path);\n                                _this.toLoad--;\n                                _this.loaded++;\n                            }\n                        }\n                    }, function (imagePath, errorMessage) {\n                        pageLoadError = true;\n                        pagesLoaded.count++;\n                        if (pagesLoaded.count == atlasPages.length) {\n                            _this.errors[path] = \"Couldn't load texture atlas page \" + imagePath + \"} of atlas \" + path;\n                            if (error)\n                                error(path, \"Couldn't load texture atlas page \" + imagePath + \" of atlas \" + path);\n                            _this.toLoad--;\n                            _this.loaded++;\n                        }\n                    });\n                };\n                for (var _i = 0, atlasPages_1 = atlasPages; _i < atlasPages_1.length; _i++) {\n                    var atlasPage = atlasPages_1[_i];\n                    _loop_1(atlasPage);\n                }\n            }, function (state, responseText) {\n                _this.errors[path] = \"Couldn't load texture atlas \" + path + \": status \" + status + \", \" + responseText;\n                if (error)\n                    error(path, \"Couldn't load texture atlas \" + path + \": status \" + status + \", \" + responseText);\n                _this.toLoad--;\n                _this.loaded++;\n            });\n        };\n        AssetManager.prototype.get = function (path) {\n            path = this.pathPrefix + path;\n            return this.assets[path];\n        };\n        AssetManager.prototype.remove = function (path) {\n            path = this.pathPrefix + path;\n            var asset = this.assets[path];\n            if (asset.dispose)\n                asset.dispose();\n            this.assets[path] = null;\n        };\n        AssetManager.prototype.removeAll = function () {\n            for (var key in this.assets) {\n                var asset = this.assets[key];\n                if (asset.dispose)\n                    asset.dispose();\n            }\n            this.assets = {};\n        };\n        AssetManager.prototype.isLoadingComplete = function () {\n            return this.toLoad == 0;\n        };\n        AssetManager.prototype.getToLoad = function () {\n            return this.toLoad;\n        };\n        AssetManager.prototype.getLoaded = function () {\n            return this.loaded;\n        };\n        AssetManager.prototype.dispose = function () {\n            this.removeAll();\n        };\n        AssetManager.prototype.hasErrors = function () {\n            return Object.keys(this.errors).length > 0;\n        };\n        AssetManager.prototype.getErrors = function () {\n            return this.errors;\n        };\n        return AssetManager;\n    }());\n    spine.AssetManager = AssetManager;\n})(spine || (spine = {}));\nvar spine;\n(function (spine) {\n    var AtlasAttachmentLoader = (function () {\n        function AtlasAttachmentLoader(atlas) {\n            this.atlas = atlas;\n        }\n        AtlasAttachmentLoader.prototype.newRegionAttachment = function (skin, name, path) {\n            var region = this.atlas.findRegion(path);\n            if (region == null)\n                throw new Error(\"Region not found in atlas: \" + path + \" (region attachment: \" + name + \")\");\n            region.renderObject = region;\n            var attachment = new spine.RegionAttachment(name);\n            attachment.setRegion(region);\n            return attachment;\n        };\n        AtlasAttachmentLoader.prototype.newMeshAttachment = function (skin, name, path) {\n            var region = this.atlas.findRegion(path);\n            if (region == null)\n                throw new Error(\"Region not found in atlas: \" + path + \" (mesh attachment: \" + name + \")\");\n            region.renderObject = region;\n            var attachment = new spine.MeshAttachment(name);\n            attachment.region = region;\n            return attachment;\n        };\n        AtlasAttachmentLoader.prototype.newBoundingBoxAttachment = function (skin, name) {\n            return new spine.BoundingBoxAttachment(name);\n        };\n        AtlasAttachmentLoader.prototype.newPathAttachment = function (skin, name) {\n            return new spine.PathAttachment(name);\n        };\n        AtlasAttachmentLoader.prototype.newPointAttachment = function (skin, name) {\n            return new spine.PointAttachment(name);\n        };\n        AtlasAttachmentLoader.prototype.newClippingAttachment = function (skin, name) {\n            return new spine.ClippingAttachment(name);\n        };\n        return AtlasAttachmentLoader;\n    }());\n    spine.AtlasAttachmentLoader = AtlasAttachmentLoader;\n})(spine || (spine = {}));\nvar spine;\n(function (spine) {\n    var BlendMode;\n    (function (BlendMode) {\n        BlendMode[BlendMode[\"Normal\"] = 0] = \"Normal\";\n        BlendMode[BlendMode[\"Additive\"] = 1] = \"Additive\";\n        BlendMode[BlendMode[\"Multiply\"] = 2] = \"Multiply\";\n        BlendMode[BlendMode[\"Screen\"] = 3] = \"Screen\";\n    })(BlendMode = spine.BlendMode || (spine.BlendMode = {}));\n})(spine || (spine = {}));\nvar spine;\n(function (spine) {\n    var Bone = (function () {\n        function Bone(data, skeleton, parent) {\n            this.children = new Array();\n            this.x = 0;\n            this.y = 0;\n            this.rotation = 0;\n            this.scaleX = 0;\n            this.scaleY = 0;\n            this.shearX = 0;\n            this.shearY = 0;\n            this.ax = 0;\n            this.ay = 0;\n            this.arotation = 0;\n            this.ascaleX = 0;\n            this.ascaleY = 0;\n            this.ashearX = 0;\n            this.ashearY = 0;\n            this.appliedValid = false;\n            this.a = 0;\n            this.b = 0;\n            this.worldX = 0;\n            this.c = 0;\n            this.d = 0;\n            this.worldY = 0;\n            this.sorted = false;\n            if (data == null)\n                throw new Error(\"data cannot be null.\");\n            if (skeleton == null)\n                throw new Error(\"skeleton cannot be null.\");\n            this.data = data;\n            this.skeleton = skeleton;\n            this.parent = parent;\n            this.setToSetupPose();\n        }\n        Bone.prototype.update = function () {\n            this.updateWorldTransformWith(this.x, this.y, this.rotation, this.scaleX, this.scaleY, this.shearX, this.shearY);\n        };\n        Bone.prototype.updateWorldTransform = function () {\n            this.updateWorldTransformWith(this.x, this.y, this.rotation, this.scaleX, this.scaleY, this.shearX, this.shearY);\n        };\n        Bone.prototype.updateWorldTransformWith = function (x, y, rotation, scaleX, scaleY, shearX, shearY) {\n            this.ax = x;\n            this.ay = y;\n            this.arotation = rotation;\n            this.ascaleX = scaleX;\n            this.ascaleY = scaleY;\n            this.ashearX = shearX;\n            this.ashearY = shearY;\n            this.appliedValid = true;\n            var parent = this.parent;\n            if (parent == null) {\n                var skeleton = this.skeleton;\n                var rotationY = rotation + 90 + shearY;\n                var sx = skeleton.scaleX;\n                var sy = skeleton.scaleY;\n                this.a = spine.MathUtils.cosDeg(rotation + shearX) * scaleX * sx;\n                this.b = spine.MathUtils.cosDeg(rotationY) * scaleY * sx;\n                this.c = spine.MathUtils.sinDeg(rotation + shearX) * scaleX * sy;\n                this.d = spine.MathUtils.sinDeg(rotationY) * scaleY * sy;\n                this.worldX = x * sx + skeleton.x;\n                this.worldY = y * sy + skeleton.y;\n                return;\n            }\n            var pa = parent.a, pb = parent.b, pc = parent.c, pd = parent.d;\n            this.worldX = pa * x + pb * y + parent.worldX;\n            this.worldY = pc * x + pd * y + parent.worldY;\n            switch (this.data.transformMode) {\n                case spine.TransformMode.Normal: {\n                    var rotationY = rotation + 90 + shearY;\n                    var la = spine.MathUtils.cosDeg(rotation + shearX) * scaleX;\n                    var lb = spine.MathUtils.cosDeg(rotationY) * scaleY;\n                    var lc = spine.MathUtils.sinDeg(rotation + shearX) * scaleX;\n                    var ld = spine.MathUtils.sinDeg(rotationY) * scaleY;\n                    this.a = pa * la + pb * lc;\n                    this.b = pa * lb + pb * ld;\n                    this.c = pc * la + pd * lc;\n                    this.d = pc * lb + pd * ld;\n                    return;\n                }\n                case spine.TransformMode.OnlyTranslation: {\n                    var rotationY = rotation + 90 + shearY;\n                    this.a = spine.MathUtils.cosDeg(rotation + shearX) * scaleX;\n                    this.b = spine.MathUtils.cosDeg(rotationY) * scaleY;\n                    this.c = spine.MathUtils.sinDeg(rotation + shearX) * scaleX;\n                    this.d = spine.MathUtils.sinDeg(rotationY) * scaleY;\n                    break;\n                }\n                case spine.TransformMode.NoRotationOrReflection: {\n                    var s = pa * pa + pc * pc;\n                    var prx = 0;\n                    if (s > 0.0001) {\n                        s = Math.abs(pa * pd - pb * pc) / s;\n                        pb = pc * s;\n                        pd = pa * s;\n                        prx = Math.atan2(pc, pa) * spine.MathUtils.radDeg;\n                    }\n                    else {\n                        pa = 0;\n                        pc = 0;\n                        prx = 90 - Math.atan2(pd, pb) * spine.MathUtils.radDeg;\n                    }\n                    var rx = rotation + shearX - prx;\n                    var ry = rotation + shearY - prx + 90;\n                    var la = spine.MathUtils.cosDeg(rx) * scaleX;\n                    var lb = spine.MathUtils.cosDeg(ry) * scaleY;\n                    var lc = spine.MathUtils.sinDeg(rx) * scaleX;\n                    var ld = spine.MathUtils.sinDeg(ry) * scaleY;\n                    this.a = pa * la - pb * lc;\n                    this.b = pa * lb - pb * ld;\n                    this.c = pc * la + pd * lc;\n                    this.d = pc * lb + pd * ld;\n                    break;\n                }\n                case spine.TransformMode.NoScale:\n                case spine.TransformMode.NoScaleOrReflection: {\n                    var cos = spine.MathUtils.cosDeg(rotation);\n                    var sin = spine.MathUtils.sinDeg(rotation);\n                    var za = (pa * cos + pb * sin) / this.skeleton.scaleX;\n                    var zc = (pc * cos + pd * sin) / this.skeleton.scaleY;\n                    var s = Math.sqrt(za * za + zc * zc);\n                    if (s > 0.00001)\n                        s = 1 / s;\n                    za *= s;\n                    zc *= s;\n                    s = Math.sqrt(za * za + zc * zc);\n                    if (this.data.transformMode == spine.TransformMode.NoScale\n                        && (pa * pd - pb * pc < 0) != (this.skeleton.scaleX < 0 != this.skeleton.scaleY < 0))\n                        s = -s;\n                    var r = Math.PI / 2 + Math.atan2(zc, za);\n                    var zb = Math.cos(r) * s;\n                    var zd = Math.sin(r) * s;\n                    var la = spine.MathUtils.cosDeg(shearX) * scaleX;\n                    var lb = spine.MathUtils.cosDeg(90 + shearY) * scaleY;\n                    var lc = spine.MathUtils.sinDeg(shearX) * scaleX;\n                    var ld = spine.MathUtils.sinDeg(90 + shearY) * scaleY;\n                    this.a = za * la + zb * lc;\n                    this.b = za * lb + zb * ld;\n                    this.c = zc * la + zd * lc;\n                    this.d = zc * lb + zd * ld;\n                    break;\n                }\n            }\n            this.a *= this.skeleton.scaleX;\n            this.b *= this.skeleton.scaleX;\n            this.c *= this.skeleton.scaleY;\n            this.d *= this.skeleton.scaleY;\n        };\n        Bone.prototype.setToSetupPose = function () {\n            var data = this.data;\n            this.x = data.x;\n            this.y = data.y;\n            this.rotation = data.rotation;\n            this.scaleX = data.scaleX;\n            this.scaleY = data.scaleY;\n            this.shearX = data.shearX;\n            this.shearY = data.shearY;\n        };\n        Bone.prototype.getWorldRotationX = function () {\n            return Math.atan2(this.c, this.a) * spine.MathUtils.radDeg;\n        };\n        Bone.prototype.getWorldRotationY = function () {\n            return Math.atan2(this.d, this.b) * spine.MathUtils.radDeg;\n        };\n        Bone.prototype.getWorldScaleX = function () {\n            return Math.sqrt(this.a * this.a + this.c * this.c);\n        };\n        Bone.prototype.getWorldScaleY = function () {\n            return Math.sqrt(this.b * this.b + this.d * this.d);\n        };\n        Bone.prototype.updateAppliedTransform = function () {\n            this.appliedValid = true;\n            var parent = this.parent;\n            if (parent == null) {\n                this.ax = this.worldX;\n                this.ay = this.worldY;\n                this.arotation = Math.atan2(this.c, this.a) * spine.MathUtils.radDeg;\n                this.ascaleX = Math.sqrt(this.a * this.a + this.c * this.c);\n                this.ascaleY = Math.sqrt(this.b * this.b + this.d * this.d);\n                this.ashearX = 0;\n                this.ashearY = Math.atan2(this.a * this.b + this.c * this.d, this.a * this.d - this.b * this.c) * spine.MathUtils.radDeg;\n                return;\n            }\n            var pa = parent.a, pb = parent.b, pc = parent.c, pd = parent.d;\n            var pid = 1 / (pa * pd - pb * pc);\n            var dx = this.worldX - parent.worldX, dy = this.worldY - parent.worldY;\n            this.ax = (dx * pd * pid - dy * pb * pid);\n            this.ay = (dy * pa * pid - dx * pc * pid);\n            var ia = pid * pd;\n            var id = pid * pa;\n            var ib = pid * pb;\n            var ic = pid * pc;\n            var ra = ia * this.a - ib * this.c;\n            var rb = ia * this.b - ib * this.d;\n            var rc = id * this.c - ic * this.a;\n            var rd = id * this.d - ic * this.b;\n            this.ashearX = 0;\n            this.ascaleX = Math.sqrt(ra * ra + rc * rc);\n            if (this.ascaleX > 0.0001) {\n                var det = ra * rd - rb * rc;\n                this.ascaleY = det / this.ascaleX;\n                this.ashearY = Math.atan2(ra * rb + rc * rd, det) * spine.MathUtils.radDeg;\n                this.arotation = Math.atan2(rc, ra) * spine.MathUtils.radDeg;\n            }\n            else {\n                this.ascaleX = 0;\n                this.ascaleY = Math.sqrt(rb * rb + rd * rd);\n                this.ashearY = 0;\n                this.arotation = 90 - Math.atan2(rd, rb) * spine.MathUtils.radDeg;\n            }\n        };\n        Bone.prototype.worldToLocal = function (world) {\n            var a = this.a, b = this.b, c = this.c, d = this.d;\n            var invDet = 1 / (a * d - b * c);\n            var x = world.x - this.worldX, y = world.y - this.worldY;\n            world.x = (x * d * invDet - y * b * invDet);\n            world.y = (y * a * invDet - x * c * invDet);\n            return world;\n        };\n        Bone.prototype.localToWorld = function (local) {\n            var x = local.x, y = local.y;\n            local.x = x * this.a + y * this.b + this.worldX;\n            local.y = x * this.c + y * this.d + this.worldY;\n            return local;\n        };\n        Bone.prototype.worldToLocalRotation = function (worldRotation) {\n            var sin = spine.MathUtils.sinDeg(worldRotation), cos = spine.MathUtils.cosDeg(worldRotation);\n            return Math.atan2(this.a * sin - this.c * cos, this.d * cos - this.b * sin) * spine.MathUtils.radDeg + this.rotation - this.shearX;\n        };\n        Bone.prototype.localToWorldRotation = function (localRotation) {\n            localRotation -= this.rotation - this.shearX;\n            var sin = spine.MathUtils.sinDeg(localRotation), cos = spine.MathUtils.cosDeg(localRotation);\n            return Math.atan2(cos * this.c + sin * this.d, cos * this.a + sin * this.b) * spine.MathUtils.radDeg;\n        };\n        Bone.prototype.rotateWorld = function (degrees) {\n            var a = this.a, b = this.b, c = this.c, d = this.d;\n            var cos = spine.MathUtils.cosDeg(degrees), sin = spine.MathUtils.sinDeg(degrees);\n            this.a = cos * a - sin * c;\n            this.b = cos * b - sin * d;\n            this.c = sin * a + cos * c;\n            this.d = sin * b + cos * d;\n            this.appliedValid = false;\n        };\n        return Bone;\n    }());\n    spine.Bone = Bone;\n})(spine || (spine = {}));\nvar spine;\n(function (spine) {\n    var BoneData = (function () {\n        function BoneData(index, name, parent) {\n            this.x = 0;\n            this.y = 0;\n            this.rotation = 0;\n            this.scaleX = 1;\n            this.scaleY = 1;\n            this.shearX = 0;\n            this.shearY = 0;\n            this.transformMode = TransformMode.Normal;\n            if (index < 0)\n                throw new Error(\"index must be >= 0.\");\n            if (name == null)\n                throw new Error(\"name cannot be null.\");\n            this.index = index;\n            this.name = name;\n            this.parent = parent;\n        }\n        return BoneData;\n    }());\n    spine.BoneData = BoneData;\n    var TransformMode;\n    (function (TransformMode) {\n        TransformMode[TransformMode[\"Normal\"] = 0] = \"Normal\";\n        TransformMode[TransformMode[\"OnlyTranslation\"] = 1] = \"OnlyTranslation\";\n        TransformMode[TransformMode[\"NoRotationOrReflection\"] = 2] = \"NoRotationOrReflection\";\n        TransformMode[TransformMode[\"NoScale\"] = 3] = \"NoScale\";\n        TransformMode[TransformMode[\"NoScaleOrReflection\"] = 4] = \"NoScaleOrReflection\";\n    })(TransformMode = spine.TransformMode || (spine.TransformMode = {}));\n})(spine || (spine = {}));\nvar spine;\n(function (spine) {\n    var Event = (function () {\n        function Event(time, data) {\n            if (data == null)\n                throw new Error(\"data cannot be null.\");\n            this.time = time;\n            this.data = data;\n        }\n        return Event;\n    }());\n    spine.Event = Event;\n})(spine || (spine = {}));\nvar spine;\n(function (spine) {\n    var EventData = (function () {\n        function EventData(name) {\n            this.name = name;\n        }\n        return EventData;\n    }());\n    spine.EventData = EventData;\n})(spine || (spine = {}));\nvar spine;\n(function (spine) {\n    var IkConstraint = (function () {\n        function IkConstraint(data, skeleton) {\n            this.bendDirection = 0;\n            this.compress = false;\n            this.stretch = false;\n            this.mix = 1;\n            if (data == null)\n                throw new Error(\"data cannot be null.\");\n            if (skeleton == null)\n                throw new Error(\"skeleton cannot be null.\");\n            this.data = data;\n            this.mix = data.mix;\n            this.bendDirection = data.bendDirection;\n            this.compress = data.compress;\n            this.stretch = data.stretch;\n            this.bones = new Array();\n            for (var i = 0; i < data.bones.length; i++)\n                this.bones.push(skeleton.findBone(data.bones[i].name));\n            this.target = skeleton.findBone(data.target.name);\n        }\n        IkConstraint.prototype.getOrder = function () {\n            return this.data.order;\n        };\n        IkConstraint.prototype.apply = function () {\n            this.update();\n        };\n        IkConstraint.prototype.update = function () {\n            var target = this.target;\n            var bones = this.bones;\n            switch (bones.length) {\n                case 1:\n                    this.apply1(bones[0], target.worldX, target.worldY, this.compress, this.stretch, this.data.uniform, this.mix);\n                    break;\n                case 2:\n                    this.apply2(bones[0], bones[1], target.worldX, target.worldY, this.bendDirection, this.stretch, this.mix);\n                    break;\n            }\n        };\n        IkConstraint.prototype.apply1 = function (bone, targetX, targetY, compress, stretch, uniform, alpha) {\n            if (!bone.appliedValid)\n                bone.updateAppliedTransform();\n            var p = bone.parent;\n            var id = 1 / (p.a * p.d - p.b * p.c);\n            var x = targetX - p.worldX, y = targetY - p.worldY;\n            var tx = (x * p.d - y * p.b) * id - bone.ax, ty = (y * p.a - x * p.c) * id - bone.ay;\n            var rotationIK = Math.atan2(ty, tx) * spine.MathUtils.radDeg - bone.ashearX - bone.arotation;\n            if (bone.ascaleX < 0)\n                rotationIK += 180;\n            if (rotationIK > 180)\n                rotationIK -= 360;\n            else if (rotationIK < -180)\n                rotationIK += 360;\n            var sx = bone.ascaleX, sy = bone.ascaleY;\n            if (compress || stretch) {\n                var b = bone.data.length * sx, dd = Math.sqrt(tx * tx + ty * ty);\n                if ((compress && dd < b) || (stretch && dd > b) && b > 0.0001) {\n                    var s = (dd / b - 1) * alpha + 1;\n                    sx *= s;\n                    if (uniform)\n                        sy *= s;\n                }\n            }\n            bone.updateWorldTransformWith(bone.ax, bone.ay, bone.arotation + rotationIK * alpha, sx, sy, bone.ashearX, bone.ashearY);\n        };\n        IkConstraint.prototype.apply2 = function (parent, child, targetX, targetY, bendDir, stretch, alpha) {\n            if (alpha == 0) {\n                child.updateWorldTransform();\n                return;\n            }\n            if (!parent.appliedValid)\n                parent.updateAppliedTransform();\n            if (!child.appliedValid)\n                child.updateAppliedTransform();\n            var px = parent.ax, py = parent.ay, psx = parent.ascaleX, sx = psx, psy = parent.ascaleY, csx = child.ascaleX;\n            var os1 = 0, os2 = 0, s2 = 0;\n            if (psx < 0) {\n                psx = -psx;\n                os1 = 180;\n                s2 = -1;\n            }\n            else {\n                os1 = 0;\n                s2 = 1;\n            }\n            if (psy < 0) {\n                psy = -psy;\n                s2 = -s2;\n            }\n            if (csx < 0) {\n                csx = -csx;\n                os2 = 180;\n            }\n            else\n                os2 = 0;\n            var cx = child.ax, cy = 0, cwx = 0, cwy = 0, a = parent.a, b = parent.b, c = parent.c, d = parent.d;\n            var u = Math.abs(psx - psy) <= 0.0001;\n            if (!u) {\n                cy = 0;\n                cwx = a * cx + parent.worldX;\n                cwy = c * cx + parent.worldY;\n            }\n            else {\n                cy = child.ay;\n                cwx = a * cx + b * cy + parent.worldX;\n                cwy = c * cx + d * cy + parent.worldY;\n            }\n            var pp = parent.parent;\n            a = pp.a;\n            b = pp.b;\n            c = pp.c;\n            d = pp.d;\n            var id = 1 / (a * d - b * c), x = targetX - pp.worldX, y = targetY - pp.worldY;\n            var tx = (x * d - y * b) * id - px, ty = (y * a - x * c) * id - py, dd = tx * tx + ty * ty;\n            x = cwx - pp.worldX;\n            y = cwy - pp.worldY;\n            var dx = (x * d - y * b) * id - px, dy = (y * a - x * c) * id - py;\n            var l1 = Math.sqrt(dx * dx + dy * dy), l2 = child.data.length * csx, a1 = 0, a2 = 0;\n            outer: if (u) {\n                l2 *= psx;\n                var cos = (dd - l1 * l1 - l2 * l2) / (2 * l1 * l2);\n                if (cos < -1)\n                    cos = -1;\n                else if (cos > 1) {\n                    cos = 1;\n                    if (stretch && l1 + l2 > 0.0001)\n                        sx *= (Math.sqrt(dd) / (l1 + l2) - 1) * alpha + 1;\n                }\n                a2 = Math.acos(cos) * bendDir;\n                a = l1 + l2 * cos;\n                b = l2 * Math.sin(a2);\n                a1 = Math.atan2(ty * a - tx * b, tx * a + ty * b);\n            }\n            else {\n                a = psx * l2;\n                b = psy * l2;\n                var aa = a * a, bb = b * b, ta = Math.atan2(ty, tx);\n                c = bb * l1 * l1 + aa * dd - aa * bb;\n                var c1 = -2 * bb * l1, c2 = bb - aa;\n                d = c1 * c1 - 4 * c2 * c;\n                if (d >= 0) {\n                    var q = Math.sqrt(d);\n                    if (c1 < 0)\n                        q = -q;\n                    q = -(c1 + q) / 2;\n                    var r0 = q / c2, r1 = c / q;\n                    var r = Math.abs(r0) < Math.abs(r1) ? r0 : r1;\n                    if (r * r <= dd) {\n                        y = Math.sqrt(dd - r * r) * bendDir;\n                        a1 = ta - Math.atan2(y, r);\n                        a2 = Math.atan2(y / psy, (r - l1) / psx);\n                        break outer;\n                    }\n                }\n                var minAngle = spine.MathUtils.PI, minX = l1 - a, minDist = minX * minX, minY = 0;\n                var maxAngle = 0, maxX = l1 + a, maxDist = maxX * maxX, maxY = 0;\n                c = -a * l1 / (aa - bb);\n                if (c >= -1 && c <= 1) {\n                    c = Math.acos(c);\n                    x = a * Math.cos(c) + l1;\n                    y = b * Math.sin(c);\n                    d = x * x + y * y;\n                    if (d < minDist) {\n                        minAngle = c;\n                        minDist = d;\n                        minX = x;\n                        minY = y;\n                    }\n                    if (d > maxDist) {\n                        maxAngle = c;\n                        maxDist = d;\n                        maxX = x;\n                        maxY = y;\n                    }\n                }\n                if (dd <= (minDist + maxDist) / 2) {\n                    a1 = ta - Math.atan2(minY * bendDir, minX);\n                    a2 = minAngle * bendDir;\n                }\n                else {\n                    a1 = ta - Math.atan2(maxY * bendDir, maxX);\n                    a2 = maxAngle * bendDir;\n                }\n            }\n            var os = Math.atan2(cy, cx) * s2;\n            var rotation = parent.arotation;\n            a1 = (a1 - os) * spine.MathUtils.radDeg + os1 - rotation;\n            if (a1 > 180)\n                a1 -= 360;\n            else if (a1 < -180)\n                a1 += 360;\n            parent.updateWorldTransformWith(px, py, rotation + a1 * alpha, sx, parent.ascaleY, 0, 0);\n            rotation = child.arotation;\n            a2 = ((a2 + os) * spine.MathUtils.radDeg - child.ashearX) * s2 + os2 - rotation;\n            if (a2 > 180)\n                a2 -= 360;\n            else if (a2 < -180)\n                a2 += 360;\n            child.updateWorldTransformWith(cx, cy, rotation + a2 * alpha, child.ascaleX, child.ascaleY, child.ashearX, child.ashearY);\n        };\n        return IkConstraint;\n    }());\n    spine.IkConstraint = IkConstraint;\n})(spine || (spine = {}));\nvar spine;\n(function (spine) {\n    var IkConstraintData = (function () {\n        function IkConstraintData(name) {\n            this.order = 0;\n            this.bones = new Array();\n            this.bendDirection = 1;\n            this.compress = false;\n            this.stretch = false;\n            this.uniform = false;\n            this.mix = 1;\n            this.name = name;\n        }\n        return IkConstraintData;\n    }());\n    spine.IkConstraintData = IkConstraintData;\n})(spine || (spine = {}));\nvar spine;\n(function (spine) {\n    var PathConstraint = (function () {\n        function PathConstraint(data, skeleton) {\n            this.position = 0;\n            this.spacing = 0;\n            this.rotateMix = 0;\n            this.translateMix = 0;\n            this.spaces = new Array();\n            this.positions = new Array();\n            this.world = new Array();\n            this.curves = new Array();\n            this.lengths = new Array();\n            this.segments = new Array();\n            if (data == null)\n                throw new Error(\"data cannot be null.\");\n            if (skeleton == null)\n                throw new Error(\"skeleton cannot be null.\");\n            this.data = data;\n            this.bones = new Array();\n            for (var i = 0, n = data.bones.length; i < n; i++)\n                this.bones.push(skeleton.findBone(data.bones[i].name));\n            this.target = skeleton.findSlot(data.target.name);\n            this.position = data.position;\n            this.spacing = data.spacing;\n            this.rotateMix = data.rotateMix;\n            this.translateMix = data.translateMix;\n        }\n        PathConstraint.prototype.apply = function () {\n            this.update();\n        };\n        PathConstraint.prototype.update = function () {\n            var attachment = this.target.getAttachment();\n            if (!(attachment instanceof spine.PathAttachment))\n                return;\n            var rotateMix = this.rotateMix, translateMix = this.translateMix;\n            var translate = translateMix > 0, rotate = rotateMix > 0;\n            if (!translate && !rotate)\n                return;\n            var data = this.data;\n            var percentSpacing = data.spacingMode == spine.SpacingMode.Percent;\n            var rotateMode = data.rotateMode;\n            var tangents = rotateMode == spine.RotateMode.Tangent, scale = rotateMode == spine.RotateMode.ChainScale;\n            var boneCount = this.bones.length, spacesCount = tangents ? boneCount : boneCount + 1;\n            var bones = this.bones;\n            var spaces = spine.Utils.setArraySize(this.spaces, spacesCount), lengths = null;\n            var spacing = this.spacing;\n            if (scale || !percentSpacing) {\n                if (scale)\n                    lengths = spine.Utils.setArraySize(this.lengths, boneCount);\n                var lengthSpacing = data.spacingMode == spine.SpacingMode.Length;\n                for (var i = 0, n = spacesCount - 1; i < n;) {\n                    var bone = bones[i];\n                    var setupLength = bone.data.length;\n                    if (setupLength < PathConstraint.epsilon) {\n                        if (scale)\n                            lengths[i] = 0;\n                        spaces[++i] = 0;\n                    }\n                    else if (percentSpacing) {\n                        if (scale) {\n                            var x = setupLength * bone.a, y = setupLength * bone.c;\n                            var length_1 = Math.sqrt(x * x + y * y);\n                            lengths[i] = length_1;\n                        }\n                        spaces[++i] = spacing;\n                    }\n                    else {\n                        var x = setupLength * bone.a, y = setupLength * bone.c;\n                        var length_2 = Math.sqrt(x * x + y * y);\n                        if (scale)\n                            lengths[i] = length_2;\n                        spaces[++i] = (lengthSpacing ? setupLength + spacing : spacing) * length_2 / setupLength;\n                    }\n                }\n            }\n            else {\n                for (var i = 1; i < spacesCount; i++)\n                    spaces[i] = spacing;\n            }\n            var positions = this.computeWorldPositions(attachment, spacesCount, tangents, data.positionMode == spine.PositionMode.Percent, percentSpacing);\n            var boneX = positions[0], boneY = positions[1], offsetRotation = data.offsetRotation;\n            var tip = false;\n            if (offsetRotation == 0)\n                tip = rotateMode == spine.RotateMode.Chain;\n            else {\n                tip = false;\n                var p = this.target.bone;\n                offsetRotation *= p.a * p.d - p.b * p.c > 0 ? spine.MathUtils.degRad : -spine.MathUtils.degRad;\n            }\n            for (var i = 0, p = 3; i < boneCount; i++, p += 3) {\n                var bone = bones[i];\n                bone.worldX += (boneX - bone.worldX) * translateMix;\n                bone.worldY += (boneY - bone.worldY) * translateMix;\n                var x = positions[p], y = positions[p + 1], dx = x - boneX, dy = y - boneY;\n                if (scale) {\n                    var length_3 = lengths[i];\n                    if (length_3 != 0) {\n                        var s = (Math.sqrt(dx * dx + dy * dy) / length_3 - 1) * rotateMix + 1;\n                        bone.a *= s;\n                        bone.c *= s;\n                    }\n                }\n                boneX = x;\n                boneY = y;\n                if (rotate) {\n                    var a = bone.a, b = bone.b, c = bone.c, d = bone.d, r = 0, cos = 0, sin = 0;\n                    if (tangents)\n                        r = positions[p - 1];\n                    else if (spaces[i + 1] == 0)\n                        r = positions[p + 2];\n                    else\n                        r = Math.atan2(dy, dx);\n                    r -= Math.atan2(c, a);\n                    if (tip) {\n                        cos = Math.cos(r);\n                        sin = Math.sin(r);\n                        var length_4 = bone.data.length;\n                        boneX += (length_4 * (cos * a - sin * c) - dx) * rotateMix;\n                        boneY += (length_4 * (sin * a + cos * c) - dy) * rotateMix;\n                    }\n                    else {\n                        r += offsetRotation;\n                    }\n                    if (r > spine.MathUtils.PI)\n                        r -= spine.MathUtils.PI2;\n                    else if (r < -spine.MathUtils.PI)\n                        r += spine.MathUtils.PI2;\n                    r *= rotateMix;\n                    cos = Math.cos(r);\n                    sin = Math.sin(r);\n                    bone.a = cos * a - sin * c;\n                    bone.b = cos * b - sin * d;\n                    bone.c = sin * a + cos * c;\n                    bone.d = sin * b + cos * d;\n                }\n                bone.appliedValid = false;\n            }\n        };\n        PathConstraint.prototype.computeWorldPositions = function (path, spacesCount, tangents, percentPosition, percentSpacing) {\n            var target = this.target;\n            var position = this.position;\n            var spaces = this.spaces, out = spine.Utils.setArraySize(this.positions, spacesCount * 3 + 2), world = null;\n            var closed = path.closed;\n            var verticesLength = path.worldVerticesLength, curveCount = verticesLength / 6, prevCurve = PathConstraint.NONE;\n            if (!path.constantSpeed) {\n                var lengths = path.lengths;\n                curveCount -= closed ? 1 : 2;\n                var pathLength_1 = lengths[curveCount];\n                if (percentPosition)\n                    position *= pathLength_1;\n                if (percentSpacing) {\n                    for (var i = 1; i < spacesCount; i++)\n                        spaces[i] *= pathLength_1;\n                }\n                world = spine.Utils.setArraySize(this.world, 8);\n                for (var i = 0, o = 0, curve = 0; i < spacesCount; i++, o += 3) {\n                    var space = spaces[i];\n                    position += space;\n                    var p = position;\n                    if (closed) {\n                        p %= pathLength_1;\n                        if (p < 0)\n                            p += pathLength_1;\n                        curve = 0;\n                    }\n                    else if (p < 0) {\n                        if (prevCurve != PathConstraint.BEFORE) {\n                            prevCurve = PathConstraint.BEFORE;\n                            path.computeWorldVertices(target, 2, 4, world, 0, 2);\n                        }\n                        this.addBeforePosition(p, world, 0, out, o);\n                        continue;\n                    }\n                    else if (p > pathLength_1) {\n                        if (prevCurve != PathConstraint.AFTER) {\n                            prevCurve = PathConstraint.AFTER;\n                            path.computeWorldVertices(target, verticesLength - 6, 4, world, 0, 2);\n                        }\n                        this.addAfterPosition(p - pathLength_1, world, 0, out, o);\n                        continue;\n                    }\n                    for (;; curve++) {\n                        var length_5 = lengths[curve];\n                        if (p > length_5)\n                            continue;\n                        if (curve == 0)\n                            p /= length_5;\n                        else {\n                            var prev = lengths[curve - 1];\n                            p = (p - prev) / (length_5 - prev);\n                        }\n                        break;\n                    }\n                    if (curve != prevCurve) {\n                        prevCurve = curve;\n                        if (closed && curve == curveCount) {\n                            path.computeWorldVertices(target, verticesLength - 4, 4, world, 0, 2);\n                            path.computeWorldVertices(target, 0, 4, world, 4, 2);\n                        }\n                        else\n                            path.computeWorldVertices(target, curve * 6 + 2, 8, world, 0, 2);\n                    }\n                    this.addCurvePosition(p, world[0], world[1], world[2], world[3], world[4], world[5], world[6], world[7], out, o, tangents || (i > 0 && space == 0));\n                }\n                return out;\n            }\n            if (closed) {\n                verticesLength += 2;\n                world = spine.Utils.setArraySize(this.world, verticesLength);\n                path.computeWorldVertices(target, 2, verticesLength - 4, world, 0, 2);\n                path.computeWorldVertices(target, 0, 2, world, verticesLength - 4, 2);\n                world[verticesLength - 2] = world[0];\n                world[verticesLength - 1] = world[1];\n            }\n            else {\n                curveCount--;\n                verticesLength -= 4;\n                world = spine.Utils.setArraySize(this.world, verticesLength);\n                path.computeWorldVertices(target, 2, verticesLength, world, 0, 2);\n            }\n            var curves = spine.Utils.setArraySize(this.curves, curveCount);\n            var pathLength = 0;\n            var x1 = world[0], y1 = world[1], cx1 = 0, cy1 = 0, cx2 = 0, cy2 = 0, x2 = 0, y2 = 0;\n            var tmpx = 0, tmpy = 0, dddfx = 0, dddfy = 0, ddfx = 0, ddfy = 0, dfx = 0, dfy = 0;\n            for (var i = 0, w = 2; i < curveCount; i++, w += 6) {\n                cx1 = world[w];\n                cy1 = world[w + 1];\n                cx2 = world[w + 2];\n                cy2 = world[w + 3];\n                x2 = world[w + 4];\n                y2 = world[w + 5];\n                tmpx = (x1 - cx1 * 2 + cx2) * 0.1875;\n                tmpy = (y1 - cy1 * 2 + cy2) * 0.1875;\n                dddfx = ((cx1 - cx2) * 3 - x1 + x2) * 0.09375;\n                dddfy = ((cy1 - cy2) * 3 - y1 + y2) * 0.09375;\n                ddfx = tmpx * 2 + dddfx;\n                ddfy = tmpy * 2 + dddfy;\n                dfx = (cx1 - x1) * 0.75 + tmpx + dddfx * 0.16666667;\n                dfy = (cy1 - y1) * 0.75 + tmpy + dddfy * 0.16666667;\n                pathLength += Math.sqrt(dfx * dfx + dfy * dfy);\n                dfx += ddfx;\n                dfy += ddfy;\n                ddfx += dddfx;\n                ddfy += dddfy;\n                pathLength += Math.sqrt(dfx * dfx + dfy * dfy);\n                dfx += ddfx;\n                dfy += ddfy;\n                pathLength += Math.sqrt(dfx * dfx + dfy * dfy);\n                dfx += ddfx + dddfx;\n                dfy += ddfy + dddfy;\n                pathLength += Math.sqrt(dfx * dfx + dfy * dfy);\n                curves[i] = pathLength;\n                x1 = x2;\n                y1 = y2;\n            }\n            if (percentPosition)\n                position *= pathLength;\n            else\n                position *= pathLength / path.lengths[curveCount - 1];\n            if (percentSpacing) {\n                for (var i = 1; i < spacesCount; i++)\n                    spaces[i] *= pathLength;\n            }\n            var segments = this.segments;\n            var curveLength = 0;\n            for (var i = 0, o = 0, curve = 0, segment = 0; i < spacesCount; i++, o += 3) {\n                var space = spaces[i];\n                position += space;\n                var p = position;\n                if (closed) {\n                    p %= pathLength;\n                    if (p < 0)\n                        p += pathLength;\n                    curve = 0;\n                }\n                else if (p < 0) {\n                    this.addBeforePosition(p, world, 0, out, o);\n                    continue;\n                }\n                else if (p > pathLength) {\n                    this.addAfterPosition(p - pathLength, world, verticesLength - 4, out, o);\n                    continue;\n                }\n                for (;; curve++) {\n                    var length_6 = curves[curve];\n                    if (p > length_6)\n                        continue;\n                    if (curve == 0)\n                        p /= length_6;\n                    else {\n                        var prev = curves[curve - 1];\n                        p = (p - prev) / (length_6 - prev);\n                    }\n                    break;\n                }\n                if (curve != prevCurve) {\n                    prevCurve = curve;\n                    var ii = curve * 6;\n                    x1 = world[ii];\n                    y1 = world[ii + 1];\n                    cx1 = world[ii + 2];\n                    cy1 = world[ii + 3];\n                    cx2 = world[ii + 4];\n                    cy2 = world[ii + 5];\n                    x2 = world[ii + 6];\n                    y2 = world[ii + 7];\n                    tmpx = (x1 - cx1 * 2 + cx2) * 0.03;\n                    tmpy = (y1 - cy1 * 2 + cy2) * 0.03;\n                    dddfx = ((cx1 - cx2) * 3 - x1 + x2) * 0.006;\n                    dddfy = ((cy1 - cy2) * 3 - y1 + y2) * 0.006;\n                    ddfx = tmpx * 2 + dddfx;\n                    ddfy = tmpy * 2 + dddfy;\n                    dfx = (cx1 - x1) * 0.3 + tmpx + dddfx * 0.16666667;\n                    dfy = (cy1 - y1) * 0.3 + tmpy + dddfy * 0.16666667;\n                    curveLength = Math.sqrt(dfx * dfx + dfy * dfy);\n                    segments[0] = curveLength;\n                    for (ii = 1; ii < 8; ii++) {\n                        dfx += ddfx;\n                        dfy += ddfy;\n                        ddfx += dddfx;\n                        ddfy += dddfy;\n                        curveLength += Math.sqrt(dfx * dfx + dfy * dfy);\n                        segments[ii] = curveLength;\n                    }\n                    dfx += ddfx;\n                    dfy += ddfy;\n                    curveLength += Math.sqrt(dfx * dfx + dfy * dfy);\n                    segments[8] = curveLength;\n                    dfx += ddfx + dddfx;\n                    dfy += ddfy + dddfy;\n                    curveLength += Math.sqrt(dfx * dfx + dfy * dfy);\n                    segments[9] = curveLength;\n                    segment = 0;\n                }\n                p *= curveLength;\n                for (;; segment++) {\n                    var length_7 = segments[segment];\n                    if (p > length_7)\n                        continue;\n                    if (segment == 0)\n                        p /= length_7;\n                    else {\n                        var prev = segments[segment - 1];\n                        p = segment + (p - prev) / (length_7 - prev);\n                    }\n                    break;\n                }\n                this.addCurvePosition(p * 0.1, x1, y1, cx1, cy1, cx2, cy2, x2, y2, out, o, tangents || (i > 0 && space == 0));\n            }\n            return out;\n        };\n        PathConstraint.prototype.addBeforePosition = function (p, temp, i, out, o) {\n            var x1 = temp[i], y1 = temp[i + 1], dx = temp[i + 2] - x1, dy = temp[i + 3] - y1, r = Math.atan2(dy, dx);\n            out[o] = x1 + p * Math.cos(r);\n            out[o + 1] = y1 + p * Math.sin(r);\n            out[o + 2] = r;\n        };\n        PathConstraint.prototype.addAfterPosition = function (p, temp, i, out, o) {\n            var x1 = temp[i + 2], y1 = temp[i + 3], dx = x1 - temp[i], dy = y1 - temp[i + 1], r = Math.atan2(dy, dx);\n            out[o] = x1 + p * Math.cos(r);\n            out[o + 1] = y1 + p * Math.sin(r);\n            out[o + 2] = r;\n        };\n        PathConstraint.prototype.addCurvePosition = function (p, x1, y1, cx1, cy1, cx2, cy2, x2, y2, out, o, tangents) {\n            if (p == 0 || isNaN(p)) {\n                out[o] = x1;\n                out[o + 1] = y1;\n                out[o + 2] = Math.atan2(cy1 - y1, cx1 - x1);\n                return;\n            }\n            var tt = p * p, ttt = tt * p, u = 1 - p, uu = u * u, uuu = uu * u;\n            var ut = u * p, ut3 = ut * 3, uut3 = u * ut3, utt3 = ut3 * p;\n            var x = x1 * uuu + cx1 * uut3 + cx2 * utt3 + x2 * ttt, y = y1 * uuu + cy1 * uut3 + cy2 * utt3 + y2 * ttt;\n            out[o] = x;\n            out[o + 1] = y;\n            if (tangents) {\n                if (p < 0.001)\n                    out[o + 2] = Math.atan2(cy1 - y1, cx1 - x1);\n                else\n                    out[o + 2] = Math.atan2(y - (y1 * uu + cy1 * ut * 2 + cy2 * tt), x - (x1 * uu + cx1 * ut * 2 + cx2 * tt));\n            }\n        };\n        PathConstraint.prototype.getOrder = function () {\n            return this.data.order;\n        };\n        PathConstraint.NONE = -1;\n        PathConstraint.BEFORE = -2;\n        PathConstraint.AFTER = -3;\n        PathConstraint.epsilon = 0.00001;\n        return PathConstraint;\n    }());\n    spine.PathConstraint = PathConstraint;\n})(spine || (spine = {}));\nvar spine;\n(function (spine) {\n    var PathConstraintData = (function () {\n        function PathConstraintData(name) {\n            this.order = 0;\n            this.bones = new Array();\n            this.name = name;\n        }\n        return PathConstraintData;\n    }());\n    spine.PathConstraintData = PathConstraintData;\n    var PositionMode;\n    (function (PositionMode) {\n        PositionMode[PositionMode[\"Fixed\"] = 0] = \"Fixed\";\n        PositionMode[PositionMode[\"Percent\"] = 1] = \"Percent\";\n    })(PositionMode = spine.PositionMode || (spine.PositionMode = {}));\n    var SpacingMode;\n    (function (SpacingMode) {\n        SpacingMode[SpacingMode[\"Length\"] = 0] = \"Length\";\n        SpacingMode[SpacingMode[\"Fixed\"] = 1] = \"Fixed\";\n        SpacingMode[SpacingMode[\"Percent\"] = 2] = \"Percent\";\n    })(SpacingMode = spine.SpacingMode || (spine.SpacingMode = {}));\n    var RotateMode;\n    (function (RotateMode) {\n        RotateMode[RotateMode[\"Tangent\"] = 0] = \"Tangent\";\n        RotateMode[RotateMode[\"Chain\"] = 1] = \"Chain\";\n        RotateMode[RotateMode[\"ChainScale\"] = 2] = \"ChainScale\";\n    })(RotateMode = spine.RotateMode || (spine.RotateMode = {}));\n})(spine || (spine = {}));\nvar spine;\n(function (spine) {\n    var Assets = (function () {\n        function Assets(clientId) {\n            this.toLoad = new Array();\n            this.assets = {};\n            this.clientId = clientId;\n        }\n        Assets.prototype.loaded = function () {\n            var i = 0;\n            for (var v in this.assets)\n                i++;\n            return i;\n        };\n        return Assets;\n    }());\n    var SharedAssetManager = (function () {\n        function SharedAssetManager(pathPrefix) {\n            if (pathPrefix === void 0) { pathPrefix = \"\"; }\n            this.clientAssets = {};\n            this.queuedAssets = {};\n            this.rawAssets = {};\n            this.errors = {};\n            this.pathPrefix = pathPrefix;\n        }\n        SharedAssetManager.prototype.queueAsset = function (clientId, textureLoader, path) {\n            var clientAssets = this.clientAssets[clientId];\n            if (clientAssets === null || clientAssets === undefined) {\n                clientAssets = new Assets(clientId);\n                this.clientAssets[clientId] = clientAssets;\n            }\n            if (textureLoader !== null)\n                clientAssets.textureLoader = textureLoader;\n            clientAssets.toLoad.push(path);\n            if (this.queuedAssets[path] === path) {\n                return false;\n            }\n            else {\n                this.queuedAssets[path] = path;\n                return true;\n            }\n        };\n        SharedAssetManager.prototype.loadText = function (clientId, path) {\n            var _this = this;\n            path = this.pathPrefix + path;\n            if (!this.queueAsset(clientId, null, path))\n                return;\n            var request = new XMLHttpRequest();\n            request.onreadystatechange = function () {\n                if (request.readyState == XMLHttpRequest.DONE) {\n                    if (request.status >= 200 && request.status < 300) {\n                        _this.rawAssets[path] = request.responseText;\n                    }\n                    else {\n                        _this.errors[path] = \"Couldn't load text \" + path + \": status \" + request.status + \", \" + request.responseText;\n                    }\n                }\n            };\n            request.open(\"GET\", path, true);\n            request.send();\n        };\n        SharedAssetManager.prototype.loadJson = function (clientId, path) {\n            var _this = this;\n            path = this.pathPrefix + path;\n            if (!this.queueAsset(clientId, null, path))\n                return;\n            var request = new XMLHttpRequest();\n            request.onreadystatechange = function () {\n                if (request.readyState == XMLHttpRequest.DONE) {\n                    if (request.status >= 200 && request.status < 300) {\n                        _this.rawAssets[path] = JSON.parse(request.responseText);\n                    }\n                    else {\n                        _this.errors[path] = \"Couldn't load text \" + path + \": status \" + request.status + \", \" + request.responseText;\n                    }\n                }\n            };\n            request.open(\"GET\", path, true);\n            request.send();\n        };\n        SharedAssetManager.prototype.loadTexture = function (clientId, textureLoader, path) {\n            var _this = this;\n            path = this.pathPrefix + path;\n            if (!this.queueAsset(clientId, textureLoader, path))\n                return;\n            var img = new Image();\n            img.src = path;\n            img.crossOrigin = \"anonymous\";\n            img.onload = function (ev) {\n                _this.rawAssets[path] = img;\n            };\n            img.onerror = function (ev) {\n                _this.errors[path] = \"Couldn't load image \" + path;\n            };\n        };\n        SharedAssetManager.prototype.get = function (clientId, path) {\n            path = this.pathPrefix + path;\n            var clientAssets = this.clientAssets[clientId];\n            if (clientAssets === null || clientAssets === undefined)\n                return true;\n            return clientAssets.assets[path];\n        };\n        SharedAssetManager.prototype.updateClientAssets = function (clientAssets) {\n            for (var i = 0; i < clientAssets.toLoad.length; i++) {\n                var path = clientAssets.toLoad[i];\n                var asset = clientAssets.assets[path];\n                if (asset === null || asset === undefined) {\n                    var rawAsset = this.rawAssets[path];\n                    if (rawAsset === null || rawAsset === undefined)\n                        continue;\n                    if (rawAsset instanceof HTMLImageElement) {\n                        clientAssets.assets[path] = clientAssets.textureLoader(rawAsset);\n                    }\n                    else {\n                        clientAssets.assets[path] = rawAsset;\n                    }\n                }\n            }\n        };\n        SharedAssetManager.prototype.isLoadingComplete = function (clientId) {\n            var clientAssets = this.clientAssets[clientId];\n            if (clientAssets === null || clientAssets === undefined)\n                return true;\n            this.updateClientAssets(clientAssets);\n            return clientAssets.toLoad.length == clientAssets.loaded();\n        };\n        SharedAssetManager.prototype.dispose = function () {\n        };\n        SharedAssetManager.prototype.hasErrors = function () {\n            return Object.keys(this.errors).length > 0;\n        };\n        SharedAssetManager.prototype.getErrors = function () {\n            return this.errors;\n        };\n        return SharedAssetManager;\n    }());\n    spine.SharedAssetManager = SharedAssetManager;\n})(spine || (spine = {}));\nvar spine;\n(function (spine) {\n    var Skeleton = (function () {\n        function Skeleton(data) {\n            this._updateCache = new Array();\n            this.updateCacheReset = new Array();\n            this.time = 0;\n            this.scaleX = 1;\n            this.scaleY = 1;\n            this.x = 0;\n            this.y = 0;\n            if (data == null)\n                throw new Error(\"data cannot be null.\");\n            this.data = data;\n            this.bones = new Array();\n            for (var i = 0; i < data.bones.length; i++) {\n                var boneData = data.bones[i];\n                var bone = void 0;\n                if (boneData.parent == null)\n                    bone = new spine.Bone(boneData, this, null);\n                else {\n                    var parent_1 = this.bones[boneData.parent.index];\n                    bone = new spine.Bone(boneData, this, parent_1);\n                    parent_1.children.push(bone);\n                }\n                this.bones.push(bone);\n            }\n            this.slots = new Array();\n            this.drawOrder = new Array();\n            for (var i = 0; i < data.slots.length; i++) {\n                var slotData = data.slots[i];\n                var bone = this.bones[slotData.boneData.index];\n                var slot = new spine.Slot(slotData, bone);\n                this.slots.push(slot);\n                this.drawOrder.push(slot);\n            }\n            this.ikConstraints = new Array();\n            for (var i = 0; i < data.ikConstraints.length; i++) {\n                var ikConstraintData = data.ikConstraints[i];\n                this.ikConstraints.push(new spine.IkConstraint(ikConstraintData, this));\n            }\n            this.transformConstraints = new Array();\n            for (var i = 0; i < data.transformConstraints.length; i++) {\n                var transformConstraintData = data.transformConstraints[i];\n                this.transformConstraints.push(new spine.TransformConstraint(transformConstraintData, this));\n            }\n            this.pathConstraints = new Array();\n            for (var i = 0; i < data.pathConstraints.length; i++) {\n                var pathConstraintData = data.pathConstraints[i];\n                this.pathConstraints.push(new spine.PathConstraint(pathConstraintData, this));\n            }\n            this.color = new spine.Color(1, 1, 1, 1);\n            this.updateCache();\n        }\n        Skeleton.prototype.updateCache = function () {\n            var updateCache = this._updateCache;\n            updateCache.length = 0;\n            this.updateCacheReset.length = 0;\n            var bones = this.bones;\n            for (var i = 0, n = bones.length; i < n; i++)\n                bones[i].sorted = false;\n            var ikConstraints = this.ikConstraints;\n            var transformConstraints = this.transformConstraints;\n            var pathConstraints = this.pathConstraints;\n            var ikCount = ikConstraints.length, transformCount = transformConstraints.length, pathCount = pathConstraints.length;\n            var constraintCount = ikCount + transformCount + pathCount;\n            outer: for (var i = 0; i < constraintCount; i++) {\n                for (var ii = 0; ii < ikCount; ii++) {\n                    var constraint = ikConstraints[ii];\n                    if (constraint.data.order == i) {\n                        this.sortIkConstraint(constraint);\n                        continue outer;\n                    }\n                }\n                for (var ii = 0; ii < transformCount; ii++) {\n                    var constraint = transformConstraints[ii];\n                    if (constraint.data.order == i) {\n                        this.sortTransformConstraint(constraint);\n                        continue outer;\n                    }\n                }\n                for (var ii = 0; ii < pathCount; ii++) {\n                    var constraint = pathConstraints[ii];\n                    if (constraint.data.order == i) {\n                        this.sortPathConstraint(constraint);\n                        continue outer;\n                    }\n                }\n            }\n            for (var i = 0, n = bones.length; i < n; i++)\n                this.sortBone(bones[i]);\n        };\n        Skeleton.prototype.sortIkConstraint = function (constraint) {\n            var target = constraint.target;\n            this.sortBone(target);\n            var constrained = constraint.bones;\n            var parent = constrained[0];\n            this.sortBone(parent);\n            if (constrained.length > 1) {\n                var child = constrained[constrained.length - 1];\n                if (!(this._updateCache.indexOf(child) > -1))\n                    this.updateCacheReset.push(child);\n            }\n            this._updateCache.push(constraint);\n            this.sortReset(parent.children);\n            constrained[constrained.length - 1].sorted = true;\n        };\n        Skeleton.prototype.sortPathConstraint = function (constraint) {\n            var slot = constraint.target;\n            var slotIndex = slot.data.index;\n            var slotBone = slot.bone;\n            if (this.skin != null)\n                this.sortPathConstraintAttachment(this.skin, slotIndex, slotBone);\n            if (this.data.defaultSkin != null && this.data.defaultSkin != this.skin)\n                this.sortPathConstraintAttachment(this.data.defaultSkin, slotIndex, slotBone);\n            for (var i = 0, n = this.data.skins.length; i < n; i++)\n                this.sortPathConstraintAttachment(this.data.skins[i], slotIndex, slotBone);\n            var attachment = slot.getAttachment();\n            if (attachment instanceof spine.PathAttachment)\n                this.sortPathConstraintAttachmentWith(attachment, slotBone);\n            var constrained = constraint.bones;\n            var boneCount = constrained.length;\n            for (var i = 0; i < boneCount; i++)\n                this.sortBone(constrained[i]);\n            this._updateCache.push(constraint);\n            for (var i = 0; i < boneCount; i++)\n                this.sortReset(constrained[i].children);\n            for (var i = 0; i < boneCount; i++)\n                constrained[i].sorted = true;\n        };\n        Skeleton.prototype.sortTransformConstraint = function (constraint) {\n            this.sortBone(constraint.target);\n            var constrained = constraint.bones;\n            var boneCount = constrained.length;\n            if (constraint.data.local) {\n                for (var i = 0; i < boneCount; i++) {\n                    var child = constrained[i];\n                    this.sortBone(child.parent);\n                    if (!(this._updateCache.indexOf(child) > -1))\n                        this.updateCacheReset.push(child);\n                }\n            }\n            else {\n                for (var i = 0; i < boneCount; i++) {\n                    this.sortBone(constrained[i]);\n                }\n            }\n            this._updateCache.push(constraint);\n            for (var ii = 0; ii < boneCount; ii++)\n                this.sortReset(constrained[ii].children);\n            for (var ii = 0; ii < boneCount; ii++)\n                constrained[ii].sorted = true;\n        };\n        Skeleton.prototype.sortPathConstraintAttachment = function (skin, slotIndex, slotBone) {\n            var attachments = skin.attachments[slotIndex];\n            if (!attachments)\n                return;\n            for (var key in attachments) {\n                this.sortPathConstraintAttachmentWith(attachments[key], slotBone);\n            }\n        };\n        Skeleton.prototype.sortPathConstraintAttachmentWith = function (attachment, slotBone) {\n            if (!(attachment instanceof spine.PathAttachment))\n                return;\n            var pathBones = attachment.bones;\n            if (pathBones == null)\n                this.sortBone(slotBone);\n            else {\n                var bones = this.bones;\n                var i = 0;\n                while (i < pathBones.length) {\n                    var boneCount = pathBones[i++];\n                    for (var n = i + boneCount; i < n; i++) {\n                        var boneIndex = pathBones[i];\n                        this.sortBone(bones[boneIndex]);\n                    }\n                }\n            }\n        };\n        Skeleton.prototype.sortBone = function (bone) {\n            if (bone.sorted)\n                return;\n            var parent = bone.parent;\n            if (parent != null)\n                this.sortBone(parent);\n            bone.sorted = true;\n            this._updateCache.push(bone);\n        };\n        Skeleton.prototype.sortReset = function (bones) {\n            for (var i = 0, n = bones.length; i < n; i++) {\n                var bone = bones[i];\n                if (bone.sorted)\n                    this.sortReset(bone.children);\n                bone.sorted = false;\n            }\n        };\n        Skeleton.prototype.updateWorldTransform = function () {\n            var updateCacheReset = this.updateCacheReset;\n            for (var i = 0, n = updateCacheReset.length; i < n; i++) {\n                var bone = updateCacheReset[i];\n                bone.ax = bone.x;\n                bone.ay = bone.y;\n                bone.arotation = bone.rotation;\n                bone.ascaleX = bone.scaleX;\n                bone.ascaleY = bone.scaleY;\n                bone.ashearX = bone.shearX;\n                bone.ashearY = bone.shearY;\n                bone.appliedValid = true;\n            }\n            var updateCache = this._updateCache;\n            for (var i = 0, n = updateCache.length; i < n; i++)\n                updateCache[i].update();\n        };\n        Skeleton.prototype.setToSetupPose = function () {\n            this.setBonesToSetupPose();\n            this.setSlotsToSetupPose();\n        };\n        Skeleton.prototype.setBonesToSetupPose = function () {\n            var bones = this.bones;\n            for (var i = 0, n = bones.length; i < n; i++)\n                bones[i].setToSetupPose();\n            var ikConstraints = this.ikConstraints;\n            for (var i = 0, n = ikConstraints.length; i < n; i++) {\n                var constraint = ikConstraints[i];\n                constraint.mix = constraint.data.mix;\n                constraint.bendDirection = constraint.data.bendDirection;\n                constraint.compress = constraint.data.compress;\n                constraint.stretch = constraint.data.stretch;\n            }\n            var transformConstraints = this.transformConstraints;\n            for (var i = 0, n = transformConstraints.length; i < n; i++) {\n                var constraint = transformConstraints[i];\n                var data = constraint.data;\n                constraint.rotateMix = data.rotateMix;\n                constraint.translateMix = data.translateMix;\n                constraint.scaleMix = data.scaleMix;\n                constraint.shearMix = data.shearMix;\n            }\n            var pathConstraints = this.pathConstraints;\n            for (var i = 0, n = pathConstraints.length; i < n; i++) {\n                var constraint = pathConstraints[i];\n                var data = constraint.data;\n                constraint.position = data.position;\n                constraint.spacing = data.spacing;\n                constraint.rotateMix = data.rotateMix;\n                constraint.translateMix = data.translateMix;\n            }\n        };\n        Skeleton.prototype.setSlotsToSetupPose = function () {\n            var slots = this.slots;\n            spine.Utils.arrayCopy(slots, 0, this.drawOrder, 0, slots.length);\n            for (var i = 0, n = slots.length; i < n; i++)\n                slots[i].setToSetupPose();\n        };\n        Skeleton.prototype.getRootBone = function () {\n            if (this.bones.length == 0)\n                return null;\n            return this.bones[0];\n        };\n        Skeleton.prototype.findBone = function (boneName) {\n            if (boneName == null)\n                throw new Error(\"boneName cannot be null.\");\n            var bones = this.bones;\n            for (var i = 0, n = bones.length; i < n; i++) {\n                var bone = bones[i];\n                if (bone.data.name == boneName)\n                    return bone;\n            }\n            return null;\n        };\n        Skeleton.prototype.findBoneIndex = function (boneName) {\n            if (boneName == null)\n                throw new Error(\"boneName cannot be null.\");\n            var bones = this.bones;\n            for (var i = 0, n = bones.length; i < n; i++)\n                if (bones[i].data.name == boneName)\n                    return i;\n            return -1;\n        };\n        Skeleton.prototype.findSlot = function (slotName) {\n            if (slotName == null)\n                throw new Error(\"slotName cannot be null.\");\n            var slots = this.slots;\n            for (var i = 0, n = slots.length; i < n; i++) {\n                var slot = slots[i];\n                if (slot.data.name == slotName)\n                    return slot;\n            }\n            return null;\n        };\n        Skeleton.prototype.findSlotIndex = function (slotName) {\n            if (slotName == null)\n                throw new Error(\"slotName cannot be null.\");\n            var slots = this.slots;\n            for (var i = 0, n = slots.length; i < n; i++)\n                if (slots[i].data.name == slotName)\n                    return i;\n            return -1;\n        };\n        Skeleton.prototype.setSkinByName = function (skinName) {\n            var skin = this.data.findSkin(skinName);\n            if (skin == null)\n                throw new Error(\"Skin not found: \" + skinName);\n            this.setSkin(skin);\n        };\n        Skeleton.prototype.setSkin = function (newSkin) {\n            if (newSkin != null) {\n                if (this.skin != null)\n                    newSkin.attachAll(this, this.skin);\n                else {\n                    var slots = this.slots;\n                    for (var i = 0, n = slots.length; i < n; i++) {\n                        var slot = slots[i];\n                        var name_1 = slot.data.attachmentName;\n                        if (name_1 != null) {\n                            var attachment = newSkin.getAttachment(i, name_1);\n                            if (attachment != null)\n                                slot.setAttachment(attachment);\n                        }\n                    }\n                }\n            }\n            this.skin = newSkin;\n        };\n        Skeleton.prototype.getAttachmentByName = function (slotName, attachmentName) {\n            return this.getAttachment(this.data.findSlotIndex(slotName), attachmentName);\n        };\n        Skeleton.prototype.getAttachment = function (slotIndex, attachmentName) {\n            if (attachmentName == null)\n                throw new Error(\"attachmentName cannot be null.\");\n            if (this.skin != null) {\n                var attachment = this.skin.getAttachment(slotIndex, attachmentName);\n                if (attachment != null)\n                    return attachment;\n            }\n            if (this.data.defaultSkin != null)\n                return this.data.defaultSkin.getAttachment(slotIndex, attachmentName);\n            return null;\n        };\n        Skeleton.prototype.setAttachment = function (slotName, attachmentName) {\n            if (slotName == null)\n                throw new Error(\"slotName cannot be null.\");\n            var slots = this.slots;\n            for (var i = 0, n = slots.length; i < n; i++) {\n                var slot = slots[i];\n                if (slot.data.name == slotName) {\n                    var attachment = null;\n                    if (attachmentName != null) {\n                        attachment = this.getAttachment(i, attachmentName);\n                        if (attachment == null)\n                            throw new Error(\"Attachment not found: \" + attachmentName + \", for slot: \" + slotName);\n                    }\n                    slot.setAttachment(attachment);\n                    return;\n                }\n            }\n            throw new Error(\"Slot not found: \" + slotName);\n        };\n        Skeleton.prototype.findIkConstraint = function (constraintName) {\n            if (constraintName == null)\n                throw new Error(\"constraintName cannot be null.\");\n            var ikConstraints = this.ikConstraints;\n            for (var i = 0, n = ikConstraints.length; i < n; i++) {\n                var ikConstraint = ikConstraints[i];\n                if (ikConstraint.data.name == constraintName)\n                    return ikConstraint;\n            }\n            return null;\n        };\n        Skeleton.prototype.findTransformConstraint = function (constraintName) {\n            if (constraintName == null)\n                throw new Error(\"constraintName cannot be null.\");\n            var transformConstraints = this.transformConstraints;\n            for (var i = 0, n = transformConstraints.length; i < n; i++) {\n                var constraint = transformConstraints[i];\n                if (constraint.data.name == constraintName)\n                    return constraint;\n            }\n            return null;\n        };\n        Skeleton.prototype.findPathConstraint = function (constraintName) {\n            if (constraintName == null)\n                throw new Error(\"constraintName cannot be null.\");\n            var pathConstraints = this.pathConstraints;\n            for (var i = 0, n = pathConstraints.length; i < n; i++) {\n                var constraint = pathConstraints[i];\n                if (constraint.data.name == constraintName)\n                    return constraint;\n            }\n            return null;\n        };\n        Skeleton.prototype.getBounds = function (offset, size, temp) {\n            if (temp === void 0) { temp = new Array(2); }\n            if (offset == null)\n                throw new Error(\"offset cannot be null.\");\n            if (size == null)\n                throw new Error(\"size cannot be null.\");\n            var drawOrder = this.drawOrder;\n            var minX = Number.POSITIVE_INFINITY, minY = Number.POSITIVE_INFINITY, maxX = Number.NEGATIVE_INFINITY, maxY = Number.NEGATIVE_INFINITY;\n            for (var i = 0, n = drawOrder.length; i < n; i++) {\n                var slot = drawOrder[i];\n                var verticesLength = 0;\n                var vertices = null;\n                var attachment = slot.getAttachment();\n                if (attachment instanceof spine.RegionAttachment) {\n                    verticesLength = 8;\n                    vertices = spine.Utils.setArraySize(temp, verticesLength, 0);\n                    attachment.computeWorldVertices(slot.bone, vertices, 0, 2);\n                }\n                else if (attachment instanceof spine.MeshAttachment) {\n                    var mesh = attachment;\n                    verticesLength = mesh.worldVerticesLength;\n                    vertices = spine.Utils.setArraySize(temp, verticesLength, 0);\n                    mesh.computeWorldVertices(slot, 0, verticesLength, vertices, 0, 2);\n                }\n                if (vertices != null) {\n                    for (var ii = 0, nn = vertices.length; ii < nn; ii += 2) {\n                        var x = vertices[ii], y = vertices[ii + 1];\n                        minX = Math.min(minX, x);\n                        minY = Math.min(minY, y);\n                        maxX = Math.max(maxX, x);\n                        maxY = Math.max(maxY, y);\n                    }\n                }\n            }\n            offset.set(minX, minY);\n            size.set(maxX - minX, maxY - minY);\n        };\n        Skeleton.prototype.update = function (delta) {\n            this.time += delta;\n        };\n        return Skeleton;\n    }());\n    spine.Skeleton = Skeleton;\n})(spine || (spine = {}));\nvar spine;\n(function (spine) {\n    var SkeletonBounds = (function () {\n        function SkeletonBounds() {\n            this.minX = 0;\n            this.minY = 0;\n            this.maxX = 0;\n            this.maxY = 0;\n            this.boundingBoxes = new Array();\n            this.polygons = new Array();\n            this.polygonPool = new spine.Pool(function () {\n                return spine.Utils.newFloatArray(16);\n            });\n        }\n        SkeletonBounds.prototype.update = function (skeleton, updateAabb) {\n            if (skeleton == null)\n                throw new Error(\"skeleton cannot be null.\");\n            var boundingBoxes = this.boundingBoxes;\n            var polygons = this.polygons;\n            var polygonPool = this.polygonPool;\n            var slots = skeleton.slots;\n            var slotCount = slots.length;\n            boundingBoxes.length = 0;\n            polygonPool.freeAll(polygons);\n            polygons.length = 0;\n            for (var i = 0; i < slotCount; i++) {\n                var slot = slots[i];\n                var attachment = slot.getAttachment();\n                if (attachment instanceof spine.BoundingBoxAttachment) {\n                    var boundingBox = attachment;\n                    boundingBoxes.push(boundingBox);\n                    var polygon = polygonPool.obtain();\n                    if (polygon.length != boundingBox.worldVerticesLength) {\n                        polygon = spine.Utils.newFloatArray(boundingBox.worldVerticesLength);\n                    }\n                    polygons.push(polygon);\n                    boundingBox.computeWorldVertices(slot, 0, boundingBox.worldVerticesLength, polygon, 0, 2);\n                }\n            }\n            if (updateAabb) {\n                this.aabbCompute();\n            }\n            else {\n                this.minX = Number.POSITIVE_INFINITY;\n                this.minY = Number.POSITIVE_INFINITY;\n                this.maxX = Number.NEGATIVE_INFINITY;\n                this.maxY = Number.NEGATIVE_INFINITY;\n            }\n        };\n        SkeletonBounds.prototype.aabbCompute = function () {\n            var minX = Number.POSITIVE_INFINITY, minY = Number.POSITIVE_INFINITY, maxX = Number.NEGATIVE_INFINITY, maxY = Number.NEGATIVE_INFINITY;\n            var polygons = this.polygons;\n            for (var i = 0, n = polygons.length; i < n; i++) {\n                var polygon = polygons[i];\n                var vertices = polygon;\n                for (var ii = 0, nn = polygon.length; ii < nn; ii += 2) {\n                    var x = vertices[ii];\n                    var y = vertices[ii + 1];\n                    minX = Math.min(minX, x);\n                    minY = Math.min(minY, y);\n                    maxX = Math.max(maxX, x);\n                    maxY = Math.max(maxY, y);\n                }\n            }\n            this.minX = minX;\n            this.minY = minY;\n            this.maxX = maxX;\n            this.maxY = maxY;\n        };\n        SkeletonBounds.prototype.aabbContainsPoint = function (x, y) {\n            return x >= this.minX && x <= this.maxX && y >= this.minY && y <= this.maxY;\n        };\n        SkeletonBounds.prototype.aabbIntersectsSegment = function (x1, y1, x2, y2) {\n            var minX = this.minX;\n            var minY = this.minY;\n            var maxX = this.maxX;\n            var maxY = this.maxY;\n            if ((x1 <= minX && x2 <= minX) || (y1 <= minY && y2 <= minY) || (x1 >= maxX && x2 >= maxX) || (y1 >= maxY && y2 >= maxY))\n                return false;\n            var m = (y2 - y1) / (x2 - x1);\n            var y = m * (minX - x1) + y1;\n            if (y > minY && y < maxY)\n                return true;\n            y = m * (maxX - x1) + y1;\n            if (y > minY && y < maxY)\n                return true;\n            var x = (minY - y1) / m + x1;\n            if (x > minX && x < maxX)\n                return true;\n            x = (maxY - y1) / m + x1;\n            if (x > minX && x < maxX)\n                return true;\n            return false;\n        };\n        SkeletonBounds.prototype.aabbIntersectsSkeleton = function (bounds) {\n            return this.minX < bounds.maxX && this.maxX > bounds.minX && this.minY < bounds.maxY && this.maxY > bounds.minY;\n        };\n        SkeletonBounds.prototype.containsPoint = function (x, y) {\n            var polygons = this.polygons;\n            for (var i = 0, n = polygons.length; i < n; i++)\n                if (this.containsPointPolygon(polygons[i], x, y))\n                    return this.boundingBoxes[i];\n            return null;\n        };\n        SkeletonBounds.prototype.containsPointPolygon = function (polygon, x, y) {\n            var vertices = polygon;\n            var nn = polygon.length;\n            var prevIndex = nn - 2;\n            var inside = false;\n            for (var ii = 0; ii < nn; ii += 2) {\n                var vertexY = vertices[ii + 1];\n                var prevY = vertices[prevIndex + 1];\n                if ((vertexY < y && prevY >= y) || (prevY < y && vertexY >= y)) {\n                    var vertexX = vertices[ii];\n                    if (vertexX + (y - vertexY) / (prevY - vertexY) * (vertices[prevIndex] - vertexX) < x)\n                        inside = !inside;\n                }\n                prevIndex = ii;\n            }\n            return inside;\n        };\n        SkeletonBounds.prototype.intersectsSegment = function (x1, y1, x2, y2) {\n            var polygons = this.polygons;\n            for (var i = 0, n = polygons.length; i < n; i++)\n                if (this.intersectsSegmentPolygon(polygons[i], x1, y1, x2, y2))\n                    return this.boundingBoxes[i];\n            return null;\n        };\n        SkeletonBounds.prototype.intersectsSegmentPolygon = function (polygon, x1, y1, x2, y2) {\n            var vertices = polygon;\n            var nn = polygon.length;\n            var width12 = x1 - x2, height12 = y1 - y2;\n            var det1 = x1 * y2 - y1 * x2;\n            var x3 = vertices[nn - 2], y3 = vertices[nn - 1];\n            for (var ii = 0; ii < nn; ii += 2) {\n                var x4 = vertices[ii], y4 = vertices[ii + 1];\n                var det2 = x3 * y4 - y3 * x4;\n                var width34 = x3 - x4, height34 = y3 - y4;\n                var det3 = width12 * height34 - height12 * width34;\n                var x = (det1 * width34 - width12 * det2) / det3;\n                if (((x >= x3 && x <= x4) || (x >= x4 && x <= x3)) && ((x >= x1 && x <= x2) || (x >= x2 && x <= x1))) {\n                    var y = (det1 * height34 - height12 * det2) / det3;\n                    if (((y >= y3 && y <= y4) || (y >= y4 && y <= y3)) && ((y >= y1 && y <= y2) || (y >= y2 && y <= y1)))\n                        return true;\n                }\n                x3 = x4;\n                y3 = y4;\n            }\n            return false;\n        };\n        SkeletonBounds.prototype.getPolygon = function (boundingBox) {\n            if (boundingBox == null)\n                throw new Error(\"boundingBox cannot be null.\");\n            var index = this.boundingBoxes.indexOf(boundingBox);\n            return index == -1 ? null : this.polygons[index];\n        };\n        SkeletonBounds.prototype.getWidth = function () {\n            return this.maxX - this.minX;\n        };\n        SkeletonBounds.prototype.getHeight = function () {\n            return this.maxY - this.minY;\n        };\n        return SkeletonBounds;\n    }());\n    spine.SkeletonBounds = SkeletonBounds;\n})(spine || (spine = {}));\nvar spine;\n(function (spine) {\n    var SkeletonClipping = (function () {\n        function SkeletonClipping() {\n            this.triangulator = new spine.Triangulator();\n            this.clippingPolygon = new Array();\n            this.clipOutput = new Array();\n            this.clippedVertices = new Array();\n            this.clippedTriangles = new Array();\n            this.scratch = new Array();\n        }\n        SkeletonClipping.prototype.clipStart = function (slot, clip) {\n            if (this.clipAttachment != null)\n                return 0;\n            this.clipAttachment = clip;\n            var n = clip.worldVerticesLength;\n            var vertices = spine.Utils.setArraySize(this.clippingPolygon, n);\n            clip.computeWorldVertices(slot, 0, n, vertices, 0, 2);\n            var clippingPolygon = this.clippingPolygon;\n            SkeletonClipping.makeClockwise(clippingPolygon);\n            var clippingPolygons = this.clippingPolygons = this.triangulator.decompose(clippingPolygon, this.triangulator.triangulate(clippingPolygon));\n            for (var i = 0, n_1 = clippingPolygons.length; i < n_1; i++) {\n                var polygon = clippingPolygons[i];\n                SkeletonClipping.makeClockwise(polygon);\n                polygon.push(polygon[0]);\n                polygon.push(polygon[1]);\n            }\n            return clippingPolygons.length;\n        };\n        SkeletonClipping.prototype.clipEndWithSlot = function (slot) {\n            if (this.clipAttachment != null && this.clipAttachment.endSlot == slot.data)\n                this.clipEnd();\n        };\n        SkeletonClipping.prototype.clipEnd = function () {\n            if (this.clipAttachment == null)\n                return;\n            this.clipAttachment = null;\n            this.clippingPolygons = null;\n            this.clippedVertices.length = 0;\n            this.clippedTriangles.length = 0;\n            this.clippingPolygon.length = 0;\n        };\n        SkeletonClipping.prototype.isClipping = function () {\n            return this.clipAttachment != null;\n        };\n        SkeletonClipping.prototype.clipTriangles = function (vertices, verticesLength, triangles, trianglesLength, uvs, light, dark, twoColor) {\n            var clipOutput = this.clipOutput, clippedVertices = this.clippedVertices;\n            var clippedTriangles = this.clippedTriangles;\n            var polygons = this.clippingPolygons;\n            var polygonsCount = this.clippingPolygons.length;\n            var vertexSize = twoColor ? 12 : 8;\n            var index = 0;\n            clippedVertices.length = 0;\n            clippedTriangles.length = 0;\n            outer: for (var i = 0; i < trianglesLength; i += 3) {\n                var vertexOffset = triangles[i] << 1;\n                var x1 = vertices[vertexOffset], y1 = vertices[vertexOffset + 1];\n                var u1 = uvs[vertexOffset], v1 = uvs[vertexOffset + 1];\n                vertexOffset = triangles[i + 1] << 1;\n                var x2 = vertices[vertexOffset], y2 = vertices[vertexOffset + 1];\n                var u2 = uvs[vertexOffset], v2 = uvs[vertexOffset + 1];\n                vertexOffset = triangles[i + 2] << 1;\n                var x3 = vertices[vertexOffset], y3 = vertices[vertexOffset + 1];\n                var u3 = uvs[vertexOffset], v3 = uvs[vertexOffset + 1];\n                for (var p = 0; p < polygonsCount; p++) {\n                    var s = clippedVertices.length;\n                    if (this.clip(x1, y1, x2, y2, x3, y3, polygons[p], clipOutput)) {\n                        var clipOutputLength = clipOutput.length;\n                        if (clipOutputLength == 0)\n                            continue;\n                        var d0 = y2 - y3, d1 = x3 - x2, d2 = x1 - x3, d4 = y3 - y1;\n                        var d = 1 / (d0 * d2 + d1 * (y1 - y3));\n                        var clipOutputCount = clipOutputLength >> 1;\n                        var clipOutputItems = this.clipOutput;\n                        var clippedVerticesItems = spine.Utils.setArraySize(clippedVertices, s + clipOutputCount * vertexSize);\n                        for (var ii = 0; ii < clipOutputLength; ii += 2) {\n                            var x = clipOutputItems[ii], y = clipOutputItems[ii + 1];\n                            clippedVerticesItems[s] = x;\n                            clippedVerticesItems[s + 1] = y;\n                            clippedVerticesItems[s + 2] = light.r;\n                            clippedVerticesItems[s + 3] = light.g;\n                            clippedVerticesItems[s + 4] = light.b;\n                            clippedVerticesItems[s + 5] = light.a;\n                            var c0 = x - x3, c1 = y - y3;\n                            var a = (d0 * c0 + d1 * c1) * d;\n                            var b = (d4 * c0 + d2 * c1) * d;\n                            var c = 1 - a - b;\n                            clippedVerticesItems[s + 6] = u1 * a + u2 * b + u3 * c;\n                            clippedVerticesItems[s + 7] = v1 * a + v2 * b + v3 * c;\n                            if (twoColor) {\n                                clippedVerticesItems[s + 8] = dark.r;\n                                clippedVerticesItems[s + 9] = dark.g;\n                                clippedVerticesItems[s + 10] = dark.b;\n                                clippedVerticesItems[s + 11] = dark.a;\n                            }\n                            s += vertexSize;\n                        }\n                        s = clippedTriangles.length;\n                        var clippedTrianglesItems = spine.Utils.setArraySize(clippedTriangles, s + 3 * (clipOutputCount - 2));\n                        clipOutputCount--;\n                        for (var ii = 1; ii < clipOutputCount; ii++) {\n                            clippedTrianglesItems[s] = index;\n                            clippedTrianglesItems[s + 1] = (index + ii);\n                            clippedTrianglesItems[s + 2] = (index + ii + 1);\n                            s += 3;\n                        }\n                        index += clipOutputCount + 1;\n                    }\n                    else {\n                        var clippedVerticesItems = spine.Utils.setArraySize(clippedVertices, s + 3 * vertexSize);\n                        clippedVerticesItems[s] = x1;\n                        clippedVerticesItems[s + 1] = y1;\n                        clippedVerticesItems[s + 2] = light.r;\n                        clippedVerticesItems[s + 3] = light.g;\n                        clippedVerticesItems[s + 4] = light.b;\n                        clippedVerticesItems[s + 5] = light.a;\n                        if (!twoColor) {\n                            clippedVerticesItems[s + 6] = u1;\n                            clippedVerticesItems[s + 7] = v1;\n                            clippedVerticesItems[s + 8] = x2;\n                            clippedVerticesItems[s + 9] = y2;\n                            clippedVerticesItems[s + 10] = light.r;\n                            clippedVerticesItems[s + 11] = light.g;\n                            clippedVerticesItems[s + 12] = light.b;\n                            clippedVerticesItems[s + 13] = light.a;\n                            clippedVerticesItems[s + 14] = u2;\n                            clippedVerticesItems[s + 15] = v2;\n                            clippedVerticesItems[s + 16] = x3;\n                            clippedVerticesItems[s + 17] = y3;\n                            clippedVerticesItems[s + 18] = light.r;\n                            clippedVerticesItems[s + 19] = light.g;\n                            clippedVerticesItems[s + 20] = light.b;\n                            clippedVerticesItems[s + 21] = light.a;\n                            clippedVerticesItems[s + 22] = u3;\n                            clippedVerticesItems[s + 23] = v3;\n                        }\n                        else {\n                            clippedVerticesItems[s + 6] = u1;\n                            clippedVerticesItems[s + 7] = v1;\n                            clippedVerticesItems[s + 8] = dark.r;\n                            clippedVerticesItems[s + 9] = dark.g;\n                            clippedVerticesItems[s + 10] = dark.b;\n                            clippedVerticesItems[s + 11] = dark.a;\n                            clippedVerticesItems[s + 12] = x2;\n                            clippedVerticesItems[s + 13] = y2;\n                            clippedVerticesItems[s + 14] = light.r;\n                            clippedVerticesItems[s + 15] = light.g;\n                            clippedVerticesItems[s + 16] = light.b;\n                            clippedVerticesItems[s + 17] = light.a;\n                            clippedVerticesItems[s + 18] = u2;\n                            clippedVerticesItems[s + 19] = v2;\n                            clippedVerticesItems[s + 20] = dark.r;\n                            clippedVerticesItems[s + 21] = dark.g;\n                            clippedVerticesItems[s + 22] = dark.b;\n                            clippedVerticesItems[s + 23] = dark.a;\n                            clippedVerticesItems[s + 24] = x3;\n                            clippedVerticesItems[s + 25] = y3;\n                            clippedVerticesItems[s + 26] = light.r;\n                            clippedVerticesItems[s + 27] = light.g;\n                            clippedVerticesItems[s + 28] = light.b;\n                            clippedVerticesItems[s + 29] = light.a;\n                            clippedVerticesItems[s + 30] = u3;\n                            clippedVerticesItems[s + 31] = v3;\n                            clippedVerticesItems[s + 32] = dark.r;\n                            clippedVerticesItems[s + 33] = dark.g;\n                            clippedVerticesItems[s + 34] = dark.b;\n                            clippedVerticesItems[s + 35] = dark.a;\n                        }\n                        s = clippedTriangles.length;\n                        var clippedTrianglesItems = spine.Utils.setArraySize(clippedTriangles, s + 3);\n                        clippedTrianglesItems[s] = index;\n                        clippedTrianglesItems[s + 1] = (index + 1);\n                        clippedTrianglesItems[s + 2] = (index + 2);\n                        index += 3;\n                        continue outer;\n                    }\n                }\n            }\n        };\n        SkeletonClipping.prototype.clip = function (x1, y1, x2, y2, x3, y3, clippingArea, output) {\n            var originalOutput = output;\n            var clipped = false;\n            var input = null;\n            if (clippingArea.length % 4 >= 2) {\n                input = output;\n                output = this.scratch;\n            }\n            else\n                input = this.scratch;\n            input.length = 0;\n            input.push(x1);\n            input.push(y1);\n            input.push(x2);\n            input.push(y2);\n            input.push(x3);\n            input.push(y3);\n            input.push(x1);\n            input.push(y1);\n            output.length = 0;\n            var clippingVertices = clippingArea;\n            var clippingVerticesLast = clippingArea.length - 4;\n            for (var i = 0;; i += 2) {\n                var edgeX = clippingVertices[i], edgeY = clippingVertices[i + 1];\n                var edgeX2 = clippingVertices[i + 2], edgeY2 = clippingVertices[i + 3];\n                var deltaX = edgeX - edgeX2, deltaY = edgeY - edgeY2;\n                var inputVertices = input;\n                var inputVerticesLength = input.length - 2, outputStart = output.length;\n                for (var ii = 0; ii < inputVerticesLength; ii += 2) {\n                    var inputX = inputVertices[ii], inputY = inputVertices[ii + 1];\n                    var inputX2 = inputVertices[ii + 2], inputY2 = inputVertices[ii + 3];\n                    var side2 = deltaX * (inputY2 - edgeY2) - deltaY * (inputX2 - edgeX2) > 0;\n                    if (deltaX * (inputY - edgeY2) - deltaY * (inputX - edgeX2) > 0) {\n                        if (side2) {\n                            output.push(inputX2);\n                            output.push(inputY2);\n                            continue;\n                        }\n                        var c0 = inputY2 - inputY, c2 = inputX2 - inputX;\n                        var s = c0 * (edgeX2 - edgeX) - c2 * (edgeY2 - edgeY);\n                        if (Math.abs(s) > 0.000001) {\n                            var ua = (c2 * (edgeY - inputY) - c0 * (edgeX - inputX)) / s;\n                            output.push(edgeX + (edgeX2 - edgeX) * ua);\n                            output.push(edgeY + (edgeY2 - edgeY) * ua);\n                        }\n                        else {\n                            output.push(edgeX);\n                            output.push(edgeY);\n                        }\n                    }\n                    else if (side2) {\n                        var c0 = inputY2 - inputY, c2 = inputX2 - inputX;\n                        var s = c0 * (edgeX2 - edgeX) - c2 * (edgeY2 - edgeY);\n                        if (Math.abs(s) > 0.000001) {\n                            var ua = (c2 * (edgeY - inputY) - c0 * (edgeX - inputX)) / s;\n                            output.push(edgeX + (edgeX2 - edgeX) * ua);\n                            output.push(edgeY + (edgeY2 - edgeY) * ua);\n                        }\n                        else {\n                            output.push(edgeX);\n                            output.push(edgeY);\n                        }\n                        output.push(inputX2);\n                        output.push(inputY2);\n                    }\n                    clipped = true;\n                }\n                if (outputStart == output.length) {\n                    originalOutput.length = 0;\n                    return true;\n                }\n                output.push(output[0]);\n                output.push(output[1]);\n                if (i == clippingVerticesLast)\n                    break;\n                var temp = output;\n                output = input;\n                output.length = 0;\n                input = temp;\n            }\n            if (originalOutput != output) {\n                originalOutput.length = 0;\n                for (var i = 0, n = output.length - 2; i < n; i++)\n                    originalOutput[i] = output[i];\n            }\n            else\n                originalOutput.length = originalOutput.length - 2;\n            return clipped;\n        };\n        SkeletonClipping.makeClockwise = function (polygon) {\n            var vertices = polygon;\n            var verticeslength = polygon.length;\n            var area = vertices[verticeslength - 2] * vertices[1] - vertices[0] * vertices[verticeslength - 1], p1x = 0, p1y = 0, p2x = 0, p2y = 0;\n            for (var i = 0, n = verticeslength - 3; i < n; i += 2) {\n                p1x = vertices[i];\n                p1y = vertices[i + 1];\n                p2x = vertices[i + 2];\n                p2y = vertices[i + 3];\n                area += p1x * p2y - p2x * p1y;\n            }\n            if (area < 0)\n                return;\n            for (var i = 0, lastX = verticeslength - 2, n = verticeslength >> 1; i < n; i += 2) {\n                var x = vertices[i], y = vertices[i + 1];\n                var other = lastX - i;\n                vertices[i] = vertices[other];\n                vertices[i + 1] = vertices[other + 1];\n                vertices[other] = x;\n                vertices[other + 1] = y;\n            }\n        };\n        return SkeletonClipping;\n    }());\n    spine.SkeletonClipping = SkeletonClipping;\n})(spine || (spine = {}));\nvar spine;\n(function (spine) {\n    var SkeletonData = (function () {\n        function SkeletonData() {\n            this.bones = new Array();\n            this.slots = new Array();\n            this.skins = new Array();\n            this.events = new Array();\n            this.animations = new Array();\n            this.ikConstraints = new Array();\n            this.transformConstraints = new Array();\n            this.pathConstraints = new Array();\n            this.fps = 0;\n        }\n        SkeletonData.prototype.findBone = function (boneName) {\n            if (boneName == null)\n                throw new Error(\"boneName cannot be null.\");\n            var bones = this.bones;\n            for (var i = 0, n = bones.length; i < n; i++) {\n                var bone = bones[i];\n                if (bone.name == boneName)\n                    return bone;\n            }\n            return null;\n        };\n        SkeletonData.prototype.findBoneIndex = function (boneName) {\n            if (boneName == null)\n                throw new Error(\"boneName cannot be null.\");\n            var bones = this.bones;\n            for (var i = 0, n = bones.length; i < n; i++)\n                if (bones[i].name == boneName)\n                    return i;\n            return -1;\n        };\n        SkeletonData.prototype.findSlot = function (slotName) {\n            if (slotName == null)\n                throw new Error(\"slotName cannot be null.\");\n            var slots = this.slots;\n            for (var i = 0, n = slots.length; i < n; i++) {\n                var slot = slots[i];\n                if (slot.name == slotName)\n                    return slot;\n            }\n            return null;\n        };\n        SkeletonData.prototype.findSlotIndex = function (slotName) {\n            if (slotName == null)\n                throw new Error(\"slotName cannot be null.\");\n            var slots = this.slots;\n            for (var i = 0, n = slots.length; i < n; i++)\n                if (slots[i].name == slotName)\n                    return i;\n            return -1;\n        };\n        SkeletonData.prototype.findSkin = function (skinName) {\n            if (skinName == null)\n                throw new Error(\"skinName cannot be null.\");\n            var skins = this.skins;\n            for (var i = 0, n = skins.length; i < n; i++) {\n                var skin = skins[i];\n                if (skin.name == skinName)\n                    return skin;\n            }\n            return null;\n        };\n        SkeletonData.prototype.findEvent = function (eventDataName) {\n            if (eventDataName == null)\n                throw new Error(\"eventDataName cannot be null.\");\n            var events = this.events;\n            for (var i = 0, n = events.length; i < n; i++) {\n                var event_4 = events[i];\n                if (event_4.name == eventDataName)\n                    return event_4;\n            }\n            return null;\n        };\n        SkeletonData.prototype.findAnimation = function (animationName) {\n            if (animationName == null)\n                throw new Error(\"animationName cannot be null.\");\n            var animations = this.animations;\n            for (var i = 0, n = animations.length; i < n; i++) {\n                var animation = animations[i];\n                if (animation.name == animationName)\n                    return animation;\n            }\n            return null;\n        };\n        SkeletonData.prototype.findIkConstraint = function (constraintName) {\n            if (constraintName == null)\n                throw new Error(\"constraintName cannot be null.\");\n            var ikConstraints = this.ikConstraints;\n            for (var i = 0, n = ikConstraints.length; i < n; i++) {\n                var constraint = ikConstraints[i];\n                if (constraint.name == constraintName)\n                    return constraint;\n            }\n            return null;\n        };\n        SkeletonData.prototype.findTransformConstraint = function (constraintName) {\n            if (constraintName == null)\n                throw new Error(\"constraintName cannot be null.\");\n            var transformConstraints = this.transformConstraints;\n            for (var i = 0, n = transformConstraints.length; i < n; i++) {\n                var constraint = transformConstraints[i];\n                if (constraint.name == constraintName)\n                    return constraint;\n            }\n            return null;\n        };\n        SkeletonData.prototype.findPathConstraint = function (constraintName) {\n            if (constraintName == null)\n                throw new Error(\"constraintName cannot be null.\");\n            var pathConstraints = this.pathConstraints;\n            for (var i = 0, n = pathConstraints.length; i < n; i++) {\n                var constraint = pathConstraints[i];\n                if (constraint.name == constraintName)\n                    return constraint;\n            }\n            return null;\n        };\n        SkeletonData.prototype.findPathConstraintIndex = function (pathConstraintName) {\n            if (pathConstraintName == null)\n                throw new Error(\"pathConstraintName cannot be null.\");\n            var pathConstraints = this.pathConstraints;\n            for (var i = 0, n = pathConstraints.length; i < n; i++)\n                if (pathConstraints[i].name == pathConstraintName)\n                    return i;\n            return -1;\n        };\n        return SkeletonData;\n    }());\n    spine.SkeletonData = SkeletonData;\n})(spine || (spine = {}));\nvar spine;\n(function (spine) {\n    var SkeletonJson = (function () {\n        function SkeletonJson(attachmentLoader) {\n            this.scale = 1;\n            this.linkedMeshes = new Array();\n            this.attachmentLoader = attachmentLoader;\n        }\n        SkeletonJson.prototype.readSkeletonData = function (json) {\n            var scale = this.scale;\n            var skeletonData = new spine.SkeletonData();\n            var root = typeof (json) === \"string\" ? JSON.parse(json) : json;\n            var skeletonMap = root.skeleton;\n            if (skeletonMap != null) {\n                skeletonData.hash = skeletonMap.hash;\n                skeletonData.version = skeletonMap.spine;\n                skeletonData.width = skeletonMap.width;\n                skeletonData.height = skeletonMap.height;\n                skeletonData.fps = skeletonMap.fps;\n                skeletonData.imagesPath = skeletonMap.images;\n            }\n            if (root.bones) {\n                for (var i = 0; i < root.bones.length; i++) {\n                    var boneMap = root.bones[i];\n                    var parent_2 = null;\n                    var parentName = this.getValue(boneMap, \"parent\", null);\n                    if (parentName != null) {\n                        parent_2 = skeletonData.findBone(parentName);\n                        if (parent_2 == null)\n                            throw new Error(\"Parent bone not found: \" + parentName);\n                    }\n                    var data = new spine.BoneData(skeletonData.bones.length, boneMap.name, parent_2);\n                    data.length = this.getValue(boneMap, \"length\", 0) * scale;\n                    data.x = this.getValue(boneMap, \"x\", 0) * scale;\n                    data.y = this.getValue(boneMap, \"y\", 0) * scale;\n                    data.rotation = this.getValue(boneMap, \"rotation\", 0);\n                    data.scaleX = this.getValue(boneMap, \"scaleX\", 1);\n                    data.scaleY = this.getValue(boneMap, \"scaleY\", 1);\n                    data.shearX = this.getValue(boneMap, \"shearX\", 0);\n                    data.shearY = this.getValue(boneMap, \"shearY\", 0);\n                    data.transformMode = SkeletonJson.transformModeFromString(this.getValue(boneMap, \"transform\", \"normal\"));\n                    skeletonData.bones.push(data);\n                }\n            }\n            if (root.slots) {\n                for (var i = 0; i < root.slots.length; i++) {\n                    var slotMap = root.slots[i];\n                    var slotName = slotMap.name;\n                    var boneName = slotMap.bone;\n                    var boneData = skeletonData.findBone(boneName);\n                    if (boneData == null)\n                        throw new Error(\"Slot bone not found: \" + boneName);\n                    var data = new spine.SlotData(skeletonData.slots.length, slotName, boneData);\n                    var color = this.getValue(slotMap, \"color\", null);\n                    if (color != null)\n                        data.color.setFromString(color);\n                    var dark = this.getValue(slotMap, \"dark\", null);\n                    if (dark != null) {\n                        data.darkColor = new spine.Color(1, 1, 1, 1);\n                        data.darkColor.setFromString(dark);\n                    }\n                    data.attachmentName = this.getValue(slotMap, \"attachment\", null);\n                    data.blendMode = SkeletonJson.blendModeFromString(this.getValue(slotMap, \"blend\", \"normal\"));\n                    skeletonData.slots.push(data);\n                }\n            }\n            if (root.ik) {\n                for (var i = 0; i < root.ik.length; i++) {\n                    var constraintMap = root.ik[i];\n                    var data = new spine.IkConstraintData(constraintMap.name);\n                    data.order = this.getValue(constraintMap, \"order\", 0);\n                    for (var j = 0; j < constraintMap.bones.length; j++) {\n                        var boneName = constraintMap.bones[j];\n                        var bone = skeletonData.findBone(boneName);\n                        if (bone == null)\n                            throw new Error(\"IK bone not found: \" + boneName);\n                        data.bones.push(bone);\n                    }\n                    var targetName = constraintMap.target;\n                    data.target = skeletonData.findBone(targetName);\n                    if (data.target == null)\n                        throw new Error(\"IK target bone not found: \" + targetName);\n                    data.mix = this.getValue(constraintMap, \"mix\", 1);\n                    data.bendDirection = this.getValue(constraintMap, \"bendPositive\", true) ? 1 : -1;\n                    data.compress = this.getValue(constraintMap, \"compress\", false);\n                    data.stretch = this.getValue(constraintMap, \"stretch\", false);\n                    data.uniform = this.getValue(constraintMap, \"uniform\", false);\n                    skeletonData.ikConstraints.push(data);\n                }\n            }\n            if (root.transform) {\n                for (var i = 0; i < root.transform.length; i++) {\n                    var constraintMap = root.transform[i];\n                    var data = new spine.TransformConstraintData(constraintMap.name);\n                    data.order = this.getValue(constraintMap, \"order\", 0);\n                    for (var j = 0; j < constraintMap.bones.length; j++) {\n                        var boneName = constraintMap.bones[j];\n                        var bone = skeletonData.findBone(boneName);\n                        if (bone == null)\n                            throw new Error(\"Transform constraint bone not found: \" + boneName);\n                        data.bones.push(bone);\n                    }\n                    var targetName = constraintMap.target;\n                    data.target = skeletonData.findBone(targetName);\n                    if (data.target == null)\n                        throw new Error(\"Transform constraint target bone not found: \" + targetName);\n                    data.local = this.getValue(constraintMap, \"local\", false);\n                    data.relative = this.getValue(constraintMap, \"relative\", false);\n                    data.offsetRotation = this.getValue(constraintMap, \"rotation\", 0);\n                    data.offsetX = this.getValue(constraintMap, \"x\", 0) * scale;\n                    data.offsetY = this.getValue(constraintMap, \"y\", 0) * scale;\n                    data.offsetScaleX = this.getValue(constraintMap, \"scaleX\", 0);\n                    data.offsetScaleY = this.getValue(constraintMap, \"scaleY\", 0);\n                    data.offsetShearY = this.getValue(constraintMap, \"shearY\", 0);\n                    data.rotateMix = this.getValue(constraintMap, \"rotateMix\", 1);\n                    data.translateMix = this.getValue(constraintMap, \"translateMix\", 1);\n                    data.scaleMix = this.getValue(constraintMap, \"scaleMix\", 1);\n                    data.shearMix = this.getValue(constraintMap, \"shearMix\", 1);\n                    skeletonData.transformConstraints.push(data);\n                }\n            }\n            if (root.path) {\n                for (var i = 0; i < root.path.length; i++) {\n                    var constraintMap = root.path[i];\n                    var data = new spine.PathConstraintData(constraintMap.name);\n                    data.order = this.getValue(constraintMap, \"order\", 0);\n                    for (var j = 0; j < constraintMap.bones.length; j++) {\n                        var boneName = constraintMap.bones[j];\n                        var bone = skeletonData.findBone(boneName);\n                        if (bone == null)\n                            throw new Error(\"Transform constraint bone not found: \" + boneName);\n                        data.bones.push(bone);\n                    }\n                    var targetName = constraintMap.target;\n                    data.target = skeletonData.findSlot(targetName);\n                    if (data.target == null)\n                        throw new Error(\"Path target slot not found: \" + targetName);\n                    data.positionMode = SkeletonJson.positionModeFromString(this.getValue(constraintMap, \"positionMode\", \"percent\"));\n                    data.spacingMode = SkeletonJson.spacingModeFromString(this.getValue(constraintMap, \"spacingMode\", \"length\"));\n                    data.rotateMode = SkeletonJson.rotateModeFromString(this.getValue(constraintMap, \"rotateMode\", \"tangent\"));\n                    data.offsetRotation = this.getValue(constraintMap, \"rotation\", 0);\n                    data.position = this.getValue(constraintMap, \"position\", 0);\n                    if (data.positionMode == spine.PositionMode.Fixed)\n                        data.position *= scale;\n                    data.spacing = this.getValue(constraintMap, \"spacing\", 0);\n                    if (data.spacingMode == spine.SpacingMode.Length || data.spacingMode == spine.SpacingMode.Fixed)\n                        data.spacing *= scale;\n                    data.rotateMix = this.getValue(constraintMap, \"rotateMix\", 1);\n                    data.translateMix = this.getValue(constraintMap, \"translateMix\", 1);\n                    skeletonData.pathConstraints.push(data);\n                }\n            }\n            if (root.skins) {\n                for (var skinName in root.skins) {\n                    var skinMap = root.skins[skinName];\n                    var skin = new spine.Skin(skinName);\n                    for (var slotName in skinMap) {\n                        var slotIndex = skeletonData.findSlotIndex(slotName);\n                        if (slotIndex == -1)\n                            throw new Error(\"Slot not found: \" + slotName);\n                        var slotMap = skinMap[slotName];\n                        for (var entryName in slotMap) {\n                            var attachment = this.readAttachment(slotMap[entryName], skin, slotIndex, entryName, skeletonData);\n                            if (attachment != null)\n                                skin.addAttachment(slotIndex, entryName, attachment);\n                        }\n                    }\n                    skeletonData.skins.push(skin);\n                    if (skin.name == \"default\")\n                        skeletonData.defaultSkin = skin;\n                }\n            }\n            for (var i = 0, n = this.linkedMeshes.length; i < n; i++) {\n                var linkedMesh = this.linkedMeshes[i];\n                var skin = linkedMesh.skin == null ? skeletonData.defaultSkin : skeletonData.findSkin(linkedMesh.skin);\n                if (skin == null)\n                    throw new Error(\"Skin not found: \" + linkedMesh.skin);\n                var parent_3 = skin.getAttachment(linkedMesh.slotIndex, linkedMesh.parent);\n                if (parent_3 == null)\n                    throw new Error(\"Parent mesh not found: \" + linkedMesh.parent);\n                linkedMesh.mesh.setParentMesh(parent_3);\n                linkedMesh.mesh.updateUVs();\n            }\n            this.linkedMeshes.length = 0;\n            if (root.events) {\n                for (var eventName in root.events) {\n                    var eventMap = root.events[eventName];\n                    var data = new spine.EventData(eventName);\n                    data.intValue = this.getValue(eventMap, \"int\", 0);\n                    data.floatValue = this.getValue(eventMap, \"float\", 0);\n                    data.stringValue = this.getValue(eventMap, \"string\", \"\");\n                    data.audioPath = this.getValue(eventMap, \"audio\", null);\n                    if (data.audioPath != null) {\n                        data.volume = this.getValue(eventMap, \"volume\", 1);\n                        data.balance = this.getValue(eventMap, \"balance\", 0);\n                    }\n                    skeletonData.events.push(data);\n                }\n            }\n            if (root.animations) {\n                for (var animationName in root.animations) {\n                    var animationMap = root.animations[animationName];\n                    this.readAnimation(animationMap, animationName, skeletonData);\n                }\n            }\n            return skeletonData;\n        };\n        SkeletonJson.prototype.readAttachment = function (map, skin, slotIndex, name, skeletonData) {\n            var scale = this.scale;\n            name = this.getValue(map, \"name\", name);\n            var type = this.getValue(map, \"type\", \"region\");\n            switch (type) {\n                case \"region\": {\n                    var path = this.getValue(map, \"path\", name);\n                    var region = this.attachmentLoader.newRegionAttachment(skin, name, path);\n                    if (region == null)\n                        return null;\n                    region.path = path;\n                    region.x = this.getValue(map, \"x\", 0) * scale;\n                    region.y = this.getValue(map, \"y\", 0) * scale;\n                    region.scaleX = this.getValue(map, \"scaleX\", 1);\n                    region.scaleY = this.getValue(map, \"scaleY\", 1);\n                    region.rotation = this.getValue(map, \"rotation\", 0);\n                    region.width = map.width * scale;\n                    region.height = map.height * scale;\n                    var color = this.getValue(map, \"color\", null);\n                    if (color != null)\n                        region.color.setFromString(color);\n                    region.updateOffset();\n                    return region;\n                }\n                case \"boundingbox\": {\n                    var box = this.attachmentLoader.newBoundingBoxAttachment(skin, name);\n                    if (box == null)\n                        return null;\n                    this.readVertices(map, box, map.vertexCount << 1);\n                    var color = this.getValue(map, \"color\", null);\n                    if (color != null)\n                        box.color.setFromString(color);\n                    return box;\n                }\n                case \"mesh\":\n                case \"linkedmesh\": {\n                    var path = this.getValue(map, \"path\", name);\n                    var mesh = this.attachmentLoader.newMeshAttachment(skin, name, path);\n                    if (mesh == null)\n                        return null;\n                    mesh.path = path;\n                    var color = this.getValue(map, \"color\", null);\n                    if (color != null)\n                        mesh.color.setFromString(color);\n                    var parent_4 = this.getValue(map, \"parent\", null);\n                    if (parent_4 != null) {\n                        mesh.inheritDeform = this.getValue(map, \"deform\", true);\n                        this.linkedMeshes.push(new LinkedMesh(mesh, this.getValue(map, \"skin\", null), slotIndex, parent_4));\n                        return mesh;\n                    }\n                    var uvs = map.uvs;\n                    this.readVertices(map, mesh, uvs.length);\n                    mesh.triangles = map.triangles;\n                    mesh.regionUVs = uvs;\n                    mesh.updateUVs();\n                    mesh.hullLength = this.getValue(map, \"hull\", 0) * 2;\n                    return mesh;\n                }\n                case \"path\": {\n                    var path = this.attachmentLoader.newPathAttachment(skin, name);\n                    if (path == null)\n                        return null;\n                    path.closed = this.getValue(map, \"closed\", false);\n                    path.constantSpeed = this.getValue(map, \"constantSpeed\", true);\n                    var vertexCount = map.vertexCount;\n                    this.readVertices(map, path, vertexCount << 1);\n                    var lengths = spine.Utils.newArray(vertexCount / 3, 0);\n                    for (var i = 0; i < map.lengths.length; i++)\n                        lengths[i] = map.lengths[i] * scale;\n                    path.lengths = lengths;\n                    var color = this.getValue(map, \"color\", null);\n                    if (color != null)\n                        path.color.setFromString(color);\n                    return path;\n                }\n                case \"point\": {\n                    var point = this.attachmentLoader.newPointAttachment(skin, name);\n                    if (point == null)\n                        return null;\n                    point.x = this.getValue(map, \"x\", 0) * scale;\n                    point.y = this.getValue(map, \"y\", 0) * scale;\n                    point.rotation = this.getValue(map, \"rotation\", 0);\n                    var color = this.getValue(map, \"color\", null);\n                    if (color != null)\n                        point.color.setFromString(color);\n                    return point;\n                }\n                case \"clipping\": {\n                    var clip = this.attachmentLoader.newClippingAttachment(skin, name);\n                    if (clip == null)\n                        return null;\n                    var end = this.getValue(map, \"end\", null);\n                    if (end != null) {\n                        var slot = skeletonData.findSlot(end);\n                        if (slot == null)\n                            throw new Error(\"Clipping end slot not found: \" + end);\n                        clip.endSlot = slot;\n                    }\n                    var vertexCount = map.vertexCount;\n                    this.readVertices(map, clip, vertexCount << 1);\n                    var color = this.getValue(map, \"color\", null);\n                    if (color != null)\n                        clip.color.setFromString(color);\n                    return clip;\n                }\n            }\n            return null;\n        };\n        SkeletonJson.prototype.readVertices = function (map, attachment, verticesLength) {\n            var scale = this.scale;\n            attachment.worldVerticesLength = verticesLength;\n            var vertices = map.vertices;\n            if (verticesLength == vertices.length) {\n                var scaledVertices = spine.Utils.toFloatArray(vertices);\n                if (scale != 1) {\n                    for (var i = 0, n = vertices.length; i < n; i++)\n                        scaledVertices[i] *= scale;\n                }\n                attachment.vertices = scaledVertices;\n                return;\n            }\n            var weights = new Array();\n            var bones = new Array();\n            for (var i = 0, n = vertices.length; i < n;) {\n                var boneCount = vertices[i++];\n                bones.push(boneCount);\n                for (var nn = i + boneCount * 4; i < nn; i += 4) {\n                    bones.push(vertices[i]);\n                    weights.push(vertices[i + 1] * scale);\n                    weights.push(vertices[i + 2] * scale);\n                    weights.push(vertices[i + 3]);\n                }\n            }\n            attachment.bones = bones;\n            attachment.vertices = spine.Utils.toFloatArray(weights);\n        };\n        SkeletonJson.prototype.readAnimation = function (map, name, skeletonData) {\n            var scale = this.scale;\n            var timelines = new Array();\n            var duration = 0;\n            if (map.slots) {\n                for (var slotName in map.slots) {\n                    var slotMap = map.slots[slotName];\n                    var slotIndex = skeletonData.findSlotIndex(slotName);\n                    if (slotIndex == -1)\n                        throw new Error(\"Slot not found: \" + slotName);\n                    for (var timelineName in slotMap) {\n                        var timelineMap = slotMap[timelineName];\n                        if (timelineName == \"attachment\") {\n                            var timeline = new spine.AttachmentTimeline(timelineMap.length);\n                            timeline.slotIndex = slotIndex;\n                            var frameIndex = 0;\n                            for (var i = 0; i < timelineMap.length; i++) {\n                                var valueMap = timelineMap[i];\n                                timeline.setFrame(frameIndex++, valueMap.time, valueMap.name);\n                            }\n                            timelines.push(timeline);\n                            duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);\n                        }\n                        else if (timelineName == \"color\") {\n                            var timeline = new spine.ColorTimeline(timelineMap.length);\n                            timeline.slotIndex = slotIndex;\n                            var frameIndex = 0;\n                            for (var i = 0; i < timelineMap.length; i++) {\n                                var valueMap = timelineMap[i];\n                                var color = new spine.Color();\n                                color.setFromString(valueMap.color);\n                                timeline.setFrame(frameIndex, valueMap.time, color.r, color.g, color.b, color.a);\n                                this.readCurve(valueMap, timeline, frameIndex);\n                                frameIndex++;\n                            }\n                            timelines.push(timeline);\n                            duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * spine.ColorTimeline.ENTRIES]);\n                        }\n                        else if (timelineName == \"twoColor\") {\n                            var timeline = new spine.TwoColorTimeline(timelineMap.length);\n                            timeline.slotIndex = slotIndex;\n                            var frameIndex = 0;\n                            for (var i = 0; i < timelineMap.length; i++) {\n                                var valueMap = timelineMap[i];\n                                var light = new spine.Color();\n                                var dark = new spine.Color();\n                                light.setFromString(valueMap.light);\n                                dark.setFromString(valueMap.dark);\n                                timeline.setFrame(frameIndex, valueMap.time, light.r, light.g, light.b, light.a, dark.r, dark.g, dark.b);\n                                this.readCurve(valueMap, timeline, frameIndex);\n                                frameIndex++;\n                            }\n                            timelines.push(timeline);\n                            duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * spine.TwoColorTimeline.ENTRIES]);\n                        }\n                        else\n                            throw new Error(\"Invalid timeline type for a slot: \" + timelineName + \" (\" + slotName + \")\");\n                    }\n                }\n            }\n            if (map.bones) {\n                for (var boneName in map.bones) {\n                    var boneMap = map.bones[boneName];\n                    var boneIndex = skeletonData.findBoneIndex(boneName);\n                    if (boneIndex == -1)\n                        throw new Error(\"Bone not found: \" + boneName);\n                    for (var timelineName in boneMap) {\n                        var timelineMap = boneMap[timelineName];\n                        if (timelineName === \"rotate\") {\n                            var timeline = new spine.RotateTimeline(timelineMap.length);\n                            timeline.boneIndex = boneIndex;\n                            var frameIndex = 0;\n                            for (var i = 0; i < timelineMap.length; i++) {\n                                var valueMap = timelineMap[i];\n                                timeline.setFrame(frameIndex, valueMap.time, valueMap.angle);\n                                this.readCurve(valueMap, timeline, frameIndex);\n                                frameIndex++;\n                            }\n                            timelines.push(timeline);\n                            duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * spine.RotateTimeline.ENTRIES]);\n                        }\n                        else if (timelineName === \"translate\" || timelineName === \"scale\" || timelineName === \"shear\") {\n                            var timeline = null;\n                            var timelineScale = 1;\n                            if (timelineName === \"scale\")\n                                timeline = new spine.ScaleTimeline(timelineMap.length);\n                            else if (timelineName === \"shear\")\n                                timeline = new spine.ShearTimeline(timelineMap.length);\n                            else {\n                                timeline = new spine.TranslateTimeline(timelineMap.length);\n                                timelineScale = scale;\n                            }\n                            timeline.boneIndex = boneIndex;\n                            var frameIndex = 0;\n                            for (var i = 0; i < timelineMap.length; i++) {\n                                var valueMap = timelineMap[i];\n                                var x = this.getValue(valueMap, \"x\", 0), y = this.getValue(valueMap, \"y\", 0);\n                                timeline.setFrame(frameIndex, valueMap.time, x * timelineScale, y * timelineScale);\n                                this.readCurve(valueMap, timeline, frameIndex);\n                                frameIndex++;\n                            }\n                            timelines.push(timeline);\n                            duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * spine.TranslateTimeline.ENTRIES]);\n                        }\n                        else\n                            throw new Error(\"Invalid timeline type for a bone: \" + timelineName + \" (\" + boneName + \")\");\n                    }\n                }\n            }\n            if (map.ik) {\n                for (var constraintName in map.ik) {\n                    var constraintMap = map.ik[constraintName];\n                    var constraint = skeletonData.findIkConstraint(constraintName);\n                    var timeline = new spine.IkConstraintTimeline(constraintMap.length);\n                    timeline.ikConstraintIndex = skeletonData.ikConstraints.indexOf(constraint);\n                    var frameIndex = 0;\n                    for (var i = 0; i < constraintMap.length; i++) {\n                        var valueMap = constraintMap[i];\n                        timeline.setFrame(frameIndex, valueMap.time, this.getValue(valueMap, \"mix\", 1), this.getValue(valueMap, \"bendPositive\", true) ? 1 : -1, this.getValue(valueMap, \"compress\", false), this.getValue(valueMap, \"stretch\", false));\n                        this.readCurve(valueMap, timeline, frameIndex);\n                        frameIndex++;\n                    }\n                    timelines.push(timeline);\n                    duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * spine.IkConstraintTimeline.ENTRIES]);\n                }\n            }\n            if (map.transform) {\n                for (var constraintName in map.transform) {\n                    var constraintMap = map.transform[constraintName];\n                    var constraint = skeletonData.findTransformConstraint(constraintName);\n                    var timeline = new spine.TransformConstraintTimeline(constraintMap.length);\n                    timeline.transformConstraintIndex = skeletonData.transformConstraints.indexOf(constraint);\n                    var frameIndex = 0;\n                    for (var i = 0; i < constraintMap.length; i++) {\n                        var valueMap = constraintMap[i];\n                        timeline.setFrame(frameIndex, valueMap.time, this.getValue(valueMap, \"rotateMix\", 1), this.getValue(valueMap, \"translateMix\", 1), this.getValue(valueMap, \"scaleMix\", 1), this.getValue(valueMap, \"shearMix\", 1));\n                        this.readCurve(valueMap, timeline, frameIndex);\n                        frameIndex++;\n                    }\n                    timelines.push(timeline);\n                    duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * spine.TransformConstraintTimeline.ENTRIES]);\n                }\n            }\n            if (map.paths) {\n                for (var constraintName in map.paths) {\n                    var constraintMap = map.paths[constraintName];\n                    var index = skeletonData.findPathConstraintIndex(constraintName);\n                    if (index == -1)\n                        throw new Error(\"Path constraint not found: \" + constraintName);\n                    var data = skeletonData.pathConstraints[index];\n                    for (var timelineName in constraintMap) {\n                        var timelineMap = constraintMap[timelineName];\n                        if (timelineName === \"position\" || timelineName === \"spacing\") {\n                            var timeline = null;\n                            var timelineScale = 1;\n                            if (timelineName === \"spacing\") {\n                                timeline = new spine.PathConstraintSpacingTimeline(timelineMap.length);\n                                if (data.spacingMode == spine.SpacingMode.Length || data.spacingMode == spine.SpacingMode.Fixed)\n                                    timelineScale = scale;\n                            }\n                            else {\n                                timeline = new spine.PathConstraintPositionTimeline(timelineMap.length);\n                                if (data.positionMode == spine.PositionMode.Fixed)\n                                    timelineScale = scale;\n                            }\n                            timeline.pathConstraintIndex = index;\n                            var frameIndex = 0;\n                            for (var i = 0; i < timelineMap.length; i++) {\n                                var valueMap = timelineMap[i];\n                                timeline.setFrame(frameIndex, valueMap.time, this.getValue(valueMap, timelineName, 0) * timelineScale);\n                                this.readCurve(valueMap, timeline, frameIndex);\n                                frameIndex++;\n                            }\n                            timelines.push(timeline);\n                            duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * spine.PathConstraintPositionTimeline.ENTRIES]);\n                        }\n                        else if (timelineName === \"mix\") {\n                            var timeline = new spine.PathConstraintMixTimeline(timelineMap.length);\n                            timeline.pathConstraintIndex = index;\n                            var frameIndex = 0;\n                            for (var i = 0; i < timelineMap.length; i++) {\n                                var valueMap = timelineMap[i];\n                                timeline.setFrame(frameIndex, valueMap.time, this.getValue(valueMap, \"rotateMix\", 1), this.getValue(valueMap, \"translateMix\", 1));\n                                this.readCurve(valueMap, timeline, frameIndex);\n                                frameIndex++;\n                            }\n                            timelines.push(timeline);\n                            duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * spine.PathConstraintMixTimeline.ENTRIES]);\n                        }\n                    }\n                }\n            }\n            if (map.deform) {\n                for (var deformName in map.deform) {\n                    var deformMap = map.deform[deformName];\n                    var skin = skeletonData.findSkin(deformName);\n                    if (skin == null)\n                        throw new Error(\"Skin not found: \" + deformName);\n                    for (var slotName in deformMap) {\n                        var slotMap = deformMap[slotName];\n                        var slotIndex = skeletonData.findSlotIndex(slotName);\n                        if (slotIndex == -1)\n                            throw new Error(\"Slot not found: \" + slotMap.name);\n                        for (var timelineName in slotMap) {\n                            var timelineMap = slotMap[timelineName];\n                            var attachment = skin.getAttachment(slotIndex, timelineName);\n                            if (attachment == null)\n                                throw new Error(\"Deform attachment not found: \" + timelineMap.name);\n                            var weighted = attachment.bones != null;\n                            var vertices = attachment.vertices;\n                            var deformLength = weighted ? vertices.length / 3 * 2 : vertices.length;\n                            var timeline = new spine.DeformTimeline(timelineMap.length);\n                            timeline.slotIndex = slotIndex;\n                            timeline.attachment = attachment;\n                            var frameIndex = 0;\n                            for (var j = 0; j < timelineMap.length; j++) {\n                                var valueMap = timelineMap[j];\n                                var deform = void 0;\n                                var verticesValue = this.getValue(valueMap, \"vertices\", null);\n                                if (verticesValue == null)\n                                    deform = weighted ? spine.Utils.newFloatArray(deformLength) : vertices;\n                                else {\n                                    deform = spine.Utils.newFloatArray(deformLength);\n                                    var start = this.getValue(valueMap, \"offset\", 0);\n                                    spine.Utils.arrayCopy(verticesValue, 0, deform, start, verticesValue.length);\n                                    if (scale != 1) {\n                                        for (var i = start, n = i + verticesValue.length; i < n; i++)\n                                            deform[i] *= scale;\n                                    }\n                                    if (!weighted) {\n                                        for (var i = 0; i < deformLength; i++)\n                                            deform[i] += vertices[i];\n                                    }\n                                }\n                                timeline.setFrame(frameIndex, valueMap.time, deform);\n                                this.readCurve(valueMap, timeline, frameIndex);\n                                frameIndex++;\n                            }\n                            timelines.push(timeline);\n                            duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);\n                        }\n                    }\n                }\n            }\n            var drawOrderNode = map.drawOrder;\n            if (drawOrderNode == null)\n                drawOrderNode = map.draworder;\n            if (drawOrderNode != null) {\n                var timeline = new spine.DrawOrderTimeline(drawOrderNode.length);\n                var slotCount = skeletonData.slots.length;\n                var frameIndex = 0;\n                for (var j = 0; j < drawOrderNode.length; j++) {\n                    var drawOrderMap = drawOrderNode[j];\n                    var drawOrder = null;\n                    var offsets = this.getValue(drawOrderMap, \"offsets\", null);\n                    if (offsets != null) {\n                        drawOrder = spine.Utils.newArray(slotCount, -1);\n                        var unchanged = spine.Utils.newArray(slotCount - offsets.length, 0);\n                        var originalIndex = 0, unchangedIndex = 0;\n                        for (var i = 0; i < offsets.length; i++) {\n                            var offsetMap = offsets[i];\n                            var slotIndex = skeletonData.findSlotIndex(offsetMap.slot);\n                            if (slotIndex == -1)\n                                throw new Error(\"Slot not found: \" + offsetMap.slot);\n                            while (originalIndex != slotIndex)\n                                unchanged[unchangedIndex++] = originalIndex++;\n                            drawOrder[originalIndex + offsetMap.offset] = originalIndex++;\n                        }\n                        while (originalIndex < slotCount)\n                            unchanged[unchangedIndex++] = originalIndex++;\n                        for (var i = slotCount - 1; i >= 0; i--)\n                            if (drawOrder[i] == -1)\n                                drawOrder[i] = unchanged[--unchangedIndex];\n                    }\n                    timeline.setFrame(frameIndex++, drawOrderMap.time, drawOrder);\n                }\n                timelines.push(timeline);\n                duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);\n            }\n            if (map.events) {\n                var timeline = new spine.EventTimeline(map.events.length);\n                var frameIndex = 0;\n                for (var i = 0; i < map.events.length; i++) {\n                    var eventMap = map.events[i];\n                    var eventData = skeletonData.findEvent(eventMap.name);\n                    if (eventData == null)\n                        throw new Error(\"Event not found: \" + eventMap.name);\n                    var event_5 = new spine.Event(spine.Utils.toSinglePrecision(eventMap.time), eventData);\n                    event_5.intValue = this.getValue(eventMap, \"int\", eventData.intValue);\n                    event_5.floatValue = this.getValue(eventMap, \"float\", eventData.floatValue);\n                    event_5.stringValue = this.getValue(eventMap, \"string\", eventData.stringValue);\n                    if (event_5.data.audioPath != null) {\n                        event_5.volume = this.getValue(eventMap, \"volume\", 1);\n                        event_5.balance = this.getValue(eventMap, \"balance\", 0);\n                    }\n                    timeline.setFrame(frameIndex++, event_5);\n                }\n                timelines.push(timeline);\n                duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);\n            }\n            if (isNaN(duration)) {\n                throw new Error(\"Error while parsing animation, duration is NaN\");\n            }\n            skeletonData.animations.push(new spine.Animation(name, timelines, duration));\n        };\n        SkeletonJson.prototype.readCurve = function (map, timeline, frameIndex) {\n            if (!map.curve)\n                return;\n            if (map.curve === \"stepped\")\n                timeline.setStepped(frameIndex);\n            else if (Object.prototype.toString.call(map.curve) === '[object Array]') {\n                var curve = map.curve;\n                timeline.setCurve(frameIndex, curve[0], curve[1], curve[2], curve[3]);\n            }\n        };\n        SkeletonJson.prototype.getValue = function (map, prop, defaultValue) {\n            return map[prop] !== undefined ? map[prop] : defaultValue;\n        };\n        SkeletonJson.blendModeFromString = function (str) {\n            str = str.toLowerCase();\n            if (str == \"normal\")\n                return spine.BlendMode.Normal;\n            if (str == \"additive\")\n                return spine.BlendMode.Additive;\n            if (str == \"multiply\")\n                return spine.BlendMode.Multiply;\n            if (str == \"screen\")\n                return spine.BlendMode.Screen;\n            throw new Error(\"Unknown blend mode: \" + str);\n        };\n        SkeletonJson.positionModeFromString = function (str) {\n            str = str.toLowerCase();\n            if (str == \"fixed\")\n                return spine.PositionMode.Fixed;\n            if (str == \"percent\")\n                return spine.PositionMode.Percent;\n            throw new Error(\"Unknown position mode: \" + str);\n        };\n        SkeletonJson.spacingModeFromString = function (str) {\n            str = str.toLowerCase();\n            if (str == \"length\")\n                return spine.SpacingMode.Length;\n            if (str == \"fixed\")\n                return spine.SpacingMode.Fixed;\n            if (str == \"percent\")\n                return spine.SpacingMode.Percent;\n            throw new Error(\"Unknown position mode: \" + str);\n        };\n        SkeletonJson.rotateModeFromString = function (str) {\n            str = str.toLowerCase();\n            if (str == \"tangent\")\n                return spine.RotateMode.Tangent;\n            if (str == \"chain\")\n                return spine.RotateMode.Chain;\n            if (str == \"chainscale\")\n                return spine.RotateMode.ChainScale;\n            throw new Error(\"Unknown rotate mode: \" + str);\n        };\n        SkeletonJson.transformModeFromString = function (str) {\n            str = str.toLowerCase();\n            if (str == \"normal\")\n                return spine.TransformMode.Normal;\n            if (str == \"onlytranslation\")\n                return spine.TransformMode.OnlyTranslation;\n            if (str == \"norotationorreflection\")\n                return spine.TransformMode.NoRotationOrReflection;\n            if (str == \"noscale\")\n                return spine.TransformMode.NoScale;\n            if (str == \"noscaleorreflection\")\n                return spine.TransformMode.NoScaleOrReflection;\n            throw new Error(\"Unknown transform mode: \" + str);\n        };\n        return SkeletonJson;\n    }());\n    spine.SkeletonJson = SkeletonJson;\n    var LinkedMesh = (function () {\n        function LinkedMesh(mesh, skin, slotIndex, parent) {\n            this.mesh = mesh;\n            this.skin = skin;\n            this.slotIndex = slotIndex;\n            this.parent = parent;\n        }\n        return LinkedMesh;\n    }());\n})(spine || (spine = {}));\nvar spine;\n(function (spine) {\n    var Skin = (function () {\n        function Skin(name) {\n            this.attachments = new Array();\n            if (name == null)\n                throw new Error(\"name cannot be null.\");\n            this.name = name;\n        }\n        Skin.prototype.addAttachment = function (slotIndex, name, attachment) {\n            if (attachment == null)\n                throw new Error(\"attachment cannot be null.\");\n            var attachments = this.attachments;\n            if (slotIndex >= attachments.length)\n                attachments.length = slotIndex + 1;\n            if (!attachments[slotIndex])\n                attachments[slotIndex] = {};\n            attachments[slotIndex][name] = attachment;\n        };\n        Skin.prototype.getAttachment = function (slotIndex, name) {\n            var dictionary = this.attachments[slotIndex];\n            return dictionary ? dictionary[name] : null;\n        };\n        Skin.prototype.attachAll = function (skeleton, oldSkin) {\n            var slotIndex = 0;\n            for (var i = 0; i < skeleton.slots.length; i++) {\n                var slot = skeleton.slots[i];\n                var slotAttachment = slot.getAttachment();\n                if (slotAttachment && slotIndex < oldSkin.attachments.length) {\n                    var dictionary = oldSkin.attachments[slotIndex];\n                    for (var key in dictionary) {\n                        var skinAttachment = dictionary[key];\n                        if (slotAttachment == skinAttachment) {\n                            var attachment = this.getAttachment(slotIndex, key);\n                            if (attachment != null)\n                                slot.setAttachment(attachment);\n                            break;\n                        }\n                    }\n                }\n                slotIndex++;\n            }\n        };\n        return Skin;\n    }());\n    spine.Skin = Skin;\n})(spine || (spine = {}));\nvar spine;\n(function (spine) {\n    var Slot = (function () {\n        function Slot(data, bone) {\n            this.attachmentVertices = new Array();\n            if (data == null)\n                throw new Error(\"data cannot be null.\");\n            if (bone == null)\n                throw new Error(\"bone cannot be null.\");\n            this.data = data;\n            this.bone = bone;\n            this.color = new spine.Color();\n            this.darkColor = data.darkColor == null ? null : new spine.Color();\n            this.setToSetupPose();\n        }\n        Slot.prototype.getAttachment = function () {\n            return this.attachment;\n        };\n        Slot.prototype.setAttachment = function (attachment) {\n            if (this.attachment == attachment)\n                return;\n            this.attachment = attachment;\n            this.attachmentTime = this.bone.skeleton.time;\n            this.attachmentVertices.length = 0;\n        };\n        Slot.prototype.setAttachmentTime = function (time) {\n            this.attachmentTime = this.bone.skeleton.time - time;\n        };\n        Slot.prototype.getAttachmentTime = function () {\n            return this.bone.skeleton.time - this.attachmentTime;\n        };\n        Slot.prototype.setToSetupPose = function () {\n            this.color.setFromColor(this.data.color);\n            if (this.darkColor != null)\n                this.darkColor.setFromColor(this.data.darkColor);\n            if (this.data.attachmentName == null)\n                this.attachment = null;\n            else {\n                this.attachment = null;\n                this.setAttachment(this.bone.skeleton.getAttachment(this.data.index, this.data.attachmentName));\n            }\n        };\n        return Slot;\n    }());\n    spine.Slot = Slot;\n})(spine || (spine = {}));\nvar spine;\n(function (spine) {\n    var SlotData = (function () {\n        function SlotData(index, name, boneData) {\n            this.color = new spine.Color(1, 1, 1, 1);\n            if (index < 0)\n                throw new Error(\"index must be >= 0.\");\n            if (name == null)\n                throw new Error(\"name cannot be null.\");\n            if (boneData == null)\n                throw new Error(\"boneData cannot be null.\");\n            this.index = index;\n            this.name = name;\n            this.boneData = boneData;\n        }\n        return SlotData;\n    }());\n    spine.SlotData = SlotData;\n})(spine || (spine = {}));\nvar spine;\n(function (spine) {\n    var Texture = (function () {\n        function Texture(image) {\n            this._image = image;\n        }\n        Texture.prototype.getImage = function () {\n            return this._image;\n        };\n        Texture.filterFromString = function (text) {\n            switch (text.toLowerCase()) {\n                case \"nearest\": return TextureFilter.Nearest;\n                case \"linear\": return TextureFilter.Linear;\n                case \"mipmap\": return TextureFilter.MipMap;\n                case \"mipmapnearestnearest\": return TextureFilter.MipMapNearestNearest;\n                case \"mipmaplinearnearest\": return TextureFilter.MipMapLinearNearest;\n                case \"mipmapnearestlinear\": return TextureFilter.MipMapNearestLinear;\n                case \"mipmaplinearlinear\": return TextureFilter.MipMapLinearLinear;\n                default: throw new Error(\"Unknown texture filter \" + text);\n            }\n        };\n        Texture.wrapFromString = function (text) {\n            switch (text.toLowerCase()) {\n                case \"mirroredtepeat\": return TextureWrap.MirroredRepeat;\n                case \"clamptoedge\": return TextureWrap.ClampToEdge;\n                case \"repeat\": return TextureWrap.Repeat;\n                default: throw new Error(\"Unknown texture wrap \" + text);\n            }\n        };\n        return Texture;\n    }());\n    spine.Texture = Texture;\n    var TextureFilter;\n    (function (TextureFilter) {\n        TextureFilter[TextureFilter[\"Nearest\"] = 9728] = \"Nearest\";\n        TextureFilter[TextureFilter[\"Linear\"] = 9729] = \"Linear\";\n        TextureFilter[TextureFilter[\"MipMap\"] = 9987] = \"MipMap\";\n        TextureFilter[TextureFilter[\"MipMapNearestNearest\"] = 9984] = \"MipMapNearestNearest\";\n        TextureFilter[TextureFilter[\"MipMapLinearNearest\"] = 9985] = \"MipMapLinearNearest\";\n        TextureFilter[TextureFilter[\"MipMapNearestLinear\"] = 9986] = \"MipMapNearestLinear\";\n        TextureFilter[TextureFilter[\"MipMapLinearLinear\"] = 9987] = \"MipMapLinearLinear\";\n    })(TextureFilter = spine.TextureFilter || (spine.TextureFilter = {}));\n    var TextureWrap;\n    (function (TextureWrap) {\n        TextureWrap[TextureWrap[\"MirroredRepeat\"] = 33648] = \"MirroredRepeat\";\n        TextureWrap[TextureWrap[\"ClampToEdge\"] = 33071] = \"ClampToEdge\";\n        TextureWrap[TextureWrap[\"Repeat\"] = 10497] = \"Repeat\";\n    })(TextureWrap = spine.TextureWrap || (spine.TextureWrap = {}));\n    var TextureRegion = (function () {\n        function TextureRegion() {\n            this.u = 0;\n            this.v = 0;\n            this.u2 = 0;\n            this.v2 = 0;\n            this.width = 0;\n            this.height = 0;\n            this.rotate = false;\n            this.offsetX = 0;\n            this.offsetY = 0;\n            this.originalWidth = 0;\n            this.originalHeight = 0;\n        }\n        return TextureRegion;\n    }());\n    spine.TextureRegion = TextureRegion;\n    var FakeTexture = (function (_super) {\n        __extends(FakeTexture, _super);\n        function FakeTexture() {\n            return _super !== null && _super.apply(this, arguments) || this;\n        }\n        FakeTexture.prototype.setFilters = function (minFilter, magFilter) { };\n        FakeTexture.prototype.setWraps = function (uWrap, vWrap) { };\n        FakeTexture.prototype.dispose = function () { };\n        return FakeTexture;\n    }(Texture));\n    spine.FakeTexture = FakeTexture;\n})(spine || (spine = {}));\nvar spine;\n(function (spine) {\n    var TextureAtlas = (function () {\n        function TextureAtlas(atlasText, textureLoader) {\n            this.pages = new Array();\n            this.regions = new Array();\n            this.load(atlasText, textureLoader);\n        }\n        TextureAtlas.prototype.load = function (atlasText, textureLoader) {\n            if (textureLoader == null)\n                throw new Error(\"textureLoader cannot be null.\");\n            var reader = new TextureAtlasReader(atlasText);\n            var tuple = new Array(4);\n            var page = null;\n            while (true) {\n                var line = reader.readLine();\n                if (line == null)\n                    break;\n                line = line.trim();\n                if (line.length == 0)\n                    page = null;\n                else if (!page) {\n                    page = new TextureAtlasPage();\n                    page.name = line;\n                    if (reader.readTuple(tuple) == 2) {\n                        page.width = parseInt(tuple[0]);\n                        page.height = parseInt(tuple[1]);\n                        reader.readTuple(tuple);\n                    }\n                    reader.readTuple(tuple);\n                    page.minFilter = spine.Texture.filterFromString(tuple[0]);\n                    page.magFilter = spine.Texture.filterFromString(tuple[1]);\n                    var direction = reader.readValue();\n                    page.uWrap = spine.TextureWrap.ClampToEdge;\n                    page.vWrap = spine.TextureWrap.ClampToEdge;\n                    if (direction == \"x\")\n                        page.uWrap = spine.TextureWrap.Repeat;\n                    else if (direction == \"y\")\n                        page.vWrap = spine.TextureWrap.Repeat;\n                    else if (direction == \"xy\")\n                        page.uWrap = page.vWrap = spine.TextureWrap.Repeat;\n                    page.texture = textureLoader(line);\n                    page.texture.setFilters(page.minFilter, page.magFilter);\n                    page.texture.setWraps(page.uWrap, page.vWrap);\n                    page.width = page.texture.getImage().width;\n                    page.height = page.texture.getImage().height;\n                    this.pages.push(page);\n                }\n                else {\n                    var region = new TextureAtlasRegion();\n                    region.name = line;\n                    region.page = page;\n                    region.rotate = reader.readValue() == \"true\";\n                    reader.readTuple(tuple);\n                    var x = parseInt(tuple[0]);\n                    var y = parseInt(tuple[1]);\n                    reader.readTuple(tuple);\n                    var width = parseInt(tuple[0]);\n                    var height = parseInt(tuple[1]);\n                    region.u = x / page.width;\n                    region.v = y / page.height;\n                    if (region.rotate) {\n                        region.u2 = (x + height) / page.width;\n                        region.v2 = (y + width) / page.height;\n                    }\n                    else {\n                        region.u2 = (x + width) / page.width;\n                        region.v2 = (y + height) / page.height;\n                    }\n                    region.x = x;\n                    region.y = y;\n                    region.width = Math.abs(width);\n                    region.height = Math.abs(height);\n                    if (reader.readTuple(tuple) == 4) {\n                        if (reader.readTuple(tuple) == 4) {\n                            reader.readTuple(tuple);\n                        }\n                    }\n                    region.originalWidth = parseInt(tuple[0]);\n                    region.originalHeight = parseInt(tuple[1]);\n                    reader.readTuple(tuple);\n                    region.offsetX = parseInt(tuple[0]);\n                    region.offsetY = parseInt(tuple[1]);\n                    region.index = parseInt(reader.readValue());\n                    region.texture = page.texture;\n                    this.regions.push(region);\n                }\n            }\n        };\n        TextureAtlas.prototype.findRegion = function (name) {\n            for (var i = 0; i < this.regions.length; i++) {\n                if (this.regions[i].name == name) {\n                    return this.regions[i];\n                }\n            }\n            return null;\n        };\n        TextureAtlas.prototype.dispose = function () {\n            for (var i = 0; i < this.pages.length; i++) {\n                this.pages[i].texture.dispose();\n            }\n        };\n        return TextureAtlas;\n    }());\n    spine.TextureAtlas = TextureAtlas;\n    var TextureAtlasReader = (function () {\n        function TextureAtlasReader(text) {\n            this.index = 0;\n            this.lines = text.split(/\\r\\n|\\r|\\n/);\n        }\n        TextureAtlasReader.prototype.readLine = function () {\n            if (this.index >= this.lines.length)\n                return null;\n            return this.lines[this.index++];\n        };\n        TextureAtlasReader.prototype.readValue = function () {\n            var line = this.readLine();\n            var colon = line.indexOf(\":\");\n            if (colon == -1)\n                throw new Error(\"Invalid line: \" + line);\n            return line.substring(colon + 1).trim();\n        };\n        TextureAtlasReader.prototype.readTuple = function (tuple) {\n            var line = this.readLine();\n            var colon = line.indexOf(\":\");\n            if (colon == -1)\n                throw new Error(\"Invalid line: \" + line);\n            var i = 0, lastMatch = colon + 1;\n            for (; i < 3; i++) {\n                var comma = line.indexOf(\",\", lastMatch);\n                if (comma == -1)\n                    break;\n                tuple[i] = line.substr(lastMatch, comma - lastMatch).trim();\n                lastMatch = comma + 1;\n            }\n            tuple[i] = line.substring(lastMatch).trim();\n            return i + 1;\n        };\n        return TextureAtlasReader;\n    }());\n    var TextureAtlasPage = (function () {\n        function TextureAtlasPage() {\n        }\n        return TextureAtlasPage;\n    }());\n    spine.TextureAtlasPage = TextureAtlasPage;\n    var TextureAtlasRegion = (function (_super) {\n        __extends(TextureAtlasRegion, _super);\n        function TextureAtlasRegion() {\n            return _super !== null && _super.apply(this, arguments) || this;\n        }\n        return TextureAtlasRegion;\n    }(spine.TextureRegion));\n    spine.TextureAtlasRegion = TextureAtlasRegion;\n})(spine || (spine = {}));\nvar spine;\n(function (spine) {\n    var TransformConstraint = (function () {\n        function TransformConstraint(data, skeleton) {\n            this.rotateMix = 0;\n            this.translateMix = 0;\n            this.scaleMix = 0;\n            this.shearMix = 0;\n            this.temp = new spine.Vector2();\n            if (data == null)\n                throw new Error(\"data cannot be null.\");\n            if (skeleton == null)\n                throw new Error(\"skeleton cannot be null.\");\n            this.data = data;\n            this.rotateMix = data.rotateMix;\n            this.translateMix = data.translateMix;\n            this.scaleMix = data.scaleMix;\n            this.shearMix = data.shearMix;\n            this.bones = new Array();\n            for (var i = 0; i < data.bones.length; i++)\n                this.bones.push(skeleton.findBone(data.bones[i].name));\n            this.target = skeleton.findBone(data.target.name);\n        }\n        TransformConstraint.prototype.apply = function () {\n            this.update();\n        };\n        TransformConstraint.prototype.update = function () {\n            if (this.data.local) {\n                if (this.data.relative)\n                    this.applyRelativeLocal();\n                else\n                    this.applyAbsoluteLocal();\n            }\n            else {\n                if (this.data.relative)\n                    this.applyRelativeWorld();\n                else\n                    this.applyAbsoluteWorld();\n            }\n        };\n        TransformConstraint.prototype.applyAbsoluteWorld = function () {\n            var rotateMix = this.rotateMix, translateMix = this.translateMix, scaleMix = this.scaleMix, shearMix = this.shearMix;\n            var target = this.target;\n            var ta = target.a, tb = target.b, tc = target.c, td = target.d;\n            var degRadReflect = ta * td - tb * tc > 0 ? spine.MathUtils.degRad : -spine.MathUtils.degRad;\n            var offsetRotation = this.data.offsetRotation * degRadReflect;\n            var offsetShearY = this.data.offsetShearY * degRadReflect;\n            var bones = this.bones;\n            for (var i = 0, n = bones.length; i < n; i++) {\n                var bone = bones[i];\n                var modified = false;\n                if (rotateMix != 0) {\n                    var a = bone.a, b = bone.b, c = bone.c, d = bone.d;\n                    var r = Math.atan2(tc, ta) - Math.atan2(c, a) + offsetRotation;\n                    if (r > spine.MathUtils.PI)\n                        r -= spine.MathUtils.PI2;\n                    else if (r < -spine.MathUtils.PI)\n                        r += spine.MathUtils.PI2;\n                    r *= rotateMix;\n                    var cos = Math.cos(r), sin = Math.sin(r);\n                    bone.a = cos * a - sin * c;\n                    bone.b = cos * b - sin * d;\n                    bone.c = sin * a + cos * c;\n                    bone.d = sin * b + cos * d;\n                    modified = true;\n                }\n                if (translateMix != 0) {\n                    var temp = this.temp;\n                    target.localToWorld(temp.set(this.data.offsetX, this.data.offsetY));\n                    bone.worldX += (temp.x - bone.worldX) * translateMix;\n                    bone.worldY += (temp.y - bone.worldY) * translateMix;\n                    modified = true;\n                }\n                if (scaleMix > 0) {\n                    var s = Math.sqrt(bone.a * bone.a + bone.c * bone.c);\n                    var ts = Math.sqrt(ta * ta + tc * tc);\n                    if (s > 0.00001)\n                        s = (s + (ts - s + this.data.offsetScaleX) * scaleMix) / s;\n                    bone.a *= s;\n                    bone.c *= s;\n                    s = Math.sqrt(bone.b * bone.b + bone.d * bone.d);\n                    ts = Math.sqrt(tb * tb + td * td);\n                    if (s > 0.00001)\n                        s = (s + (ts - s + this.data.offsetScaleY) * scaleMix) / s;\n                    bone.b *= s;\n                    bone.d *= s;\n                    modified = true;\n                }\n                if (shearMix > 0) {\n                    var b = bone.b, d = bone.d;\n                    var by = Math.atan2(d, b);\n                    var r = Math.atan2(td, tb) - Math.atan2(tc, ta) - (by - Math.atan2(bone.c, bone.a));\n                    if (r > spine.MathUtils.PI)\n                        r -= spine.MathUtils.PI2;\n                    else if (r < -spine.MathUtils.PI)\n                        r += spine.MathUtils.PI2;\n                    r = by + (r + offsetShearY) * shearMix;\n                    var s = Math.sqrt(b * b + d * d);\n                    bone.b = Math.cos(r) * s;\n                    bone.d = Math.sin(r) * s;\n                    modified = true;\n                }\n                if (modified)\n                    bone.appliedValid = false;\n            }\n        };\n        TransformConstraint.prototype.applyRelativeWorld = function () {\n            var rotateMix = this.rotateMix, translateMix = this.translateMix, scaleMix = this.scaleMix, shearMix = this.shearMix;\n            var target = this.target;\n            var ta = target.a, tb = target.b, tc = target.c, td = target.d;\n            var degRadReflect = ta * td - tb * tc > 0 ? spine.MathUtils.degRad : -spine.MathUtils.degRad;\n            var offsetRotation = this.data.offsetRotation * degRadReflect, offsetShearY = this.data.offsetShearY * degRadReflect;\n            var bones = this.bones;\n            for (var i = 0, n = bones.length; i < n; i++) {\n                var bone = bones[i];\n                var modified = false;\n                if (rotateMix != 0) {\n                    var a = bone.a, b = bone.b, c = bone.c, d = bone.d;\n                    var r = Math.atan2(tc, ta) + offsetRotation;\n                    if (r > spine.MathUtils.PI)\n                        r -= spine.MathUtils.PI2;\n                    else if (r < -spine.MathUtils.PI)\n                        r += spine.MathUtils.PI2;\n                    r *= rotateMix;\n                    var cos = Math.cos(r), sin = Math.sin(r);\n                    bone.a = cos * a - sin * c;\n                    bone.b = cos * b - sin * d;\n                    bone.c = sin * a + cos * c;\n                    bone.d = sin * b + cos * d;\n                    modified = true;\n                }\n                if (translateMix != 0) {\n                    var temp = this.temp;\n                    target.localToWorld(temp.set(this.data.offsetX, this.data.offsetY));\n                    bone.worldX += temp.x * translateMix;\n                    bone.worldY += temp.y * translateMix;\n                    modified = true;\n                }\n                if (scaleMix > 0) {\n                    var s = (Math.sqrt(ta * ta + tc * tc) - 1 + this.data.offsetScaleX) * scaleMix + 1;\n                    bone.a *= s;\n                    bone.c *= s;\n                    s = (Math.sqrt(tb * tb + td * td) - 1 + this.data.offsetScaleY) * scaleMix + 1;\n                    bone.b *= s;\n                    bone.d *= s;\n                    modified = true;\n                }\n                if (shearMix > 0) {\n                    var r = Math.atan2(td, tb) - Math.atan2(tc, ta);\n                    if (r > spine.MathUtils.PI)\n                        r -= spine.MathUtils.PI2;\n                    else if (r < -spine.MathUtils.PI)\n                        r += spine.MathUtils.PI2;\n                    var b = bone.b, d = bone.d;\n                    r = Math.atan2(d, b) + (r - spine.MathUtils.PI / 2 + offsetShearY) * shearMix;\n                    var s = Math.sqrt(b * b + d * d);\n                    bone.b = Math.cos(r) * s;\n                    bone.d = Math.sin(r) * s;\n                    modified = true;\n                }\n                if (modified)\n                    bone.appliedValid = false;\n            }\n        };\n        TransformConstraint.prototype.applyAbsoluteLocal = function () {\n            var rotateMix = this.rotateMix, translateMix = this.translateMix, scaleMix = this.scaleMix, shearMix = this.shearMix;\n            var target = this.target;\n            if (!target.appliedValid)\n                target.updateAppliedTransform();\n            var bones = this.bones;\n            for (var i = 0, n = bones.length; i < n; i++) {\n                var bone = bones[i];\n                if (!bone.appliedValid)\n                    bone.updateAppliedTransform();\n                var rotation = bone.arotation;\n                if (rotateMix != 0) {\n                    var r = target.arotation - rotation + this.data.offsetRotation;\n                    r -= (16384 - ((16384.499999999996 - r / 360) | 0)) * 360;\n                    rotation += r * rotateMix;\n                }\n                var x = bone.ax, y = bone.ay;\n                if (translateMix != 0) {\n                    x += (target.ax - x + this.data.offsetX) * translateMix;\n                    y += (target.ay - y + this.data.offsetY) * translateMix;\n                }\n                var scaleX = bone.ascaleX, scaleY = bone.ascaleY;\n                if (scaleMix != 0) {\n                    if (scaleX > 0.00001)\n                        scaleX = (scaleX + (target.ascaleX - scaleX + this.data.offsetScaleX) * scaleMix) / scaleX;\n                    if (scaleY > 0.00001)\n                        scaleY = (scaleY + (target.ascaleY - scaleY + this.data.offsetScaleY) * scaleMix) / scaleY;\n                }\n                var shearY = bone.ashearY;\n                if (shearMix != 0) {\n                    var r = target.ashearY - shearY + this.data.offsetShearY;\n                    r -= (16384 - ((16384.499999999996 - r / 360) | 0)) * 360;\n                    bone.shearY += r * shearMix;\n                }\n                bone.updateWorldTransformWith(x, y, rotation, scaleX, scaleY, bone.ashearX, shearY);\n            }\n        };\n        TransformConstraint.prototype.applyRelativeLocal = function () {\n            var rotateMix = this.rotateMix, translateMix = this.translateMix, scaleMix = this.scaleMix, shearMix = this.shearMix;\n            var target = this.target;\n            if (!target.appliedValid)\n                target.updateAppliedTransform();\n            var bones = this.bones;\n            for (var i = 0, n = bones.length; i < n; i++) {\n                var bone = bones[i];\n                if (!bone.appliedValid)\n                    bone.updateAppliedTransform();\n                var rotation = bone.arotation;\n                if (rotateMix != 0)\n                    rotation += (target.arotation + this.data.offsetRotation) * rotateMix;\n                var x = bone.ax, y = bone.ay;\n                if (translateMix != 0) {\n                    x += (target.ax + this.data.offsetX) * translateMix;\n                    y += (target.ay + this.data.offsetY) * translateMix;\n                }\n                var scaleX = bone.ascaleX, scaleY = bone.ascaleY;\n                if (scaleMix != 0) {\n                    if (scaleX > 0.00001)\n                        scaleX *= ((target.ascaleX - 1 + this.data.offsetScaleX) * scaleMix) + 1;\n                    if (scaleY > 0.00001)\n                        scaleY *= ((target.ascaleY - 1 + this.data.offsetScaleY) * scaleMix) + 1;\n                }\n                var shearY = bone.ashearY;\n                if (shearMix != 0)\n                    shearY += (target.ashearY + this.data.offsetShearY) * shearMix;\n                bone.updateWorldTransformWith(x, y, rotation, scaleX, scaleY, bone.ashearX, shearY);\n            }\n        };\n        TransformConstraint.prototype.getOrder = function () {\n            return this.data.order;\n        };\n        return TransformConstraint;\n    }());\n    spine.TransformConstraint = TransformConstraint;\n})(spine || (spine = {}));\nvar spine;\n(function (spine) {\n    var TransformConstraintData = (function () {\n        function TransformConstraintData(name) {\n            this.order = 0;\n            this.bones = new Array();\n            this.rotateMix = 0;\n            this.translateMix = 0;\n            this.scaleMix = 0;\n            this.shearMix = 0;\n            this.offsetRotation = 0;\n            this.offsetX = 0;\n            this.offsetY = 0;\n            this.offsetScaleX = 0;\n            this.offsetScaleY = 0;\n            this.offsetShearY = 0;\n            this.relative = false;\n            this.local = false;\n            if (name == null)\n                throw new Error(\"name cannot be null.\");\n            this.name = name;\n        }\n        return TransformConstraintData;\n    }());\n    spine.TransformConstraintData = TransformConstraintData;\n})(spine || (spine = {}));\nvar spine;\n(function (spine) {\n    var Triangulator = (function () {\n        function Triangulator() {\n            this.convexPolygons = new Array();\n            this.convexPolygonsIndices = new Array();\n            this.indicesArray = new Array();\n            this.isConcaveArray = new Array();\n            this.triangles = new Array();\n            this.polygonPool = new spine.Pool(function () {\n                return new Array();\n            });\n            this.polygonIndicesPool = new spine.Pool(function () {\n                return new Array();\n            });\n        }\n        Triangulator.prototype.triangulate = function (verticesArray) {\n            var vertices = verticesArray;\n            var vertexCount = verticesArray.length >> 1;\n            var indices = this.indicesArray;\n            indices.length = 0;\n            for (var i = 0; i < vertexCount; i++)\n                indices[i] = i;\n            var isConcave = this.isConcaveArray;\n            isConcave.length = 0;\n            for (var i = 0, n = vertexCount; i < n; ++i)\n                isConcave[i] = Triangulator.isConcave(i, vertexCount, vertices, indices);\n            var triangles = this.triangles;\n            triangles.length = 0;\n            while (vertexCount > 3) {\n                var previous = vertexCount - 1, i = 0, next = 1;\n                while (true) {\n                    outer: if (!isConcave[i]) {\n                        var p1 = indices[previous] << 1, p2 = indices[i] << 1, p3 = indices[next] << 1;\n                        var p1x = vertices[p1], p1y = vertices[p1 + 1];\n                        var p2x = vertices[p2], p2y = vertices[p2 + 1];\n                        var p3x = vertices[p3], p3y = vertices[p3 + 1];\n                        for (var ii = (next + 1) % vertexCount; ii != previous; ii = (ii + 1) % vertexCount) {\n                            if (!isConcave[ii])\n                                continue;\n                            var v = indices[ii] << 1;\n                            var vx = vertices[v], vy = vertices[v + 1];\n                            if (Triangulator.positiveArea(p3x, p3y, p1x, p1y, vx, vy)) {\n                                if (Triangulator.positiveArea(p1x, p1y, p2x, p2y, vx, vy)) {\n                                    if (Triangulator.positiveArea(p2x, p2y, p3x, p3y, vx, vy))\n                                        break outer;\n                                }\n                            }\n                        }\n                        break;\n                    }\n                    if (next == 0) {\n                        do {\n                            if (!isConcave[i])\n                                break;\n                            i--;\n                        } while (i > 0);\n                        break;\n                    }\n                    previous = i;\n                    i = next;\n                    next = (next + 1) % vertexCount;\n                }\n                triangles.push(indices[(vertexCount + i - 1) % vertexCount]);\n                triangles.push(indices[i]);\n                triangles.push(indices[(i + 1) % vertexCount]);\n                indices.splice(i, 1);\n                isConcave.splice(i, 1);\n                vertexCount--;\n                var previousIndex = (vertexCount + i - 1) % vertexCount;\n                var nextIndex = i == vertexCount ? 0 : i;\n                isConcave[previousIndex] = Triangulator.isConcave(previousIndex, vertexCount, vertices, indices);\n                isConcave[nextIndex] = Triangulator.isConcave(nextIndex, vertexCount, vertices, indices);\n            }\n            if (vertexCount == 3) {\n                triangles.push(indices[2]);\n                triangles.push(indices[0]);\n                triangles.push(indices[1]);\n            }\n            return triangles;\n        };\n        Triangulator.prototype.decompose = function (verticesArray, triangles) {\n            var vertices = verticesArray;\n            var convexPolygons = this.convexPolygons;\n            this.polygonPool.freeAll(convexPolygons);\n            convexPolygons.length = 0;\n            var convexPolygonsIndices = this.convexPolygonsIndices;\n            this.polygonIndicesPool.freeAll(convexPolygonsIndices);\n            convexPolygonsIndices.length = 0;\n            var polygonIndices = this.polygonIndicesPool.obtain();\n            polygonIndices.length = 0;\n            var polygon = this.polygonPool.obtain();\n            polygon.length = 0;\n            var fanBaseIndex = -1, lastWinding = 0;\n            for (var i = 0, n = triangles.length; i < n; i += 3) {\n                var t1 = triangles[i] << 1, t2 = triangles[i + 1] << 1, t3 = triangles[i + 2] << 1;\n                var x1 = vertices[t1], y1 = vertices[t1 + 1];\n                var x2 = vertices[t2], y2 = vertices[t2 + 1];\n                var x3 = vertices[t3], y3 = vertices[t3 + 1];\n                var merged = false;\n                if (fanBaseIndex == t1) {\n                    var o = polygon.length - 4;\n                    var winding1 = Triangulator.winding(polygon[o], polygon[o + 1], polygon[o + 2], polygon[o + 3], x3, y3);\n                    var winding2 = Triangulator.winding(x3, y3, polygon[0], polygon[1], polygon[2], polygon[3]);\n                    if (winding1 == lastWinding && winding2 == lastWinding) {\n                        polygon.push(x3);\n                        polygon.push(y3);\n                        polygonIndices.push(t3);\n                        merged = true;\n                    }\n                }\n                if (!merged) {\n                    if (polygon.length > 0) {\n                        convexPolygons.push(polygon);\n                        convexPolygonsIndices.push(polygonIndices);\n                    }\n                    else {\n                        this.polygonPool.free(polygon);\n                        this.polygonIndicesPool.free(polygonIndices);\n                    }\n                    polygon = this.polygonPool.obtain();\n                    polygon.length = 0;\n                    polygon.push(x1);\n                    polygon.push(y1);\n                    polygon.push(x2);\n                    polygon.push(y2);\n                    polygon.push(x3);\n                    polygon.push(y3);\n                    polygonIndices = this.polygonIndicesPool.obtain();\n                    polygonIndices.length = 0;\n                    polygonIndices.push(t1);\n                    polygonIndices.push(t2);\n                    polygonIndices.push(t3);\n                    lastWinding = Triangulator.winding(x1, y1, x2, y2, x3, y3);\n                    fanBaseIndex = t1;\n                }\n            }\n            if (polygon.length > 0) {\n                convexPolygons.push(polygon);\n                convexPolygonsIndices.push(polygonIndices);\n            }\n            for (var i = 0, n = convexPolygons.length; i < n; i++) {\n                polygonIndices = convexPolygonsIndices[i];\n                if (polygonIndices.length == 0)\n                    continue;\n                var firstIndex = polygonIndices[0];\n                var lastIndex = polygonIndices[polygonIndices.length - 1];\n                polygon = convexPolygons[i];\n                var o = polygon.length - 4;\n                var prevPrevX = polygon[o], prevPrevY = polygon[o + 1];\n                var prevX = polygon[o + 2], prevY = polygon[o + 3];\n                var firstX = polygon[0], firstY = polygon[1];\n                var secondX = polygon[2], secondY = polygon[3];\n                var winding = Triangulator.winding(prevPrevX, prevPrevY, prevX, prevY, firstX, firstY);\n                for (var ii = 0; ii < n; ii++) {\n                    if (ii == i)\n                        continue;\n                    var otherIndices = convexPolygonsIndices[ii];\n                    if (otherIndices.length != 3)\n                        continue;\n                    var otherFirstIndex = otherIndices[0];\n                    var otherSecondIndex = otherIndices[1];\n                    var otherLastIndex = otherIndices[2];\n                    var otherPoly = convexPolygons[ii];\n                    var x3 = otherPoly[otherPoly.length - 2], y3 = otherPoly[otherPoly.length - 1];\n                    if (otherFirstIndex != firstIndex || otherSecondIndex != lastIndex)\n                        continue;\n                    var winding1 = Triangulator.winding(prevPrevX, prevPrevY, prevX, prevY, x3, y3);\n                    var winding2 = Triangulator.winding(x3, y3, firstX, firstY, secondX, secondY);\n                    if (winding1 == winding && winding2 == winding) {\n                        otherPoly.length = 0;\n                        otherIndices.length = 0;\n                        polygon.push(x3);\n                        polygon.push(y3);\n                        polygonIndices.push(otherLastIndex);\n                        prevPrevX = prevX;\n                        prevPrevY = prevY;\n                        prevX = x3;\n                        prevY = y3;\n                        ii = 0;\n                    }\n                }\n            }\n            for (var i = convexPolygons.length - 1; i >= 0; i--) {\n                polygon = convexPolygons[i];\n                if (polygon.length == 0) {\n                    convexPolygons.splice(i, 1);\n                    this.polygonPool.free(polygon);\n                    polygonIndices = convexPolygonsIndices[i];\n                    convexPolygonsIndices.splice(i, 1);\n                    this.polygonIndicesPool.free(polygonIndices);\n                }\n            }\n            return convexPolygons;\n        };\n        Triangulator.isConcave = function (index, vertexCount, vertices, indices) {\n            var previous = indices[(vertexCount + index - 1) % vertexCount] << 1;\n            var current = indices[index] << 1;\n            var next = indices[(index + 1) % vertexCount] << 1;\n            return !this.positiveArea(vertices[previous], vertices[previous + 1], vertices[current], vertices[current + 1], vertices[next], vertices[next + 1]);\n        };\n        Triangulator.positiveArea = function (p1x, p1y, p2x, p2y, p3x, p3y) {\n            return p1x * (p3y - p2y) + p2x * (p1y - p3y) + p3x * (p2y - p1y) >= 0;\n        };\n        Triangulator.winding = function (p1x, p1y, p2x, p2y, p3x, p3y) {\n            var px = p2x - p1x, py = p2y - p1y;\n            return p3x * py - p3y * px + px * p1y - p1x * py >= 0 ? 1 : -1;\n        };\n        return Triangulator;\n    }());\n    spine.Triangulator = Triangulator;\n})(spine || (spine = {}));\nvar spine;\n(function (spine) {\n    var IntSet = (function () {\n        function IntSet() {\n            this.array = new Array();\n        }\n        IntSet.prototype.add = function (value) {\n            var contains = this.contains(value);\n            this.array[value | 0] = value | 0;\n            return !contains;\n        };\n        IntSet.prototype.contains = function (value) {\n            return this.array[value | 0] != undefined;\n        };\n        IntSet.prototype.remove = function (value) {\n            this.array[value | 0] = undefined;\n        };\n        IntSet.prototype.clear = function () {\n            this.array.length = 0;\n        };\n        return IntSet;\n    }());\n    spine.IntSet = IntSet;\n    var Color = (function () {\n        function Color(r, g, b, a) {\n            if (r === void 0) { r = 0; }\n            if (g === void 0) { g = 0; }\n            if (b === void 0) { b = 0; }\n            if (a === void 0) { a = 0; }\n            this.r = r;\n            this.g = g;\n            this.b = b;\n            this.a = a;\n        }\n        Color.prototype.set = function (r, g, b, a) {\n            this.r = r;\n            this.g = g;\n            this.b = b;\n            this.a = a;\n            this.clamp();\n            return this;\n        };\n        Color.prototype.setFromColor = function (c) {\n            this.r = c.r;\n            this.g = c.g;\n            this.b = c.b;\n            this.a = c.a;\n            return this;\n        };\n        Color.prototype.setFromString = function (hex) {\n            hex = hex.charAt(0) == '#' ? hex.substr(1) : hex;\n            this.r = parseInt(hex.substr(0, 2), 16) / 255.0;\n            this.g = parseInt(hex.substr(2, 2), 16) / 255.0;\n            this.b = parseInt(hex.substr(4, 2), 16) / 255.0;\n            this.a = (hex.length != 8 ? 255 : parseInt(hex.substr(6, 2), 16)) / 255.0;\n            return this;\n        };\n        Color.prototype.add = function (r, g, b, a) {\n            this.r += r;\n            this.g += g;\n            this.b += b;\n            this.a += a;\n            this.clamp();\n            return this;\n        };\n        Color.prototype.clamp = function () {\n            if (this.r < 0)\n                this.r = 0;\n            else if (this.r > 1)\n                this.r = 1;\n            if (this.g < 0)\n                this.g = 0;\n            else if (this.g > 1)\n                this.g = 1;\n            if (this.b < 0)\n                this.b = 0;\n            else if (this.b > 1)\n                this.b = 1;\n            if (this.a < 0)\n                this.a = 0;\n            else if (this.a > 1)\n                this.a = 1;\n            return this;\n        };\n        Color.WHITE = new Color(1, 1, 1, 1);\n        Color.RED = new Color(1, 0, 0, 1);\n        Color.GREEN = new Color(0, 1, 0, 1);\n        Color.BLUE = new Color(0, 0, 1, 1);\n        Color.MAGENTA = new Color(1, 0, 1, 1);\n        return Color;\n    }());\n    spine.Color = Color;\n    var MathUtils = (function () {\n        function MathUtils() {\n        }\n        MathUtils.clamp = function (value, min, max) {\n            if (value < min)\n                return min;\n            if (value > max)\n                return max;\n            return value;\n        };\n        MathUtils.cosDeg = function (degrees) {\n            return Math.cos(degrees * MathUtils.degRad);\n        };\n        MathUtils.sinDeg = function (degrees) {\n            return Math.sin(degrees * MathUtils.degRad);\n        };\n        MathUtils.signum = function (value) {\n            return value > 0 ? 1 : value < 0 ? -1 : 0;\n        };\n        MathUtils.toInt = function (x) {\n            return x > 0 ? Math.floor(x) : Math.ceil(x);\n        };\n        MathUtils.cbrt = function (x) {\n            var y = Math.pow(Math.abs(x), 1 / 3);\n            return x < 0 ? -y : y;\n        };\n        MathUtils.randomTriangular = function (min, max) {\n            return MathUtils.randomTriangularWith(min, max, (min + max) * 0.5);\n        };\n        MathUtils.randomTriangularWith = function (min, max, mode) {\n            var u = Math.random();\n            var d = max - min;\n            if (u <= (mode - min) / d)\n                return min + Math.sqrt(u * d * (mode - min));\n            return max - Math.sqrt((1 - u) * d * (max - mode));\n        };\n        MathUtils.PI = 3.1415927;\n        MathUtils.PI2 = MathUtils.PI * 2;\n        MathUtils.radiansToDegrees = 180 / MathUtils.PI;\n        MathUtils.radDeg = MathUtils.radiansToDegrees;\n        MathUtils.degreesToRadians = MathUtils.PI / 180;\n        MathUtils.degRad = MathUtils.degreesToRadians;\n        return MathUtils;\n    }());\n    spine.MathUtils = MathUtils;\n    var Interpolation = (function () {\n        function Interpolation() {\n        }\n        Interpolation.prototype.apply = function (start, end, a) {\n            return start + (end - start) * this.applyInternal(a);\n        };\n        return Interpolation;\n    }());\n    spine.Interpolation = Interpolation;\n    var Pow = (function (_super) {\n        __extends(Pow, _super);\n        function Pow(power) {\n            var _this = _super.call(this) || this;\n            _this.power = 2;\n            _this.power = power;\n            return _this;\n        }\n        Pow.prototype.applyInternal = function (a) {\n            if (a <= 0.5)\n                return Math.pow(a * 2, this.power) / 2;\n            return Math.pow((a - 1) * 2, this.power) / (this.power % 2 == 0 ? -2 : 2) + 1;\n        };\n        return Pow;\n    }(Interpolation));\n    spine.Pow = Pow;\n    var PowOut = (function (_super) {\n        __extends(PowOut, _super);\n        function PowOut(power) {\n            return _super.call(this, power) || this;\n        }\n        PowOut.prototype.applyInternal = function (a) {\n            return Math.pow(a - 1, this.power) * (this.power % 2 == 0 ? -1 : 1) + 1;\n        };\n        return PowOut;\n    }(Pow));\n    spine.PowOut = PowOut;\n    var Utils = (function () {\n        function Utils() {\n        }\n        Utils.arrayCopy = function (source, sourceStart, dest, destStart, numElements) {\n            for (var i = sourceStart, j = destStart; i < sourceStart + numElements; i++, j++) {\n                dest[j] = source[i];\n            }\n        };\n        Utils.setArraySize = function (array, size, value) {\n            if (value === void 0) { value = 0; }\n            var oldSize = array.length;\n            if (oldSize == size)\n                return array;\n            array.length = size;\n            if (oldSize < size) {\n                for (var i = oldSize; i < size; i++)\n                    array[i] = value;\n            }\n            return array;\n        };\n        Utils.ensureArrayCapacity = function (array, size, value) {\n            if (value === void 0) { value = 0; }\n            if (array.length >= size)\n                return array;\n            return Utils.setArraySize(array, size, value);\n        };\n        Utils.newArray = function (size, defaultValue) {\n            var array = new Array(size);\n            for (var i = 0; i < size; i++)\n                array[i] = defaultValue;\n            return array;\n        };\n        Utils.newFloatArray = function (size) {\n            if (Utils.SUPPORTS_TYPED_ARRAYS) {\n                return new Float32Array(size);\n            }\n            else {\n                var array = new Array(size);\n                for (var i = 0; i < array.length; i++)\n                    array[i] = 0;\n                return array;\n            }\n        };\n        Utils.newShortArray = function (size) {\n            if (Utils.SUPPORTS_TYPED_ARRAYS) {\n                return new Int16Array(size);\n            }\n            else {\n                var array = new Array(size);\n                for (var i = 0; i < array.length; i++)\n                    array[i] = 0;\n                return array;\n            }\n        };\n        Utils.toFloatArray = function (array) {\n            return Utils.SUPPORTS_TYPED_ARRAYS ? new Float32Array(array) : array;\n        };\n        Utils.toSinglePrecision = function (value) {\n            return Utils.SUPPORTS_TYPED_ARRAYS ? Math.fround(value) : value;\n        };\n        Utils.webkit602BugfixHelper = function (alpha, blend) {\n        };\n        Utils.SUPPORTS_TYPED_ARRAYS = typeof (Float32Array) !== \"undefined\";\n        return Utils;\n    }());\n    spine.Utils = Utils;\n    var DebugUtils = (function () {\n        function DebugUtils() {\n        }\n        DebugUtils.logBones = function (skeleton) {\n            for (var i = 0; i < skeleton.bones.length; i++) {\n                var bone = skeleton.bones[i];\n                console.log(bone.data.name + \", \" + bone.a + \", \" + bone.b + \", \" + bone.c + \", \" + bone.d + \", \" + bone.worldX + \", \" + bone.worldY);\n            }\n        };\n        return DebugUtils;\n    }());\n    spine.DebugUtils = DebugUtils;\n    var Pool = (function () {\n        function Pool(instantiator) {\n            this.items = new Array();\n            this.instantiator = instantiator;\n        }\n        Pool.prototype.obtain = function () {\n            return this.items.length > 0 ? this.items.pop() : this.instantiator();\n        };\n        Pool.prototype.free = function (item) {\n            if (item.reset)\n                item.reset();\n            this.items.push(item);\n        };\n        Pool.prototype.freeAll = function (items) {\n            for (var i = 0; i < items.length; i++) {\n                if (items[i].reset)\n                    items[i].reset();\n                this.items[i] = items[i];\n            }\n        };\n        Pool.prototype.clear = function () {\n            this.items.length = 0;\n        };\n        return Pool;\n    }());\n    spine.Pool = Pool;\n    var Vector2 = (function () {\n        function Vector2(x, y) {\n            if (x === void 0) { x = 0; }\n            if (y === void 0) { y = 0; }\n            this.x = x;\n            this.y = y;\n        }\n        Vector2.prototype.set = function (x, y) {\n            this.x = x;\n            this.y = y;\n            return this;\n        };\n        Vector2.prototype.length = function () {\n            var x = this.x;\n            var y = this.y;\n            return Math.sqrt(x * x + y * y);\n        };\n        Vector2.prototype.normalize = function () {\n            var len = this.length();\n            if (len != 0) {\n                this.x /= len;\n                this.y /= len;\n            }\n            return this;\n        };\n        return Vector2;\n    }());\n    spine.Vector2 = Vector2;\n    var TimeKeeper = (function () {\n        function TimeKeeper() {\n            this.maxDelta = 0.064;\n            this.framesPerSecond = 0;\n            this.delta = 0;\n            this.totalTime = 0;\n            this.lastTime = Date.now() / 1000;\n            this.frameCount = 0;\n            this.frameTime = 0;\n        }\n        TimeKeeper.prototype.update = function () {\n            var now = Date.now() / 1000;\n            this.delta = now - this.lastTime;\n            this.frameTime += this.delta;\n            this.totalTime += this.delta;\n            if (this.delta > this.maxDelta)\n                this.delta = this.maxDelta;\n            this.lastTime = now;\n            this.frameCount++;\n            if (this.frameTime > 1) {\n                this.framesPerSecond = this.frameCount / this.frameTime;\n                this.frameTime = 0;\n                this.frameCount = 0;\n            }\n        };\n        return TimeKeeper;\n    }());\n    spine.TimeKeeper = TimeKeeper;\n    var WindowedMean = (function () {\n        function WindowedMean(windowSize) {\n            if (windowSize === void 0) { windowSize = 32; }\n            this.addedValues = 0;\n            this.lastValue = 0;\n            this.mean = 0;\n            this.dirty = true;\n            this.values = new Array(windowSize);\n        }\n        WindowedMean.prototype.hasEnoughData = function () {\n            return this.addedValues >= this.values.length;\n        };\n        WindowedMean.prototype.addValue = function (value) {\n            if (this.addedValues < this.values.length)\n                this.addedValues++;\n            this.values[this.lastValue++] = value;\n            if (this.lastValue > this.values.length - 1)\n                this.lastValue = 0;\n            this.dirty = true;\n        };\n        WindowedMean.prototype.getMean = function () {\n            if (this.hasEnoughData()) {\n                if (this.dirty) {\n                    var mean = 0;\n                    for (var i = 0; i < this.values.length; i++) {\n                        mean += this.values[i];\n                    }\n                    this.mean = mean / this.values.length;\n                    this.dirty = false;\n                }\n                return this.mean;\n            }\n            else {\n                return 0;\n            }\n        };\n        return WindowedMean;\n    }());\n    spine.WindowedMean = WindowedMean;\n})(spine || (spine = {}));\n(function () {\n    if (!Math.fround) {\n        Math.fround = (function (array) {\n            return function (x) {\n                return array[0] = x, array[0];\n            };\n        })(new Float32Array(1));\n    }\n})();\nvar spine;\n(function (spine) {\n    var Attachment = (function () {\n        function Attachment(name) {\n            if (name == null)\n                throw new Error(\"name cannot be null.\");\n            this.name = name;\n        }\n        return Attachment;\n    }());\n    spine.Attachment = Attachment;\n    var VertexAttachment = (function (_super) {\n        __extends(VertexAttachment, _super);\n        function VertexAttachment(name) {\n            var _this = _super.call(this, name) || this;\n            _this.id = (VertexAttachment.nextID++ & 65535) << 11;\n            _this.worldVerticesLength = 0;\n            return _this;\n        }\n        VertexAttachment.prototype.computeWorldVertices = function (slot, start, count, worldVertices, offset, stride) {\n            count = offset + (count >> 1) * stride;\n            var skeleton = slot.bone.skeleton;\n            var deformArray = slot.attachmentVertices;\n            var vertices = this.vertices;\n            var bones = this.bones;\n            if (bones == null) {\n                if (deformArray.length > 0)\n                    vertices = deformArray;\n                var bone = slot.bone;\n                var x = bone.worldX;\n                var y = bone.worldY;\n                var a = bone.a, b = bone.b, c = bone.c, d = bone.d;\n                for (var v_1 = start, w = offset; w < count; v_1 += 2, w += stride) {\n                    var vx = vertices[v_1], vy = vertices[v_1 + 1];\n                    worldVertices[w] = vx * a + vy * b + x;\n                    worldVertices[w + 1] = vx * c + vy * d + y;\n                }\n                return;\n            }\n            var v = 0, skip = 0;\n            for (var i = 0; i < start; i += 2) {\n                var n = bones[v];\n                v += n + 1;\n                skip += n;\n            }\n            var skeletonBones = skeleton.bones;\n            if (deformArray.length == 0) {\n                for (var w = offset, b = skip * 3; w < count; w += stride) {\n                    var wx = 0, wy = 0;\n                    var n = bones[v++];\n                    n += v;\n                    for (; v < n; v++, b += 3) {\n                        var bone = skeletonBones[bones[v]];\n                        var vx = vertices[b], vy = vertices[b + 1], weight = vertices[b + 2];\n                        wx += (vx * bone.a + vy * bone.b + bone.worldX) * weight;\n                        wy += (vx * bone.c + vy * bone.d + bone.worldY) * weight;\n                    }\n                    worldVertices[w] = wx;\n                    worldVertices[w + 1] = wy;\n                }\n            }\n            else {\n                var deform = deformArray;\n                for (var w = offset, b = skip * 3, f = skip << 1; w < count; w += stride) {\n                    var wx = 0, wy = 0;\n                    var n = bones[v++];\n                    n += v;\n                    for (; v < n; v++, b += 3, f += 2) {\n                        var bone = skeletonBones[bones[v]];\n                        var vx = vertices[b] + deform[f], vy = vertices[b + 1] + deform[f + 1], weight = vertices[b + 2];\n                        wx += (vx * bone.a + vy * bone.b + bone.worldX) * weight;\n                        wy += (vx * bone.c + vy * bone.d + bone.worldY) * weight;\n                    }\n                    worldVertices[w] = wx;\n                    worldVertices[w + 1] = wy;\n                }\n            }\n        };\n        VertexAttachment.prototype.applyDeform = function (sourceAttachment) {\n            return this == sourceAttachment;\n        };\n        VertexAttachment.nextID = 0;\n        return VertexAttachment;\n    }(Attachment));\n    spine.VertexAttachment = VertexAttachment;\n})(spine || (spine = {}));\nvar spine;\n(function (spine) {\n    var AttachmentType;\n    (function (AttachmentType) {\n        AttachmentType[AttachmentType[\"Region\"] = 0] = \"Region\";\n        AttachmentType[AttachmentType[\"BoundingBox\"] = 1] = \"BoundingBox\";\n        AttachmentType[AttachmentType[\"Mesh\"] = 2] = \"Mesh\";\n        AttachmentType[AttachmentType[\"LinkedMesh\"] = 3] = \"LinkedMesh\";\n        AttachmentType[AttachmentType[\"Path\"] = 4] = \"Path\";\n        AttachmentType[AttachmentType[\"Point\"] = 5] = \"Point\";\n    })(AttachmentType = spine.AttachmentType || (spine.AttachmentType = {}));\n})(spine || (spine = {}));\nvar spine;\n(function (spine) {\n    var BoundingBoxAttachment = (function (_super) {\n        __extends(BoundingBoxAttachment, _super);\n        function BoundingBoxAttachment(name) {\n            var _this = _super.call(this, name) || this;\n            _this.color = new spine.Color(1, 1, 1, 1);\n            return _this;\n        }\n        return BoundingBoxAttachment;\n    }(spine.VertexAttachment));\n    spine.BoundingBoxAttachment = BoundingBoxAttachment;\n})(spine || (spine = {}));\nvar spine;\n(function (spine) {\n    var ClippingAttachment = (function (_super) {\n        __extends(ClippingAttachment, _super);\n        function ClippingAttachment(name) {\n            var _this = _super.call(this, name) || this;\n            _this.color = new spine.Color(0.2275, 0.2275, 0.8078, 1);\n            return _this;\n        }\n        return ClippingAttachment;\n    }(spine.VertexAttachment));\n    spine.ClippingAttachment = ClippingAttachment;\n})(spine || (spine = {}));\nvar spine;\n(function (spine) {\n    var MeshAttachment = (function (_super) {\n        __extends(MeshAttachment, _super);\n        function MeshAttachment(name) {\n            var _this = _super.call(this, name) || this;\n            _this.color = new spine.Color(1, 1, 1, 1);\n            _this.inheritDeform = false;\n            _this.tempColor = new spine.Color(0, 0, 0, 0);\n            return _this;\n        }\n        MeshAttachment.prototype.updateUVs = function () {\n            var regionUVs = this.regionUVs;\n            if (this.uvs == null || this.uvs.length != regionUVs.length)\n                this.uvs = spine.Utils.newFloatArray(regionUVs.length);\n            var uvs = this.uvs;\n            var u = 0, v = 0, width = 0, height = 0;\n            if (this.region instanceof spine.TextureAtlasRegion) {\n                var region = this.region;\n                var textureWidth = region.texture.getImage().width, textureHeight = region.texture.getImage().height;\n                if (region.rotate) {\n                    u = region.u - (region.originalHeight - region.offsetY - region.height) / textureWidth;\n                    v = region.v - (region.originalWidth - region.offsetX - region.width) / textureHeight;\n                    width = region.originalHeight / textureWidth;\n                    height = region.originalWidth / textureHeight;\n                    for (var i = 0, n = uvs.length; i < n; i += 2) {\n                        uvs[i] = u + regionUVs[i + 1] * width;\n                        uvs[i + 1] = v + height - regionUVs[i] * height;\n                    }\n                    return;\n                }\n                u = region.u - region.offsetX / textureWidth;\n                v = region.v - (region.originalHeight - region.offsetY - region.height) / textureHeight;\n                width = region.originalWidth / textureWidth;\n                height = region.originalHeight / textureHeight;\n            }\n            else if (this.region == null) {\n                u = v = 0;\n                width = height = 1;\n            }\n            else {\n                u = this.region.u;\n                v = this.region.v;\n                width = this.region.u2 - u;\n                height = this.region.v2 - v;\n            }\n            for (var i = 0, n = uvs.length; i < n; i += 2) {\n                uvs[i] = u + regionUVs[i] * width;\n                uvs[i + 1] = v + regionUVs[i + 1] * height;\n            }\n        };\n        MeshAttachment.prototype.applyDeform = function (sourceAttachment) {\n            return this == sourceAttachment || (this.inheritDeform && this.parentMesh == sourceAttachment);\n        };\n        MeshAttachment.prototype.getParentMesh = function () {\n            return this.parentMesh;\n        };\n        MeshAttachment.prototype.setParentMesh = function (parentMesh) {\n            this.parentMesh = parentMesh;\n            if (parentMesh != null) {\n                this.bones = parentMesh.bones;\n                this.vertices = parentMesh.vertices;\n                this.worldVerticesLength = parentMesh.worldVerticesLength;\n                this.regionUVs = parentMesh.regionUVs;\n                this.triangles = parentMesh.triangles;\n                this.hullLength = parentMesh.hullLength;\n                this.worldVerticesLength = parentMesh.worldVerticesLength;\n            }\n        };\n        return MeshAttachment;\n    }(spine.VertexAttachment));\n    spine.MeshAttachment = MeshAttachment;\n})(spine || (spine = {}));\nvar spine;\n(function (spine) {\n    var PathAttachment = (function (_super) {\n        __extends(PathAttachment, _super);\n        function PathAttachment(name) {\n            var _this = _super.call(this, name) || this;\n            _this.closed = false;\n            _this.constantSpeed = false;\n            _this.color = new spine.Color(1, 1, 1, 1);\n            return _this;\n        }\n        return PathAttachment;\n    }(spine.VertexAttachment));\n    spine.PathAttachment = PathAttachment;\n})(spine || (spine = {}));\nvar spine;\n(function (spine) {\n    var PointAttachment = (function (_super) {\n        __extends(PointAttachment, _super);\n        function PointAttachment(name) {\n            var _this = _super.call(this, name) || this;\n            _this.color = new spine.Color(0.38, 0.94, 0, 1);\n            return _this;\n        }\n        PointAttachment.prototype.computeWorldPosition = function (bone, point) {\n            point.x = this.x * bone.a + this.y * bone.b + bone.worldX;\n            point.y = this.x * bone.c + this.y * bone.d + bone.worldY;\n            return point;\n        };\n        PointAttachment.prototype.computeWorldRotation = function (bone) {\n            var cos = spine.MathUtils.cosDeg(this.rotation), sin = spine.MathUtils.sinDeg(this.rotation);\n            var x = cos * bone.a + sin * bone.b;\n            var y = cos * bone.c + sin * bone.d;\n            return Math.atan2(y, x) * spine.MathUtils.radDeg;\n        };\n        return PointAttachment;\n    }(spine.VertexAttachment));\n    spine.PointAttachment = PointAttachment;\n})(spine || (spine = {}));\nvar spine;\n(function (spine) {\n    var RegionAttachment = (function (_super) {\n        __extends(RegionAttachment, _super);\n        function RegionAttachment(name) {\n            var _this = _super.call(this, name) || this;\n            _this.x = 0;\n            _this.y = 0;\n            _this.scaleX = 1;\n            _this.scaleY = 1;\n            _this.rotation = 0;\n            _this.width = 0;\n            _this.height = 0;\n            _this.color = new spine.Color(1, 1, 1, 1);\n            _this.offset = spine.Utils.newFloatArray(8);\n            _this.uvs = spine.Utils.newFloatArray(8);\n            _this.tempColor = new spine.Color(1, 1, 1, 1);\n            return _this;\n        }\n        RegionAttachment.prototype.updateOffset = function () {\n            var regionScaleX = this.width / this.region.originalWidth * this.scaleX;\n            var regionScaleY = this.height / this.region.originalHeight * this.scaleY;\n            var localX = -this.width / 2 * this.scaleX + this.region.offsetX * regionScaleX;\n            var localY = -this.height / 2 * this.scaleY + this.region.offsetY * regionScaleY;\n            var localX2 = localX + this.region.width * regionScaleX;\n            var localY2 = localY + this.region.height * regionScaleY;\n            var radians = this.rotation * Math.PI / 180;\n            var cos = Math.cos(radians);\n            var sin = Math.sin(radians);\n            var localXCos = localX * cos + this.x;\n            var localXSin = localX * sin;\n            var localYCos = localY * cos + this.y;\n            var localYSin = localY * sin;\n            var localX2Cos = localX2 * cos + this.x;\n            var localX2Sin = localX2 * sin;\n            var localY2Cos = localY2 * cos + this.y;\n            var localY2Sin = localY2 * sin;\n            var offset = this.offset;\n            offset[RegionAttachment.OX1] = localXCos - localYSin;\n            offset[RegionAttachment.OY1] = localYCos + localXSin;\n            offset[RegionAttachment.OX2] = localXCos - localY2Sin;\n            offset[RegionAttachment.OY2] = localY2Cos + localXSin;\n            offset[RegionAttachment.OX3] = localX2Cos - localY2Sin;\n            offset[RegionAttachment.OY3] = localY2Cos + localX2Sin;\n            offset[RegionAttachment.OX4] = localX2Cos - localYSin;\n            offset[RegionAttachment.OY4] = localYCos + localX2Sin;\n        };\n        RegionAttachment.prototype.setRegion = function (region) {\n            this.region = region;\n            var uvs = this.uvs;\n            if (region.rotate) {\n                uvs[2] = region.u;\n                uvs[3] = region.v2;\n                uvs[4] = region.u;\n                uvs[5] = region.v;\n                uvs[6] = region.u2;\n                uvs[7] = region.v;\n                uvs[0] = region.u2;\n                uvs[1] = region.v2;\n            }\n            else {\n                uvs[0] = region.u;\n                uvs[1] = region.v2;\n                uvs[2] = region.u;\n                uvs[3] = region.v;\n                uvs[4] = region.u2;\n                uvs[5] = region.v;\n                uvs[6] = region.u2;\n                uvs[7] = region.v2;\n            }\n        };\n        RegionAttachment.prototype.computeWorldVertices = function (bone, worldVertices, offset, stride) {\n            var vertexOffset = this.offset;\n            var x = bone.worldX, y = bone.worldY;\n            var a = bone.a, b = bone.b, c = bone.c, d = bone.d;\n            var offsetX = 0, offsetY = 0;\n            offsetX = vertexOffset[RegionAttachment.OX1];\n            offsetY = vertexOffset[RegionAttachment.OY1];\n            worldVertices[offset] = offsetX * a + offsetY * b + x;\n            worldVertices[offset + 1] = offsetX * c + offsetY * d + y;\n            offset += stride;\n            offsetX = vertexOffset[RegionAttachment.OX2];\n            offsetY = vertexOffset[RegionAttachment.OY2];\n            worldVertices[offset] = offsetX * a + offsetY * b + x;\n            worldVertices[offset + 1] = offsetX * c + offsetY * d + y;\n            offset += stride;\n            offsetX = vertexOffset[RegionAttachment.OX3];\n            offsetY = vertexOffset[RegionAttachment.OY3];\n            worldVertices[offset] = offsetX * a + offsetY * b + x;\n            worldVertices[offset + 1] = offsetX * c + offsetY * d + y;\n            offset += stride;\n            offsetX = vertexOffset[RegionAttachment.OX4];\n            offsetY = vertexOffset[RegionAttachment.OY4];\n            worldVertices[offset] = offsetX * a + offsetY * b + x;\n            worldVertices[offset + 1] = offsetX * c + offsetY * d + y;\n        };\n        RegionAttachment.OX1 = 0;\n        RegionAttachment.OY1 = 1;\n        RegionAttachment.OX2 = 2;\n        RegionAttachment.OY2 = 3;\n        RegionAttachment.OX3 = 4;\n        RegionAttachment.OY3 = 5;\n        RegionAttachment.OX4 = 6;\n        RegionAttachment.OY4 = 7;\n        RegionAttachment.X1 = 0;\n        RegionAttachment.Y1 = 1;\n        RegionAttachment.C1R = 2;\n        RegionAttachment.C1G = 3;\n        RegionAttachment.C1B = 4;\n        RegionAttachment.C1A = 5;\n        RegionAttachment.U1 = 6;\n        RegionAttachment.V1 = 7;\n        RegionAttachment.X2 = 8;\n        RegionAttachment.Y2 = 9;\n        RegionAttachment.C2R = 10;\n        RegionAttachment.C2G = 11;\n        RegionAttachment.C2B = 12;\n        RegionAttachment.C2A = 13;\n        RegionAttachment.U2 = 14;\n        RegionAttachment.V2 = 15;\n        RegionAttachment.X3 = 16;\n        RegionAttachment.Y3 = 17;\n        RegionAttachment.C3R = 18;\n        RegionAttachment.C3G = 19;\n        RegionAttachment.C3B = 20;\n        RegionAttachment.C3A = 21;\n        RegionAttachment.U3 = 22;\n        RegionAttachment.V3 = 23;\n        RegionAttachment.X4 = 24;\n        RegionAttachment.Y4 = 25;\n        RegionAttachment.C4R = 26;\n        RegionAttachment.C4G = 27;\n        RegionAttachment.C4B = 28;\n        RegionAttachment.C4A = 29;\n        RegionAttachment.U4 = 30;\n        RegionAttachment.V4 = 31;\n        return RegionAttachment;\n    }(spine.Attachment));\n    spine.RegionAttachment = RegionAttachment;\n})(spine || (spine = {}));\nvar spine;\n(function (spine) {\n    var JitterEffect = (function () {\n        function JitterEffect(jitterX, jitterY) {\n            this.jitterX = 0;\n            this.jitterY = 0;\n            this.jitterX = jitterX;\n            this.jitterY = jitterY;\n        }\n        JitterEffect.prototype.begin = function (skeleton) {\n        };\n        JitterEffect.prototype.transform = function (position, uv, light, dark) {\n            position.x += spine.MathUtils.randomTriangular(-this.jitterX, this.jitterY);\n            position.y += spine.MathUtils.randomTriangular(-this.jitterX, this.jitterY);\n        };\n        JitterEffect.prototype.end = function () {\n        };\n        return JitterEffect;\n    }());\n    spine.JitterEffect = JitterEffect;\n})(spine || (spine = {}));\nvar spine;\n(function (spine) {\n    var SwirlEffect = (function () {\n        function SwirlEffect(radius) {\n            this.centerX = 0;\n            this.centerY = 0;\n            this.radius = 0;\n            this.angle = 0;\n            this.worldX = 0;\n            this.worldY = 0;\n            this.radius = radius;\n        }\n        SwirlEffect.prototype.begin = function (skeleton) {\n            this.worldX = skeleton.x + this.centerX;\n            this.worldY = skeleton.y + this.centerY;\n        };\n        SwirlEffect.prototype.transform = function (position, uv, light, dark) {\n            var radAngle = this.angle * spine.MathUtils.degreesToRadians;\n            var x = position.x - this.worldX;\n            var y = position.y - this.worldY;\n            var dist = Math.sqrt(x * x + y * y);\n            if (dist < this.radius) {\n                var theta = SwirlEffect.interpolation.apply(0, radAngle, (this.radius - dist) / this.radius);\n                var cos = Math.cos(theta);\n                var sin = Math.sin(theta);\n                position.x = cos * x - sin * y + this.worldX;\n                position.y = sin * x + cos * y + this.worldY;\n            }\n        };\n        SwirlEffect.prototype.end = function () {\n        };\n        SwirlEffect.interpolation = new spine.PowOut(2);\n        return SwirlEffect;\n    }());\n    spine.SwirlEffect = SwirlEffect;\n})(spine || (spine = {}));\nvar spine;\n(function (spine) {\n    var canvas;\n    (function (canvas) {\n        var AssetManager = (function (_super) {\n            __extends(AssetManager, _super);\n            function AssetManager(pathPrefix) {\n                if (pathPrefix === void 0) { pathPrefix = \"\"; }\n                return _super.call(this, function (image) { return new spine.canvas.CanvasTexture(image); }, pathPrefix) || this;\n            }\n            return AssetManager;\n        }(spine.AssetManager));\n        canvas.AssetManager = AssetManager;\n    })(canvas = spine.canvas || (spine.canvas = {}));\n})(spine || (spine = {}));\nvar spine;\n(function (spine) {\n    var canvas;\n    (function (canvas) {\n        var CanvasTexture = (function (_super) {\n            __extends(CanvasTexture, _super);\n            function CanvasTexture(image) {\n                return _super.call(this, image) || this;\n            }\n            CanvasTexture.prototype.setFilters = function (minFilter, magFilter) { };\n            CanvasTexture.prototype.setWraps = function (uWrap, vWrap) { };\n            CanvasTexture.prototype.dispose = function () { };\n            return CanvasTexture;\n        }(spine.Texture));\n        canvas.CanvasTexture = CanvasTexture;\n    })(canvas = spine.canvas || (spine.canvas = {}));\n})(spine || (spine = {}));\nvar spine;\n(function (spine) {\n    var canvas;\n    (function (canvas) {\n        var SkeletonRenderer = (function () {\n            function SkeletonRenderer(context) {\n                this.triangleRendering = false;\n                this.debugRendering = false;\n                this.vertices = spine.Utils.newFloatArray(8 * 1024);\n                this.tempColor = new spine.Color();\n                this.ctx = context;\n            }\n            SkeletonRenderer.prototype.draw = function (skeleton) {\n                if (this.triangleRendering)\n                    this.drawTriangles(skeleton);\n                else\n                    this.drawImages(skeleton);\n            };\n            SkeletonRenderer.prototype.drawImages = function (skeleton) {\n                var ctx = this.ctx;\n                var drawOrder = skeleton.drawOrder;\n                if (this.debugRendering)\n                    ctx.strokeStyle = \"green\";\n                ctx.save();\n                for (var i = 0, n = drawOrder.length; i < n; i++) {\n                    var slot = drawOrder[i];\n                    var attachment = slot.getAttachment();\n                    var regionAttachment = null;\n                    var region = null;\n                    var image = null;\n                    if (attachment instanceof spine.RegionAttachment) {\n                        regionAttachment = attachment;\n                        region = regionAttachment.region;\n                        image = region.texture.getImage();\n                    }\n                    else\n                        continue;\n                    var skeleton_1 = slot.bone.skeleton;\n                    var skeletonColor = skeleton_1.color;\n                    var slotColor = slot.color;\n                    var regionColor = regionAttachment.color;\n                    var alpha = skeletonColor.a * slotColor.a * regionColor.a;\n                    var color = this.tempColor;\n                    color.set(skeletonColor.r * slotColor.r * regionColor.r, skeletonColor.g * slotColor.g * regionColor.g, skeletonColor.b * slotColor.b * regionColor.b, alpha);\n                    var att = attachment;\n                    var bone = slot.bone;\n                    var w = region.width;\n                    var h = region.height;\n                    ctx.save();\n                    ctx.transform(bone.a, bone.c, bone.b, bone.d, bone.worldX, bone.worldY);\n                    ctx.translate(attachment.offset[0], attachment.offset[1]);\n                    ctx.rotate(attachment.rotation * Math.PI / 180);\n                    var atlasScale = att.width / w;\n                    ctx.scale(atlasScale * attachment.scaleX, atlasScale * attachment.scaleY);\n                    ctx.translate(w / 2, h / 2);\n                    if (attachment.region.rotate) {\n                        var t = w;\n                        w = h;\n                        h = t;\n                        ctx.rotate(-Math.PI / 2);\n                    }\n                    ctx.scale(1, -1);\n                    ctx.translate(-w / 2, -h / 2);\n                    if (color.r != 1 || color.g != 1 || color.b != 1 || color.a != 1) {\n                        ctx.globalAlpha = color.a;\n                    }\n                    ctx.drawImage(image, region.x, region.y, w, h, 0, 0, w, h);\n                    if (this.debugRendering)\n                        ctx.strokeRect(0, 0, w, h);\n                    ctx.restore();\n                }\n                ctx.restore();\n            };\n            SkeletonRenderer.prototype.drawTriangles = function (skeleton) {\n                var blendMode = null;\n                var vertices = this.vertices;\n                var triangles = null;\n                var drawOrder = skeleton.drawOrder;\n                for (var i = 0, n = drawOrder.length; i < n; i++) {\n                    var slot = drawOrder[i];\n                    var attachment = slot.getAttachment();\n                    var texture = null;\n                    var region = null;\n                    if (attachment instanceof spine.RegionAttachment) {\n                        var regionAttachment = attachment;\n                        vertices = this.computeRegionVertices(slot, regionAttachment, false);\n                        triangles = SkeletonRenderer.QUAD_TRIANGLES;\n                        region = regionAttachment.region;\n                        texture = region.texture.getImage();\n                    }\n                    else if (attachment instanceof spine.MeshAttachment) {\n                        var mesh = attachment;\n                        vertices = this.computeMeshVertices(slot, mesh, false);\n                        triangles = mesh.triangles;\n                        texture = mesh.region.renderObject.texture.getImage();\n                    }\n                    else\n                        continue;\n                    if (texture != null) {\n                        var slotBlendMode = slot.data.blendMode;\n                        if (slotBlendMode != blendMode) {\n                            blendMode = slotBlendMode;\n                        }\n                        var skeleton_2 = slot.bone.skeleton;\n                        var skeletonColor = skeleton_2.color;\n                        var slotColor = slot.color;\n                        var attachmentColor = attachment.color;\n                        var alpha = skeletonColor.a * slotColor.a * attachmentColor.a;\n                        var color = this.tempColor;\n                        color.set(skeletonColor.r * slotColor.r * attachmentColor.r, skeletonColor.g * slotColor.g * attachmentColor.g, skeletonColor.b * slotColor.b * attachmentColor.b, alpha);\n                        var ctx = this.ctx;\n                        if (color.r != 1 || color.g != 1 || color.b != 1 || color.a != 1) {\n                            ctx.globalAlpha = color.a;\n                        }\n                        for (var j = 0; j < triangles.length; j += 3) {\n                            var t1 = triangles[j] * 8, t2 = triangles[j + 1] * 8, t3 = triangles[j + 2] * 8;\n                            var x0 = vertices[t1], y0 = vertices[t1 + 1], u0 = vertices[t1 + 6], v0 = vertices[t1 + 7];\n                            var x1 = vertices[t2], y1 = vertices[t2 + 1], u1 = vertices[t2 + 6], v1 = vertices[t2 + 7];\n                            var x2 = vertices[t3], y2 = vertices[t3 + 1], u2 = vertices[t3 + 6], v2 = vertices[t3 + 7];\n                            this.drawTriangle(texture, x0, y0, u0, v0, x1, y1, u1, v1, x2, y2, u2, v2);\n                            if (this.debugRendering) {\n                                ctx.strokeStyle = \"green\";\n                                ctx.beginPath();\n                                ctx.moveTo(x0, y0);\n                                ctx.lineTo(x1, y1);\n                                ctx.lineTo(x2, y2);\n                                ctx.lineTo(x0, y0);\n                                ctx.stroke();\n                            }\n                        }\n                    }\n                }\n                this.ctx.globalAlpha = 1;\n            };\n            SkeletonRenderer.prototype.drawTriangle = function (img, x0, y0, u0, v0, x1, y1, u1, v1, x2, y2, u2, v2) {\n                var ctx = this.ctx;\n                u0 *= img.width;\n                v0 *= img.height;\n                u1 *= img.width;\n                v1 *= img.height;\n                u2 *= img.width;\n                v2 *= img.height;\n                ctx.beginPath();\n                ctx.moveTo(x0, y0);\n                ctx.lineTo(x1, y1);\n                ctx.lineTo(x2, y2);\n                ctx.closePath();\n                x1 -= x0;\n                y1 -= y0;\n                x2 -= x0;\n                y2 -= y0;\n                u1 -= u0;\n                v1 -= v0;\n                u2 -= u0;\n                v2 -= v0;\n                var det = 1 / (u1 * v2 - u2 * v1), a = (v2 * x1 - v1 * x2) * det, b = (v2 * y1 - v1 * y2) * det, c = (u1 * x2 - u2 * x1) * det, d = (u1 * y2 - u2 * y1) * det, e = x0 - a * u0 - c * v0, f = y0 - b * u0 - d * v0;\n                ctx.save();\n                ctx.transform(a, b, c, d, e, f);\n                ctx.clip();\n                ctx.drawImage(img, 0, 0);\n                ctx.restore();\n            };\n            SkeletonRenderer.prototype.computeRegionVertices = function (slot, region, pma) {\n                var skeleton = slot.bone.skeleton;\n                var skeletonColor = skeleton.color;\n                var slotColor = slot.color;\n                var regionColor = region.color;\n                var alpha = skeletonColor.a * slotColor.a * regionColor.a;\n                var multiplier = pma ? alpha : 1;\n                var color = this.tempColor;\n                color.set(skeletonColor.r * slotColor.r * regionColor.r * multiplier, skeletonColor.g * slotColor.g * regionColor.g * multiplier, skeletonColor.b * slotColor.b * regionColor.b * multiplier, alpha);\n                region.computeWorldVertices(slot.bone, this.vertices, 0, SkeletonRenderer.VERTEX_SIZE);\n                var vertices = this.vertices;\n                var uvs = region.uvs;\n                vertices[spine.RegionAttachment.C1R] = color.r;\n                vertices[spine.RegionAttachment.C1G] = color.g;\n                vertices[spine.RegionAttachment.C1B] = color.b;\n                vertices[spine.RegionAttachment.C1A] = color.a;\n                vertices[spine.RegionAttachment.U1] = uvs[0];\n                vertices[spine.RegionAttachment.V1] = uvs[1];\n                vertices[spine.RegionAttachment.C2R] = color.r;\n                vertices[spine.RegionAttachment.C2G] = color.g;\n                vertices[spine.RegionAttachment.C2B] = color.b;\n                vertices[spine.RegionAttachment.C2A] = color.a;\n                vertices[spine.RegionAttachment.U2] = uvs[2];\n                vertices[spine.RegionAttachment.V2] = uvs[3];\n                vertices[spine.RegionAttachment.C3R] = color.r;\n                vertices[spine.RegionAttachment.C3G] = color.g;\n                vertices[spine.RegionAttachment.C3B] = color.b;\n                vertices[spine.RegionAttachment.C3A] = color.a;\n                vertices[spine.RegionAttachment.U3] = uvs[4];\n                vertices[spine.RegionAttachment.V3] = uvs[5];\n                vertices[spine.RegionAttachment.C4R] = color.r;\n                vertices[spine.RegionAttachment.C4G] = color.g;\n                vertices[spine.RegionAttachment.C4B] = color.b;\n                vertices[spine.RegionAttachment.C4A] = color.a;\n                vertices[spine.RegionAttachment.U4] = uvs[6];\n                vertices[spine.RegionAttachment.V4] = uvs[7];\n                return vertices;\n            };\n            SkeletonRenderer.prototype.computeMeshVertices = function (slot, mesh, pma) {\n                var skeleton = slot.bone.skeleton;\n                var skeletonColor = skeleton.color;\n                var slotColor = slot.color;\n                var regionColor = mesh.color;\n                var alpha = skeletonColor.a * slotColor.a * regionColor.a;\n                var multiplier = pma ? alpha : 1;\n                var color = this.tempColor;\n                color.set(skeletonColor.r * slotColor.r * regionColor.r * multiplier, skeletonColor.g * slotColor.g * regionColor.g * multiplier, skeletonColor.b * slotColor.b * regionColor.b * multiplier, alpha);\n                var numVertices = mesh.worldVerticesLength / 2;\n                if (this.vertices.length < mesh.worldVerticesLength) {\n                    this.vertices = spine.Utils.newFloatArray(mesh.worldVerticesLength);\n                }\n                var vertices = this.vertices;\n                mesh.computeWorldVertices(slot, 0, mesh.worldVerticesLength, vertices, 0, SkeletonRenderer.VERTEX_SIZE);\n                var uvs = mesh.uvs;\n                for (var i = 0, n = numVertices, u = 0, v = 2; i < n; i++) {\n                    vertices[v++] = color.r;\n                    vertices[v++] = color.g;\n                    vertices[v++] = color.b;\n                    vertices[v++] = color.a;\n                    vertices[v++] = uvs[u++];\n                    vertices[v++] = uvs[u++];\n                    v += 2;\n                }\n                return vertices;\n            };\n            SkeletonRenderer.QUAD_TRIANGLES = [0, 1, 2, 2, 3, 0];\n            SkeletonRenderer.VERTEX_SIZE = 2 + 2 + 4;\n            return SkeletonRenderer;\n        }());\n        canvas.SkeletonRenderer = SkeletonRenderer;\n    })(canvas = spine.canvas || (spine.canvas = {}));\n})(spine || (spine = {}));\nvar spine;\n(function (spine) {\n    var webgl;\n    (function (webgl) {\n        var AssetManager = (function (_super) {\n            __extends(AssetManager, _super);\n            function AssetManager(context, pathPrefix) {\n                if (pathPrefix === void 0) { pathPrefix = \"\"; }\n                return _super.call(this, function (image) {\n                    return new spine.webgl.GLTexture(context, image);\n                }, pathPrefix) || this;\n            }\n            return AssetManager;\n        }(spine.AssetManager));\n        webgl.AssetManager = AssetManager;\n    })(webgl = spine.webgl || (spine.webgl = {}));\n})(spine || (spine = {}));\nvar spine;\n(function (spine) {\n    var webgl;\n    (function (webgl) {\n        var OrthoCamera = (function () {\n            function OrthoCamera(viewportWidth, viewportHeight) {\n                this.position = new webgl.Vector3(0, 0, 0);\n                this.direction = new webgl.Vector3(0, 0, -1);\n                this.up = new webgl.Vector3(0, 1, 0);\n                this.near = 0;\n                this.far = 100;\n                this.zoom = 1;\n                this.viewportWidth = 0;\n                this.viewportHeight = 0;\n                this.projectionView = new webgl.Matrix4();\n                this.inverseProjectionView = new webgl.Matrix4();\n                this.projection = new webgl.Matrix4();\n                this.view = new webgl.Matrix4();\n                this.tmp = new webgl.Vector3();\n                this.viewportWidth = viewportWidth;\n                this.viewportHeight = viewportHeight;\n                this.update();\n            }\n            OrthoCamera.prototype.update = function () {\n                var projection = this.projection;\n                var view = this.view;\n                var projectionView = this.projectionView;\n                var inverseProjectionView = this.inverseProjectionView;\n                var zoom = this.zoom, viewportWidth = this.viewportWidth, viewportHeight = this.viewportHeight;\n                projection.ortho(zoom * (-viewportWidth / 2), zoom * (viewportWidth / 2), zoom * (-viewportHeight / 2), zoom * (viewportHeight / 2), this.near, this.far);\n                view.lookAt(this.position, this.direction, this.up);\n                projectionView.set(projection.values);\n                projectionView.multiply(view);\n                inverseProjectionView.set(projectionView.values).invert();\n            };\n            OrthoCamera.prototype.screenToWorld = function (screenCoords, screenWidth, screenHeight) {\n                var x = screenCoords.x, y = screenHeight - screenCoords.y - 1;\n                var tmp = this.tmp;\n                tmp.x = (2 * x) / screenWidth - 1;\n                tmp.y = (2 * y) / screenHeight - 1;\n                tmp.z = (2 * screenCoords.z) - 1;\n                tmp.project(this.inverseProjectionView);\n                screenCoords.set(tmp.x, tmp.y, tmp.z);\n                return screenCoords;\n            };\n            OrthoCamera.prototype.setViewport = function (viewportWidth, viewportHeight) {\n                this.viewportWidth = viewportWidth;\n                this.viewportHeight = viewportHeight;\n            };\n            return OrthoCamera;\n        }());\n        webgl.OrthoCamera = OrthoCamera;\n    })(webgl = spine.webgl || (spine.webgl = {}));\n})(spine || (spine = {}));\nvar spine;\n(function (spine) {\n    var webgl;\n    (function (webgl) {\n        var GLTexture = (function (_super) {\n            __extends(GLTexture, _super);\n            function GLTexture(context, image, useMipMaps) {\n                if (useMipMaps === void 0) { useMipMaps = false; }\n                var _this = _super.call(this, image) || this;\n                _this.texture = null;\n                _this.boundUnit = 0;\n                _this.useMipMaps = false;\n                _this.context = context instanceof webgl.ManagedWebGLRenderingContext ? context : new webgl.ManagedWebGLRenderingContext(context);\n                _this.useMipMaps = useMipMaps;\n                _this.restore();\n                _this.context.addRestorable(_this);\n                return _this;\n            }\n            GLTexture.prototype.setFilters = function (minFilter, magFilter) {\n                var gl = this.context.gl;\n                this.bind();\n                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, minFilter);\n                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, magFilter);\n            };\n            GLTexture.prototype.setWraps = function (uWrap, vWrap) {\n                var gl = this.context.gl;\n                this.bind();\n                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, uWrap);\n                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, vWrap);\n            };\n            GLTexture.prototype.update = function (useMipMaps) {\n                var gl = this.context.gl;\n                if (!this.texture) {\n                    this.texture = this.context.gl.createTexture();\n                }\n                this.bind();\n                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, this._image);\n                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, useMipMaps ? gl.LINEAR_MIPMAP_LINEAR : gl.LINEAR);\n                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n                if (useMipMaps)\n                    gl.generateMipmap(gl.TEXTURE_2D);\n            };\n            GLTexture.prototype.restore = function () {\n                this.texture = null;\n                this.update(this.useMipMaps);\n            };\n            GLTexture.prototype.bind = function (unit) {\n                if (unit === void 0) { unit = 0; }\n                var gl = this.context.gl;\n                this.boundUnit = unit;\n                gl.activeTexture(gl.TEXTURE0 + unit);\n                gl.bindTexture(gl.TEXTURE_2D, this.texture);\n            };\n            GLTexture.prototype.unbind = function () {\n                var gl = this.context.gl;\n                gl.activeTexture(gl.TEXTURE0 + this.boundUnit);\n                gl.bindTexture(gl.TEXTURE_2D, null);\n            };\n            GLTexture.prototype.dispose = function () {\n                this.context.removeRestorable(this);\n                var gl = this.context.gl;\n                gl.deleteTexture(this.texture);\n            };\n            return GLTexture;\n        }(spine.Texture));\n        webgl.GLTexture = GLTexture;\n    })(webgl = spine.webgl || (spine.webgl = {}));\n})(spine || (spine = {}));\nvar spine;\n(function (spine) {\n    var webgl;\n    (function (webgl) {\n        webgl.M00 = 0;\n        webgl.M01 = 4;\n        webgl.M02 = 8;\n        webgl.M03 = 12;\n        webgl.M10 = 1;\n        webgl.M11 = 5;\n        webgl.M12 = 9;\n        webgl.M13 = 13;\n        webgl.M20 = 2;\n        webgl.M21 = 6;\n        webgl.M22 = 10;\n        webgl.M23 = 14;\n        webgl.M30 = 3;\n        webgl.M31 = 7;\n        webgl.M32 = 11;\n        webgl.M33 = 15;\n        var Matrix4 = (function () {\n            function Matrix4() {\n                this.temp = new Float32Array(16);\n                this.values = new Float32Array(16);\n                var v = this.values;\n                v[webgl.M00] = 1;\n                v[webgl.M11] = 1;\n                v[webgl.M22] = 1;\n                v[webgl.M33] = 1;\n            }\n            Matrix4.prototype.set = function (values) {\n                this.values.set(values);\n                return this;\n            };\n            Matrix4.prototype.transpose = function () {\n                var t = this.temp;\n                var v = this.values;\n                t[webgl.M00] = v[webgl.M00];\n                t[webgl.M01] = v[webgl.M10];\n                t[webgl.M02] = v[webgl.M20];\n                t[webgl.M03] = v[webgl.M30];\n                t[webgl.M10] = v[webgl.M01];\n                t[webgl.M11] = v[webgl.M11];\n                t[webgl.M12] = v[webgl.M21];\n                t[webgl.M13] = v[webgl.M31];\n                t[webgl.M20] = v[webgl.M02];\n                t[webgl.M21] = v[webgl.M12];\n                t[webgl.M22] = v[webgl.M22];\n                t[webgl.M23] = v[webgl.M32];\n                t[webgl.M30] = v[webgl.M03];\n                t[webgl.M31] = v[webgl.M13];\n                t[webgl.M32] = v[webgl.M23];\n                t[webgl.M33] = v[webgl.M33];\n                return this.set(t);\n            };\n            Matrix4.prototype.identity = function () {\n                var v = this.values;\n                v[webgl.M00] = 1;\n                v[webgl.M01] = 0;\n                v[webgl.M02] = 0;\n                v[webgl.M03] = 0;\n                v[webgl.M10] = 0;\n                v[webgl.M11] = 1;\n                v[webgl.M12] = 0;\n                v[webgl.M13] = 0;\n                v[webgl.M20] = 0;\n                v[webgl.M21] = 0;\n                v[webgl.M22] = 1;\n                v[webgl.M23] = 0;\n                v[webgl.M30] = 0;\n                v[webgl.M31] = 0;\n                v[webgl.M32] = 0;\n                v[webgl.M33] = 1;\n                return this;\n            };\n            Matrix4.prototype.invert = function () {\n                var v = this.values;\n                var t = this.temp;\n                var l_det = v[webgl.M30] * v[webgl.M21] * v[webgl.M12] * v[webgl.M03] - v[webgl.M20] * v[webgl.M31] * v[webgl.M12] * v[webgl.M03] - v[webgl.M30] * v[webgl.M11] * v[webgl.M22] * v[webgl.M03]\n                    + v[webgl.M10] * v[webgl.M31] * v[webgl.M22] * v[webgl.M03] + v[webgl.M20] * v[webgl.M11] * v[webgl.M32] * v[webgl.M03] - v[webgl.M10] * v[webgl.M21] * v[webgl.M32] * v[webgl.M03]\n                    - v[webgl.M30] * v[webgl.M21] * v[webgl.M02] * v[webgl.M13] + v[webgl.M20] * v[webgl.M31] * v[webgl.M02] * v[webgl.M13] + v[webgl.M30] * v[webgl.M01] * v[webgl.M22] * v[webgl.M13]\n                    - v[webgl.M00] * v[webgl.M31] * v[webgl.M22] * v[webgl.M13] - v[webgl.M20] * v[webgl.M01] * v[webgl.M32] * v[webgl.M13] + v[webgl.M00] * v[webgl.M21] * v[webgl.M32] * v[webgl.M13]\n                    + v[webgl.M30] * v[webgl.M11] * v[webgl.M02] * v[webgl.M23] - v[webgl.M10] * v[webgl.M31] * v[webgl.M02] * v[webgl.M23] - v[webgl.M30] * v[webgl.M01] * v[webgl.M12] * v[webgl.M23]\n                    + v[webgl.M00] * v[webgl.M31] * v[webgl.M12] * v[webgl.M23] + v[webgl.M10] * v[webgl.M01] * v[webgl.M32] * v[webgl.M23] - v[webgl.M00] * v[webgl.M11] * v[webgl.M32] * v[webgl.M23]\n                    - v[webgl.M20] * v[webgl.M11] * v[webgl.M02] * v[webgl.M33] + v[webgl.M10] * v[webgl.M21] * v[webgl.M02] * v[webgl.M33] + v[webgl.M20] * v[webgl.M01] * v[webgl.M12] * v[webgl.M33]\n                    - v[webgl.M00] * v[webgl.M21] * v[webgl.M12] * v[webgl.M33] - v[webgl.M10] * v[webgl.M01] * v[webgl.M22] * v[webgl.M33] + v[webgl.M00] * v[webgl.M11] * v[webgl.M22] * v[webgl.M33];\n                if (l_det == 0)\n                    throw new Error(\"non-invertible matrix\");\n                var inv_det = 1.0 / l_det;\n                t[webgl.M00] = v[webgl.M12] * v[webgl.M23] * v[webgl.M31] - v[webgl.M13] * v[webgl.M22] * v[webgl.M31] + v[webgl.M13] * v[webgl.M21] * v[webgl.M32]\n                    - v[webgl.M11] * v[webgl.M23] * v[webgl.M32] - v[webgl.M12] * v[webgl.M21] * v[webgl.M33] + v[webgl.M11] * v[webgl.M22] * v[webgl.M33];\n                t[webgl.M01] = v[webgl.M03] * v[webgl.M22] * v[webgl.M31] - v[webgl.M02] * v[webgl.M23] * v[webgl.M31] - v[webgl.M03] * v[webgl.M21] * v[webgl.M32]\n                    + v[webgl.M01] * v[webgl.M23] * v[webgl.M32] + v[webgl.M02] * v[webgl.M21] * v[webgl.M33] - v[webgl.M01] * v[webgl.M22] * v[webgl.M33];\n                t[webgl.M02] = v[webgl.M02] * v[webgl.M13] * v[webgl.M31] - v[webgl.M03] * v[webgl.M12] * v[webgl.M31] + v[webgl.M03] * v[webgl.M11] * v[webgl.M32]\n                    - v[webgl.M01] * v[webgl.M13] * v[webgl.M32] - v[webgl.M02] * v[webgl.M11] * v[webgl.M33] + v[webgl.M01] * v[webgl.M12] * v[webgl.M33];\n                t[webgl.M03] = v[webgl.M03] * v[webgl.M12] * v[webgl.M21] - v[webgl.M02] * v[webgl.M13] * v[webgl.M21] - v[webgl.M03] * v[webgl.M11] * v[webgl.M22]\n                    + v[webgl.M01] * v[webgl.M13] * v[webgl.M22] + v[webgl.M02] * v[webgl.M11] * v[webgl.M23] - v[webgl.M01] * v[webgl.M12] * v[webgl.M23];\n                t[webgl.M10] = v[webgl.M13] * v[webgl.M22] * v[webgl.M30] - v[webgl.M12] * v[webgl.M23] * v[webgl.M30] - v[webgl.M13] * v[webgl.M20] * v[webgl.M32]\n                    + v[webgl.M10] * v[webgl.M23] * v[webgl.M32] + v[webgl.M12] * v[webgl.M20] * v[webgl.M33] - v[webgl.M10] * v[webgl.M22] * v[webgl.M33];\n                t[webgl.M11] = v[webgl.M02] * v[webgl.M23] * v[webgl.M30] - v[webgl.M03] * v[webgl.M22] * v[webgl.M30] + v[webgl.M03] * v[webgl.M20] * v[webgl.M32]\n                    - v[webgl.M00] * v[webgl.M23] * v[webgl.M32] - v[webgl.M02] * v[webgl.M20] * v[webgl.M33] + v[webgl.M00] * v[webgl.M22] * v[webgl.M33];\n                t[webgl.M12] = v[webgl.M03] * v[webgl.M12] * v[webgl.M30] - v[webgl.M02] * v[webgl.M13] * v[webgl.M30] - v[webgl.M03] * v[webgl.M10] * v[webgl.M32]\n                    + v[webgl.M00] * v[webgl.M13] * v[webgl.M32] + v[webgl.M02] * v[webgl.M10] * v[webgl.M33] - v[webgl.M00] * v[webgl.M12] * v[webgl.M33];\n                t[webgl.M13] = v[webgl.M02] * v[webgl.M13] * v[webgl.M20] - v[webgl.M03] * v[webgl.M12] * v[webgl.M20] + v[webgl.M03] * v[webgl.M10] * v[webgl.M22]\n                    - v[webgl.M00] * v[webgl.M13] * v[webgl.M22] - v[webgl.M02] * v[webgl.M10] * v[webgl.M23] + v[webgl.M00] * v[webgl.M12] * v[webgl.M23];\n                t[webgl.M20] = v[webgl.M11] * v[webgl.M23] * v[webgl.M30] - v[webgl.M13] * v[webgl.M21] * v[webgl.M30] + v[webgl.M13] * v[webgl.M20] * v[webgl.M31]\n                    - v[webgl.M10] * v[webgl.M23] * v[webgl.M31] - v[webgl.M11] * v[webgl.M20] * v[webgl.M33] + v[webgl.M10] * v[webgl.M21] * v[webgl.M33];\n                t[webgl.M21] = v[webgl.M03] * v[webgl.M21] * v[webgl.M30] - v[webgl.M01] * v[webgl.M23] * v[webgl.M30] - v[webgl.M03] * v[webgl.M20] * v[webgl.M31]\n                    + v[webgl.M00] * v[webgl.M23] * v[webgl.M31] + v[webgl.M01] * v[webgl.M20] * v[webgl.M33] - v[webgl.M00] * v[webgl.M21] * v[webgl.M33];\n                t[webgl.M22] = v[webgl.M01] * v[webgl.M13] * v[webgl.M30] - v[webgl.M03] * v[webgl.M11] * v[webgl.M30] + v[webgl.M03] * v[webgl.M10] * v[webgl.M31]\n                    - v[webgl.M00] * v[webgl.M13] * v[webgl.M31] - v[webgl.M01] * v[webgl.M10] * v[webgl.M33] + v[webgl.M00] * v[webgl.M11] * v[webgl.M33];\n                t[webgl.M23] = v[webgl.M03] * v[webgl.M11] * v[webgl.M20] - v[webgl.M01] * v[webgl.M13] * v[webgl.M20] - v[webgl.M03] * v[webgl.M10] * v[webgl.M21]\n                    + v[webgl.M00] * v[webgl.M13] * v[webgl.M21] + v[webgl.M01] * v[webgl.M10] * v[webgl.M23] - v[webgl.M00] * v[webgl.M11] * v[webgl.M23];\n                t[webgl.M30] = v[webgl.M12] * v[webgl.M21] * v[webgl.M30] - v[webgl.M11] * v[webgl.M22] * v[webgl.M30] - v[webgl.M12] * v[webgl.M20] * v[webgl.M31]\n                    + v[webgl.M10] * v[webgl.M22] * v[webgl.M31] + v[webgl.M11] * v[webgl.M20] * v[webgl.M32] - v[webgl.M10] * v[webgl.M21] * v[webgl.M32];\n                t[webgl.M31] = v[webgl.M01] * v[webgl.M22] * v[webgl.M30] - v[webgl.M02] * v[webgl.M21] * v[webgl.M30] + v[webgl.M02] * v[webgl.M20] * v[webgl.M31]\n                    - v[webgl.M00] * v[webgl.M22] * v[webgl.M31] - v[webgl.M01] * v[webgl.M20] * v[webgl.M32] + v[webgl.M00] * v[webgl.M21] * v[webgl.M32];\n                t[webgl.M32] = v[webgl.M02] * v[webgl.M11] * v[webgl.M30] - v[webgl.M01] * v[webgl.M12] * v[webgl.M30] - v[webgl.M02] * v[webgl.M10] * v[webgl.M31]\n                    + v[webgl.M00] * v[webgl.M12] * v[webgl.M31] + v[webgl.M01] * v[webgl.M10] * v[webgl.M32] - v[webgl.M00] * v[webgl.M11] * v[webgl.M32];\n                t[webgl.M33] = v[webgl.M01] * v[webgl.M12] * v[webgl.M20] - v[webgl.M02] * v[webgl.M11] * v[webgl.M20] + v[webgl.M02] * v[webgl.M10] * v[webgl.M21]\n                    - v[webgl.M00] * v[webgl.M12] * v[webgl.M21] - v[webgl.M01] * v[webgl.M10] * v[webgl.M22] + v[webgl.M00] * v[webgl.M11] * v[webgl.M22];\n                v[webgl.M00] = t[webgl.M00] * inv_det;\n                v[webgl.M01] = t[webgl.M01] * inv_det;\n                v[webgl.M02] = t[webgl.M02] * inv_det;\n                v[webgl.M03] = t[webgl.M03] * inv_det;\n                v[webgl.M10] = t[webgl.M10] * inv_det;\n                v[webgl.M11] = t[webgl.M11] * inv_det;\n                v[webgl.M12] = t[webgl.M12] * inv_det;\n                v[webgl.M13] = t[webgl.M13] * inv_det;\n                v[webgl.M20] = t[webgl.M20] * inv_det;\n                v[webgl.M21] = t[webgl.M21] * inv_det;\n                v[webgl.M22] = t[webgl.M22] * inv_det;\n                v[webgl.M23] = t[webgl.M23] * inv_det;\n                v[webgl.M30] = t[webgl.M30] * inv_det;\n                v[webgl.M31] = t[webgl.M31] * inv_det;\n                v[webgl.M32] = t[webgl.M32] * inv_det;\n                v[webgl.M33] = t[webgl.M33] * inv_det;\n                return this;\n            };\n            Matrix4.prototype.determinant = function () {\n                var v = this.values;\n                return v[webgl.M30] * v[webgl.M21] * v[webgl.M12] * v[webgl.M03] - v[webgl.M20] * v[webgl.M31] * v[webgl.M12] * v[webgl.M03] - v[webgl.M30] * v[webgl.M11] * v[webgl.M22] * v[webgl.M03]\n                    + v[webgl.M10] * v[webgl.M31] * v[webgl.M22] * v[webgl.M03] + v[webgl.M20] * v[webgl.M11] * v[webgl.M32] * v[webgl.M03] - v[webgl.M10] * v[webgl.M21] * v[webgl.M32] * v[webgl.M03]\n                    - v[webgl.M30] * v[webgl.M21] * v[webgl.M02] * v[webgl.M13] + v[webgl.M20] * v[webgl.M31] * v[webgl.M02] * v[webgl.M13] + v[webgl.M30] * v[webgl.M01] * v[webgl.M22] * v[webgl.M13]\n                    - v[webgl.M00] * v[webgl.M31] * v[webgl.M22] * v[webgl.M13] - v[webgl.M20] * v[webgl.M01] * v[webgl.M32] * v[webgl.M13] + v[webgl.M00] * v[webgl.M21] * v[webgl.M32] * v[webgl.M13]\n                    + v[webgl.M30] * v[webgl.M11] * v[webgl.M02] * v[webgl.M23] - v[webgl.M10] * v[webgl.M31] * v[webgl.M02] * v[webgl.M23] - v[webgl.M30] * v[webgl.M01] * v[webgl.M12] * v[webgl.M23]\n                    + v[webgl.M00] * v[webgl.M31] * v[webgl.M12] * v[webgl.M23] + v[webgl.M10] * v[webgl.M01] * v[webgl.M32] * v[webgl.M23] - v[webgl.M00] * v[webgl.M11] * v[webgl.M32] * v[webgl.M23]\n                    - v[webgl.M20] * v[webgl.M11] * v[webgl.M02] * v[webgl.M33] + v[webgl.M10] * v[webgl.M21] * v[webgl.M02] * v[webgl.M33] + v[webgl.M20] * v[webgl.M01] * v[webgl.M12] * v[webgl.M33]\n                    - v[webgl.M00] * v[webgl.M21] * v[webgl.M12] * v[webgl.M33] - v[webgl.M10] * v[webgl.M01] * v[webgl.M22] * v[webgl.M33] + v[webgl.M00] * v[webgl.M11] * v[webgl.M22] * v[webgl.M33];\n            };\n            Matrix4.prototype.translate = function (x, y, z) {\n                var v = this.values;\n                v[webgl.M03] += x;\n                v[webgl.M13] += y;\n                v[webgl.M23] += z;\n                return this;\n            };\n            Matrix4.prototype.copy = function () {\n                return new Matrix4().set(this.values);\n            };\n            Matrix4.prototype.projection = function (near, far, fovy, aspectRatio) {\n                this.identity();\n                var l_fd = (1.0 / Math.tan((fovy * (Math.PI / 180)) / 2.0));\n                var l_a1 = (far + near) / (near - far);\n                var l_a2 = (2 * far * near) / (near - far);\n                var v = this.values;\n                v[webgl.M00] = l_fd / aspectRatio;\n                v[webgl.M10] = 0;\n                v[webgl.M20] = 0;\n                v[webgl.M30] = 0;\n                v[webgl.M01] = 0;\n                v[webgl.M11] = l_fd;\n                v[webgl.M21] = 0;\n                v[webgl.M31] = 0;\n                v[webgl.M02] = 0;\n                v[webgl.M12] = 0;\n                v[webgl.M22] = l_a1;\n                v[webgl.M32] = -1;\n                v[webgl.M03] = 0;\n                v[webgl.M13] = 0;\n                v[webgl.M23] = l_a2;\n                v[webgl.M33] = 0;\n                return this;\n            };\n            Matrix4.prototype.ortho2d = function (x, y, width, height) {\n                return this.ortho(x, x + width, y, y + height, 0, 1);\n            };\n            Matrix4.prototype.ortho = function (left, right, bottom, top, near, far) {\n                this.identity();\n                var x_orth = 2 / (right - left);\n                var y_orth = 2 / (top - bottom);\n                var z_orth = -2 / (far - near);\n                var tx = -(right + left) / (right - left);\n                var ty = -(top + bottom) / (top - bottom);\n                var tz = -(far + near) / (far - near);\n                var v = this.values;\n                v[webgl.M00] = x_orth;\n                v[webgl.M10] = 0;\n                v[webgl.M20] = 0;\n                v[webgl.M30] = 0;\n                v[webgl.M01] = 0;\n                v[webgl.M11] = y_orth;\n                v[webgl.M21] = 0;\n                v[webgl.M31] = 0;\n                v[webgl.M02] = 0;\n                v[webgl.M12] = 0;\n                v[webgl.M22] = z_orth;\n                v[webgl.M32] = 0;\n                v[webgl.M03] = tx;\n                v[webgl.M13] = ty;\n                v[webgl.M23] = tz;\n                v[webgl.M33] = 1;\n                return this;\n            };\n            Matrix4.prototype.multiply = function (matrix) {\n                var t = this.temp;\n                var v = this.values;\n                var m = matrix.values;\n                t[webgl.M00] = v[webgl.M00] * m[webgl.M00] + v[webgl.M01] * m[webgl.M10] + v[webgl.M02] * m[webgl.M20] + v[webgl.M03] * m[webgl.M30];\n                t[webgl.M01] = v[webgl.M00] * m[webgl.M01] + v[webgl.M01] * m[webgl.M11] + v[webgl.M02] * m[webgl.M21] + v[webgl.M03] * m[webgl.M31];\n                t[webgl.M02] = v[webgl.M00] * m[webgl.M02] + v[webgl.M01] * m[webgl.M12] + v[webgl.M02] * m[webgl.M22] + v[webgl.M03] * m[webgl.M32];\n                t[webgl.M03] = v[webgl.M00] * m[webgl.M03] + v[webgl.M01] * m[webgl.M13] + v[webgl.M02] * m[webgl.M23] + v[webgl.M03] * m[webgl.M33];\n                t[webgl.M10] = v[webgl.M10] * m[webgl.M00] + v[webgl.M11] * m[webgl.M10] + v[webgl.M12] * m[webgl.M20] + v[webgl.M13] * m[webgl.M30];\n                t[webgl.M11] = v[webgl.M10] * m[webgl.M01] + v[webgl.M11] * m[webgl.M11] + v[webgl.M12] * m[webgl.M21] + v[webgl.M13] * m[webgl.M31];\n                t[webgl.M12] = v[webgl.M10] * m[webgl.M02] + v[webgl.M11] * m[webgl.M12] + v[webgl.M12] * m[webgl.M22] + v[webgl.M13] * m[webgl.M32];\n                t[webgl.M13] = v[webgl.M10] * m[webgl.M03] + v[webgl.M11] * m[webgl.M13] + v[webgl.M12] * m[webgl.M23] + v[webgl.M13] * m[webgl.M33];\n                t[webgl.M20] = v[webgl.M20] * m[webgl.M00] + v[webgl.M21] * m[webgl.M10] + v[webgl.M22] * m[webgl.M20] + v[webgl.M23] * m[webgl.M30];\n                t[webgl.M21] = v[webgl.M20] * m[webgl.M01] + v[webgl.M21] * m[webgl.M11] + v[webgl.M22] * m[webgl.M21] + v[webgl.M23] * m[webgl.M31];\n                t[webgl.M22] = v[webgl.M20] * m[webgl.M02] + v[webgl.M21] * m[webgl.M12] + v[webgl.M22] * m[webgl.M22] + v[webgl.M23] * m[webgl.M32];\n                t[webgl.M23] = v[webgl.M20] * m[webgl.M03] + v[webgl.M21] * m[webgl.M13] + v[webgl.M22] * m[webgl.M23] + v[webgl.M23] * m[webgl.M33];\n                t[webgl.M30] = v[webgl.M30] * m[webgl.M00] + v[webgl.M31] * m[webgl.M10] + v[webgl.M32] * m[webgl.M20] + v[webgl.M33] * m[webgl.M30];\n                t[webgl.M31] = v[webgl.M30] * m[webgl.M01] + v[webgl.M31] * m[webgl.M11] + v[webgl.M32] * m[webgl.M21] + v[webgl.M33] * m[webgl.M31];\n                t[webgl.M32] = v[webgl.M30] * m[webgl.M02] + v[webgl.M31] * m[webgl.M12] + v[webgl.M32] * m[webgl.M22] + v[webgl.M33] * m[webgl.M32];\n                t[webgl.M33] = v[webgl.M30] * m[webgl.M03] + v[webgl.M31] * m[webgl.M13] + v[webgl.M32] * m[webgl.M23] + v[webgl.M33] * m[webgl.M33];\n                return this.set(this.temp);\n            };\n            Matrix4.prototype.multiplyLeft = function (matrix) {\n                var t = this.temp;\n                var v = this.values;\n                var m = matrix.values;\n                t[webgl.M00] = m[webgl.M00] * v[webgl.M00] + m[webgl.M01] * v[webgl.M10] + m[webgl.M02] * v[webgl.M20] + m[webgl.M03] * v[webgl.M30];\n                t[webgl.M01] = m[webgl.M00] * v[webgl.M01] + m[webgl.M01] * v[webgl.M11] + m[webgl.M02] * v[webgl.M21] + m[webgl.M03] * v[webgl.M31];\n                t[webgl.M02] = m[webgl.M00] * v[webgl.M02] + m[webgl.M01] * v[webgl.M12] + m[webgl.M02] * v[webgl.M22] + m[webgl.M03] * v[webgl.M32];\n                t[webgl.M03] = m[webgl.M00] * v[webgl.M03] + m[webgl.M01] * v[webgl.M13] + m[webgl.M02] * v[webgl.M23] + m[webgl.M03] * v[webgl.M33];\n                t[webgl.M10] = m[webgl.M10] * v[webgl.M00] + m[webgl.M11] * v[webgl.M10] + m[webgl.M12] * v[webgl.M20] + m[webgl.M13] * v[webgl.M30];\n                t[webgl.M11] = m[webgl.M10] * v[webgl.M01] + m[webgl.M11] * v[webgl.M11] + m[webgl.M12] * v[webgl.M21] + m[webgl.M13] * v[webgl.M31];\n                t[webgl.M12] = m[webgl.M10] * v[webgl.M02] + m[webgl.M11] * v[webgl.M12] + m[webgl.M12] * v[webgl.M22] + m[webgl.M13] * v[webgl.M32];\n                t[webgl.M13] = m[webgl.M10] * v[webgl.M03] + m[webgl.M11] * v[webgl.M13] + m[webgl.M12] * v[webgl.M23] + m[webgl.M13] * v[webgl.M33];\n                t[webgl.M20] = m[webgl.M20] * v[webgl.M00] + m[webgl.M21] * v[webgl.M10] + m[webgl.M22] * v[webgl.M20] + m[webgl.M23] * v[webgl.M30];\n                t[webgl.M21] = m[webgl.M20] * v[webgl.M01] + m[webgl.M21] * v[webgl.M11] + m[webgl.M22] * v[webgl.M21] + m[webgl.M23] * v[webgl.M31];\n                t[webgl.M22] = m[webgl.M20] * v[webgl.M02] + m[webgl.M21] * v[webgl.M12] + m[webgl.M22] * v[webgl.M22] + m[webgl.M23] * v[webgl.M32];\n                t[webgl.M23] = m[webgl.M20] * v[webgl.M03] + m[webgl.M21] * v[webgl.M13] + m[webgl.M22] * v[webgl.M23] + m[webgl.M23] * v[webgl.M33];\n                t[webgl.M30] = m[webgl.M30] * v[webgl.M00] + m[webgl.M31] * v[webgl.M10] + m[webgl.M32] * v[webgl.M20] + m[webgl.M33] * v[webgl.M30];\n                t[webgl.M31] = m[webgl.M30] * v[webgl.M01] + m[webgl.M31] * v[webgl.M11] + m[webgl.M32] * v[webgl.M21] + m[webgl.M33] * v[webgl.M31];\n                t[webgl.M32] = m[webgl.M30] * v[webgl.M02] + m[webgl.M31] * v[webgl.M12] + m[webgl.M32] * v[webgl.M22] + m[webgl.M33] * v[webgl.M32];\n                t[webgl.M33] = m[webgl.M30] * v[webgl.M03] + m[webgl.M31] * v[webgl.M13] + m[webgl.M32] * v[webgl.M23] + m[webgl.M33] * v[webgl.M33];\n                return this.set(this.temp);\n            };\n            Matrix4.prototype.lookAt = function (position, direction, up) {\n                Matrix4.initTemps();\n                var xAxis = Matrix4.xAxis, yAxis = Matrix4.yAxis, zAxis = Matrix4.zAxis;\n                zAxis.setFrom(direction).normalize();\n                xAxis.setFrom(direction).normalize();\n                xAxis.cross(up).normalize();\n                yAxis.setFrom(xAxis).cross(zAxis).normalize();\n                this.identity();\n                var val = this.values;\n                val[webgl.M00] = xAxis.x;\n                val[webgl.M01] = xAxis.y;\n                val[webgl.M02] = xAxis.z;\n                val[webgl.M10] = yAxis.x;\n                val[webgl.M11] = yAxis.y;\n                val[webgl.M12] = yAxis.z;\n                val[webgl.M20] = -zAxis.x;\n                val[webgl.M21] = -zAxis.y;\n                val[webgl.M22] = -zAxis.z;\n                Matrix4.tmpMatrix.identity();\n                Matrix4.tmpMatrix.values[webgl.M03] = -position.x;\n                Matrix4.tmpMatrix.values[webgl.M13] = -position.y;\n                Matrix4.tmpMatrix.values[webgl.M23] = -position.z;\n                this.multiply(Matrix4.tmpMatrix);\n                return this;\n            };\n            Matrix4.initTemps = function () {\n                if (Matrix4.xAxis === null)\n                    Matrix4.xAxis = new webgl.Vector3();\n                if (Matrix4.yAxis === null)\n                    Matrix4.yAxis = new webgl.Vector3();\n                if (Matrix4.zAxis === null)\n                    Matrix4.zAxis = new webgl.Vector3();\n            };\n            Matrix4.xAxis = null;\n            Matrix4.yAxis = null;\n            Matrix4.zAxis = null;\n            Matrix4.tmpMatrix = new Matrix4();\n            return Matrix4;\n        }());\n        webgl.Matrix4 = Matrix4;\n    })(webgl = spine.webgl || (spine.webgl = {}));\n})(spine || (spine = {}));\nvar spine;\n(function (spine) {\n    var webgl;\n    (function (webgl) {\n        var Mesh = (function () {\n            function Mesh(context, attributes, maxVertices, maxIndices) {\n                this.attributes = attributes;\n                this.verticesLength = 0;\n                this.dirtyVertices = false;\n                this.indicesLength = 0;\n                this.dirtyIndices = false;\n                this.elementsPerVertex = 0;\n                this.context = context instanceof webgl.ManagedWebGLRenderingContext ? context : new webgl.ManagedWebGLRenderingContext(context);\n                this.elementsPerVertex = 0;\n                for (var i = 0; i < attributes.length; i++) {\n                    this.elementsPerVertex += attributes[i].numElements;\n                }\n                this.vertices = new Float32Array(maxVertices * this.elementsPerVertex);\n                this.indices = new Uint16Array(maxIndices);\n                this.context.addRestorable(this);\n            }\n            Mesh.prototype.getAttributes = function () { return this.attributes; };\n            Mesh.prototype.maxVertices = function () { return this.vertices.length / this.elementsPerVertex; };\n            Mesh.prototype.numVertices = function () { return this.verticesLength / this.elementsPerVertex; };\n            Mesh.prototype.setVerticesLength = function (length) {\n                this.dirtyVertices = true;\n                this.verticesLength = length;\n            };\n            Mesh.prototype.getVertices = function () { return this.vertices; };\n            Mesh.prototype.maxIndices = function () { return this.indices.length; };\n            Mesh.prototype.numIndices = function () { return this.indicesLength; };\n            Mesh.prototype.setIndicesLength = function (length) {\n                this.dirtyIndices = true;\n                this.indicesLength = length;\n            };\n            Mesh.prototype.getIndices = function () { return this.indices; };\n            ;\n            Mesh.prototype.getVertexSizeInFloats = function () {\n                var size = 0;\n                for (var i = 0; i < this.attributes.length; i++) {\n                    var attribute = this.attributes[i];\n                    size += attribute.numElements;\n                }\n                return size;\n            };\n            Mesh.prototype.setVertices = function (vertices) {\n                this.dirtyVertices = true;\n                if (vertices.length > this.vertices.length)\n                    throw Error(\"Mesh can't store more than \" + this.maxVertices() + \" vertices\");\n                this.vertices.set(vertices, 0);\n                this.verticesLength = vertices.length;\n            };\n            Mesh.prototype.setIndices = function (indices) {\n                this.dirtyIndices = true;\n                if (indices.length > this.indices.length)\n                    throw Error(\"Mesh can't store more than \" + this.maxIndices() + \" indices\");\n                this.indices.set(indices, 0);\n                this.indicesLength = indices.length;\n            };\n            Mesh.prototype.draw = function (shader, primitiveType) {\n                this.drawWithOffset(shader, primitiveType, 0, this.indicesLength > 0 ? this.indicesLength : this.verticesLength / this.elementsPerVertex);\n            };\n            Mesh.prototype.drawWithOffset = function (shader, primitiveType, offset, count) {\n                var gl = this.context.gl;\n                if (this.dirtyVertices || this.dirtyIndices)\n                    this.update();\n                this.bind(shader);\n                if (this.indicesLength > 0) {\n                    gl.drawElements(primitiveType, count, gl.UNSIGNED_SHORT, offset * 2);\n                }\n                else {\n                    gl.drawArrays(primitiveType, offset, count);\n                }\n                this.unbind(shader);\n            };\n            Mesh.prototype.bind = function (shader) {\n                var gl = this.context.gl;\n                gl.bindBuffer(gl.ARRAY_BUFFER, this.verticesBuffer);\n                var offset = 0;\n                for (var i = 0; i < this.attributes.length; i++) {\n                    var attrib = this.attributes[i];\n                    var location_1 = shader.getAttributeLocation(attrib.name);\n                    gl.enableVertexAttribArray(location_1);\n                    gl.vertexAttribPointer(location_1, attrib.numElements, gl.FLOAT, false, this.elementsPerVertex * 4, offset * 4);\n                    offset += attrib.numElements;\n                }\n                if (this.indicesLength > 0)\n                    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indicesBuffer);\n            };\n            Mesh.prototype.unbind = function (shader) {\n                var gl = this.context.gl;\n                for (var i = 0; i < this.attributes.length; i++) {\n                    var attrib = this.attributes[i];\n                    var location_2 = shader.getAttributeLocation(attrib.name);\n                    gl.disableVertexAttribArray(location_2);\n                }\n                gl.bindBuffer(gl.ARRAY_BUFFER, null);\n                if (this.indicesLength > 0)\n                    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);\n            };\n            Mesh.prototype.update = function () {\n                var gl = this.context.gl;\n                if (this.dirtyVertices) {\n                    if (!this.verticesBuffer) {\n                        this.verticesBuffer = gl.createBuffer();\n                    }\n                    gl.bindBuffer(gl.ARRAY_BUFFER, this.verticesBuffer);\n                    gl.bufferData(gl.ARRAY_BUFFER, this.vertices.subarray(0, this.verticesLength), gl.DYNAMIC_DRAW);\n                    this.dirtyVertices = false;\n                }\n                if (this.dirtyIndices) {\n                    if (!this.indicesBuffer) {\n                        this.indicesBuffer = gl.createBuffer();\n                    }\n                    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indicesBuffer);\n                    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.indices.subarray(0, this.indicesLength), gl.DYNAMIC_DRAW);\n                    this.dirtyIndices = false;\n                }\n            };\n            Mesh.prototype.restore = function () {\n                this.verticesBuffer = null;\n                this.indicesBuffer = null;\n                this.update();\n            };\n            Mesh.prototype.dispose = function () {\n                this.context.removeRestorable(this);\n                var gl = this.context.gl;\n                gl.deleteBuffer(this.verticesBuffer);\n                gl.deleteBuffer(this.indicesBuffer);\n            };\n            return Mesh;\n        }());\n        webgl.Mesh = Mesh;\n        var VertexAttribute = (function () {\n            function VertexAttribute(name, type, numElements) {\n                this.name = name;\n                this.type = type;\n                this.numElements = numElements;\n            }\n            return VertexAttribute;\n        }());\n        webgl.VertexAttribute = VertexAttribute;\n        var Position2Attribute = (function (_super) {\n            __extends(Position2Attribute, _super);\n            function Position2Attribute() {\n                return _super.call(this, webgl.Shader.POSITION, VertexAttributeType.Float, 2) || this;\n            }\n            return Position2Attribute;\n        }(VertexAttribute));\n        webgl.Position2Attribute = Position2Attribute;\n        var Position3Attribute = (function (_super) {\n            __extends(Position3Attribute, _super);\n            function Position3Attribute() {\n                return _super.call(this, webgl.Shader.POSITION, VertexAttributeType.Float, 3) || this;\n            }\n            return Position3Attribute;\n        }(VertexAttribute));\n        webgl.Position3Attribute = Position3Attribute;\n        var TexCoordAttribute = (function (_super) {\n            __extends(TexCoordAttribute, _super);\n            function TexCoordAttribute(unit) {\n                if (unit === void 0) { unit = 0; }\n                return _super.call(this, webgl.Shader.TEXCOORDS + (unit == 0 ? \"\" : unit), VertexAttributeType.Float, 2) || this;\n            }\n            return TexCoordAttribute;\n        }(VertexAttribute));\n        webgl.TexCoordAttribute = TexCoordAttribute;\n        var ColorAttribute = (function (_super) {\n            __extends(ColorAttribute, _super);\n            function ColorAttribute() {\n                return _super.call(this, webgl.Shader.COLOR, VertexAttributeType.Float, 4) || this;\n            }\n            return ColorAttribute;\n        }(VertexAttribute));\n        webgl.ColorAttribute = ColorAttribute;\n        var Color2Attribute = (function (_super) {\n            __extends(Color2Attribute, _super);\n            function Color2Attribute() {\n                return _super.call(this, webgl.Shader.COLOR2, VertexAttributeType.Float, 4) || this;\n            }\n            return Color2Attribute;\n        }(VertexAttribute));\n        webgl.Color2Attribute = Color2Attribute;\n        var VertexAttributeType;\n        (function (VertexAttributeType) {\n            VertexAttributeType[VertexAttributeType[\"Float\"] = 0] = \"Float\";\n        })(VertexAttributeType = webgl.VertexAttributeType || (webgl.VertexAttributeType = {}));\n    })(webgl = spine.webgl || (spine.webgl = {}));\n})(spine || (spine = {}));\nvar spine;\n(function (spine) {\n    var webgl;\n    (function (webgl) {\n        var PolygonBatcher = (function () {\n            function PolygonBatcher(context, twoColorTint, maxVertices) {\n                if (twoColorTint === void 0) { twoColorTint = true; }\n                if (maxVertices === void 0) { maxVertices = 10920; }\n                this.isDrawing = false;\n                this.shader = null;\n                this.lastTexture = null;\n                this.verticesLength = 0;\n                this.indicesLength = 0;\n                if (maxVertices > 10920)\n                    throw new Error(\"Can't have more than 10920 triangles per batch: \" + maxVertices);\n                this.context = context instanceof webgl.ManagedWebGLRenderingContext ? context : new webgl.ManagedWebGLRenderingContext(context);\n                var attributes = twoColorTint ?\n                    [new webgl.Position2Attribute(), new webgl.ColorAttribute(), new webgl.TexCoordAttribute(), new webgl.Color2Attribute()] :\n                    [new webgl.Position2Attribute(), new webgl.ColorAttribute(), new webgl.TexCoordAttribute()];\n                this.mesh = new webgl.Mesh(context, attributes, maxVertices, maxVertices * 3);\n                this.srcBlend = this.context.gl.SRC_ALPHA;\n                this.dstBlend = this.context.gl.ONE_MINUS_SRC_ALPHA;\n            }\n            PolygonBatcher.prototype.begin = function (shader) {\n                var gl = this.context.gl;\n                if (this.isDrawing)\n                    throw new Error(\"PolygonBatch is already drawing. Call PolygonBatch.end() before calling PolygonBatch.begin()\");\n                this.drawCalls = 0;\n                this.shader = shader;\n                this.lastTexture = null;\n                this.isDrawing = true;\n                gl.enable(gl.BLEND);\n                gl.blendFunc(this.srcBlend, this.dstBlend);\n            };\n            PolygonBatcher.prototype.setBlendMode = function (srcBlend, dstBlend) {\n                var gl = this.context.gl;\n                this.srcBlend = srcBlend;\n                this.dstBlend = dstBlend;\n                if (this.isDrawing) {\n                    this.flush();\n                    gl.blendFunc(this.srcBlend, this.dstBlend);\n                }\n            };\n            PolygonBatcher.prototype.draw = function (texture, vertices, indices) {\n                if (texture != this.lastTexture) {\n                    this.flush();\n                    this.lastTexture = texture;\n                }\n                else if (this.verticesLength + vertices.length > this.mesh.getVertices().length ||\n                    this.indicesLength + indices.length > this.mesh.getIndices().length) {\n                    this.flush();\n                }\n                var indexStart = this.mesh.numVertices();\n                this.mesh.getVertices().set(vertices, this.verticesLength);\n                this.verticesLength += vertices.length;\n                this.mesh.setVerticesLength(this.verticesLength);\n                var indicesArray = this.mesh.getIndices();\n                for (var i = this.indicesLength, j = 0; j < indices.length; i++, j++)\n                    indicesArray[i] = indices[j] + indexStart;\n                this.indicesLength += indices.length;\n                this.mesh.setIndicesLength(this.indicesLength);\n            };\n            PolygonBatcher.prototype.flush = function () {\n                var gl = this.context.gl;\n                if (this.verticesLength == 0)\n                    return;\n                this.lastTexture.bind();\n                this.mesh.draw(this.shader, gl.TRIANGLES);\n                this.verticesLength = 0;\n                this.indicesLength = 0;\n                this.mesh.setVerticesLength(0);\n                this.mesh.setIndicesLength(0);\n                this.drawCalls++;\n            };\n            PolygonBatcher.prototype.end = function () {\n                var gl = this.context.gl;\n                if (!this.isDrawing)\n                    throw new Error(\"PolygonBatch is not drawing. Call PolygonBatch.begin() before calling PolygonBatch.end()\");\n                if (this.verticesLength > 0 || this.indicesLength > 0)\n                    this.flush();\n                this.shader = null;\n                this.lastTexture = null;\n                this.isDrawing = false;\n                gl.disable(gl.BLEND);\n            };\n            PolygonBatcher.prototype.getDrawCalls = function () { return this.drawCalls; };\n            PolygonBatcher.prototype.dispose = function () {\n                this.mesh.dispose();\n            };\n            return PolygonBatcher;\n        }());\n        webgl.PolygonBatcher = PolygonBatcher;\n    })(webgl = spine.webgl || (spine.webgl = {}));\n})(spine || (spine = {}));\nvar spine;\n(function (spine) {\n    var webgl;\n    (function (webgl) {\n        var SceneRenderer = (function () {\n            function SceneRenderer(canvas, context, twoColorTint) {\n                if (twoColorTint === void 0) { twoColorTint = true; }\n                this.twoColorTint = false;\n                this.activeRenderer = null;\n                this.QUAD = [\n                    0, 0, 1, 1, 1, 1, 0, 0,\n                    0, 0, 1, 1, 1, 1, 0, 0,\n                    0, 0, 1, 1, 1, 1, 0, 0,\n                    0, 0, 1, 1, 1, 1, 0, 0,\n                ];\n                this.QUAD_TRIANGLES = [0, 1, 2, 2, 3, 0];\n                this.WHITE = new spine.Color(1, 1, 1, 1);\n                this.canvas = canvas;\n                this.context = context instanceof webgl.ManagedWebGLRenderingContext ? context : new webgl.ManagedWebGLRenderingContext(context);\n                this.twoColorTint = twoColorTint;\n                this.camera = new webgl.OrthoCamera(canvas.width, canvas.height);\n                this.batcherShader = twoColorTint ? webgl.Shader.newTwoColoredTextured(this.context) : webgl.Shader.newColoredTextured(this.context);\n                this.batcher = new webgl.PolygonBatcher(this.context, twoColorTint);\n                this.shapesShader = webgl.Shader.newColored(this.context);\n                this.shapes = new webgl.ShapeRenderer(this.context);\n                this.skeletonRenderer = new webgl.SkeletonRenderer(this.context, twoColorTint);\n                this.skeletonDebugRenderer = new webgl.SkeletonDebugRenderer(this.context);\n            }\n            SceneRenderer.prototype.begin = function () {\n                this.camera.update();\n                this.enableRenderer(this.batcher);\n            };\n            SceneRenderer.prototype.drawSkeleton = function (skeleton, premultipliedAlpha, slotRangeStart, slotRangeEnd) {\n                if (premultipliedAlpha === void 0) { premultipliedAlpha = false; }\n                if (slotRangeStart === void 0) { slotRangeStart = -1; }\n                if (slotRangeEnd === void 0) { slotRangeEnd = -1; }\n                this.enableRenderer(this.batcher);\n                this.skeletonRenderer.premultipliedAlpha = premultipliedAlpha;\n                this.skeletonRenderer.draw(this.batcher, skeleton, slotRangeStart, slotRangeEnd);\n            };\n            SceneRenderer.prototype.drawSkeletonDebug = function (skeleton, premultipliedAlpha, ignoredBones) {\n                if (premultipliedAlpha === void 0) { premultipliedAlpha = false; }\n                if (ignoredBones === void 0) { ignoredBones = null; }\n                this.enableRenderer(this.shapes);\n                this.skeletonDebugRenderer.premultipliedAlpha = premultipliedAlpha;\n                this.skeletonDebugRenderer.draw(this.shapes, skeleton, ignoredBones);\n            };\n            SceneRenderer.prototype.drawTexture = function (texture, x, y, width, height, color) {\n                if (color === void 0) { color = null; }\n                this.enableRenderer(this.batcher);\n                if (color === null)\n                    color = this.WHITE;\n                var quad = this.QUAD;\n                var i = 0;\n                quad[i++] = x;\n                quad[i++] = y;\n                quad[i++] = color.r;\n                quad[i++] = color.g;\n                quad[i++] = color.b;\n                quad[i++] = color.a;\n                quad[i++] = 0;\n                quad[i++] = 1;\n                if (this.twoColorTint) {\n                    quad[i++] = 0;\n                    quad[i++] = 0;\n                    quad[i++] = 0;\n                    quad[i++] = 0;\n                }\n                quad[i++] = x + width;\n                quad[i++] = y;\n                quad[i++] = color.r;\n                quad[i++] = color.g;\n                quad[i++] = color.b;\n                quad[i++] = color.a;\n                quad[i++] = 1;\n                quad[i++] = 1;\n                if (this.twoColorTint) {\n                    quad[i++] = 0;\n                    quad[i++] = 0;\n                    quad[i++] = 0;\n                    quad[i++] = 0;\n                }\n                quad[i++] = x + width;\n                quad[i++] = y + height;\n                quad[i++] = color.r;\n                quad[i++] = color.g;\n                quad[i++] = color.b;\n                quad[i++] = color.a;\n                quad[i++] = 1;\n                quad[i++] = 0;\n                if (this.twoColorTint) {\n                    quad[i++] = 0;\n                    quad[i++] = 0;\n                    quad[i++] = 0;\n                    quad[i++] = 0;\n                }\n                quad[i++] = x;\n                quad[i++] = y + height;\n                quad[i++] = color.r;\n                quad[i++] = color.g;\n                quad[i++] = color.b;\n                quad[i++] = color.a;\n                quad[i++] = 0;\n                quad[i++] = 0;\n                if (this.twoColorTint) {\n                    quad[i++] = 0;\n                    quad[i++] = 0;\n                    quad[i++] = 0;\n                    quad[i++] = 0;\n                }\n                this.batcher.draw(texture, quad, this.QUAD_TRIANGLES);\n            };\n            SceneRenderer.prototype.drawTextureUV = function (texture, x, y, width, height, u, v, u2, v2, color) {\n                if (color === void 0) { color = null; }\n                this.enableRenderer(this.batcher);\n                if (color === null)\n                    color = this.WHITE;\n                var quad = this.QUAD;\n                var i = 0;\n                quad[i++] = x;\n                quad[i++] = y;\n                quad[i++] = color.r;\n                quad[i++] = color.g;\n                quad[i++] = color.b;\n                quad[i++] = color.a;\n                quad[i++] = u;\n                quad[i++] = v;\n                if (this.twoColorTint) {\n                    quad[i++] = 0;\n                    quad[i++] = 0;\n                    quad[i++] = 0;\n                    quad[i++] = 0;\n                }\n                quad[i++] = x + width;\n                quad[i++] = y;\n                quad[i++] = color.r;\n                quad[i++] = color.g;\n                quad[i++] = color.b;\n                quad[i++] = color.a;\n                quad[i++] = u2;\n                quad[i++] = v;\n                if (this.twoColorTint) {\n                    quad[i++] = 0;\n                    quad[i++] = 0;\n                    quad[i++] = 0;\n                    quad[i++] = 0;\n                }\n                quad[i++] = x + width;\n                quad[i++] = y + height;\n                quad[i++] = color.r;\n                quad[i++] = color.g;\n                quad[i++] = color.b;\n                quad[i++] = color.a;\n                quad[i++] = u2;\n                quad[i++] = v2;\n                if (this.twoColorTint) {\n                    quad[i++] = 0;\n                    quad[i++] = 0;\n                    quad[i++] = 0;\n                    quad[i++] = 0;\n                }\n                quad[i++] = x;\n                quad[i++] = y + height;\n                quad[i++] = color.r;\n                quad[i++] = color.g;\n                quad[i++] = color.b;\n                quad[i++] = color.a;\n                quad[i++] = u;\n                quad[i++] = v2;\n                if (this.twoColorTint) {\n                    quad[i++] = 0;\n                    quad[i++] = 0;\n                    quad[i++] = 0;\n                    quad[i++] = 0;\n                }\n                this.batcher.draw(texture, quad, this.QUAD_TRIANGLES);\n            };\n            SceneRenderer.prototype.drawTextureRotated = function (texture, x, y, width, height, pivotX, pivotY, angle, color, premultipliedAlpha) {\n                if (color === void 0) { color = null; }\n                if (premultipliedAlpha === void 0) { premultipliedAlpha = false; }\n                this.enableRenderer(this.batcher);\n                if (color === null)\n                    color = this.WHITE;\n                var quad = this.QUAD;\n                var worldOriginX = x + pivotX;\n                var worldOriginY = y + pivotY;\n                var fx = -pivotX;\n                var fy = -pivotY;\n                var fx2 = width - pivotX;\n                var fy2 = height - pivotY;\n                var p1x = fx;\n                var p1y = fy;\n                var p2x = fx;\n                var p2y = fy2;\n                var p3x = fx2;\n                var p3y = fy2;\n                var p4x = fx2;\n                var p4y = fy;\n                var x1 = 0;\n                var y1 = 0;\n                var x2 = 0;\n                var y2 = 0;\n                var x3 = 0;\n                var y3 = 0;\n                var x4 = 0;\n                var y4 = 0;\n                if (angle != 0) {\n                    var cos = spine.MathUtils.cosDeg(angle);\n                    var sin = spine.MathUtils.sinDeg(angle);\n                    x1 = cos * p1x - sin * p1y;\n                    y1 = sin * p1x + cos * p1y;\n                    x4 = cos * p2x - sin * p2y;\n                    y4 = sin * p2x + cos * p2y;\n                    x3 = cos * p3x - sin * p3y;\n                    y3 = sin * p3x + cos * p3y;\n                    x2 = x3 + (x1 - x4);\n                    y2 = y3 + (y1 - y4);\n                }\n                else {\n                    x1 = p1x;\n                    y1 = p1y;\n                    x4 = p2x;\n                    y4 = p2y;\n                    x3 = p3x;\n                    y3 = p3y;\n                    x2 = p4x;\n                    y2 = p4y;\n                }\n                x1 += worldOriginX;\n                y1 += worldOriginY;\n                x2 += worldOriginX;\n                y2 += worldOriginY;\n                x3 += worldOriginX;\n                y3 += worldOriginY;\n                x4 += worldOriginX;\n                y4 += worldOriginY;\n                var i = 0;\n                quad[i++] = x1;\n                quad[i++] = y1;\n                quad[i++] = color.r;\n                quad[i++] = color.g;\n                quad[i++] = color.b;\n                quad[i++] = color.a;\n                quad[i++] = 0;\n                quad[i++] = 1;\n                if (this.twoColorTint) {\n                    quad[i++] = 0;\n                    quad[i++] = 0;\n                    quad[i++] = 0;\n                    quad[i++] = 0;\n                }\n                quad[i++] = x2;\n                quad[i++] = y2;\n                quad[i++] = color.r;\n                quad[i++] = color.g;\n                quad[i++] = color.b;\n                quad[i++] = color.a;\n                quad[i++] = 1;\n                quad[i++] = 1;\n                if (this.twoColorTint) {\n                    quad[i++] = 0;\n                    quad[i++] = 0;\n                    quad[i++] = 0;\n                    quad[i++] = 0;\n                }\n                quad[i++] = x3;\n                quad[i++] = y3;\n                quad[i++] = color.r;\n                quad[i++] = color.g;\n                quad[i++] = color.b;\n                quad[i++] = color.a;\n                quad[i++] = 1;\n                quad[i++] = 0;\n                if (this.twoColorTint) {\n                    quad[i++] = 0;\n                    quad[i++] = 0;\n                    quad[i++] = 0;\n                    quad[i++] = 0;\n                }\n                quad[i++] = x4;\n                quad[i++] = y4;\n                quad[i++] = color.r;\n                quad[i++] = color.g;\n                quad[i++] = color.b;\n                quad[i++] = color.a;\n                quad[i++] = 0;\n                quad[i++] = 0;\n                if (this.twoColorTint) {\n                    quad[i++] = 0;\n                    quad[i++] = 0;\n                    quad[i++] = 0;\n                    quad[i++] = 0;\n                }\n                this.batcher.draw(texture, quad, this.QUAD_TRIANGLES);\n            };\n            SceneRenderer.prototype.drawRegion = function (region, x, y, width, height, color, premultipliedAlpha) {\n                if (color === void 0) { color = null; }\n                if (premultipliedAlpha === void 0) { premultipliedAlpha = false; }\n                this.enableRenderer(this.batcher);\n                if (color === null)\n                    color = this.WHITE;\n                var quad = this.QUAD;\n                var i = 0;\n                quad[i++] = x;\n                quad[i++] = y;\n                quad[i++] = color.r;\n                quad[i++] = color.g;\n                quad[i++] = color.b;\n                quad[i++] = color.a;\n                quad[i++] = region.u;\n                quad[i++] = region.v2;\n                if (this.twoColorTint) {\n                    quad[i++] = 0;\n                    quad[i++] = 0;\n                    quad[i++] = 0;\n                    quad[i++] = 0;\n                }\n                quad[i++] = x + width;\n                quad[i++] = y;\n                quad[i++] = color.r;\n                quad[i++] = color.g;\n                quad[i++] = color.b;\n                quad[i++] = color.a;\n                quad[i++] = region.u2;\n                quad[i++] = region.v2;\n                if (this.twoColorTint) {\n                    quad[i++] = 0;\n                    quad[i++] = 0;\n                    quad[i++] = 0;\n                    quad[i++] = 0;\n                }\n                quad[i++] = x + width;\n                quad[i++] = y + height;\n                quad[i++] = color.r;\n                quad[i++] = color.g;\n                quad[i++] = color.b;\n                quad[i++] = color.a;\n                quad[i++] = region.u2;\n                quad[i++] = region.v;\n                if (this.twoColorTint) {\n                    quad[i++] = 0;\n                    quad[i++] = 0;\n                    quad[i++] = 0;\n                    quad[i++] = 0;\n                }\n                quad[i++] = x;\n                quad[i++] = y + height;\n                quad[i++] = color.r;\n                quad[i++] = color.g;\n                quad[i++] = color.b;\n                quad[i++] = color.a;\n                quad[i++] = region.u;\n                quad[i++] = region.v;\n                if (this.twoColorTint) {\n                    quad[i++] = 0;\n                    quad[i++] = 0;\n                    quad[i++] = 0;\n                    quad[i++] = 0;\n                }\n                this.batcher.draw(region.texture, quad, this.QUAD_TRIANGLES);\n            };\n            SceneRenderer.prototype.line = function (x, y, x2, y2, color, color2) {\n                if (color === void 0) { color = null; }\n                if (color2 === void 0) { color2 = null; }\n                this.enableRenderer(this.shapes);\n                this.shapes.line(x, y, x2, y2, color);\n            };\n            SceneRenderer.prototype.triangle = function (filled, x, y, x2, y2, x3, y3, color, color2, color3) {\n                if (color === void 0) { color = null; }\n                if (color2 === void 0) { color2 = null; }\n                if (color3 === void 0) { color3 = null; }\n                this.enableRenderer(this.shapes);\n                this.shapes.triangle(filled, x, y, x2, y2, x3, y3, color, color2, color3);\n            };\n            SceneRenderer.prototype.quad = function (filled, x, y, x2, y2, x3, y3, x4, y4, color, color2, color3, color4) {\n                if (color === void 0) { color = null; }\n                if (color2 === void 0) { color2 = null; }\n                if (color3 === void 0) { color3 = null; }\n                if (color4 === void 0) { color4 = null; }\n                this.enableRenderer(this.shapes);\n                this.shapes.quad(filled, x, y, x2, y2, x3, y3, x4, y4, color, color2, color3, color4);\n            };\n            SceneRenderer.prototype.rect = function (filled, x, y, width, height, color) {\n                if (color === void 0) { color = null; }\n                this.enableRenderer(this.shapes);\n                this.shapes.rect(filled, x, y, width, height, color);\n            };\n            SceneRenderer.prototype.rectLine = function (filled, x1, y1, x2, y2, width, color) {\n                if (color === void 0) { color = null; }\n                this.enableRenderer(this.shapes);\n                this.shapes.rectLine(filled, x1, y1, x2, y2, width, color);\n            };\n            SceneRenderer.prototype.polygon = function (polygonVertices, offset, count, color) {\n                if (color === void 0) { color = null; }\n                this.enableRenderer(this.shapes);\n                this.shapes.polygon(polygonVertices, offset, count, color);\n            };\n            SceneRenderer.prototype.circle = function (filled, x, y, radius, color, segments) {\n                if (color === void 0) { color = null; }\n                if (segments === void 0) { segments = 0; }\n                this.enableRenderer(this.shapes);\n                this.shapes.circle(filled, x, y, radius, color, segments);\n            };\n            SceneRenderer.prototype.curve = function (x1, y1, cx1, cy1, cx2, cy2, x2, y2, segments, color) {\n                if (color === void 0) { color = null; }\n                this.enableRenderer(this.shapes);\n                this.shapes.curve(x1, y1, cx1, cy1, cx2, cy2, x2, y2, segments, color);\n            };\n            SceneRenderer.prototype.end = function () {\n                if (this.activeRenderer === this.batcher)\n                    this.batcher.end();\n                else if (this.activeRenderer === this.shapes)\n                    this.shapes.end();\n                this.activeRenderer = null;\n            };\n            SceneRenderer.prototype.resize = function (resizeMode) {\n                var canvas = this.canvas;\n                var w = canvas.clientWidth;\n                var h = canvas.clientHeight;\n                if (canvas.width != w || canvas.height != h) {\n                    canvas.width = w;\n                    canvas.height = h;\n                }\n                this.context.gl.viewport(0, 0, canvas.width, canvas.height);\n                if (resizeMode === ResizeMode.Stretch) {\n                }\n                else if (resizeMode === ResizeMode.Expand) {\n                    this.camera.setViewport(w, h);\n                }\n                else if (resizeMode === ResizeMode.Fit) {\n                    var sourceWidth = canvas.width, sourceHeight = canvas.height;\n                    var targetWidth = this.camera.viewportWidth, targetHeight = this.camera.viewportHeight;\n                    var targetRatio = targetHeight / targetWidth;\n                    var sourceRatio = sourceHeight / sourceWidth;\n                    var scale = targetRatio < sourceRatio ? targetWidth / sourceWidth : targetHeight / sourceHeight;\n                    this.camera.viewportWidth = sourceWidth * scale;\n                    this.camera.viewportHeight = sourceHeight * scale;\n                }\n                this.camera.update();\n            };\n            SceneRenderer.prototype.enableRenderer = function (renderer) {\n                if (this.activeRenderer === renderer)\n                    return;\n                this.end();\n                if (renderer instanceof webgl.PolygonBatcher) {\n                    this.batcherShader.bind();\n                    this.batcherShader.setUniform4x4f(webgl.Shader.MVP_MATRIX, this.camera.projectionView.values);\n                    this.batcherShader.setUniformi(\"u_texture\", 0);\n                    this.batcher.begin(this.batcherShader);\n                    this.activeRenderer = this.batcher;\n                }\n                else if (renderer instanceof webgl.ShapeRenderer) {\n                    this.shapesShader.bind();\n                    this.shapesShader.setUniform4x4f(webgl.Shader.MVP_MATRIX, this.camera.projectionView.values);\n                    this.shapes.begin(this.shapesShader);\n                    this.activeRenderer = this.shapes;\n                }\n                else {\n                    this.activeRenderer = this.skeletonDebugRenderer;\n                }\n            };\n            SceneRenderer.prototype.dispose = function () {\n                this.batcher.dispose();\n                this.batcherShader.dispose();\n                this.shapes.dispose();\n                this.shapesShader.dispose();\n                this.skeletonDebugRenderer.dispose();\n            };\n            return SceneRenderer;\n        }());\n        webgl.SceneRenderer = SceneRenderer;\n        var ResizeMode;\n        (function (ResizeMode) {\n            ResizeMode[ResizeMode[\"Stretch\"] = 0] = \"Stretch\";\n            ResizeMode[ResizeMode[\"Expand\"] = 1] = \"Expand\";\n            ResizeMode[ResizeMode[\"Fit\"] = 2] = \"Fit\";\n        })(ResizeMode = webgl.ResizeMode || (webgl.ResizeMode = {}));\n    })(webgl = spine.webgl || (spine.webgl = {}));\n})(spine || (spine = {}));\nvar spine;\n(function (spine) {\n    var webgl;\n    (function (webgl) {\n        var Shader = (function () {\n            function Shader(context, vertexShader, fragmentShader) {\n                this.vertexShader = vertexShader;\n                this.fragmentShader = fragmentShader;\n                this.vs = null;\n                this.fs = null;\n                this.program = null;\n                this.tmp2x2 = new Float32Array(2 * 2);\n                this.tmp3x3 = new Float32Array(3 * 3);\n                this.tmp4x4 = new Float32Array(4 * 4);\n                this.vsSource = vertexShader;\n                this.fsSource = fragmentShader;\n                this.context = context instanceof webgl.ManagedWebGLRenderingContext ? context : new webgl.ManagedWebGLRenderingContext(context);\n                this.context.addRestorable(this);\n                this.compile();\n            }\n            Shader.prototype.getProgram = function () { return this.program; };\n            Shader.prototype.getVertexShader = function () { return this.vertexShader; };\n            Shader.prototype.getFragmentShader = function () { return this.fragmentShader; };\n            Shader.prototype.getVertexShaderSource = function () { return this.vsSource; };\n            Shader.prototype.getFragmentSource = function () { return this.fsSource; };\n            Shader.prototype.compile = function () {\n                var gl = this.context.gl;\n                try {\n                    this.vs = this.compileShader(gl.VERTEX_SHADER, this.vertexShader);\n                    this.fs = this.compileShader(gl.FRAGMENT_SHADER, this.fragmentShader);\n                    this.program = this.compileProgram(this.vs, this.fs);\n                }\n                catch (e) {\n                    this.dispose();\n                    throw e;\n                }\n            };\n            Shader.prototype.compileShader = function (type, source) {\n                var gl = this.context.gl;\n                var shader = gl.createShader(type);\n                gl.shaderSource(shader, source);\n                gl.compileShader(shader);\n                if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n                    var error = \"Couldn't compile shader: \" + gl.getShaderInfoLog(shader);\n                    gl.deleteShader(shader);\n                    if (!gl.isContextLost())\n                        throw new Error(error);\n                }\n                return shader;\n            };\n            Shader.prototype.compileProgram = function (vs, fs) {\n                var gl = this.context.gl;\n                var program = gl.createProgram();\n                gl.attachShader(program, vs);\n                gl.attachShader(program, fs);\n                gl.linkProgram(program);\n                if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n                    var error = \"Couldn't compile shader program: \" + gl.getProgramInfoLog(program);\n                    gl.deleteProgram(program);\n                    if (!gl.isContextLost())\n                        throw new Error(error);\n                }\n                return program;\n            };\n            Shader.prototype.restore = function () {\n                this.compile();\n            };\n            Shader.prototype.bind = function () {\n                this.context.gl.useProgram(this.program);\n            };\n            Shader.prototype.unbind = function () {\n                this.context.gl.useProgram(null);\n            };\n            Shader.prototype.setUniformi = function (uniform, value) {\n                this.context.gl.uniform1i(this.getUniformLocation(uniform), value);\n            };\n            Shader.prototype.setUniformf = function (uniform, value) {\n                this.context.gl.uniform1f(this.getUniformLocation(uniform), value);\n            };\n            Shader.prototype.setUniform2f = function (uniform, value, value2) {\n                this.context.gl.uniform2f(this.getUniformLocation(uniform), value, value2);\n            };\n            Shader.prototype.setUniform3f = function (uniform, value, value2, value3) {\n                this.context.gl.uniform3f(this.getUniformLocation(uniform), value, value2, value3);\n            };\n            Shader.prototype.setUniform4f = function (uniform, value, value2, value3, value4) {\n                this.context.gl.uniform4f(this.getUniformLocation(uniform), value, value2, value3, value4);\n            };\n            Shader.prototype.setUniform2x2f = function (uniform, value) {\n                var gl = this.context.gl;\n                this.tmp2x2.set(value);\n                gl.uniformMatrix2fv(this.getUniformLocation(uniform), false, this.tmp2x2);\n            };\n            Shader.prototype.setUniform3x3f = function (uniform, value) {\n                var gl = this.context.gl;\n                this.tmp3x3.set(value);\n                gl.uniformMatrix3fv(this.getUniformLocation(uniform), false, this.tmp3x3);\n            };\n            Shader.prototype.setUniform4x4f = function (uniform, value) {\n                var gl = this.context.gl;\n                this.tmp4x4.set(value);\n                gl.uniformMatrix4fv(this.getUniformLocation(uniform), false, this.tmp4x4);\n            };\n            Shader.prototype.getUniformLocation = function (uniform) {\n                var gl = this.context.gl;\n                var location = gl.getUniformLocation(this.program, uniform);\n                if (!location && !gl.isContextLost())\n                    throw new Error(\"Couldn't find location for uniform \" + uniform);\n                return location;\n            };\n            Shader.prototype.getAttributeLocation = function (attribute) {\n                var gl = this.context.gl;\n                var location = gl.getAttribLocation(this.program, attribute);\n                if (location == -1 && !gl.isContextLost())\n                    throw new Error(\"Couldn't find location for attribute \" + attribute);\n                return location;\n            };\n            Shader.prototype.dispose = function () {\n                this.context.removeRestorable(this);\n                var gl = this.context.gl;\n                if (this.vs) {\n                    gl.deleteShader(this.vs);\n                    this.vs = null;\n                }\n                if (this.fs) {\n                    gl.deleteShader(this.fs);\n                    this.fs = null;\n                }\n                if (this.program) {\n                    gl.deleteProgram(this.program);\n                    this.program = null;\n                }\n            };\n            Shader.newColoredTextured = function (context) {\n                var vs = \"\\n\\t\\t\\t\\tattribute vec4 \" + Shader.POSITION + \";\\n\\t\\t\\t\\tattribute vec4 \" + Shader.COLOR + \";\\n\\t\\t\\t\\tattribute vec2 \" + Shader.TEXCOORDS + \";\\n\\t\\t\\t\\tuniform mat4 \" + Shader.MVP_MATRIX + \";\\n\\t\\t\\t\\tvarying vec4 v_color;\\n\\t\\t\\t\\tvarying vec2 v_texCoords;\\n\\n\\t\\t\\t\\tvoid main () {\\n\\t\\t\\t\\t\\tv_color = \" + Shader.COLOR + \";\\n\\t\\t\\t\\t\\tv_texCoords = \" + Shader.TEXCOORDS + \";\\n\\t\\t\\t\\t\\tgl_Position = \" + Shader.MVP_MATRIX + \" * \" + Shader.POSITION + \";\\n\\t\\t\\t\\t}\\n\\t\\t\\t\";\n                var fs = \"\\n\\t\\t\\t\\t#ifdef GL_ES\\n\\t\\t\\t\\t\\t#define LOWP lowp\\n\\t\\t\\t\\t\\tprecision mediump float;\\n\\t\\t\\t\\t#else\\n\\t\\t\\t\\t\\t#define LOWP\\n\\t\\t\\t\\t#endif\\n\\t\\t\\t\\tvarying LOWP vec4 v_color;\\n\\t\\t\\t\\tvarying vec2 v_texCoords;\\n\\t\\t\\t\\tuniform sampler2D u_texture;\\n\\n\\t\\t\\t\\tvoid main () {\\n\\t\\t\\t\\t\\tgl_FragColor = v_color * texture2D(u_texture, v_texCoords);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\";\n                return new Shader(context, vs, fs);\n            };\n            Shader.newTwoColoredTextured = function (context) {\n                var vs = \"\\n\\t\\t\\t\\tattribute vec4 \" + Shader.POSITION + \";\\n\\t\\t\\t\\tattribute vec4 \" + Shader.COLOR + \";\\n\\t\\t\\t\\tattribute vec4 \" + Shader.COLOR2 + \";\\n\\t\\t\\t\\tattribute vec2 \" + Shader.TEXCOORDS + \";\\n\\t\\t\\t\\tuniform mat4 \" + Shader.MVP_MATRIX + \";\\n\\t\\t\\t\\tvarying vec4 v_light;\\n\\t\\t\\t\\tvarying vec4 v_dark;\\n\\t\\t\\t\\tvarying vec2 v_texCoords;\\n\\n\\t\\t\\t\\tvoid main () {\\n\\t\\t\\t\\t\\tv_light = \" + Shader.COLOR + \";\\n\\t\\t\\t\\t\\tv_dark = \" + Shader.COLOR2 + \";\\n\\t\\t\\t\\t\\tv_texCoords = \" + Shader.TEXCOORDS + \";\\n\\t\\t\\t\\t\\tgl_Position = \" + Shader.MVP_MATRIX + \" * \" + Shader.POSITION + \";\\n\\t\\t\\t\\t}\\n\\t\\t\\t\";\n                var fs = \"\\n\\t\\t\\t\\t#ifdef GL_ES\\n\\t\\t\\t\\t\\t#define LOWP lowp\\n\\t\\t\\t\\t\\tprecision mediump float;\\n\\t\\t\\t\\t#else\\n\\t\\t\\t\\t\\t#define LOWP\\n\\t\\t\\t\\t#endif\\n\\t\\t\\t\\tvarying LOWP vec4 v_light;\\n\\t\\t\\t\\tvarying LOWP vec4 v_dark;\\n\\t\\t\\t\\tvarying vec2 v_texCoords;\\n\\t\\t\\t\\tuniform sampler2D u_texture;\\n\\n\\t\\t\\t\\tvoid main () {\\n\\t\\t\\t\\t\\tvec4 texColor = texture2D(u_texture, v_texCoords);\\n\\t\\t\\t\\t\\tgl_FragColor.a = texColor.a * v_light.a;\\n\\t\\t\\t\\t\\tgl_FragColor.rgb = ((texColor.a - 1.0) * v_dark.a + 1.0 - texColor.rgb) * v_dark.rgb + texColor.rgb * v_light.rgb;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\";\n                return new Shader(context, vs, fs);\n            };\n            Shader.newColored = function (context) {\n                var vs = \"\\n\\t\\t\\t\\tattribute vec4 \" + Shader.POSITION + \";\\n\\t\\t\\t\\tattribute vec4 \" + Shader.COLOR + \";\\n\\t\\t\\t\\tuniform mat4 \" + Shader.MVP_MATRIX + \";\\n\\t\\t\\t\\tvarying vec4 v_color;\\n\\n\\t\\t\\t\\tvoid main () {\\n\\t\\t\\t\\t\\tv_color = \" + Shader.COLOR + \";\\n\\t\\t\\t\\t\\tgl_Position = \" + Shader.MVP_MATRIX + \" * \" + Shader.POSITION + \";\\n\\t\\t\\t\\t}\\n\\t\\t\\t\";\n                var fs = \"\\n\\t\\t\\t\\t#ifdef GL_ES\\n\\t\\t\\t\\t\\t#define LOWP lowp\\n\\t\\t\\t\\t\\tprecision mediump float;\\n\\t\\t\\t\\t#else\\n\\t\\t\\t\\t\\t#define LOWP\\n\\t\\t\\t\\t#endif\\n\\t\\t\\t\\tvarying LOWP vec4 v_color;\\n\\n\\t\\t\\t\\tvoid main () {\\n\\t\\t\\t\\t\\tgl_FragColor = v_color;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\";\n                return new Shader(context, vs, fs);\n            };\n            Shader.MVP_MATRIX = \"u_projTrans\";\n            Shader.POSITION = \"a_position\";\n            Shader.COLOR = \"a_color\";\n            Shader.COLOR2 = \"a_color2\";\n            Shader.TEXCOORDS = \"a_texCoords\";\n            Shader.SAMPLER = \"u_texture\";\n            return Shader;\n        }());\n        webgl.Shader = Shader;\n    })(webgl = spine.webgl || (spine.webgl = {}));\n})(spine || (spine = {}));\nvar spine;\n(function (spine) {\n    var webgl;\n    (function (webgl) {\n        var ShapeRenderer = (function () {\n            function ShapeRenderer(context, maxVertices) {\n                if (maxVertices === void 0) { maxVertices = 10920; }\n                this.isDrawing = false;\n                this.shapeType = ShapeType.Filled;\n                this.color = new spine.Color(1, 1, 1, 1);\n                this.vertexIndex = 0;\n                this.tmp = new spine.Vector2();\n                if (maxVertices > 10920)\n                    throw new Error(\"Can't have more than 10920 triangles per batch: \" + maxVertices);\n                this.context = context instanceof webgl.ManagedWebGLRenderingContext ? context : new webgl.ManagedWebGLRenderingContext(context);\n                this.mesh = new webgl.Mesh(context, [new webgl.Position2Attribute(), new webgl.ColorAttribute()], maxVertices, 0);\n                this.srcBlend = this.context.gl.SRC_ALPHA;\n                this.dstBlend = this.context.gl.ONE_MINUS_SRC_ALPHA;\n            }\n            ShapeRenderer.prototype.begin = function (shader) {\n                if (this.isDrawing)\n                    throw new Error(\"ShapeRenderer.begin() has already been called\");\n                this.shader = shader;\n                this.vertexIndex = 0;\n                this.isDrawing = true;\n                var gl = this.context.gl;\n                gl.enable(gl.BLEND);\n                gl.blendFunc(this.srcBlend, this.dstBlend);\n            };\n            ShapeRenderer.prototype.setBlendMode = function (srcBlend, dstBlend) {\n                var gl = this.context.gl;\n                this.srcBlend = srcBlend;\n                this.dstBlend = dstBlend;\n                if (this.isDrawing) {\n                    this.flush();\n                    gl.blendFunc(this.srcBlend, this.dstBlend);\n                }\n            };\n            ShapeRenderer.prototype.setColor = function (color) {\n                this.color.setFromColor(color);\n            };\n            ShapeRenderer.prototype.setColorWith = function (r, g, b, a) {\n                this.color.set(r, g, b, a);\n            };\n            ShapeRenderer.prototype.point = function (x, y, color) {\n                if (color === void 0) { color = null; }\n                this.check(ShapeType.Point, 1);\n                if (color === null)\n                    color = this.color;\n                this.vertex(x, y, color);\n            };\n            ShapeRenderer.prototype.line = function (x, y, x2, y2, color) {\n                if (color === void 0) { color = null; }\n                this.check(ShapeType.Line, 2);\n                var vertices = this.mesh.getVertices();\n                var idx = this.vertexIndex;\n                if (color === null)\n                    color = this.color;\n                this.vertex(x, y, color);\n                this.vertex(x2, y2, color);\n            };\n            ShapeRenderer.prototype.triangle = function (filled, x, y, x2, y2, x3, y3, color, color2, color3) {\n                if (color === void 0) { color = null; }\n                if (color2 === void 0) { color2 = null; }\n                if (color3 === void 0) { color3 = null; }\n                this.check(filled ? ShapeType.Filled : ShapeType.Line, 3);\n                var vertices = this.mesh.getVertices();\n                var idx = this.vertexIndex;\n                if (color === null)\n                    color = this.color;\n                if (color2 === null)\n                    color2 = this.color;\n                if (color3 === null)\n                    color3 = this.color;\n                if (filled) {\n                    this.vertex(x, y, color);\n                    this.vertex(x2, y2, color2);\n                    this.vertex(x3, y3, color3);\n                }\n                else {\n                    this.vertex(x, y, color);\n                    this.vertex(x2, y2, color2);\n                    this.vertex(x2, y2, color);\n                    this.vertex(x3, y3, color2);\n                    this.vertex(x3, y3, color);\n                    this.vertex(x, y, color2);\n                }\n            };\n            ShapeRenderer.prototype.quad = function (filled, x, y, x2, y2, x3, y3, x4, y4, color, color2, color3, color4) {\n                if (color === void 0) { color = null; }\n                if (color2 === void 0) { color2 = null; }\n                if (color3 === void 0) { color3 = null; }\n                if (color4 === void 0) { color4 = null; }\n                this.check(filled ? ShapeType.Filled : ShapeType.Line, 3);\n                var vertices = this.mesh.getVertices();\n                var idx = this.vertexIndex;\n                if (color === null)\n                    color = this.color;\n                if (color2 === null)\n                    color2 = this.color;\n                if (color3 === null)\n                    color3 = this.color;\n                if (color4 === null)\n                    color4 = this.color;\n                if (filled) {\n                    this.vertex(x, y, color);\n                    this.vertex(x2, y2, color2);\n                    this.vertex(x3, y3, color3);\n                    this.vertex(x3, y3, color3);\n                    this.vertex(x4, y4, color4);\n                    this.vertex(x, y, color);\n                }\n                else {\n                    this.vertex(x, y, color);\n                    this.vertex(x2, y2, color2);\n                    this.vertex(x2, y2, color2);\n                    this.vertex(x3, y3, color3);\n                    this.vertex(x3, y3, color3);\n                    this.vertex(x4, y4, color4);\n                    this.vertex(x4, y4, color4);\n                    this.vertex(x, y, color);\n                }\n            };\n            ShapeRenderer.prototype.rect = function (filled, x, y, width, height, color) {\n                if (color === void 0) { color = null; }\n                this.quad(filled, x, y, x + width, y, x + width, y + height, x, y + height, color, color, color, color);\n            };\n            ShapeRenderer.prototype.rectLine = function (filled, x1, y1, x2, y2, width, color) {\n                if (color === void 0) { color = null; }\n                this.check(filled ? ShapeType.Filled : ShapeType.Line, 8);\n                if (color === null)\n                    color = this.color;\n                var t = this.tmp.set(y2 - y1, x1 - x2);\n                t.normalize();\n                width *= 0.5;\n                var tx = t.x * width;\n                var ty = t.y * width;\n                if (!filled) {\n                    this.vertex(x1 + tx, y1 + ty, color);\n                    this.vertex(x1 - tx, y1 - ty, color);\n                    this.vertex(x2 + tx, y2 + ty, color);\n                    this.vertex(x2 - tx, y2 - ty, color);\n                    this.vertex(x2 + tx, y2 + ty, color);\n                    this.vertex(x1 + tx, y1 + ty, color);\n                    this.vertex(x2 - tx, y2 - ty, color);\n                    this.vertex(x1 - tx, y1 - ty, color);\n                }\n                else {\n                    this.vertex(x1 + tx, y1 + ty, color);\n                    this.vertex(x1 - tx, y1 - ty, color);\n                    this.vertex(x2 + tx, y2 + ty, color);\n                    this.vertex(x2 - tx, y2 - ty, color);\n                    this.vertex(x2 + tx, y2 + ty, color);\n                    this.vertex(x1 - tx, y1 - ty, color);\n                }\n            };\n            ShapeRenderer.prototype.x = function (x, y, size) {\n                this.line(x - size, y - size, x + size, y + size);\n                this.line(x - size, y + size, x + size, y - size);\n            };\n            ShapeRenderer.prototype.polygon = function (polygonVertices, offset, count, color) {\n                if (color === void 0) { color = null; }\n                if (count < 3)\n                    throw new Error(\"Polygon must contain at least 3 vertices\");\n                this.check(ShapeType.Line, count * 2);\n                if (color === null)\n                    color = this.color;\n                var vertices = this.mesh.getVertices();\n                var idx = this.vertexIndex;\n                offset <<= 1;\n                count <<= 1;\n                var firstX = polygonVertices[offset];\n                var firstY = polygonVertices[offset + 1];\n                var last = offset + count;\n                for (var i = offset, n = offset + count - 2; i < n; i += 2) {\n                    var x1 = polygonVertices[i];\n                    var y1 = polygonVertices[i + 1];\n                    var x2 = 0;\n                    var y2 = 0;\n                    if (i + 2 >= last) {\n                        x2 = firstX;\n                        y2 = firstY;\n                    }\n                    else {\n                        x2 = polygonVertices[i + 2];\n                        y2 = polygonVertices[i + 3];\n                    }\n                    this.vertex(x1, y1, color);\n                    this.vertex(x2, y2, color);\n                }\n            };\n            ShapeRenderer.prototype.circle = function (filled, x, y, radius, color, segments) {\n                if (color === void 0) { color = null; }\n                if (segments === void 0) { segments = 0; }\n                if (segments === 0)\n                    segments = Math.max(1, (6 * spine.MathUtils.cbrt(radius)) | 0);\n                if (segments <= 0)\n                    throw new Error(\"segments must be > 0.\");\n                if (color === null)\n                    color = this.color;\n                var angle = 2 * spine.MathUtils.PI / segments;\n                var cos = Math.cos(angle);\n                var sin = Math.sin(angle);\n                var cx = radius, cy = 0;\n                if (!filled) {\n                    this.check(ShapeType.Line, segments * 2 + 2);\n                    for (var i = 0; i < segments; i++) {\n                        this.vertex(x + cx, y + cy, color);\n                        var temp_1 = cx;\n                        cx = cos * cx - sin * cy;\n                        cy = sin * temp_1 + cos * cy;\n                        this.vertex(x + cx, y + cy, color);\n                    }\n                    this.vertex(x + cx, y + cy, color);\n                }\n                else {\n                    this.check(ShapeType.Filled, segments * 3 + 3);\n                    segments--;\n                    for (var i = 0; i < segments; i++) {\n                        this.vertex(x, y, color);\n                        this.vertex(x + cx, y + cy, color);\n                        var temp_2 = cx;\n                        cx = cos * cx - sin * cy;\n                        cy = sin * temp_2 + cos * cy;\n                        this.vertex(x + cx, y + cy, color);\n                    }\n                    this.vertex(x, y, color);\n                    this.vertex(x + cx, y + cy, color);\n                }\n                var temp = cx;\n                cx = radius;\n                cy = 0;\n                this.vertex(x + cx, y + cy, color);\n            };\n            ShapeRenderer.prototype.curve = function (x1, y1, cx1, cy1, cx2, cy2, x2, y2, segments, color) {\n                if (color === void 0) { color = null; }\n                this.check(ShapeType.Line, segments * 2 + 2);\n                if (color === null)\n                    color = this.color;\n                var subdiv_step = 1 / segments;\n                var subdiv_step2 = subdiv_step * subdiv_step;\n                var subdiv_step3 = subdiv_step * subdiv_step * subdiv_step;\n                var pre1 = 3 * subdiv_step;\n                var pre2 = 3 * subdiv_step2;\n                var pre4 = 6 * subdiv_step2;\n                var pre5 = 6 * subdiv_step3;\n                var tmp1x = x1 - cx1 * 2 + cx2;\n                var tmp1y = y1 - cy1 * 2 + cy2;\n                var tmp2x = (cx1 - cx2) * 3 - x1 + x2;\n                var tmp2y = (cy1 - cy2) * 3 - y1 + y2;\n                var fx = x1;\n                var fy = y1;\n                var dfx = (cx1 - x1) * pre1 + tmp1x * pre2 + tmp2x * subdiv_step3;\n                var dfy = (cy1 - y1) * pre1 + tmp1y * pre2 + tmp2y * subdiv_step3;\n                var ddfx = tmp1x * pre4 + tmp2x * pre5;\n                var ddfy = tmp1y * pre4 + tmp2y * pre5;\n                var dddfx = tmp2x * pre5;\n                var dddfy = tmp2y * pre5;\n                while (segments-- > 0) {\n                    this.vertex(fx, fy, color);\n                    fx += dfx;\n                    fy += dfy;\n                    dfx += ddfx;\n                    dfy += ddfy;\n                    ddfx += dddfx;\n                    ddfy += dddfy;\n                    this.vertex(fx, fy, color);\n                }\n                this.vertex(fx, fy, color);\n                this.vertex(x2, y2, color);\n            };\n            ShapeRenderer.prototype.vertex = function (x, y, color) {\n                var idx = this.vertexIndex;\n                var vertices = this.mesh.getVertices();\n                vertices[idx++] = x;\n                vertices[idx++] = y;\n                vertices[idx++] = color.r;\n                vertices[idx++] = color.g;\n                vertices[idx++] = color.b;\n                vertices[idx++] = color.a;\n                this.vertexIndex = idx;\n            };\n            ShapeRenderer.prototype.end = function () {\n                if (!this.isDrawing)\n                    throw new Error(\"ShapeRenderer.begin() has not been called\");\n                this.flush();\n                this.context.gl.disable(this.context.gl.BLEND);\n                this.isDrawing = false;\n            };\n            ShapeRenderer.prototype.flush = function () {\n                if (this.vertexIndex == 0)\n                    return;\n                this.mesh.setVerticesLength(this.vertexIndex);\n                this.mesh.draw(this.shader, this.shapeType);\n                this.vertexIndex = 0;\n            };\n            ShapeRenderer.prototype.check = function (shapeType, numVertices) {\n                if (!this.isDrawing)\n                    throw new Error(\"ShapeRenderer.begin() has not been called\");\n                if (this.shapeType == shapeType) {\n                    if (this.mesh.maxVertices() - this.mesh.numVertices() < numVertices)\n                        this.flush();\n                    else\n                        return;\n                }\n                else {\n                    this.flush();\n                    this.shapeType = shapeType;\n                }\n            };\n            ShapeRenderer.prototype.dispose = function () {\n                this.mesh.dispose();\n            };\n            return ShapeRenderer;\n        }());\n        webgl.ShapeRenderer = ShapeRenderer;\n        var ShapeType;\n        (function (ShapeType) {\n            ShapeType[ShapeType[\"Point\"] = 0] = \"Point\";\n            ShapeType[ShapeType[\"Line\"] = 1] = \"Line\";\n            ShapeType[ShapeType[\"Filled\"] = 4] = \"Filled\";\n        })(ShapeType = webgl.ShapeType || (webgl.ShapeType = {}));\n    })(webgl = spine.webgl || (spine.webgl = {}));\n})(spine || (spine = {}));\nvar spine;\n(function (spine) {\n    var webgl;\n    (function (webgl) {\n        var SkeletonDebugRenderer = (function () {\n            function SkeletonDebugRenderer(context) {\n                this.boneLineColor = new spine.Color(1, 0, 0, 1);\n                this.boneOriginColor = new spine.Color(0, 1, 0, 1);\n                this.attachmentLineColor = new spine.Color(0, 0, 1, 0.5);\n                this.triangleLineColor = new spine.Color(1, 0.64, 0, 0.5);\n                this.pathColor = new spine.Color().setFromString(\"FF7F00\");\n                this.clipColor = new spine.Color(0.8, 0, 0, 2);\n                this.aabbColor = new spine.Color(0, 1, 0, 0.5);\n                this.drawBones = true;\n                this.drawRegionAttachments = true;\n                this.drawBoundingBoxes = true;\n                this.drawMeshHull = true;\n                this.drawMeshTriangles = true;\n                this.drawPaths = true;\n                this.drawSkeletonXY = false;\n                this.drawClipping = true;\n                this.premultipliedAlpha = false;\n                this.scale = 1;\n                this.boneWidth = 2;\n                this.bounds = new spine.SkeletonBounds();\n                this.temp = new Array();\n                this.vertices = spine.Utils.newFloatArray(2 * 1024);\n                this.context = context instanceof webgl.ManagedWebGLRenderingContext ? context : new webgl.ManagedWebGLRenderingContext(context);\n            }\n            SkeletonDebugRenderer.prototype.draw = function (shapes, skeleton, ignoredBones) {\n                if (ignoredBones === void 0) { ignoredBones = null; }\n                var skeletonX = skeleton.x;\n                var skeletonY = skeleton.y;\n                var gl = this.context.gl;\n                var srcFunc = this.premultipliedAlpha ? gl.ONE : gl.SRC_ALPHA;\n                shapes.setBlendMode(srcFunc, gl.ONE_MINUS_SRC_ALPHA);\n                var bones = skeleton.bones;\n                if (this.drawBones) {\n                    shapes.setColor(this.boneLineColor);\n                    for (var i = 0, n = bones.length; i < n; i++) {\n                        var bone = bones[i];\n                        if (ignoredBones && ignoredBones.indexOf(bone.data.name) > -1)\n                            continue;\n                        if (bone.parent == null)\n                            continue;\n                        var x = skeletonX + bone.data.length * bone.a + bone.worldX;\n                        var y = skeletonY + bone.data.length * bone.c + bone.worldY;\n                        shapes.rectLine(true, skeletonX + bone.worldX, skeletonY + bone.worldY, x, y, this.boneWidth * this.scale);\n                    }\n                    if (this.drawSkeletonXY)\n                        shapes.x(skeletonX, skeletonY, 4 * this.scale);\n                }\n                if (this.drawRegionAttachments) {\n                    shapes.setColor(this.attachmentLineColor);\n                    var slots = skeleton.slots;\n                    for (var i = 0, n = slots.length; i < n; i++) {\n                        var slot = slots[i];\n                        var attachment = slot.getAttachment();\n                        if (attachment instanceof spine.RegionAttachment) {\n                            var regionAttachment = attachment;\n                            var vertices = this.vertices;\n                            regionAttachment.computeWorldVertices(slot.bone, vertices, 0, 2);\n                            shapes.line(vertices[0], vertices[1], vertices[2], vertices[3]);\n                            shapes.line(vertices[2], vertices[3], vertices[4], vertices[5]);\n                            shapes.line(vertices[4], vertices[5], vertices[6], vertices[7]);\n                            shapes.line(vertices[6], vertices[7], vertices[0], vertices[1]);\n                        }\n                    }\n                }\n                if (this.drawMeshHull || this.drawMeshTriangles) {\n                    var slots = skeleton.slots;\n                    for (var i = 0, n = slots.length; i < n; i++) {\n                        var slot = slots[i];\n                        var attachment = slot.getAttachment();\n                        if (!(attachment instanceof spine.MeshAttachment))\n                            continue;\n                        var mesh = attachment;\n                        var vertices = this.vertices;\n                        mesh.computeWorldVertices(slot, 0, mesh.worldVerticesLength, vertices, 0, 2);\n                        var triangles = mesh.triangles;\n                        var hullLength = mesh.hullLength;\n                        if (this.drawMeshTriangles) {\n                            shapes.setColor(this.triangleLineColor);\n                            for (var ii = 0, nn = triangles.length; ii < nn; ii += 3) {\n                                var v1 = triangles[ii] * 2, v2 = triangles[ii + 1] * 2, v3 = triangles[ii + 2] * 2;\n                                shapes.triangle(false, vertices[v1], vertices[v1 + 1], vertices[v2], vertices[v2 + 1], vertices[v3], vertices[v3 + 1]);\n                            }\n                        }\n                        if (this.drawMeshHull && hullLength > 0) {\n                            shapes.setColor(this.attachmentLineColor);\n                            hullLength = (hullLength >> 1) * 2;\n                            var lastX = vertices[hullLength - 2], lastY = vertices[hullLength - 1];\n                            for (var ii = 0, nn = hullLength; ii < nn; ii += 2) {\n                                var x = vertices[ii], y = vertices[ii + 1];\n                                shapes.line(x, y, lastX, lastY);\n                                lastX = x;\n                                lastY = y;\n                            }\n                        }\n                    }\n                }\n                if (this.drawBoundingBoxes) {\n                    var bounds = this.bounds;\n                    bounds.update(skeleton, true);\n                    shapes.setColor(this.aabbColor);\n                    shapes.rect(false, bounds.minX, bounds.minY, bounds.getWidth(), bounds.getHeight());\n                    var polygons = bounds.polygons;\n                    var boxes = bounds.boundingBoxes;\n                    for (var i = 0, n = polygons.length; i < n; i++) {\n                        var polygon = polygons[i];\n                        shapes.setColor(boxes[i].color);\n                        shapes.polygon(polygon, 0, polygon.length);\n                    }\n                }\n                if (this.drawPaths) {\n                    var slots = skeleton.slots;\n                    for (var i = 0, n = slots.length; i < n; i++) {\n                        var slot = slots[i];\n                        var attachment = slot.getAttachment();\n                        if (!(attachment instanceof spine.PathAttachment))\n                            continue;\n                        var path = attachment;\n                        var nn = path.worldVerticesLength;\n                        var world = this.temp = spine.Utils.setArraySize(this.temp, nn, 0);\n                        path.computeWorldVertices(slot, 0, nn, world, 0, 2);\n                        var color = this.pathColor;\n                        var x1 = world[2], y1 = world[3], x2 = 0, y2 = 0;\n                        if (path.closed) {\n                            shapes.setColor(color);\n                            var cx1 = world[0], cy1 = world[1], cx2 = world[nn - 2], cy2 = world[nn - 1];\n                            x2 = world[nn - 4];\n                            y2 = world[nn - 3];\n                            shapes.curve(x1, y1, cx1, cy1, cx2, cy2, x2, y2, 32);\n                            shapes.setColor(SkeletonDebugRenderer.LIGHT_GRAY);\n                            shapes.line(x1, y1, cx1, cy1);\n                            shapes.line(x2, y2, cx2, cy2);\n                        }\n                        nn -= 4;\n                        for (var ii = 4; ii < nn; ii += 6) {\n                            var cx1 = world[ii], cy1 = world[ii + 1], cx2 = world[ii + 2], cy2 = world[ii + 3];\n                            x2 = world[ii + 4];\n                            y2 = world[ii + 5];\n                            shapes.setColor(color);\n                            shapes.curve(x1, y1, cx1, cy1, cx2, cy2, x2, y2, 32);\n                            shapes.setColor(SkeletonDebugRenderer.LIGHT_GRAY);\n                            shapes.line(x1, y1, cx1, cy1);\n                            shapes.line(x2, y2, cx2, cy2);\n                            x1 = x2;\n                            y1 = y2;\n                        }\n                    }\n                }\n                if (this.drawBones) {\n                    shapes.setColor(this.boneOriginColor);\n                    for (var i = 0, n = bones.length; i < n; i++) {\n                        var bone = bones[i];\n                        if (ignoredBones && ignoredBones.indexOf(bone.data.name) > -1)\n                            continue;\n                        shapes.circle(true, skeletonX + bone.worldX, skeletonY + bone.worldY, 3 * this.scale, SkeletonDebugRenderer.GREEN, 8);\n                    }\n                }\n                if (this.drawClipping) {\n                    var slots = skeleton.slots;\n                    shapes.setColor(this.clipColor);\n                    for (var i = 0, n = slots.length; i < n; i++) {\n                        var slot = slots[i];\n                        var attachment = slot.getAttachment();\n                        if (!(attachment instanceof spine.ClippingAttachment))\n                            continue;\n                        var clip = attachment;\n                        var nn = clip.worldVerticesLength;\n                        var world = this.temp = spine.Utils.setArraySize(this.temp, nn, 0);\n                        clip.computeWorldVertices(slot, 0, nn, world, 0, 2);\n                        for (var i_16 = 0, n_2 = world.length; i_16 < n_2; i_16 += 2) {\n                            var x = world[i_16];\n                            var y = world[i_16 + 1];\n                            var x2 = world[(i_16 + 2) % world.length];\n                            var y2 = world[(i_16 + 3) % world.length];\n                            shapes.line(x, y, x2, y2);\n                        }\n                    }\n                }\n            };\n            SkeletonDebugRenderer.prototype.dispose = function () {\n            };\n            SkeletonDebugRenderer.LIGHT_GRAY = new spine.Color(192 / 255, 192 / 255, 192 / 255, 1);\n            SkeletonDebugRenderer.GREEN = new spine.Color(0, 1, 0, 1);\n            return SkeletonDebugRenderer;\n        }());\n        webgl.SkeletonDebugRenderer = SkeletonDebugRenderer;\n    })(webgl = spine.webgl || (spine.webgl = {}));\n})(spine || (spine = {}));\nvar spine;\n(function (spine) {\n    var webgl;\n    (function (webgl) {\n        var Renderable = (function () {\n            function Renderable(vertices, numVertices, numFloats) {\n                this.vertices = vertices;\n                this.numVertices = numVertices;\n                this.numFloats = numFloats;\n            }\n            return Renderable;\n        }());\n        ;\n        var SkeletonRenderer = (function () {\n            function SkeletonRenderer(context, twoColorTint) {\n                if (twoColorTint === void 0) { twoColorTint = true; }\n                this.premultipliedAlpha = false;\n                this.vertexEffect = null;\n                this.tempColor = new spine.Color();\n                this.tempColor2 = new spine.Color();\n                this.vertexSize = 2 + 2 + 4;\n                this.twoColorTint = false;\n                this.renderable = new Renderable(null, 0, 0);\n                this.clipper = new spine.SkeletonClipping();\n                this.temp = new spine.Vector2();\n                this.temp2 = new spine.Vector2();\n                this.temp3 = new spine.Color();\n                this.temp4 = new spine.Color();\n                this.twoColorTint = twoColorTint;\n                if (twoColorTint)\n                    this.vertexSize += 4;\n                this.vertices = spine.Utils.newFloatArray(this.vertexSize * 1024);\n            }\n            SkeletonRenderer.prototype.draw = function (batcher, skeleton, slotRangeStart, slotRangeEnd) {\n                if (slotRangeStart === void 0) { slotRangeStart = -1; }\n                if (slotRangeEnd === void 0) { slotRangeEnd = -1; }\n                var clipper = this.clipper;\n                var premultipliedAlpha = this.premultipliedAlpha;\n                var twoColorTint = this.twoColorTint;\n                var blendMode = null;\n                var tempPos = this.temp;\n                var tempUv = this.temp2;\n                var tempLight = this.temp3;\n                var tempDark = this.temp4;\n                var renderable = this.renderable;\n                var uvs = null;\n                var triangles = null;\n                var drawOrder = skeleton.drawOrder;\n                var attachmentColor = null;\n                var skeletonColor = skeleton.color;\n                var vertexSize = twoColorTint ? 12 : 8;\n                var inRange = false;\n                if (slotRangeStart == -1)\n                    inRange = true;\n                for (var i = 0, n = drawOrder.length; i < n; i++) {\n                    var clippedVertexSize = clipper.isClipping() ? 2 : vertexSize;\n                    var slot = drawOrder[i];\n                    if (slotRangeStart >= 0 && slotRangeStart == slot.data.index) {\n                        inRange = true;\n                    }\n                    if (!inRange) {\n                        clipper.clipEndWithSlot(slot);\n                        continue;\n                    }\n                    if (slotRangeEnd >= 0 && slotRangeEnd == slot.data.index) {\n                        inRange = false;\n                    }\n                    var attachment = slot.getAttachment();\n                    var texture = null;\n                    if (attachment instanceof spine.RegionAttachment) {\n                        var region = attachment;\n                        renderable.vertices = this.vertices;\n                        renderable.numVertices = 4;\n                        renderable.numFloats = clippedVertexSize << 2;\n                        region.computeWorldVertices(slot.bone, renderable.vertices, 0, clippedVertexSize);\n                        triangles = SkeletonRenderer.QUAD_TRIANGLES;\n                        uvs = region.uvs;\n                        texture = region.region.renderObject.texture;\n                        attachmentColor = region.color;\n                    }\n                    else if (attachment instanceof spine.MeshAttachment) {\n                        var mesh = attachment;\n                        renderable.vertices = this.vertices;\n                        renderable.numVertices = (mesh.worldVerticesLength >> 1);\n                        renderable.numFloats = renderable.numVertices * clippedVertexSize;\n                        if (renderable.numFloats > renderable.vertices.length) {\n                            renderable.vertices = this.vertices = spine.Utils.newFloatArray(renderable.numFloats);\n                        }\n                        mesh.computeWorldVertices(slot, 0, mesh.worldVerticesLength, renderable.vertices, 0, clippedVertexSize);\n                        triangles = mesh.triangles;\n                        texture = mesh.region.renderObject.texture;\n                        uvs = mesh.uvs;\n                        attachmentColor = mesh.color;\n                    }\n                    else if (attachment instanceof spine.ClippingAttachment) {\n                        var clip = (attachment);\n                        clipper.clipStart(slot, clip);\n                        continue;\n                    }\n                    else {\n                        clipper.clipEndWithSlot(slot);\n                        continue;\n                    }\n                    if (texture != null) {\n                        var slotColor = slot.color;\n                        var finalColor = this.tempColor;\n                        finalColor.r = skeletonColor.r * slotColor.r * attachmentColor.r;\n                        finalColor.g = skeletonColor.g * slotColor.g * attachmentColor.g;\n                        finalColor.b = skeletonColor.b * slotColor.b * attachmentColor.b;\n                        finalColor.a = skeletonColor.a * slotColor.a * attachmentColor.a;\n                        if (premultipliedAlpha) {\n                            finalColor.r *= finalColor.a;\n                            finalColor.g *= finalColor.a;\n                            finalColor.b *= finalColor.a;\n                        }\n                        var darkColor = this.tempColor2;\n                        if (slot.darkColor == null)\n                            darkColor.set(0, 0, 0, 1.0);\n                        else {\n                            if (premultipliedAlpha) {\n                                darkColor.r = slot.darkColor.r * finalColor.a;\n                                darkColor.g = slot.darkColor.g * finalColor.a;\n                                darkColor.b = slot.darkColor.b * finalColor.a;\n                            }\n                            else {\n                                darkColor.setFromColor(slot.darkColor);\n                            }\n                            darkColor.a = premultipliedAlpha ? 1.0 : 0.0;\n                        }\n                        var slotBlendMode = slot.data.blendMode;\n                        if (slotBlendMode != blendMode) {\n                            blendMode = slotBlendMode;\n                            batcher.setBlendMode(webgl.WebGLBlendModeConverter.getSourceGLBlendMode(blendMode, premultipliedAlpha), webgl.WebGLBlendModeConverter.getDestGLBlendMode(blendMode));\n                        }\n                        if (clipper.isClipping()) {\n                            clipper.clipTriangles(renderable.vertices, renderable.numFloats, triangles, triangles.length, uvs, finalColor, darkColor, twoColorTint);\n                            var clippedVertices = new Float32Array(clipper.clippedVertices);\n                            var clippedTriangles = clipper.clippedTriangles;\n                            if (this.vertexEffect != null) {\n                                var vertexEffect = this.vertexEffect;\n                                var verts = clippedVertices;\n                                if (!twoColorTint) {\n                                    for (var v = 0, n_3 = clippedVertices.length; v < n_3; v += vertexSize) {\n                                        tempPos.x = verts[v];\n                                        tempPos.y = verts[v + 1];\n                                        tempLight.set(verts[v + 2], verts[v + 3], verts[v + 4], verts[v + 5]);\n                                        tempUv.x = verts[v + 6];\n                                        tempUv.y = verts[v + 7];\n                                        tempDark.set(0, 0, 0, 0);\n                                        vertexEffect.transform(tempPos, tempUv, tempLight, tempDark);\n                                        verts[v] = tempPos.x;\n                                        verts[v + 1] = tempPos.y;\n                                        verts[v + 2] = tempLight.r;\n                                        verts[v + 3] = tempLight.g;\n                                        verts[v + 4] = tempLight.b;\n                                        verts[v + 5] = tempLight.a;\n                                        verts[v + 6] = tempUv.x;\n                                        verts[v + 7] = tempUv.y;\n                                    }\n                                }\n                                else {\n                                    for (var v = 0, n_4 = clippedVertices.length; v < n_4; v += vertexSize) {\n                                        tempPos.x = verts[v];\n                                        tempPos.y = verts[v + 1];\n                                        tempLight.set(verts[v + 2], verts[v + 3], verts[v + 4], verts[v + 5]);\n                                        tempUv.x = verts[v + 6];\n                                        tempUv.y = verts[v + 7];\n                                        tempDark.set(verts[v + 8], verts[v + 9], verts[v + 10], verts[v + 11]);\n                                        vertexEffect.transform(tempPos, tempUv, tempLight, tempDark);\n                                        verts[v] = tempPos.x;\n                                        verts[v + 1] = tempPos.y;\n                                        verts[v + 2] = tempLight.r;\n                                        verts[v + 3] = tempLight.g;\n                                        verts[v + 4] = tempLight.b;\n                                        verts[v + 5] = tempLight.a;\n                                        verts[v + 6] = tempUv.x;\n                                        verts[v + 7] = tempUv.y;\n                                        verts[v + 8] = tempDark.r;\n                                        verts[v + 9] = tempDark.g;\n                                        verts[v + 10] = tempDark.b;\n                                        verts[v + 11] = tempDark.a;\n                                    }\n                                }\n                            }\n                            batcher.draw(texture, clippedVertices, clippedTriangles);\n                        }\n                        else {\n                            var verts = renderable.vertices;\n                            if (this.vertexEffect != null) {\n                                var vertexEffect = this.vertexEffect;\n                                if (!twoColorTint) {\n                                    for (var v = 0, u = 0, n_5 = renderable.numFloats; v < n_5; v += vertexSize, u += 2) {\n                                        tempPos.x = verts[v];\n                                        tempPos.y = verts[v + 1];\n                                        tempUv.x = uvs[u];\n                                        tempUv.y = uvs[u + 1];\n                                        tempLight.setFromColor(finalColor);\n                                        tempDark.set(0, 0, 0, 0);\n                                        vertexEffect.transform(tempPos, tempUv, tempLight, tempDark);\n                                        verts[v] = tempPos.x;\n                                        verts[v + 1] = tempPos.y;\n                                        verts[v + 2] = tempLight.r;\n                                        verts[v + 3] = tempLight.g;\n                                        verts[v + 4] = tempLight.b;\n                                        verts[v + 5] = tempLight.a;\n                                        verts[v + 6] = tempUv.x;\n                                        verts[v + 7] = tempUv.y;\n                                    }\n                                }\n                                else {\n                                    for (var v = 0, u = 0, n_6 = renderable.numFloats; v < n_6; v += vertexSize, u += 2) {\n                                        tempPos.x = verts[v];\n                                        tempPos.y = verts[v + 1];\n                                        tempUv.x = uvs[u];\n                                        tempUv.y = uvs[u + 1];\n                                        tempLight.setFromColor(finalColor);\n                                        tempDark.setFromColor(darkColor);\n                                        vertexEffect.transform(tempPos, tempUv, tempLight, tempDark);\n                                        verts[v] = tempPos.x;\n                                        verts[v + 1] = tempPos.y;\n                                        verts[v + 2] = tempLight.r;\n                                        verts[v + 3] = tempLight.g;\n                                        verts[v + 4] = tempLight.b;\n                                        verts[v + 5] = tempLight.a;\n                                        verts[v + 6] = tempUv.x;\n                                        verts[v + 7] = tempUv.y;\n                                        verts[v + 8] = tempDark.r;\n                                        verts[v + 9] = tempDark.g;\n                                        verts[v + 10] = tempDark.b;\n                                        verts[v + 11] = tempDark.a;\n                                    }\n                                }\n                            }\n                            else {\n                                if (!twoColorTint) {\n                                    for (var v = 2, u = 0, n_7 = renderable.numFloats; v < n_7; v += vertexSize, u += 2) {\n                                        verts[v] = finalColor.r;\n                                        verts[v + 1] = finalColor.g;\n                                        verts[v + 2] = finalColor.b;\n                                        verts[v + 3] = finalColor.a;\n                                        verts[v + 4] = uvs[u];\n                                        verts[v + 5] = uvs[u + 1];\n                                    }\n                                }\n                                else {\n                                    for (var v = 2, u = 0, n_8 = renderable.numFloats; v < n_8; v += vertexSize, u += 2) {\n                                        verts[v] = finalColor.r;\n                                        verts[v + 1] = finalColor.g;\n                                        verts[v + 2] = finalColor.b;\n                                        verts[v + 3] = finalColor.a;\n                                        verts[v + 4] = uvs[u];\n                                        verts[v + 5] = uvs[u + 1];\n                                        verts[v + 6] = darkColor.r;\n                                        verts[v + 7] = darkColor.g;\n                                        verts[v + 8] = darkColor.b;\n                                        verts[v + 9] = darkColor.a;\n                                    }\n                                }\n                            }\n                            var view = renderable.vertices.subarray(0, renderable.numFloats);\n                            batcher.draw(texture, view, triangles);\n                        }\n                    }\n                    clipper.clipEndWithSlot(slot);\n                }\n                clipper.clipEnd();\n            };\n            SkeletonRenderer.QUAD_TRIANGLES = [0, 1, 2, 2, 3, 0];\n            return SkeletonRenderer;\n        }());\n        webgl.SkeletonRenderer = SkeletonRenderer;\n    })(webgl = spine.webgl || (spine.webgl = {}));\n})(spine || (spine = {}));\nvar spine;\n(function (spine) {\n    var webgl;\n    (function (webgl) {\n        var Vector3 = (function () {\n            function Vector3(x, y, z) {\n                if (x === void 0) { x = 0; }\n                if (y === void 0) { y = 0; }\n                if (z === void 0) { z = 0; }\n                this.x = 0;\n                this.y = 0;\n                this.z = 0;\n                this.x = x;\n                this.y = y;\n                this.z = z;\n            }\n            Vector3.prototype.setFrom = function (v) {\n                this.x = v.x;\n                this.y = v.y;\n                this.z = v.z;\n                return this;\n            };\n            Vector3.prototype.set = function (x, y, z) {\n                this.x = x;\n                this.y = y;\n                this.z = z;\n                return this;\n            };\n            Vector3.prototype.add = function (v) {\n                this.x += v.x;\n                this.y += v.y;\n                this.z += v.z;\n                return this;\n            };\n            Vector3.prototype.sub = function (v) {\n                this.x -= v.x;\n                this.y -= v.y;\n                this.z -= v.z;\n                return this;\n            };\n            Vector3.prototype.scale = function (s) {\n                this.x *= s;\n                this.y *= s;\n                this.z *= s;\n                return this;\n            };\n            Vector3.prototype.normalize = function () {\n                var len = this.length();\n                if (len == 0)\n                    return this;\n                len = 1 / len;\n                this.x *= len;\n                this.y *= len;\n                this.z *= len;\n                return this;\n            };\n            Vector3.prototype.cross = function (v) {\n                return this.set(this.y * v.z - this.z * v.y, this.z * v.x - this.x * v.z, this.x * v.y - this.y * v.x);\n            };\n            Vector3.prototype.multiply = function (matrix) {\n                var l_mat = matrix.values;\n                return this.set(this.x * l_mat[webgl.M00] + this.y * l_mat[webgl.M01] + this.z * l_mat[webgl.M02] + l_mat[webgl.M03], this.x * l_mat[webgl.M10] + this.y * l_mat[webgl.M11] + this.z * l_mat[webgl.M12] + l_mat[webgl.M13], this.x * l_mat[webgl.M20] + this.y * l_mat[webgl.M21] + this.z * l_mat[webgl.M22] + l_mat[webgl.M23]);\n            };\n            Vector3.prototype.project = function (matrix) {\n                var l_mat = matrix.values;\n                var l_w = 1 / (this.x * l_mat[webgl.M30] + this.y * l_mat[webgl.M31] + this.z * l_mat[webgl.M32] + l_mat[webgl.M33]);\n                return this.set((this.x * l_mat[webgl.M00] + this.y * l_mat[webgl.M01] + this.z * l_mat[webgl.M02] + l_mat[webgl.M03]) * l_w, (this.x * l_mat[webgl.M10] + this.y * l_mat[webgl.M11] + this.z * l_mat[webgl.M12] + l_mat[webgl.M13]) * l_w, (this.x * l_mat[webgl.M20] + this.y * l_mat[webgl.M21] + this.z * l_mat[webgl.M22] + l_mat[webgl.M23]) * l_w);\n            };\n            Vector3.prototype.dot = function (v) {\n                return this.x * v.x + this.y * v.y + this.z * v.z;\n            };\n            Vector3.prototype.length = function () {\n                return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);\n            };\n            Vector3.prototype.distance = function (v) {\n                var a = v.x - this.x;\n                var b = v.y - this.y;\n                var c = v.z - this.z;\n                return Math.sqrt(a * a + b * b + c * c);\n            };\n            return Vector3;\n        }());\n        webgl.Vector3 = Vector3;\n    })(webgl = spine.webgl || (spine.webgl = {}));\n})(spine || (spine = {}));\nvar spine;\n(function (spine) {\n    var webgl;\n    (function (webgl) {\n        var ManagedWebGLRenderingContext = (function () {\n            function ManagedWebGLRenderingContext(canvasOrContext, contextConfig) {\n                var _this = this;\n                if (contextConfig === void 0) { contextConfig = { alpha: \"true\" }; }\n                this.restorables = new Array();\n                if (canvasOrContext instanceof HTMLCanvasElement) {\n                    var canvas_1 = canvasOrContext;\n                    this.gl = (canvas_1.getContext(\"webgl\", contextConfig) || canvas_1.getContext(\"experimental-webgl\", contextConfig));\n                    this.canvas = canvas_1;\n                    canvas_1.addEventListener(\"webglcontextlost\", function (e) {\n                        var event = e;\n                        if (e) {\n                            e.preventDefault();\n                        }\n                    });\n                    canvas_1.addEventListener(\"webglcontextrestored\", function (e) {\n                        for (var i = 0, n = _this.restorables.length; i < n; i++) {\n                            _this.restorables[i].restore();\n                        }\n                    });\n                }\n                else {\n                    this.gl = canvasOrContext;\n                    this.canvas = this.gl.canvas;\n                }\n            }\n            ManagedWebGLRenderingContext.prototype.addRestorable = function (restorable) {\n                this.restorables.push(restorable);\n            };\n            ManagedWebGLRenderingContext.prototype.removeRestorable = function (restorable) {\n                var index = this.restorables.indexOf(restorable);\n                if (index > -1)\n                    this.restorables.splice(index, 1);\n            };\n            return ManagedWebGLRenderingContext;\n        }());\n        webgl.ManagedWebGLRenderingContext = ManagedWebGLRenderingContext;\n        var WebGLBlendModeConverter = (function () {\n            function WebGLBlendModeConverter() {\n            }\n            WebGLBlendModeConverter.getDestGLBlendMode = function (blendMode) {\n                switch (blendMode) {\n                    case spine.BlendMode.Normal: return WebGLBlendModeConverter.ONE_MINUS_SRC_ALPHA;\n                    case spine.BlendMode.Additive: return WebGLBlendModeConverter.ONE;\n                    case spine.BlendMode.Multiply: return WebGLBlendModeConverter.ONE_MINUS_SRC_ALPHA;\n                    case spine.BlendMode.Screen: return WebGLBlendModeConverter.ONE_MINUS_SRC_ALPHA;\n                    default: throw new Error(\"Unknown blend mode: \" + blendMode);\n                }\n            };\n            WebGLBlendModeConverter.getSourceGLBlendMode = function (blendMode, premultipliedAlpha) {\n                if (premultipliedAlpha === void 0) { premultipliedAlpha = false; }\n                switch (blendMode) {\n                    case spine.BlendMode.Normal: return premultipliedAlpha ? WebGLBlendModeConverter.ONE : WebGLBlendModeConverter.SRC_ALPHA;\n                    case spine.BlendMode.Additive: return premultipliedAlpha ? WebGLBlendModeConverter.ONE : WebGLBlendModeConverter.SRC_ALPHA;\n                    case spine.BlendMode.Multiply: return WebGLBlendModeConverter.DST_COLOR;\n                    case spine.BlendMode.Screen: return WebGLBlendModeConverter.ONE;\n                    default: throw new Error(\"Unknown blend mode: \" + blendMode);\n                }\n            };\n            WebGLBlendModeConverter.ZERO = 0;\n            WebGLBlendModeConverter.ONE = 1;\n            WebGLBlendModeConverter.SRC_COLOR = 0x0300;\n            WebGLBlendModeConverter.ONE_MINUS_SRC_COLOR = 0x0301;\n            WebGLBlendModeConverter.SRC_ALPHA = 0x0302;\n            WebGLBlendModeConverter.ONE_MINUS_SRC_ALPHA = 0x0303;\n            WebGLBlendModeConverter.DST_ALPHA = 0x0304;\n            WebGLBlendModeConverter.ONE_MINUS_DST_ALPHA = 0x0305;\n            WebGLBlendModeConverter.DST_COLOR = 0x0306;\n            return WebGLBlendModeConverter;\n        }());\n        webgl.WebGLBlendModeConverter = WebGLBlendModeConverter;\n    })(webgl = spine.webgl || (spine.webgl = {}));\n})(spine || (spine = {}));\n//# sourceMappingURL=spine-both.js.map\n\n/*** EXPORTS FROM exports-loader ***/\nmodule.exports = spine;\n}.call(window));"],"sourceRoot":""}